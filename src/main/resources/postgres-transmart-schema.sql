--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

--
-- Name: amapp; Type: SCHEMA; Schema: -; Owner: amapp
--

CREATE SCHEMA amapp;


ALTER SCHEMA amapp OWNER TO amapp;

--
-- Name: biomart; Type: SCHEMA; Schema: -; Owner: biomart
--

CREATE SCHEMA biomart;


ALTER SCHEMA biomart OWNER TO biomart;

--
-- Name: biomart_user; Type: SCHEMA; Schema: -; Owner: biomart_user
--

CREATE SCHEMA biomart_user;


ALTER SCHEMA biomart_user OWNER TO biomart_user;

--
-- Name: deapp; Type: SCHEMA; Schema: -; Owner: deapp
--

CREATE SCHEMA deapp;


ALTER SCHEMA deapp OWNER TO deapp;

--
-- Name: fmapp; Type: SCHEMA; Schema: -; Owner: fmapp
--

CREATE SCHEMA fmapp;


ALTER SCHEMA fmapp OWNER TO fmapp;

--
-- Name: galaxy; Type: SCHEMA; Schema: -; Owner: galaxy
--

CREATE SCHEMA galaxy;


ALTER SCHEMA galaxy OWNER TO galaxy;

--
-- Name: i2b2demodata; Type: SCHEMA; Schema: -; Owner: i2b2demodata
--

CREATE SCHEMA i2b2demodata;


ALTER SCHEMA i2b2demodata OWNER TO i2b2demodata;

--
-- Name: i2b2metadata; Type: SCHEMA; Schema: -; Owner: i2b2metadata
--

CREATE SCHEMA i2b2metadata;


ALTER SCHEMA i2b2metadata OWNER TO i2b2metadata;

--
-- Name: searchapp; Type: SCHEMA; Schema: -; Owner: searchapp
--

CREATE SCHEMA searchapp;


ALTER SCHEMA searchapp OWNER TO searchapp;

--
-- Name: tm_cz; Type: SCHEMA; Schema: -; Owner: tm_cz
--

CREATE SCHEMA tm_cz;


ALTER SCHEMA tm_cz OWNER TO tm_cz;

--
-- Name: tm_dataloader; Type: SCHEMA; Schema: -; Owner: tm_dataloader
--

CREATE SCHEMA tm_dataloader;


ALTER SCHEMA tm_dataloader OWNER TO tm_dataloader;

--
-- Name: tm_lz; Type: SCHEMA; Schema: -; Owner: tm_lz
--

CREATE SCHEMA tm_lz;


ALTER SCHEMA tm_lz OWNER TO tm_lz;

--
-- Name: tm_wz; Type: SCHEMA; Schema: -; Owner: tm_wz
--

CREATE SCHEMA tm_wz;


ALTER SCHEMA tm_wz OWNER TO tm_wz;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET search_path = amapp, pg_catalog;

--
-- Name: am_tag_value_uid(bigint); Type: FUNCTION; Schema: amapp; Owner: amapp
--

CREATE FUNCTION am_tag_value_uid(tag_value_id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
	BEGIN
	  RETURN 'TAG:' || TAG_VALUE_ID::text;
	END;
$$;


ALTER FUNCTION amapp.am_tag_value_uid(tag_value_id bigint) OWNER TO amapp;

--
-- Name: tf_trg_am_tag_item_id(); Type: FUNCTION; Schema: amapp; Owner: amapp
--

CREATE FUNCTION tf_trg_am_tag_item_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.TAG_ITEM_ID is null then
 select nextval('amapp.SEQ_AMAPP_DATA_ID') into NEW.TAG_ITEM_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION amapp.tf_trg_am_tag_item_id() OWNER TO amapp;

--
-- Name: tf_trg_am_tag_temp_assoc_id(); Type: FUNCTION; Schema: amapp; Owner: amapp
--

CREATE FUNCTION tf_trg_am_tag_temp_assoc_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.ID is null then
 select nextval('amapp.SEQ_AMAPP_DATA_ID') into NEW.ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION amapp.tf_trg_am_tag_temp_assoc_id() OWNER TO amapp;

--
-- Name: tf_trg_am_tag_template_id(); Type: FUNCTION; Schema: amapp; Owner: amapp
--

CREATE FUNCTION tf_trg_am_tag_template_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.TAG_TEMPLATE_ID is null then
 select nextval('amapp.SEQ_AMAPP_DATA_ID') into NEW.TAG_TEMPLATE_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION amapp.tf_trg_am_tag_template_id() OWNER TO amapp;

--
-- Name: tf_trg_am_tag_value_id(); Type: FUNCTION; Schema: amapp; Owner: amapp
--

CREATE FUNCTION tf_trg_am_tag_value_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.TAG_VALUE_ID is null then
 select nextval('amapp.SEQ_AMAPP_DATA_ID') into NEW.TAG_VALUE_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION amapp.tf_trg_am_tag_value_id() OWNER TO amapp;

--
-- Name: tf_trg_am_tag_value_uid(); Type: FUNCTION; Schema: amapp; Owner: amapp
--

CREATE FUNCTION tf_trg_am_tag_value_uid() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_count bigint;
BEGIN
  SELECT COUNT(*) INTO rec_count 
  FROM am_data_uid 
  WHERE am_data_id = new.tag_value_id;
  
  if rec_count = 0 then
    insert into amapp.am_data_uid (am_data_id, unique_id, am_data_type)
    values (NEW.tag_value_id, am_tag_value_uid(NEW.tag_value_id), 'AM_TAG_VALUE');
  end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION amapp.tf_trg_am_tag_value_uid() OWNER TO amapp;

SET search_path = biomart, pg_catalog;

--
-- Name: bio_assay_analysis_uid(character varying); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_assay_analysis_uid(analysis_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'BAA:' || coalesce(ANALYSIS_NAME, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_assay_analysis_uid(analysis_name character varying) OWNER TO biomart;

--
-- Name: bio_assay_platform_uid(character varying); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_assay_platform_uid(platform_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_assay_platform

  RETURN 'BAP:' || coalesce(PLATFORM_NAME, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_assay_platform_uid(platform_name character varying) OWNER TO biomart;

--
-- Name: bio_asy_analysis_pltfm_uid(character varying); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_asy_analysis_pltfm_uid(platform_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_asy_analysis_pltfm

  RETURN 'BAAP:' || coalesce(PLATFORM_NAME, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_asy_analysis_pltfm_uid(platform_name character varying) OWNER TO biomart;

--
-- Name: bio_compound_uid(character varying, character varying, character varying); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Function to create compound_uid.

  RETURN 'COM:' || coalesce(CAS_REGISTRY, coalesce(JNJ_NUMBER, coalesce(CNTO_NUMBER, 'ERROR')));
END;
$_$;


ALTER FUNCTION biomart.bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) OWNER TO biomart;

--
-- Name: bio_curation_dataset_uid(character varying); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_curation_dataset_uid(bio_curation_type character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_curation_dataset.

  RETURN 'BCD:' || coalesce(BIO_CURATION_TYPE, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_curation_dataset_uid(bio_curation_type character varying) OWNER TO biomart;

--
-- Name: bio_disease_uid(character varying); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_disease_uid(mesh_code character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates bio_disease_uid.

  RETURN 'DIS:' || coalesce(MESH_CODE, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_disease_uid(mesh_code character varying) OWNER TO biomart;

--
-- Name: bio_experiment_uid(character varying); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_experiment_uid(primary_id character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'EXP:' || coalesce(PRIMARY_ID, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_experiment_uid(primary_id character varying) OWNER TO biomart;

--
-- Name: bio_jub_oncol_data_uid(numeric, character varying); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_jub_oncol_data_uid(record_id numeric, bio_curation_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_jub_oncol_data.

  RETURN 'BJOD:' || coalesce(trim(TO_CHAR(RECORD_ID, '9999999999999999999')), 'ERROR') || ':' || coalesce(BIO_CURATION_NAME, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_jub_oncol_data_uid(record_id numeric, bio_curation_name character varying) OWNER TO biomart;

--
-- Name: bio_jub_oncol_sum_data_uid(numeric, character varying); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION bio_jub_oncol_sum_data_uid(record_id numeric, bio_curation_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_jub_oncol_sum_data

  RETURN 'BJOS:' || coalesce(trim(TO_CHAR(RECORD_ID, '9999999999999999999')), 'ERROR') || ':' || coalesce(BIO_CURATION_NAME, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.bio_jub_oncol_sum_data_uid(record_id numeric, bio_curation_name character varying) OWNER TO biomart;

--
-- Name: biomarker_gene_uid(character varying); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION biomarker_gene_uid(gene_id character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for biomarker_gene

  RETURN 'GENE:' || coalesce(GENE_ID, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.biomarker_gene_uid(gene_id character varying) OWNER TO biomart;

--
-- Name: biomarker_pathway_uid(character varying, character varying); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION biomarker_pathway_uid(p_source character varying, pathway_id character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for biomarker_pathway.

  RETURN 'PATHWAY:'|| P_SOURCE || ':' || coalesce(PATHWAY_ID, 'ERROR');
END;
$_$;


ALTER FUNCTION biomart.biomarker_pathway_uid(p_source character varying, pathway_id character varying) OWNER TO biomart;

--
-- Name: cum_normal_dist(numeric, numeric, numeric); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE

 -------------------------------------------------------------------------------
  -- implementation of a cumalative normal distribution
  -- JWS@20090601 - First rev.
  -- param foldChg: fold change ratio from from analysis_data table
  -- param mu: mean of all analsyis_data records for a given analysis
  -- param sigma: std dev of all analsyis_data records for a given analysis
  -------------------------------------------------------------------------------

  -- temporary vars  
  t1 decimal;
  
  -- fractional error dist input
  fract_error_input decimal;
  
  -- return result (i.e. Prob [X<=x])
  ans decimal;  


BEGIN
  t1:= (foldChg-mu)/sigma;  
  fract_error_input:= t1/SQRT(2);
  ans:= 0.5 * (1.0 + biomart.fract_error_dist(fract_error_input));
  return ans; 
END;
$$;


ALTER FUNCTION biomart.cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) OWNER TO biomart;

--
-- Name: fract_error_dist(numeric); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION fract_error_dist(norminput numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE


 -------------------------------------------------------------------------------
  -- implementation of fractional error distribution
  -- JWS@20090601 - First rev.
  -------------------------------------------------------------------------------
  -- temp var
  t1 decimal:= 1.0 / (1.0 + 0.5 * ABS(normInput));
  
  -- exponent input to next equation
  exponent_input decimal:= -normInput*normInput - 1.26551223 + 
                           t1*(1.00002368 + t1*(0.37409196 + t1*(0.09678418 + t1*(-0.18628806 + t1*(0.27886807 + t1*(-1.13520398 + t1*(1.48851587 + t1*(-0.82215223 + t1*(0.17087277)))))))));
  -- Horner's method
  ans decimal:= 1 - t1 * EXP(exponent_input);

  fractError decimal;


BEGIN
  -- handle sign
  IF normInput>0.0 THEN fractError:= ans; ELSE fractError:= -ans; END IF;
  return fractError;

END;
$$;


ALTER FUNCTION biomart.fract_error_dist(norminput numeric) OWNER TO biomart;

--
-- Name: refresh_bio_lit_int_model_mv(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION refresh_bio_lit_int_model_mv() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN

  -- populate the fake "materialized view" (i.e. actually a table) by deleting everything from it and then re-populating
  -- eventually we need a smarter algorithm for doing this

    delete from biomart.bio_lit_int_model_mv;

    insert into biomart.bio_lit_int_model_mv
    (bio_lit_int_data_id, experimental_model)    
    select bio_lit_int_data_id, experimental_model
       from biomart.bio_lit_int_model_view;  

    return true;
END;
 
 
 
$$;


ALTER FUNCTION biomart.refresh_bio_lit_int_model_mv() OWNER TO biomart;

--
-- Name: refresh_bio_marker_correl_mv(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION refresh_bio_marker_correl_mv() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN

  -- populate the fake "materialized view" (i.e. actually a table) by deleting everything from it and then re-populating
  -- eventually we need a smarter algorithm for doing this

    delete from biomart.bio_marker_correl_mv;

    insert into biomart.bio_marker_correl_mv
    (BIO_MARKER_ID, ASSO_BIO_MARKER_ID, CORREL_TYPE, mv_id)    
    select BIO_MARKER_ID, ASSO_BIO_MARKER_ID, CORREL_TYPE, mv_id
       from biomart.bio_marker_correl_view;  

    return true;
END;
$$;


ALTER FUNCTION biomart.refresh_bio_marker_correl_mv() OWNER TO biomart;

--
-- Name: tea_npv_precompute(numeric, numeric, numeric); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE


 -------------------------------------------------------------------------------
  -- used for gene signature TEA algorithm which precomputes normalized p-values
  -- based ON biomart.fold change ratio from analysis_data records
  -- JWS@20090601 - First rev.
  -- param foldChg: input is fold change ratio from from analysis_data table
  -- param mu: mean of all analsyis_data records for a given analysis
  -- param sigma: std dev of all analsyis_data records for a given analysis
  -------------------------------------------------------------------------------
  npv decimal;
  outlier_cutoff decimal:=1.0e-5;
  

BEGIN
  -- normalized p-value 
  npv:= 1.0 - cum_normal_dist(abs(foldChg),mu,sigma);
  
  -- cap outliers to minimum value
  IF npv<outlier_cutoff THEN npv:= outlier_cutoff; END IF;
  
  RETURN npv;
  
END;
$$;


ALTER FUNCTION biomart.tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) OWNER TO biomart;

--
-- Name: tf_trg_bio_ad_hoc_prop_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_ad_hoc_prop_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.AD_HOC_PROPERTY_ID is null then
 select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.AD_HOC_PROPERTY_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_ad_hoc_prop_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_analysis_al_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_analysis_al_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
	IF NEW.BIO_ANALYSIS_ATT_LINEAGE_ID IS NULL
		THEN
		SELECT nextval('BIOMART.SEQ_BIO_DATA_ID') INTO NEW.BIO_ANALYSIS_ATT_LINEAGE_ID;
	END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_bio_analysis_al_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_analysis_attribute_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_analysis_attribute_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		if NEW.BIO_ANALYSIS_ATTRIBUTE_ID IS NULL
			THEN
			SELECT nextval('BIOMART.SEQ_BIO_DATA_ID') INTO NEW.BIO_ANALYSIS_ATTRIBUTE_ID;
  		END IF;
	RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_bio_analysis_attribute_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_analysis_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_analysis_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_ASSAY_ANALYSIS_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASSAY_ANALYSIS_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_analysis_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_analysis_uid(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_analysis_uid() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_count bigint;
BEGIN
  SELECT COUNT(*) INTO rec_count 
  FROM biomart.bio_data_uid 
  WHERE bio_data_id = new.bio_assay_analysis_id;
  
  if rec_count = 0 then
    insert into biomart.bio_data_uid (bio_data_id, unique_id, bio_data_type)
    values (NEW.bio_assay_analysis_id, biomart.bio_assay_analysis_uid(NEW.bio_assay_analysis_id::text), 'BIO_ASSAY_ANALYSIS');
  end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_analysis_uid() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_cohort_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_cohort_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.BIO_ASSAY_COHORT_ID IS NULL
		THEN
		SELECT nextval('BIOMART.SEQ_BIO_DATA_ID') INTO NEW.BIO_ASSAY_COHORT_ID;
	END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_cohort_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_ASSAY_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASSAY_DATA_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_dataset_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_dataset_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_ASSAY_DATASET_ID is null then
         select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASSAY_DATASET_ID ;
    end if;
RETURN NEW;
end;

$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_dataset_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_f_g_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_f_g_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_ASSAY_FEATURE_GROUP_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASSAY_FEATURE_GROUP_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_f_g_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_ASSAY_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASSAY_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_assay_platform_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_assay_platform_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_ASSAY_PLATFORM_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASSAY_PLATFORM_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_assay_platform_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_asy_adi_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_asy_adi_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
      if coalesce(NEW.bio_asy_analysis_data_idx_id::text, '') = '' then          
        select nextval('biomart.seq_bio_data_id') into NEW.bio_asy_analysis_data_idx_id;       
      end if;       
       RETURN NEW;
  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_asy_adi_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_asy_analysis_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_asy_analysis_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.BIO_ASY_ANALYSIS_DATA_ID IS NULL
		THEN  select nextval('SEQ_BIO_DATA_ID') INTO NEW.BIO_ASY_ANALYSIS_DATA_ID;
	END IF;
	RETURN NEW;
END
$$;


ALTER FUNCTION biomart.tf_trg_bio_asy_analysis_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_asy_analysis_pltfm_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_asy_analysis_pltfm_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_ASY_ANALYSIS_PLTFM_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_ASY_ANALYSIS_PLTFM_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_asy_analysis_pltfm_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_asy_dt_stats_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_asy_dt_stats_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
	IF NEW.BIO_ASSAY_DATA_STATS_ID IS NULL
		THEN
		SELECT nextval('BIOMART.SEQ_BIO_DATA_FACT_ID') INTO NEW.BIO_ASSAY_DATA_STATS_ID;
	END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_bio_asy_dt_stats_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_cell_line_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_cell_line_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_CELL_LINE_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CELL_LINE_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_cell_line_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_cl_trl_time_pt_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_cl_trl_time_pt_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_CLINC_TRIAL_TM_PT_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CLINC_TRIAL_TM_PT_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_cl_trl_time_pt_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_clin_trl_pt_grp_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_clin_trl_pt_grp_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_CLINICAL_TRIAL_P_GROUP_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CLINICAL_TRIAL_P_GROUP_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_clin_trl_pt_grp_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_cln_trl_attr_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_cln_trl_attr_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_CLINC_TRIAL_ATTR_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CLINC_TRIAL_ATTR_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_cln_trl_attr_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_compound_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_compound_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_COMPOUND_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_COMPOUND_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_compound_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_concept_code_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_concept_code_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_CONCEPT_CODE_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CONCEPT_CODE_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_concept_code_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_content_ref_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_content_ref_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_CONTENT_REFERENCE_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CONTENT_REFERENCE_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_content_ref_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_content_repo_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_content_repo_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_CONTENT_REPO_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CONTENT_REPO_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_content_repo_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_curation_dataset_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_curation_dataset_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if NEW.BIO_CURATION_DATASET_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CURATION_DATASET_ID ;
      end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_curation_dataset_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_data_attr_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_data_attr_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_DATA_ATTRIBUTE_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_DATA_ATTRIBUTE_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_data_attr_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_data_correl_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_data_correl_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_DATA_CORREL_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_DATA_CORREL_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_data_correl_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_data_ext_code_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_data_ext_code_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_DATA_EXT_CODE_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_DATA_EXT_CODE_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_data_ext_code_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_disease_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_disease_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
     if NEW.BIO_DISEASE_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_DISEASE_ID ;
     end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_disease_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_experiment_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_experiment_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if NEW.BIO_EXPERIMENT_ID is null then
         select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_EXPERIMENT_ID ;
      end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_experiment_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_experiment_uid(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_experiment_uid() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_count bigint;
BEGIN
  SELECT COUNT(*) INTO rec_count 
  FROM biomart.bio_data_uid 
  WHERE bio_data_id = NEW.bio_experiment_id;
  
  if rec_count = 0 then
    insert into biomart.bio_data_uid (bio_data_id, unique_id, bio_data_type)
    values (NEW.bio_experiment_id, biomart.bio_experiment_uid(NEW.accession), 'BIO_EXPERIMENT');
  end if;
RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_bio_experiment_uid() OWNER TO biomart;

--
-- Name: tf_trg_bio_file_content_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_file_content_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_FILE_CONTENT_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_FILE_CONTENT_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_file_content_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_alt_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_alt_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_ALT_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_ALT_DATA_ID ;
       end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_alt_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_amd_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_amd_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_AMD_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_AMD_DATA_ID ;
       end if;
       RETURN NEW;
    end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_amd_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_inh_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_inh_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_INH_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_INH_DATA_ID ;
       end if; 
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_inh_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_int_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_int_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_INT_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_INT_DATA_ID ;
       end if; 
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_int_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_model_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_model_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_MODEL_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_MODEL_DATA_ID ;
       end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_model_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_pe_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_pe_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_PE_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_PE_DATA_ID ;
       end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_pe_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_ref_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_ref_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_REF_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_REF_DATA_ID ;
       end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_ref_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_lit_sum_data_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_lit_sum_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.BIO_LIT_SUM_DATA_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_LIT_SUM_DATA_ID ;
       end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_lit_sum_data_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_marker_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_marker_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin  if NEW.BIO_MARKER_ID is null then          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_MARKER_ID ;       end if;  RETURN NEW;  end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_marker_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_mkr_correl_descr_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_mkr_correl_descr_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_DATA_CORREL_DESCR_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_DATA_CORREL_DESCR_ID ;
    end if;
RETURN NEW;
end;

$$;


ALTER FUNCTION biomart.tf_trg_bio_mkr_correl_descr_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_observation_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_observation_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_OBSERVATION_ID is null then
        select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_OBSERVATION_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_observation_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_patient_event_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_patient_event_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_PATIENT_EVENT_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_PATIENT_EVENT_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_patient_event_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_patient_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_patient_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_PATIENT_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_PATIENT_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_patient_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_pt_evt_attr_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_pt_evt_attr_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_CLINIC_TRIAL_ATTRIBUTE_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_CLINIC_TRIAL_ATTRIBUTE_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_pt_evt_attr_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_sample_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_sample_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_SAMPLE_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_SAMPLE_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_sample_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_subject_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_subject_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.BIO_SUBJECT_ID is null then
          select nextval('biomart.SEQ_BIO_DATA_ID') into NEW.BIO_SUBJECT_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trg_bio_subject_id() OWNER TO biomart;

--
-- Name: tf_trg_bio_taxon_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_bio_taxon_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN IF NEW.BIO_TAXONOMY_ID IS NULL THEN
  select nextval('biomart.SEQ_BIO_DATA_ID') INTO NEW.BIO_TAXONOMY_ID ;
END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_bio_taxon_id() OWNER TO biomart;

--
-- Name: tf_trg_ctd2_clin_inhib_effect(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_ctd2_clin_inhib_effect() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN     
 	IF NEW.CTD_CIE_SEQ IS NULL THEN 
		select nextval('biomart.SEQ_CLINICAL_TRIAL_DESIGN_ID') INTO NEW.CTD_CIE_SEQ ;  
	END IF;  
	RETURN NEW;  
END;
$$;


ALTER FUNCTION biomart.tf_trg_ctd2_clin_inhib_effect() OWNER TO biomart;

--
-- Name: tf_trg_ctd2_disease(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_ctd2_disease() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN     
	IF NEW.CTD_DISEASE_SEQ IS NULL THEN 
		select nextval('biomart.SEQ_CLINICAL_TRIAL_DESIGN_ID') INTO NEW.CTD_DISEASE_SEQ ;  
	END IF;    
	RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_ctd2_disease() OWNER TO biomart;

--
-- Name: tf_trg_ctd2_inhib_details(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_ctd2_inhib_details() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN     
	IF NEW.CTD_INHIB_SEQ IS NULL THEN 
		select nextval('biomart.SEQ_CLINICAL_TRIAL_DESIGN_ID') INTO NEW.CTD_INHIB_SEQ ;  
	END IF;    
	RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_ctd2_inhib_details() OWNER TO biomart;

--
-- Name: tf_trg_ctd2_study_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_ctd2_study_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN     
	IF NEW.CTD_STUDY_ID IS NULL THEN 
		select nextval('biomart.SEQ_CLINICAL_TRIAL_DESIGN_ID') INTO NEW.CTD_STUDY_ID ;  
	END IF;    
	RETURN NEW;
END;
$$;


ALTER FUNCTION biomart.tf_trg_ctd2_study_id() OWNER TO biomart;

--
-- Name: tf_trg_ctd2_trial_details(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trg_ctd2_trial_details() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN     
	IF NEW.CTD_TD_SEQ IS NULL THEN 
		select nextval('biomart.SEQ_CLINICAL_TRIAL_DESIGN_ID') INTO NEW.CTD_TD_SEQ ;  
	END IF;   
	RETURN NEW; 
END;
$$;


ALTER FUNCTION biomart.tf_trg_ctd2_trial_details() OWNER TO biomart;

--
-- Name: tf_trig_clinical_trial_design_id(); Type: FUNCTION; Schema: biomart; Owner: biomart
--

CREATE FUNCTION tf_trig_clinical_trial_design_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
    if NEW.CLINICAL_TRIAL_DESIGN_ID is null then          
      select nextval('biomart.SEQ_CLINICAL_TRIAL_DESIGN_ID') into NEW.CLINICAL_TRIAL_DESIGN_ID ;  
    end if; 
    RETURN NEW;
end;
$$;


ALTER FUNCTION biomart.tf_trig_clinical_trial_design_id() OWNER TO biomart;

SET search_path = biomart_user, pg_catalog;

--
-- Name: i2b2_bulk_add_search_term(bigint); Type: FUNCTION; Schema: biomart_user; Owner: biomart_user
--

CREATE FUNCTION i2b2_bulk_add_search_term(currentjobid bigint DEFAULT NULL::bigint) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research null, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	--Audit variables
	newJobFlag integer(1);
	databaseName varchar(100);
	procedureName varchar(100);
	jobID bigint;
	stepCt bigint;

	v_keyword_term	varchar(500);
  v_display_category varchar(500);
  v_data_category varchar(500);
  v_prefix varchar(20);
  v_unique_ID varchar(500);
  v_source_cd varchar(500);
  v_parent_term varchar(500);
  v_bio_data_id bigint;
  
	sqlText			varchar(2000);
	Parent_Id 		integer;
	new_Term_Id 	integer;
	keyword_id 		integer;
	Lcount 			integer; 
	Ncount 			integer;
  
	--v_category_display	varchar2(200);

  	type keyword_rec  is record
	(keywordName		varchar(500)),
   dataCategory varchar(500),
   UIDPrefix varchar(20),
   uniqueID varchar(500),
   sourceCd varchar(500),
   parentTerm varchar(500),
   bio_data_id bigint
	);

	type keyword_table is table of keyword_rec; 
	keyword_array keyword_table;
	
  

BEGIN

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
    	
	--stepCt := 0;
  
	--cz_write_audit(jobId,databaseName,procedureName,'Start Procedure',SQL%ROWCOUNT,stepCt,'Done');
	--Stepct := Stepct + 1;	
  
	  select keyword, display_category, data_category, UID_prefix, unique_id, source_cd, parent_term, bio_data_id
    bulk collect into keyword_array
  	from tm_lz.lt_src_search_keyword
    where (keyword IS NOT NULL AND keyword::text <> '');

 
	for i in keyword_array.first .. keyword_array.last
	loop
		v_keyword_term := keyword_array(i).keywordName;
    v_display_category := keyword_array(i).displayCategory;
    v_data_category := keyword_array(i).dataCategory;
    v_prefix := keyword_array(i).UIDPrefix;
    v_unique_ID := keyword_array(i).uniqueID;
    v_source_cd := keyword_array(i).sourceCd;
    v_parent_term := keyword_array(i).parentTerm;
    v_bio_data_id := keyword_array(i).bio_data_id;
    
    --dbms_output.put_line('keyword: ' || v_keyword_term);


		if (coalesce(v_display_category::text, '') = '') then
			v_display_category := v_data_category;
    end if;


    if (coalesce(v_unique_ID::text, '') = '') then
      if ((v_prefix IS NOT NULL AND v_prefix::text <> '')) then
        v_unique_ID := v_prefix || ':' || v_data_category || ':' || v_keyword_term;
      end if;
    end if;
   

		-- Insert taxonomy term into searchapp.search_keyword
		-- (searches Search_Keyword with the parent term to find the category to use)
		Insert Into Searchapp.Search_Keyword 
		(Data_Category
		,Keyword
		,Unique_Id
		,Source_Code
		,Display_Data_Category
    ,Bio_data_id)
		PERFORM v_data_category
			  ,v_keyword_term
			  ,v_unique_ID
			  ,v_source_cd
			  ,v_display_category
        ,v_bio_data_id
		
		where not exists
			(select 1 from searchapp.search_keyword x
			 where upper(x.data_category) = upper(v_data_category)
			   and upper(x.keyword) = upper(v_keyword_term)
         and upper(x.bio_data_id) = upper(v_bio_data_id));
		Cz_Write_Audit(Jobid,Databasename,Procedurename,v_keyword_term || ' added to Searchapp.Search_Keyword',Sql%Rowcount,Stepct,'Done');
		Stepct := Stepct + 1;	
		commit;
  
		-- Get the ID of the new term in Search_Keyword
		Select Search_Keyword_Id  Into keyword_Id 
		From  Searchapp.Search_Keyword 
		Where Upper(Keyword) = Upper(v_keyword_term)
		and upper(data_category) = upper(v_data_category)
    and upper(bio_data_id) = upper(v_bio_data_id);
		Cz_Write_Audit(Jobid,Databasename,Procedurename,'New search keyword ID stored in Keyword_Id',Sql%Rowcount,Stepct,'Done');
		Stepct := Stepct + 1;	
		
		-- Insert the new term into Searchapp.Search_v_keyword_term 
		insert into searchapp.search_keyword_term 
		(keyword_term
		,search_keyword_id
		,rank
		,term_length)
		PERFORM UPPER(v_keyword_term)
			  ,Keyword_Id
			  ,1
			  ,Length(v_keyword_term) 
		
		where not exists
			(select 1 from searchapp.search_keyword_term x
			 where upper(x.keyword_term) = upper(v_keyword_term)
			   and x.search_keyword_id = Keyword_Id);
		Cz_Write_Audit(Jobid,Databasename,Procedurename,'Term added to Searchapp.Search_v_keyword_term',Sql%Rowcount,Stepct,'Done');
		Stepct := Stepct + 1;	
		commit;

	end loop;

	Cz_Write_Audit(Jobid,Databasename,Procedurename,'End '|| procedureName,0,Stepct,'Done');
	Stepct := Stepct + 1;  

 
     ---Cleanup OVERALL JOB if this proc is being run standalone    
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;
  
    EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
  
END;
 
$_$;


ALTER FUNCTION biomart_user.i2b2_bulk_add_search_term(currentjobid bigint) OWNER TO biomart_user;

--
-- Name: i2b2_metabolomics_zscore_calc(character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: biomart_user; Owner: biomart_user
--

CREATE FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying DEFAULT 'L'::character varying, currentjobid numeric DEFAULT (-1), data_type character varying DEFAULT 'R'::character varying, log_base numeric DEFAULT 2) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
This Stored Procedure is used in ETL load METABOLOMICS data
Date:1/3/2014
******************************************************************/

  TrialID varchar(100);
  sourceCD	varchar(50);
  sqlText varchar(2000);
  runType varchar(10);
  dataType varchar(10);
  stgTrial varchar(100);
  idxExists integer;
  pExists	integer;
  nbrRecs integer;
  logBase numeric;
   
  --Audit variables
  newJobFlag integer(1);
  databaseName varchar(100);
  procedureName varchar(100);
  jobID numeric;
  stepCt integer;
  
  --  exceptions
  invalid_runType exception;
  trial_mismatch exception;
  trial_missing exception;
  

BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	  RAISE NOTICE 'DK0';
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
   
  stepCt := 0;
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done');
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting'
,SQL%ROWCOUNT,stepCt,'Done');
		raise invalid_runType;
	end if;
  
--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_METABOLOMICS_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from WT_SUBJECT_MBOLOMICS_PROBESET;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in WT_SUBJECT_MBOLOMICS_PROBESET - procedure exiting'
,SQL%ROWCOUNT,stepCt,'Done');
			--raise trial_mismatch;
		end if;
	end if;

/*	remove Reload processing
--	For Reload, make sure that the TrialId passed as parameter has data in de_subject_METABOLOMICS_data
--	If not, raise exception

	if runType = 'R' then
		select count(*) into idxExists
		from DE_SUBJECT_METABOLOMICS_DATA
  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
   
  stepCt := 0;
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done');
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting',SQL%ROWCOUNT,stepCt,'Done');
		raise invalid_runType;
	end if;
  
		where trial_name = TrialId;
		
		if idxExists = 0 then
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'No data for TrialId in DE_SUBJECT_METABOLOMICS_DATA - procedure exiting',SQL%ROWCOUNT,stepCt,'Done');
			raise trial_missing;
		end if;
	end if;
*/
   
--	truncate tmp tables

	EXECUTE('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_LOGS');
	EXECUTE('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_CALCS');
	EXECUTE('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_MED');

	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'WT_SUBJECT_METABOLOMICS_LOGS'
	  and index_name = 'WT_SUBJECT_MBOLOMICS_LOGS_I1'
	  and owner = 'TM_WZ';

	if idxExists = 1 then
		EXECUTE('drop index tm_wz.WT_SUBJECT_MBOLOMICS_LOGS_I1');		
	end if;
	
	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'WT_SUBJECT_METABOLOMICS_CALCS'
	  and index_name = 'WT_SUBJECT_METABOLOMICS_CALCS_I1'
	  and owner = 'TM_WZ';

	if idxExists = 1 then
		EXECUTE('drop index tm_wz.WT_SUBJECT_METABOLOMICS_CALCS_I1');
	end if;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value


	if dataType = 'L' then

		insert into WT_SUBJECT_METABOLOMICS_LOGS 
			(probeset
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
			,subject_id
			)
			PERFORM probeset
				  ,intensity_value  
				  ,assay_id 
				  ,intensity_value
				  ,patient_id
			--	  ,sample_cd
				  ,subject_id
			from WT_SUBJECT_MBOLOMICS_PROBESET
			where trial_name = TrialId;
           
		--end if;
	else	

                	insert into WT_SUBJECT_METABOLOMICS_LOGS 
			(probeset
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
			,subject_id
			)
			PERFORM probeset
				  ,intensity_value 
				  ,assay_id 
				  ,log(2,intensity_value)
				  ,patient_id
		--		  ,sample_cd
				  ,subject_id
			from WT_SUBJECT_MBOLOMICS_PROBESET
			where trial_name = TrialId;
--		end if;

	end if;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_mirna_logs',SQL%ROWCOUNT,stepCt,'Done');

	commit;

	EXECUTE('create index tm_wz.WT_SUBJECT_MBOLOMICS_LOGS_I1 on tm_wz.WT_SUBJECT_METABOLOMICS_LOGS (trial_name, probeset) nologging  tablespace "INDX"');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_MBOLOMICS_LOGS_I1',0,stepCt,'Done');
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe

	insert into WT_SUBJECT_METABOLOMICS_CALCS
	(trial_name
	,probeset
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
	PERFORM d.trial_name 
		  ,d.probeset
		  ,avg(log_intensity)
		  ,median(log_intensity)
		  ,stddev(log_intensity)
	from WT_SUBJECT_METABOLOMICS_LOGS d 
	group by d.trial_name 
			,d.probeset;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ WT_SUBJECT_METABOLOMICS_CALCS',SQL%ROWCOUNT,stepCt,'Done');

	commit;

	--execute immediate('create index tm_wz.wt_subject_METABOLOMICS_calcs_i1 on tm_wz.WT_SUBJECT_METABOLOMICS_CALCS (trial_name, probeset_id) nologging tablespace "INDX"');
	--stepCt := stepCt + 1;
	--cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_METABOLOMICS_CALCS',0,stepCt,'Done');
		
-- calculate zscore

	
        insert into WT_SUBJECT_METABOLOMICS_MED parallel 
	(probeset
	,intensity_value
	,log_intensity
	,assay_id
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,patient_id
--	,sample_cd
	,subject_id
	)
	PERFORM d.probeset
		  ,d.intensity_value 
		  ,d.log_intensity 
		  ,d.assay_id  
		  ,c.mean_intensity 
		  ,c.stddev_intensity 
		  ,c.median_intensity 
		  ,(CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END)
		  ,d.patient_id
	--	  ,d.sample_cd
		  ,d.subject_id
    from WT_SUBJECT_METABOLOMICS_LOGS d 
		,WT_SUBJECT_METABOLOMICS_CALCS c 
    where trim(d.probeset) = c.probeset;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ WT_SUBJECT_METABOLOMICS_MED',SQL%ROWCOUNT,stepCt,'Done');

    commit;

/*
	select count(*) into n
	select count(*) into nbrRecs
	from WT_SUBJECT_METABOLOMICS_MED;
	
	if nbrRecs > 10000000 then
		i2b2_mrna_index_maint('DROP',,jobId);
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on DEAPP de_subject_METABOLOMICS_data',0,stepCt,'Done');
	else
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Less than 10M records, index drop bypassed',0,stepCt,'Done');
	end if;
*/
	


/*
	insert into DE_SUBJECT_METABOLOMICS_DATA
	(
        trial_source
        ,trial_name
	,metabolite_annotation_id
	--,component
	--,gene_symbol
	--,gene_id
	,assay_id
	,subject_id
	,raw_intensity 
        ,log_intensity
	,zscore
	,patient_id
		)
                select m.trial_name || ':' || mpp.source_cd,
                  TrialID
                ,d.Id
		  ,m.assay_id
                  ,m.subject_id 
                  ,m.intensity_value
                  ,log(2,m.intensity_value)
			  ,case when m.intensity_value < -2.5
			        then -2.5
					when m.intensity_value > 2.5
					then 2.5
					else m.intensity_value
			   end as zscore
                           ,m.patient_id
                from WT_SUBJECT_MBOLOMICS_PROBESET  m,
                (select distinct mp.source_cd From "TM_LZ"."LT_SRC_METABOLOMIC_MAP" mp where rownum = 1 and mp.trial_name =TrialID) mpp
                ,DEAPP.DE_METABOLITE_ANNOTATION d
		where m.trial_name = TrialID
                and d.biochemical_name = m.probeset;
        */
        insert into DE_SUBJECT_METABOLOMICS_DATA
	(
        trial_source
	,trial_name
	,metabolite_annotation_id
	--,component
	--,gene_symbol
	--,gene_id
	,assay_id
	,subject_id
	,raw_intensity 
        ,log_intensity
	,zscore
	,patient_id
	)
	PERFORM 
                  TrialId || ':' || mpp.source_cd,
                  TrialId
                 ,d.id
                 --,m.probeset_id 
                 --,d.hmdb_id
                 --,d.biomarker_id
                 ,m.assay_id
                 ,m.subject_id
	    --  ,decode(dataType,'R',m.intensity_value,'L',power(logBase, m.log_intensity),null)
                  ,m.intensity_value
		  ,round(m.log_intensity,4)
                  ,round(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE round(m.zscore,5) END,5)		  
                   ,m.patient_id
	from WT_SUBJECT_METABOLOMICS_MED m,
        (select distinct mp.source_cd,mp.platform From "TM_LZ"."LT_SRC_METABOLOMIC_MAP" mp LIMIT 1 OFFSET 1 and mp.trial_name =TrialID) mpp                
       , DE_METABOLITE_ANNOTATION d
        where trim(d.biochemical_name) = trim(m.probeset)
        and d.gpl_id = mpp.platform;
        
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial in DEAPP DE_SUBJECT_METABOLOMICS_DATA',SQL%ROWCOUNT,stepCt,'Done');

  	commit;

--	add indexes, if indexes were not dropped, procedure will not try and recreate
/*
	i2b2_mrna_index_maint('ADD',,jobId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Add indexes on DEAPP de_subject_METABOLOMICS_data',0,stepCt,'Done');
*/
	
--	cleanup tmp_ files

	--execute immediate('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_LOGS');
	--execute immediate('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_CALCS');
	--execute immediate('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_MED');

   	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION

  WHEN invalid_runType or trial_mismatch or trial_missing then
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
  
    cz_end_audit (jobID, 'FAIL');
  when OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);


    cz_end_audit (jobID, 'FAIL');
	
END;
 
$_$;


ALTER FUNCTION biomart_user.i2b2_metabolomics_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) OWNER TO biomart_user;

--
-- Name: instr(character varying, character varying, character varying); Type: FUNCTION; Schema: biomart_user; Owner: biomart_user
--

CREATE FUNCTION instr(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
    string ALIAS FOR $1;
    string_to_search ALIAS FOR $2;
    beg_index ALIAS FOR $3;
BEGIN	
	return biomart_user.instr($1,$2,CAST($3 as int4));
END;
$_$;


ALTER FUNCTION biomart_user.instr(character varying, character varying, character varying) OWNER TO biomart_user;

--
-- Name: instr(character varying, character varying, integer, integer); Type: FUNCTION; Schema: biomart_user; Owner: biomart_user
--

CREATE FUNCTION instr(string character varying, string_to_search character varying, beg_index integer DEFAULT 1, occur_index integer DEFAULT 1) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$

DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;

BEGIN
    IF beg_index > 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;

    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos > 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;

                END IF;

            END IF;

            beg := beg - 1;

        END LOOP;

        RETURN 0;

    END IF;

END;

$$;


ALTER FUNCTION biomart_user.instr(string character varying, string_to_search character varying, beg_index integer, occur_index integer) OWNER TO biomart_user;

SET search_path = deapp, pg_catalog;

--
-- Name: dump_table_to_csv(character varying, character varying, character varying); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION dump_table_to_csv(p_tname character varying, p_dir character varying, p_filename character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

        l_output        utl_file.file_type;
        l_theCursor     integer default dbms_sql.open_cursor;
        l_columnValue   varchar(4000);
        l_status        integer;
        l_query         varchar(1000)
                       default 'select * from ' || p_tname;
       l_colCnt        integer := 0;
       l_separator     varchar(1);
       l_descTbl       dbms_sql.desc_tab;
   
BEGIN
       l_output := utl_file.fopen( p_dir, p_filename, 'w' );
       EXECUTE 'alter session set nls_date_format=''dd-mon-yyyy hh24:mi:ss''
';

       dbms_sql.parse(  l_theCursor,  l_query, dbms_sql.native );
       dbms_sql.describe_columns( l_theCursor, l_colCnt, l_descTbl );

      for i in 1 .. l_colCnt loop
           utl_file.put( l_output, l_separator || '"' || l_descTbl(i).col_name || '"'
);
           dbms_sql.define_column( l_theCursor, i, l_columnValue, 4000 );
          l_separator := ',';
       end loop;
       utl_file.new_line( l_output );

       l_status := dbms_sql.execute(l_theCursor);

       while ( dbms_sql.fetch_rows(l_theCursor) > 0 ) loop
           l_separator := '';
           for i in 1 .. l_colCnt loop
               dbms_sql.column_value( l_theCursor, i, l_columnValue );
               utl_file.put( l_output, l_separator || l_columnValue );
               l_separator := ',';
           end loop;
           utl_file.new_line( l_output );
       end loop;
       dbms_sql.close_cursor(l_theCursor);
       utl_file.fclose( l_output );

       EXECUTE 'alter session set nls_date_format=''dd-MON-yy'' ';
   exception
       when others then
           EXECUTE 'alter session set nls_date_format=''dd-MON-yy'' ';
           raise;
   end;
 
$$;


ALTER FUNCTION deapp.dump_table_to_csv(p_tname character varying, p_dir character varying, p_filename character varying) OWNER TO deapp;

--
-- Name: i2b2_process_rna_seq_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_cd character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT NULL::character varying, currentjobid numeric DEFAULT (-1), OUT rtn_code numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
* This stored procedure is for ETL to load RNA sequencing
* Date:10/23/2013
******************************************************************/
--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint	

  TrialID		varchar(100);
  RootNode		varchar(2000);
  root_level	integer;
  topNode		varchar(2000);
  topLevel		integer;
  tPath			varchar(2000);
  study_name	varchar(100);
  sourceCd		varchar(50);
  secureStudy	varchar(1);

  dataType		varchar(10);
  sqlText		varchar(1000);
  tText			varchar(1000);
  gplTitle		varchar(1000);
  pExists		bigint;
  partTbl   	bigint;
  partExists 	bigint;
  sampleCt		bigint;
  idxExists 	bigint;
  logBase		bigint;
  pCount		integer;
  sCount		integer;
  tablespaceName	varchar(200);
  v_bio_experiment_id	bigint;
  
    --Audit variables
  newJobFlag integer(1);
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  
  --unmapped_patients exception;
  missing_platform	exception;
  missing_tissue	EXCEPTION;
  unmapped_platform exception;
  multiple_platform	exception;
  no_probeset_recs	exception;
  

  
	addNodes CURSOR FOR
	SELECT distinct t.leaf_node
          ,t.node_name
	from  wt_RNA_SEQ_nodes t
	where not exists
		 (select 1 from i2b2 x
		  where t.leaf_node = x.c_fullname);

 
--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  delNodes CURSOR FOR
  SELECT distinct c_fullname 
  from  i2b2
  where c_fullname like topNode || '%'
    and substring(c_visualattributes from 2 for 1) = 'H';
    --and c_visualattributes like '_H_';



BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\');	
	PERFORM length(topNode)-length(replace(topNode,'\','')) into topLevel ;
	
	if coalesce(data_type::text, '') = '' then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;
	
	logBase := log_base;
	sourceCd := upper(coalesce(source_cd,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_RNA_SEQ_data',0,stepCt,'Done');
	
	--	Get count of records in lt_src_RNA_SEQ_subj_samp_map
	
	select count(*) into sCount
	from lt_src_RNA_SEQ_subj_samp_map;
	
	--	check if all subject_sample map records have a platform, If not, abort run
	
	select count(*) into pCount
	from lt_src_RNA_SEQ_subj_samp_map
	where coalesce(platform::text, '') = '';
	
	if pCount > 0 then
		raise missing_platform;
	end if;
  
  	
	
	
	/*select count(*) into pCount
	from DE_gpl_info
	where platform in (select distinct m.platform from lt_src_RNA_SEQ_subj_samp_map m);
	*/
	/*if PCOUNT = 0 then
		RAISE UNMAPPED_platform;
	end if;*/
		
	--	check if all subject_sample map records have a tissue_type, If not, abort run
	
	select count(*) into pCount
	from lt_src_RNA_SEQ_subj_samp_map
	where coalesce(tissue_type::text, '') = '';
	
	if pCount > 0 then
		raise missing_tissue;
	end if;
	
	--	check if there are multiple platforms, if yes, then platform must be supplied in lt_src_RNA_SEQ_data
	
	select count(*) into pCount
	from (select sample_cd
		  from lt_src_RNA_SEQ_subj_samp_map
		  group by sample_cd
		  GROUP BY xd.concept_Cd
		  having Max(xf.valtype_cd) = 'N');
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName, HAVING count(distinct platform) > 1);
	
	if pCount > 0 then
		raise multiple_platform;
	end if;
		
	-- Get root_node from topNode
  
	PERFORM parse_nth_value(topNode, 2, '\') into RootNode ;
	
	select count(*) into pExists
	from table_access
	where c_name = rootNode;
	
	if pExists = 0 then
		i2b2_add_root_node(rootNode, jobId);
	end if;
	
	select c_hlevel into root_level
	from i2b2
	where c_name = RootNode;
	
	-- Get study name from topNode
  
	PERFORM parse_nth_value(topNode, topLevel, '\') into study_name ;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,null),'(\\){2,}', '\');
	PERFORM length(tPath) - length(replace(tPath,'\',null)) into pCount ;

	if pCount > 2 then
		i2b2_fill_in_tree(null, tPath, jobId);
	end if;

	--	uppercase study_id in lt_src_RNA_SEQ_subj_samp_map in case curator forgot
	
	update lt_src_RNA_SEQ_subj_samp_map
	set trial_name=upper(trial_name);
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in lt_src_RNA_SEQ_subj_samp_map',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd
	
	insert into patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    PERFORM nextval('seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || s.site_id || ':' || s.subject_id,'(::){1,}', ':') as sourcesystem_cd
		 from lt_src_RNA_SEQ_subj_samp_map s
		    -- ,de_gpl_info g
		 where (s.subject_id IS NOT NULL AND s.subject_id::text <> '')
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		 --  and s.platform = g.platform
		   --and upper(g.marker_type) = 'GENE EXPRESSION'
		   and not exists
			  (select 1 from patient_dimension x
			   where x.sourcesystem_cd = 
				 regexp_replace(TrialID || ':' || s.site_id || ':' || s.subject_id,'(::){1,}', ':'))
		) x;
	
	pCount := SQL%ROWCOUNT;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',pCount,stepCt,'Done');
	commit;
	
	i2b2_create_security_for_trial(TrialId, secureStudy, jobID);

	--	Delete existing observation_fact data, will be repopulated
	
	delete from observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = 'RNA_AFFYMETRIX');

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	select count(*) into pExists
	from all_tables
	where table_name = 'DE_SUBJECT_RNA_DATA'
	  and partitioned = 'YES';
	  
	if pExists = 0 then
		--	dataset is not partitioned so must delete
		
		delete from de_subject_rna_data
		where trial_source = TrialId || ':' || sourceCd;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete data from de_subject_rna_data',SQL%ROWCOUNT,stepCt,'Done');
		commit;
	else
		--	Create partition in de_subject_RNA_data if it doesn't exist else truncate partition
			
		select count(*)
			into pExists
			from all_tab_partitions
			where table_name = 'DE_SUBJECT_RNA_DATA'
			  and partition_name = TrialId || ':' || sourceCd;
			--10/30/2013  //modified
		if pExists = 0 then
					
			--	needed to add partition to de_subject_RNA_data

			sqlText := 'alter table deapp.de_subject_rna_data add PARTITION "' || TrialID || ':' || sourceCd || '"  VALUES (' || '''' || TrialID || ':' || sourceCd || '''' || ') ' ||
						   'NOLOGGING COMPRESS TABLESPACE "TRANSMART" ';
			EXECUTE(sqlText);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Adding partition to de_subject_rna_data',0,stepCt,'Done');
				
		else
			sqlText := 'alter table deapp.de_subject_rna_data truncate partition "' || TrialID || ':' || sourceCd || '"';
			EXECUTE(sqlText);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in de_subject_rna_data',0,stepCt,'Done');
		end if;
		
	end if;
		
	--	Cleanup any existing data in de_subject_sample_mapping.  

	delete from DE_SUBJECT_SAMPLE_MAPPING 
	where trial_name = TrialID 
	  and coalesce(source_cd,'STD') = sourceCd
	  and platform = 'RNA_AFFYMETRIX'; --Making sure only RNA_sequencing data is deleted
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');

	commit;

--	truncate tmp node table

	EXECUTE('truncate table tm_wz.wt_RNA_SEQ_nodes');
	
--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
--	from wt_subject_RNA_sequencing_data

	EXECUTE('truncate table tm_wz.wt_RNA_SEQ_node_values');

	insert into wt_RNA_SEQ_node_values
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	PERFORM distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,''--g.title
    from lt_src_RNA_SEQ_subj_samp_map a
	  --  ,de_gpl_info g 
	where a.trial_name = TrialID
	--  and nvl(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	 -- and a.platform = g.platform
	--  and upper(g.marker_type) = 'GENE EXPRESSION'
	--  and g.title = (select min(x.title) from de_gpl_info x where nvl(a.platform,'GPL570') = x.platform)
      -- and upper(g.organism) = 'HOMO SAPIENS'
	  ;
	--  and decode(dataType,'R',sign(a.intensity_value),1) = 1;	--	take all values when dataType T, only >0 for dataType R
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP wt_RNA_SEQ_node_values',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	insert into wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	PERFORM distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       category_cd,'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\','(\\){2,}', '\') 
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  wt_RNA_SEQ_node_values;

    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_RNA_SEQ_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert for platform node so platform concept can be populated
	
	insert into wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	PERFORM distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  wt_RNA_SEQ_node_values;
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in wt_RNA_SEQ_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd
	
	insert into wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	PERFORM distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  wt_RNA_SEQ_node_values
	where category_cd like '%ATTR1%'
	  and (attribute_1 IS NOT NULL AND attribute_1::text <> '');
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in wt_RNA_SEQ_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd

	insert into wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	PERFORM distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  wt_RNA_SEQ_node_values
	where category_cd like '%ATTR2%'
	  and (attribute_2 IS NOT NULL AND attribute_2::text <> '');
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_RNA_SEQ_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert for tissue_type node so sample_type_cd can be populated 

	insert into wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	PERFORM distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  wt_RNA_SEQ_node_values
	where category_cd like '%TISSUETYPE%';

    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_RNA_SEQ_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
				
	update wt_RNA_SEQ_nodes
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\',null)),'\');
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_RNA_SEQ_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
		
--	add leaf nodes for RNA_sequencing data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)

		i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId);
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;
		
		cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');
		
		i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID);

	END LOOP;  
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
	
	update i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
		
--	update concept_cd for nodes, this is done to make the next insert easier

	update wt_RNA_SEQ_nodes t
	set concept_cd=(select c.concept_cd from concept_dimension c
	                where c.concept_path = t.leaf_node
				   )
    where exists
         (select 1 from concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and coalesce(t.concept_cd::text, '') = '';
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update wt_RNA_SEQ_nodes with newly created concept_cds',SQL%ROWCOUNT,stepCt,'Done');
	commit;

  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_RNA_sequencing_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in wt_RNA_SEQ_nodes
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in wt_RNA_SEQ_nodes
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in wt_RNA_SEQ_nodes
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in wt_RNA_SEQ_nodes
  --PLATFORM        = RNA_sequencing_AFFYMETRIX - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in wt_RNA_SEQ_nodes
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_RNA_SEQ_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd
  
  --ASSAY_ID        = generated by trigger

	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
    )
	PERFORM t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,deapp.nextval('seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,'RNA_AFFYMETRIX' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || to_char(b.patient_num) as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+RNA_SEQ+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from lt_src_RNA_SEQ_subj_samp_map a		
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join patient_dimension b
		  on regexp_replace(TrialID || ':' || a.site_id || ':' || a.subject_id,'(::){1,}', ':') = b.sourcesystem_cd
		inner join wt_RNA_SEQ_nodes ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'@') = coalesce(ln.attribute_1,'@')
			and coalesce(a.attribute_2,'@') = coalesce(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join wt_RNA_SEQ_nodes pn
			on a.platform = pn.platform
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(pn.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(pn.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'	  
		left outer join wt_RNA_SEQ_nodes ttp
			on a.tissue_type = ttp.tissue_type
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = coalesce(ttp.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(ttp.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'		  
		left outer join wt_RNA_SEQ_nodes a1
			on a.attribute_1 = a1.attribute_1
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a1.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a1.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'		  
		left outer join wt_RNA_SEQ_nodes a2
			on a.attribute_2 = a1.attribute_2
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a2.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a2.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'			  
		left outer join patient_dimension sid
			on  regexp_replace(TrialId || 'S:' || a.site_id || ':' || a.subject_id || ':' || a.sample_cd,
							  '(::){1,}', ':') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  (ln.concept_cd IS NOT NULL AND ln.concept_cd::text <> '')) t;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');

  commit;
--	recreate de_subject_sample_mapping indexes

	--execute immediate('create index de_subject_smpl_mpng_idx1 on de_subject_sample_mapping(timepoint, patient_id, trial_name) parallel nologging'); 
	--execute immediate('create index de_subject_smpl_mpng_idx2 on de_subject_sample_mapping(patient_id, timepoint_cd, platform_cd, assay_id, trial_name) parallel nologging'); 
	--execute immediate('create bitmap index de_subject_smpl_mpng_idx3 on de_subject_sample_mapping(sample_type_cd) parallel nologging');
	--execute immediate('create index de_subject_smpl_mpng_idx4 on de_subject_sample_mapping(gpl_id) parallel nologging');
	--execute immediate('create index de_subject_smpl_mpng_idx4 on de_subject_sample_mapping(platform, gpl_id) parallel nologging');
    --stepCt := stepCt + 1;
	--cz_write_audit(jobId,databaseName,procedureName,'Recreate indexes on DEAPP de_subject_sample_mapping',0,stepCt,'Done');

--	Insert records for patients and samples into observation_fact

	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,INSTANCE_NUM
    )
    PERFORM distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null	--	not numeric for RNA_sequencing
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,1
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCD
      and m.platform = 'RNA_AFFYMETRIX';
	  
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');

    commit;
  
	--	Insert sample facts 
	
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,INSTANCE_NUM
    )
    PERFORM distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null	--	not numeric for RNA_sequencing
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,1
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCd
      and m.platform = 'RNA_AFFYMETRIX'
	  and m.patient_id != m.sample_id;
	  
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');

    commit;
    
	--Update I2b2 for correct data type
	
	update i2b2 t
	set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
	where t.c_basecode in (select distinct x.concept_cd from wt_RNA_SEQ_nodes x);
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	update i2b2
	SET c_columndatatype = 'N',
      --Static XML String
		c_metadataxml = '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
	where c_basecode IN (
		  SELECT xd.concept_cd
		  from wt_RNA_SEQ_nodes xd
			  ,observation_fact xf
		  where xf.concept_cd = xd.concept_cd
		  procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
	commit;
  
/*
	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	update i2b2 a
    set c_visualattributes = 'LA'
    where 1 = (
      select count(*)
      from i2b2 b
      where b.c_fullname like (a.c_fullname || '%'))
      and c_fullname like '%' || topNode || '%';
*/

	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	update i2b2 a
    set c_visualattributes = 'LAH'
	where a.c_basecode in (select distinct x.concept_code from de_subject_sample_mapping x
						   where x.trial_name = TrialId
						     and x.platform = 'RNA_AFFYMETRIX'
							 and (x.concept_code IS NOT NULL AND x.concept_code::text <> ''));
	  
	stepCt := stepCt + 1;
     
	cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
  
	COMMIT;
   insert into probeset_deapp
   (
   probeset,
   platform 
   )select distinct s.probeset
               ,m.platform               
            from lt_src_rna_seq_data s,
                 lt_src_RNA_SEQ_subj_samp_map m  
                 where s.trial_name=m.trial_name  
                   and not exists
		 (select 1 from probeset_deapp x
		  where m.platform = x.platform
		    and s.probeset = x.probeset);
                    
                    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert new probesets into probeset_deapp',SQL%ROWCOUNT,stepCt,'Done');
        
        

  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for RNA_sequencing data
  
    i2b2_create_concept_counts(topNode ,jobID );
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done');
	
	--	delete each node that is hidden

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		i2b2_delete_1_node(r_delNodes.c_fullname);
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		
		cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');

	END LOOP;  	

  --Reload Security: Inserts one record for every I2B2 record into the security table

    i2b2_load_security_data(jobId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done');

--	tag data with probeset_id from reference.probeset_deapp
  
	EXECUTE ('truncate table tm_wz.wt_subject_rna_probeset');
	
	--	note: assay_id represents a unique subject/site/sample


	insert into wt_subject_rna_probeset
	(probeset_id
--	,expr_id
	,intensity_value
	,patient_id
--	,sample_cd
--	,subject_id
	,trial_name
	,assay_id
	) select md.probeset
--		  ,sd.sample_cd
		 , avg(md.intensity_value) as intensity_value
		  ,sd.patient_id
--		  ,sd.sample_cd
--		  ,sd.subject_id
		 ,TrialId as trial_name
		  ,sd.assay_id
	from de_subject_sample_mapping sd
		,lt_src_RNA_SEQ_data md   
		,probeset_deapp gs
	where sd.sample_cd = md.expr_id
	  and sd.platform = 'RNA_AFFYMETRIX'
	  and sd.trial_name = TrialId
	  and sd.source_cd = sourceCd
	--  and sd.gpl_id = gs.platform
	and md.probeset = gs.probeset
	  and decode(dataType,'R',sign(md.intensity_value),1) = 1  --	take only >0 for dataType R
          --and rownum = 1
	group by md.probeset
		--  ,sd.sample_cd
		  ,sd.patient_id
		--  ,sd.sample_cd
		--  ,sd.subject_id
		  ,sd.assay_id;

	pExists := SQL%ROWCOUNT;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_rna_probeset',SQL%ROWCOUNT,stepCt,'Done');

	commit;		
	
	/*if pExists = 0 then
		raise no_probeset_recs;
	end if;*/

	--	insert into de_subject_rna_data when dataType is T (transformed)

	if dataType = 'T' then
		insert into de_subject_rna_data
		(trial_source
		,probeset_id
		,assay_id
		,patient_id
		--,sample_id
		--,subject_id
		,trial_name
		,zscore
		)
		PERFORM TrialId || ':' || sourceCd
			  ,probeset_id
			  ,assay_id
			  ,patient_id
			  --,sample_id
			  --,subject_id
			  ,trial_name
			  ,case when intensity_value < -2.5
			        then -2.5
					when intensity_value > 2.5
					then 2.5
					else intensity_value
			   end as zscore
		from wt_subject_rna_probeset 
		where trial_name = TrialID;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Insert transformed into DEAPP de_subject_rna_data',SQL%ROWCOUNT,stepCt,'Done');

		commit;	
	else
		
	--	Calculate ZScores and insert data into de_subject_rna_data.  The 'L' parameter indicates that the RNA_sequencing  data will be selected from
	--	wt_subject_RNA_seq_probeset as part of a Load.  

		if dataType = 'R' or dataType = 'L' then
			I2B2_RNA_SEQ_ZSCORE_CALC(TrialID,'L',jobId,dataType,logBase,sourceCD);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',0,stepCt,'Done');
			commit;
		end if;
	
	end if;
	
    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_RNA_SEQ_data',0,stepCt,'Done');

	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;
	
	PERFORM 0 into rtn_code ;

	EXCEPTION
	--when unmapped_patients then
	--	cz_write_audit(jobId,databasename,procedurename,'No site_id/subject_id mapped to patient_dimension',1,stepCt,'ERROR');
	--	cz_error_handler(jobid,procedurename);
	--	cz_end_audit (jobId,'FAIL');
	when missing_platform then
		cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		cz_error_handler(jobid,procedurename);
		cz_end_audit (jobId,'FAIL');
		PERFORM 161 into rtn_code ;
	when missing_tissue then
		cz_write_audit(jobId,databasename,procedurename,'Tissue Type data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		cz_error_handler(jobid,procedurename);
		CZ_END_AUDIT (JOBID,'FAIL');
		PERFORM 162 into rtn_code ;
	/*when unmapped_platform then
		cz_write_audit(jobId,databasename,procedurename,'Platform not found in de_RNA_annotation',1,stepCt,'ERROR');
		CZ_ERROR_HANDLER(JOBID,PROCEDURENAME);
		cz_end_audit (jobId,'FAIL');
		select 163 into rtn_code from dual;*/
	when multiple_platform then
		cz_write_audit(jobId,databasename,procedurename,'Multiple platforms for sample_cd in lt_src_RNA_SEQ_subj_samp_map',1,stepCt,'ERROR');
		CZ_ERROR_HANDLER(JOBID,PROCEDURENAME);
		cz_end_audit (jobId,'FAIL');
		PERFORM 164 into rtn_code ;
	/*when no_probeset_recs then
		cz_write_audit(jobId,databasename,procedurename,'Unable to match probesets to platform in probeset_deapp',1,stepCt,'ERROR');
		CZ_ERROR_HANDLER(JOBID,PROCEDURENAME);
		cz_end_audit (jobId,'FAIL');
		select 165 into rtn_code from dual;*/
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		--End Proc
		cz_end_audit (jobID, 'FAIL');
		PERFORM 166 into rtn_code ;
END;
 
$_$;


ALTER FUNCTION deapp.i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, OUT rtn_code numeric) OWNER TO deapp;

--
-- Name: protein_comparison_qry(character varying, character varying, character varying, character varying, refcursor); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION protein_comparison_qry(patient_ids character varying, sample_types character varying, pathway_uid1 character varying, timepoints character varying, INOUT cv_1 refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE

  --Counter to check if samples exist.
  sample_record_count integer;
  timepoint_count integer;


BEGIN
  -------------------------------------------------------------------------------
   -- Returns PROBESET, GENE_SYMBOL, REFSEQ, LOG10_INTENSITY, PVALUE, PATIENT_ID, ASSAY_ID
   -- result set for specifed Pathways filtered
   -- by Sample Types and Subject_id.
   -- KCR@20090206 - First rev.
   -- KCR@20090212 - Second rev.  Changed logic so that if Sampel is not found it returns Zero.
   -- KCR@20090206 - Third rev. Using Collections to hold parsed values instead of DB table.
   -- HX@20090317  - Replace pathway_name with pathway_uid
   -- HX@20090318  - Add pathway_uid column into DE_PATHWAY and populate data
   --                from BIOMART.BIO_DATA_UID

   -- 2009-05-04: replace refseq with probeset
   -- 2009-05-26: remove GENE_SYMBOL's concatenation and change probeset to refseq
   -- 2009-05-29: change LOG10_INTENSITY to LOG2_INTENSITY
   -- 2009-06-18: add raw_intensity and change log2_intensity to zscore
   -- 2009-06-23: Add timepoints as a parameter
   -------------------------------------------------------------------------------

-- Check if sample Types Exist
SELECT COUNT(*)
  INTO sample_record_count
  FROM DE_SUBJECT_SAMPLE_MAPPING
    WHERE concept_code IN
      --Passing string to Text parser Function
      (SELECT * from table(text_parser(sample_types)));

 --Sample Record Count is invalid or non existent.
  IF sample_record_count = 0
    THEN
    BEGIN

      select count(*) into timepoint_count
      from table(text_parser(timepoints));

      if timepoint_count=0 then

          OPEN cv_1 FOR
          SELECT distinct a.component, a.GENE_SYMBOL, a.zscore,
                 a.patient_ID, a.ASSAY_ID, a.intensity
              FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids)))
          order by a.GENE_SYMBOL, a.COMPONENT, a.patient_ID ;

      else

          OPEN cv_1 FOR
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL, a.zscore,
                 a.patient_ID, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids))) and
                b.TIMEPOINT_CD IN (SELECT * from table(text_parser(timepoints))) and
                a.PATIENT_ID=b.patient_id and a.timepoint=b.timepoint and
                a.assay_id=b.assay_id
          order by a.GENE_SYMBOL, a.COMPONENT, a.patient_ID;
      end if;
    END;

  --else use all filters (If Subject is non existent or invalid, then return
  ELSE
    BEGIN

    if timepoint_count=0 then
      OPEN cv_1 FOR
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL,  a.zscore,
                 a.patient_ID, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.PATIENT_ID = b.PATIENT_ID and a.assay_id = b.assay_id and
                b.concept_code IN (SELECT * from table(text_parser(sample_types))) and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids)))
          order by a.GENE_SYMBOL, a.COMPONENT, a.patient_ID;

    else

      OPEN cv_1 FOR
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL, a.zscore,
                 a.patient_ID, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.PATIENT_ID = b.PATIENT_ID and a.assay_id = b.assay_id and
                b.concept_code IN (SELECT * from table(text_parser(sample_types))) and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids))) and
                b.TIMEPOINT_CD IN (SELECT * from table(text_parser(timepoints))) and
                a.PATIENT_ID=b.patient_id and a.timepoint=b.timepoint
          order by a.GENE_SYMBOL, a.COMPONENT, a.patient_ID;

    end if;

    END;
  END IF;
END protein_comparison_qry;
 
$$;


ALTER FUNCTION deapp.protein_comparison_qry(patient_ids character varying, sample_types character varying, pathway_uid1 character varying, timepoints character varying, INOUT cv_1 refcursor) OWNER TO deapp;

--
-- Name: protein_dbl_comp_qry(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, refcursor); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION protein_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, sample_types1 character varying, sample_types2 character varying, pathway_uid1 character varying, pathway_uid2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE

  sample_record_count1 integer;
  sample_record_count2 integer;
  timepoint_count1 integer;
  timepoint_count2 integer;

BEGIN
-- Check if sample Types Exist
SELECT COUNT(*)
  INTO sample_record_count1
  FROM DE_SUBJECT_SAMPLE_MAPPING
    WHERE concept_code IN
      --Passing string to Text parser Function
      (SELECT * from table(text_parser(sample_types1)));

SELECT COUNT(*)
  INTO sample_record_count2
  FROM DE_SUBJECT_SAMPLE_MAPPING
    WHERE concept_code IN
      --Passing string to Text parser Function
      (SELECT * from table(text_parser(sample_types2)));

 --Sample Record Count is invalid or non existent.
  IF sample_record_count1 = 0
    THEN
    BEGIN

      select count(*) into timepoint_count1
      from table(text_parser(timepoints1));

      select count(*) into timepoint_count2
      from table(text_parser(timepoints2));

      if ((timepoint_count1=0) and (timepoint_count2=0)) then

          OPEN cv_1 FOR
          SELECT distinct a.component, a.GENE_SYMBOL, a.zscore,
                 'S1_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
              FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids1)))
          UNION
          SELECT distinct a.component, a.GENE_SYMBOL, a.zscore,
                 'S2_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
              FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids2)))
          order by GENE_SYMBOL, COMPONENT, patient_ID ;
      elsif ((timepoint_count1>0) and (timepoint_count2=0)) then
          OPEN cv_1 FOR
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL, a.zscore,
                 'S1_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids1))) and
                b.TIMEPOINT_CD IN (SELECT * from table(text_parser(timepoints1))) and
                a.PATIENT_ID=b.patient_id and a.timepoint=b.timepoint and
                a.assay_id=b.assay_id
          UNION
          SELECT distinct a.component, a.GENE_SYMBOL, a.zscore,
                 'S2_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
              FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids2)))
          order by GENE_SYMBOL, COMPONENT, patient_ID ;

      elsif ((timepoint_count1=0) and (timepoint_count2>0)) then
          OPEN cv_1 FOR
          SELECT distinct a.component, a.GENE_SYMBOL, a.zscore,
                 'S1_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
              FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids1)))
          UNION
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL, a.zscore,
                 'S2_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids2))) and
                b.TIMEPOINT_CD IN (SELECT * from table(text_parser(timepoints2))) and
                a.PATIENT_ID=b.patient_id and a.timepoint=b.timepoint and
                a.assay_id=b.assay_id
          order by GENE_SYMBOL, COMPONENT, patient_ID ;

      else

          OPEN cv_1 FOR
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL, a.zscore,
                 'S1_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids1))) and
                b.TIMEPOINT_CD IN (SELECT * from table(text_parser(timepoints1))) and
                a.PATIENT_ID=b.patient_id and a.timepoint=b.timepoint and
                a.assay_id=b.assay_id
          UNION
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL, a.zscore,
                 'S2_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids2))) and
                b.TIMEPOINT_CD IN (SELECT * from table(text_parser(timepoints2))) and
                a.PATIENT_ID=b.patient_id and a.timepoint=b.timepoint and
                a.assay_id=b.assay_id
          order by GENE_SYMBOL, COMPONENT, patient_ID;
      end if;
    END;

  --else use all filters (If Subject is non existent or invalid, then return
  ELSE
    BEGIN

    if ((timepoint_count1=0) and (timepoint_count2=0)) then
      OPEN cv_1 FOR
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL,  a.zscore,
                 'S1_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.PATIENT_ID = b.PATIENT_ID and a.assay_id = b.assay_id and
                b.concept_code IN (SELECT * from table(text_parser(sample_types1))) and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids1)))
          UNION
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL,  a.zscore,
                 'S2_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.PATIENT_ID = b.PATIENT_ID and a.assay_id = b.assay_id and
                b.concept_code IN (SELECT * from table(text_parser(sample_types2))) and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids2)))
          order by GENE_SYMBOL, COMPONENT, patient_ID;
    elsif ((timepoint_count1>0) and (timepoint_count2=0)) then
      OPEN cv_1 FOR
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL, a.zscore,
                 'S1_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.PATIENT_ID = b.PATIENT_ID and a.assay_id = b.assay_id and
                b.concept_code IN (SELECT * from table(text_parser(sample_types1))) and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids1))) and
                b.TIMEPOINT_CD IN (SELECT * from table(text_parser(timepoints1))) and
                a.PATIENT_ID=b.patient_id and a.timepoint=b.timepoint
          UNION
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL,  a.zscore,
                 'S2_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.PATIENT_ID = b.PATIENT_ID and a.assay_id = b.assay_id and
                b.concept_code IN (SELECT * from table(text_parser(sample_types2))) and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids2)))
          order by GENE_SYMBOL, COMPONENT, patient_ID;
    elsif ((timepoint_count1=0) and (timepoint_count2>0)) then
      OPEN cv_1 FOR
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL,  a.zscore,
                 'S1_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.PATIENT_ID = b.PATIENT_ID and a.assay_id = b.assay_id and
                b.concept_code IN (SELECT * from table(text_parser(sample_types1))) and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids1)))
          UNION
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL, a.zscore,
                 'S2_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.PATIENT_ID = b.PATIENT_ID and a.assay_id = b.assay_id and
                b.concept_code IN (SELECT * from table(text_parser(sample_types2))) and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids2))) and
                b.TIMEPOINT_CD IN (SELECT * from table(text_parser(timepoints2))) and
                a.PATIENT_ID=b.patient_id and a.timepoint=b.timepoint
          order by GENE_SYMBOL, COMPONENT, patient_ID;
    else

      OPEN cv_1 FOR
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL, a.zscore,
                 'S1_' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.PATIENT_ID = b.PATIENT_ID and a.assay_id = b.assay_id and
                b.concept_code IN (SELECT * from table(text_parser(sample_types1))) and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids1))) and
                b.TIMEPOINT_CD IN (SELECT * from table(text_parser(timepoints1))) and
                a.PATIENT_ID=b.patient_id and a.timepoint=b.timepoint
          UNION
          SELECT distinct a.COMPONENT, a.GENE_SYMBOL, a.zscore,
                 'S2' || a.patient_ID as patient_id, a.ASSAY_ID, a.intensity
          FROM DE_SUBJECT_PROTEIN_DATA a, DE_pathway_gene c, de_pathway p,
               DE_subject_sample_mapping b
          where p.pathway_uid= pathway_uid1 and c.pathway_id= p.id and
                a.gene_symbol = c.gene_symbol and
                a.PATIENT_ID = b.PATIENT_ID and a.assay_id = b.assay_id and
                b.concept_code IN (SELECT * from table(text_parser(sample_types2))) and
                a.patient_id IN (SELECT * from table(text_parser(patient_ids2))) and
                b.TIMEPOINT_CD IN (SELECT * from table(text_parser(timepoints2))) and
                a.PATIENT_ID=b.patient_id and a.timepoint=b.timepoint
          order by GENE_SYMBOL, COMPONENT, patient_ID;

    end if;

    END;
  END IF;

END PROTEIN_DBL_COMP_QRY;
 
 
 
$$;


ALTER FUNCTION deapp.protein_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, sample_types1 character varying, sample_types2 character varying, pathway_uid1 character varying, pathway_uid2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) OWNER TO deapp;

--
-- Name: rbm_comparison_qry(character varying, character varying, character varying, refcursor); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION rbm_comparison_qry(patient_ids character varying, concept_cds character varying, timepoints character varying, INOUT cv_1 refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE


  tp_cnt integer;

BEGIN
  -------------------------------------------------------------------------------
   -- Returns ANTIGENE, GENE_SYMBOL, VALUE, PATIENT_ID, ASSAY_ID
   -- result set for specifed Pathways filtered
   -- by Sample Types and Subject_id.
   -- HX@20090317 - First rev.
   -- HX@20090319 - Rename DE_RBM_DATA to DE_SUBJECT_RBM_DATA and move CONCEPT_CD
   --     from DE_RBM_DATA to DE_SUBJECT_SAMPLE_MAPPING, and make the query
   --     and table names are  consistent with MicroArray's one

   -- 2009-06-18: change normalized_value to zscore
   -- 2009-06-23: Add timepoints as parameter
   -- 2009-06-30: Remove t1.zscore is not null condition
   -------------------------------------------------------------------------------

   select count(*) into tp_cnt
   from de_subject_sample_mapping
   where timepoint_cd in
       (select * from table(text_parser(timepoints)));


   if (tp_cnt=0) then
        OPEN cv_1 FOR
           SELECT distinct t1.ANTIGEN_NAME, t1.GENE_SYMBOL, t1.zscore as value,
                 t1.patient_id, t1.assay_id
           FROM DE_SUBJECT_RBM_DATA t1
           where -- t1.zscore is not null and
              t1.patient_id IN (SELECT * from table(text_parser(patient_ids)))
               order by t1.ANTIGEN_NAME, t1.GENE_SYMBOL, t1.patient_id;
   else
        OPEN cv_1 FOR
           SELECT distinct t1.ANTIGEN_NAME, t1.GENE_SYMBOL, t1.zscore as value,
                  t1.patient_id, t1.assay_id
           FROM DE_SUBJECT_RBM_DATA t1, de_subject_sample_mapping t2
           where --t1.zscore is not null and
              t2.patient_id IN (SELECT * from table(text_parser(patient_ids))) and
              t2.timepoint_cd in (select * from TABLE(text_parser(timepoints))) and
              t1.data_uid = t2.data_uid and t1.assay_id=t2.assay_id
              order by t1.ANTIGEN_NAME, t1.GENE_SYMBOL, t1.patient_id;
    end if;
END RBM_comparison_qry;
 
 
 
$$;


ALTER FUNCTION deapp.rbm_comparison_qry(patient_ids character varying, concept_cds character varying, timepoints character varying, INOUT cv_1 refcursor) OWNER TO deapp;

--
-- Name: rbm_dbl_comp_qry(character varying, character varying, character varying, character varying, character varying, character varying, refcursor); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION rbm_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, concept_cds1 character varying, concept_cds2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE

  tp_cnt1 integer;
  tp_cnt2 integer;

BEGIN
   select count(*) into tp_cnt1
   from de_subject_sample_mapping
   where timepoint_cd in
       (select * from table(text_parser(timepoints1)));

   select count(*) into tp_cnt2
   from de_subject_sample_mapping
   where timepoint_cd in
       (select * from table(text_parser(timepoints2)));


   if ((tp_cnt1=0) and (tp_cnt2=0)) then
        OPEN cv_1 FOR
           SELECT distinct ANTIGEN_NAME, GENE_SYMBOL, zscore as value,
                 'S1_' || patient_id as patient_id, assay_id
           FROM DE_SUBJECT_RBM_DATA
           where -- t1.zscore is not null and
              patient_id IN (SELECT * from table(text_parser(patient_ids1)))
          UNION
          SELECT distinct ANTIGEN_NAME, GENE_SYMBOL, zscore as value,
                 'S2_' || patient_id as patient_id, assay_id
           FROM DE_SUBJECT_RBM_DATA t1
           where -- t1.zscore is not null and
              patient_id IN (SELECT * from table(text_parser(patient_ids2)))
               order by ANTIGEN_NAME, GENE_SYMBOL, patient_id;
   elsif ((tp_cnt1=0) and (tp_cnt2 > 0)) then
           OPEN cv_1 FOR
           SELECT distinct ANTIGEN_NAME, GENE_SYMBOL, zscore as value,
                 'S1_' || patient_id as patient_id, assay_id
           FROM DE_SUBJECT_RBM_DATA t1
           where -- zscore is not null and
              patient_id IN (SELECT * from table(text_parser(patient_ids1)))
          UNION
           SELECT distinct t1.ANTIGEN_NAME, t1.GENE_SYMBOL, t1.zscore as value,
                  'S1_' || t1.patient_id as patient_id, t1.assay_id
           FROM DE_SUBJECT_RBM_DATA t1, de_subject_sample_mapping t2
           where --t1.zscore is not null and
              t2.patient_id IN (SELECT * from table(text_parser(patient_ids2))) and
              t2.timepoint_cd in (select * from TABLE(text_parser(timepoints2))) and
              t1.data_uid = t2.data_uid and t1.assay_id=t2.assay_id
              order by ANTIGEN_NAME, GENE_SYMBOL, patient_id;

   elsif ((tp_cnt1 > 0 ) and (tp_cnt2 = 0)) then
        OPEN cv_1 FOR
           SELECT distinct t1.ANTIGEN_NAME, t1.GENE_SYMBOL, t1.zscore as value,
                  'S1_' || t1.patient_id as patient_id  , t1.assay_id
           FROM DE_SUBJECT_RBM_DATA t1, de_subject_sample_mapping t2
           where --t1.zscore is not null and
              t2.patient_id IN (SELECT * from table(text_parser(patient_ids1))) and
              t2.timepoint_cd in (select * from TABLE(text_parser(timepoints1))) and
              t1.data_uid = t2.data_uid and t1.assay_id=t2.assay_id
          UNION
          SELECT distinct t1.ANTIGEN_NAME, t1.GENE_SYMBOL, t1.zscore as value,
                 'S2_' || patient_id as patient_id, t1.assay_id
           FROM DE_SUBJECT_RBM_DATA t1
           where -- t1.zscore is not null and
              t1.patient_id IN (SELECT * from table(text_parser(patient_ids2)))
               order by ANTIGEN_NAME, GENE_SYMBOL, patient_id;
   else
        OPEN cv_1 FOR
          SELECT distinct t1.ANTIGEN_NAME, t1.GENE_SYMBOL, t1.zscore as value,
                  'S1_' || t1.patient_id as patient_id, t1.assay_id
           FROM DE_SUBJECT_RBM_DATA t1, de_subject_sample_mapping t2
           where --t1.zscore is not null and
              t2.patient_id IN (SELECT * from table(text_parser(patient_ids1))) and
              t2.timepoint_cd in (select * from TABLE(text_parser(timepoints1))) and
              t1.data_uid = t2.data_uid and t1.assay_id=t2.assay_id
          UNION
          SELECT distinct t1.ANTIGEN_NAME, t1.GENE_SYMBOL, t1.zscore as value,
                  'S2_' || t1.patient_id as patient_id, t1.assay_id
           FROM DE_SUBJECT_RBM_DATA t1, de_subject_sample_mapping t2
           where --t1.zscore is not null and
              t2.patient_id IN (SELECT * from table(text_parser(patient_ids2))) and
              t2.timepoint_cd in (select * from TABLE(text_parser(timepoints2))) and
              t1.data_uid = t2.data_uid and t1.assay_id=t2.assay_id
              order by ANTIGEN_NAME, GENE_SYMBOL, patient_id;
    end if;

END RBM_DBL_COMP_QRY;
 
$$;


ALTER FUNCTION deapp.rbm_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, concept_cds1 character varying, concept_cds2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) OWNER TO deapp;

--
-- Name: tf_de_parent_cd_trg(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_de_parent_cd_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  SELECT nextval('deapp.de_parent_cd_seq')
  INTO new.parent_cd
  ;
RETURN NEW;
END;
$$;


ALTER FUNCTION deapp.tf_de_parent_cd_trg() OWNER TO deapp;

--
-- Name: tf_rbm_id_trigger(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_rbm_id_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.ID is null then
 select nextval('deapp.RBM_ANNOTATION_ID') into NEW.ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_rbm_id_trigger() OWNER TO deapp;

--
-- Name: tf_trg_de_mrna_annotation_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_mrna_annotation_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.DE_MRNA_ANNOTATION_ID is null then
 select nextval('deapp.SEQ_DE_MRNA_ANNOTATION_ID') into NEW.DE_MRNA_ANNOTATION_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_mrna_annotation_id() OWNER TO deapp;

--
-- Name: tf_trg_de_pathway_gene_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_pathway_gene_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.ID is null then
 select nextval('deapp.SEQ_DATA_ID') into NEW.ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_pathway_gene_id() OWNER TO deapp;

--
-- Name: tf_trg_de_pathway_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_pathway_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.ID is null then
 select nextval('deapp.SEQ_DATA_ID') into NEW.ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_pathway_id() OWNER TO deapp;

--
-- Name: tf_trg_de_snp_info_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_snp_info_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if NEW.SNP_INFO_ID is null then
         select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_INFO_ID ;
      end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_snp_info_id() OWNER TO deapp;

--
-- Name: tf_trg_de_snp_probe_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_snp_probe_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if NEW.SNP_PROBE_ID is null then
         select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_PROBE_ID ;
      end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_snp_probe_id() OWNER TO deapp;

--
-- Name: tf_trg_de_snp_probe_sorted_def_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_snp_probe_sorted_def_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if NEW.SNP_PROBE_SORTED_DEF_ID is null then
         select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_PROBE_SORTED_DEF_ID ;
      end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_snp_probe_sorted_def_id() OWNER TO deapp;

--
-- Name: tf_trg_de_subj_rbm_data_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_subj_rbm_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.ID is null then
 select nextval('deapp.DE_SUBJECT_RBM_DATA_SEQ') into NEW.ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_subj_rbm_data_id() OWNER TO deapp;

--
-- Name: tf_trg_de_subject_snp_dataset_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_subject_snp_dataset_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if NEW.SUBJECT_SNP_DATASET_ID is null then
         select nextval('deapp.SEQ_DATA_ID') into NEW.SUBJECT_SNP_DATASET_ID ;
      end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_subject_snp_dataset_id() OWNER TO deapp;

--
-- Name: tf_trg_de_subject_sorted_def_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_de_subject_sorted_def_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
if coalesce(NEW.SNP_SUBJECT_SORTED_DEF_ID::text, '') = '' then
select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_SUBJECT_SORTED_DEF_ID ;
end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_de_subject_sorted_def_id() OWNER TO deapp;

--
-- Name: tf_trg_snp_data_by_patient_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_snp_data_by_patient_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if NEW.SNP_DATA_BY_PATIENT_ID is null then
         select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_DATA_BY_PATIENT_ID ;
  end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_snp_data_by_patient_id() OWNER TO deapp;

--
-- Name: tf_trg_snp_data_by_pprobe_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_snp_data_by_pprobe_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
      if NEW.SNP_DATA_BY_PROBE_ID is null then
         select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_DATA_BY_PROBE_ID ;
      end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_snp_data_by_pprobe_id() OWNER TO deapp;

--
-- Name: tf_trg_snp_data_dataset_loc_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_snp_data_dataset_loc_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.SNP_DATA_DATASET_LOC_ID is null then
 select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_DATA_DATASET_LOC_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_snp_data_dataset_loc_id() OWNER TO deapp;

--
-- Name: tf_trg_snp_subject_sorted_def_id(); Type: FUNCTION; Schema: deapp; Owner: deapp
--

CREATE FUNCTION tf_trg_snp_subject_sorted_def_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
if coalesce(NEW.SNP_SUBJECT_SORTED_DEF_ID::text, '') = '' then
select nextval('deapp.SEQ_DATA_ID') into NEW.SNP_SUBJECT_SORTED_DEF_ID ;
end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION deapp.tf_trg_snp_subject_sorted_def_id() OWNER TO deapp;

SET search_path = fmapp, pg_catalog;

--
-- Name: fm_file_uid(character varying); Type: FUNCTION; Schema: fmapp; Owner: fmapp
--

CREATE FUNCTION fm_file_uid(file_id character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for fm_file.

  RETURN 'FIL:' || coalesce(FILE_ID, 'ERROR');
END;
$_$;


ALTER FUNCTION fmapp.fm_file_uid(file_id character varying) OWNER TO fmapp;

--
-- Name: fm_folder_uid(numeric); Type: FUNCTION; Schema: fmapp; Owner: fmapp
--

CREATE FUNCTION fm_folder_uid(folder_id numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
	BEGIN
		RETURN 'FOL:' || FOLDER_ID;
	END;
$$;


ALTER FUNCTION fmapp.fm_folder_uid(folder_id numeric) OWNER TO fmapp;

--
-- Name: fm_get_folder_full_name(bigint); Type: FUNCTION; Schema: fmapp; Owner: fmapp
--

CREATE FUNCTION fm_get_folder_full_name(p_folder_id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_parent_id bigint;
  v_folder_full_name character varying(1000);
begin

  select parent_id into v_parent_id
  from fm_folder
  where folder_id = p_folder_id;
  
  v_folder_full_name := fm_folder_uid(p_folder_id) || '\';
  
  while v_parent_id is not null
  loop
    v_folder_full_name := fm_folder_uid(v_parent_id) || '\' || v_folder_full_name;

    select parent_id into v_parent_id
    from fm_folder
    where folder_id = v_parent_id;
  end loop;

  v_folder_full_name := '\' || v_folder_full_name;
  
  return v_folder_full_name;  
end;
$$;


ALTER FUNCTION fmapp.fm_get_folder_full_name(p_folder_id bigint) OWNER TO fmapp;

--
-- Name: fm_update_folder_full_name(); Type: FUNCTION; Schema: fmapp; Owner: fmapp
--

CREATE FUNCTION fm_update_folder_full_name() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_folder_full_name character varying(1000);
  folder_ids CURSOR is
    select folder_id
    from fm_folder;
    
begin
  for folder_rec in folder_ids
  loop
    select fm_get_folder_full_name(folder_rec.folder_id) into v_folder_full_name
    from dual;
    
    update fm_folder set folder_full_name = v_folder_full_name
    where folder_id = folder_rec.folder_id;
  end loop;
end;
$$;


ALTER FUNCTION fmapp.fm_update_folder_full_name() OWNER TO fmapp;

--
-- Name: tf_trg_fm_file_id(); Type: FUNCTION; Schema: fmapp; Owner: fmapp
--

CREATE FUNCTION tf_trg_fm_file_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.FILE_ID is null then
 select nextval('fmapp.SEQ_FM_ID') into NEW.FILE_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION fmapp.tf_trg_fm_file_id() OWNER TO fmapp;

--
-- Name: tf_trg_fm_file_uid(); Type: FUNCTION; Schema: fmapp; Owner: fmapp
--

CREATE FUNCTION tf_trg_fm_file_uid() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_count bigint;
BEGIN
  SELECT COUNT(*) INTO rec_count 
  FROM fm_data_uid 
  WHERE fm_data_id = new.file_id;
  
  if rec_count = 0 then
    insert into fmapp.fm_data_uid (fm_data_id, unique_id, fm_data_type)
    values (NEW.file_id, fm_file_uid(NEW.file_id::text), 'FM_FILE');
  end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION fmapp.tf_trg_fm_file_uid() OWNER TO fmapp;

--
-- Name: tf_trg_fm_folder_id(); Type: FUNCTION; Schema: fmapp; Owner: fmapp
--

CREATE FUNCTION tf_trg_fm_folder_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	begin
      if coalesce(NEW.FOLDER_ID::text, '') = '' then
        select nextval('FMAPP.SEQ_FM_ID') into NEW.FOLDER_ID ;
      end if;
	  if coalesce(NEW.FOLDER_FULL_NAME::text, '') = '' then
		if coalesce(NEW.PARENT_ID::text, '') = '' then
			select '\' || fm_folder_uid(NEW.folder_id) || '\' into NEW.FOLDER_FULL_NAME ;
		else
			select folder_full_name || fm_folder_uid(NEW.folder_id) || '\' into NEW.FOLDER_FULL_NAME 
      from fm_folder
      where folder_id = NEW.parent_id;
		end if;
      end if;
      RETURN NEW;
  end;
$$;


ALTER FUNCTION fmapp.tf_trg_fm_folder_id() OWNER TO fmapp;

--
-- Name: tf_trg_fm_folder_uid(); Type: FUNCTION; Schema: fmapp; Owner: fmapp
--

CREATE FUNCTION tf_trg_fm_folder_uid() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_count bigint;
BEGIN
  SELECT COUNT(*) INTO rec_count 
  FROM fm_data_uid 
  WHERE fm_data_id = new.folder_id;
  
  if rec_count = 0 then
    insert into fmapp.fm_data_uid (fm_data_id, unique_id, fm_data_type)
    values (NEW.folder_id, fm_folder_uid(NEW.folder_id), 'FM_FOLDER');
  end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION fmapp.tf_trg_fm_folder_uid() OWNER TO fmapp;

SET search_path = i2b2demodata, pg_catalog;

--
-- Name: create_temp_concept_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

BEGIN 
execute 'create table ' ||  tempConceptTableName || ' (
        CONCEPT_CD VARCHAR(50) NOT NULL, 
	CONCEPT_PATH VARCHAR(900) NOT NULL , 
	NAME_CHAR VARCHAR(2000), 
	CONCEPT_BLOB TEXT, 
	UPDATE_DATE date, 
	DOWNLOAD_DATE DATE, 
	IMPORT_DATE DATE, 
	SOURCESYSTEM_CD VARCHAR(50)
	 )';

 execute 'CREATE INDEX idx_' || tempConceptTableName || '_pat_id ON ' || tempConceptTableName || '  (CONCEPT_PATH)';
  
   

EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_eid_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

BEGIN 
execute 'create table ' ||  tempPatientMappingTableName || ' (
	ENCOUNTER_MAP_ID       	VARCHAR(200) NOT NULL,
    ENCOUNTER_MAP_ID_SOURCE	VARCHAR(50) NOT NULL,
    PATIENT_MAP_ID          VARCHAR(200), 
	PATIENT_MAP_ID_SOURCE   VARCHAR(50), 
    ENCOUNTER_ID       	    VARCHAR(200) NOT NULL,
    ENCOUNTER_ID_SOURCE     VARCHAR(50) ,
    ENCOUNTER_NUM           NUMERIC, 
    ENCOUNTER_MAP_ID_STATUS    VARCHAR(50),
    PROCESS_STATUS_FLAG     CHAR(1),
	UPDATE_DATE DATE, 
	DOWNLOAD_DATE DATE, 
	IMPORT_DATE DATE, 
	SOURCESYSTEM_CD VARCHAR(50)
)';

execute 'CREATE INDEX idx_' || tempPatientMappingTableName || '_eid_id ON ' || tempPatientMappingTableName || '  (ENCOUNTER_ID, ENCOUNTER_ID_SOURCE, ENCOUNTER_MAP_ID, ENCOUNTER_MAP_ID_SOURCE, ENCOUNTER_NUM)';

 execute 'CREATE INDEX idx_' || tempPatientMappingTableName || '_stateid_eid_id ON ' || tempPatientMappingTableName || '  (PROCESS_STATUS_FLAG)';  
    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_modifier_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_modifier_table(tempmodifiertablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
EXECUTE 'create table ' ||  tempModifierTableName || ' (
        MODIFIER_CD varchar(50) NOT NULL,
	MODIFIER_PATH varchar(900) NOT NULL ,
	NAME_CHAR varchar(2000),
	MODIFIER_BLOB text,
	UPDATE_DATE timestamp,
	DOWNLOAD_DATE timestamp,
	IMPORT_DATE timestamp,
	SOURCESYSTEM_CD varchar(50)
	 )';

 EXECUTE 'CREATE INDEX idx_' || tempModifierTableName || '_pat_id ON ' || tempModifierTableName || '  (MODIFIER_PATH)';

EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '%%%', SQLSTATE,  ' - ' , SQLERRM;
END;
 
$$;


ALTER FUNCTION i2b2demodata.create_temp_modifier_table(tempmodifiertablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_patient_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 
	-- Create temp table to store encounter/visit information
	execute 'create table ' ||  tempPatientDimensionTableName || ' (
		PATIENT_ID VARCHAR(200), 
		PATIENT_ID_SOURCE VARCHAR(50),
		PATIENT_NUM NUMERIC(38,0),
	    VITAL_STATUS_CD VARCHAR(50), 
	    BIRTH_DATE DATE, 
	    DEATH_DATE DATE, 
	    SEX_CD CHAR(50), 
	    AGE_IN_YEARS_NUM NUMERIC(5,0), 
	    LANGUAGE_CD VARCHAR(50), 
		RACE_CD VARCHAR(50 ), 
		MARITAL_STATUS_CD VARCHAR(50), 
		RELIGION_CD VARCHAR(50), 
		ZIP_CD VARCHAR(50), 
		STATECITYZIP_PATH VARCHAR(700), 
		PATIENT_BLOB TEXT, 
		UPDATE_DATE DATE, 
		DOWNLOAD_DATE DATE, 
		IMPORT_DATE DATE, 
		SOURCESYSTEM_CD VARCHAR(50)
	)';

execute 'CREATE INDEX idx_' || tempPatientDimensionTableName || '_pat_id ON ' || tempPatientDimensionTableName || '  (PATIENT_ID, PATIENT_ID_SOURCE,PATIENT_NUM)';
  
     
    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_pid_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

BEGIN 
execute 'create table ' ||  tempPatientMappingTableName || ' (
	   	PATIENT_MAP_ID VARCHAR(200), 
		PATIENT_MAP_ID_SOURCE VARCHAR(50), 
		PATIENT_ID_STATUS VARCHAR(50), 
		PATIENT_ID  VARCHAR(200),
	    PATIENT_ID_SOURCE varchar(50),
		PATIENT_NUM NUMERIC(38,0),
	    PATIENT_MAP_ID_STATUS VARCHAR(50), 
		PROCESS_STATUS_FLAG CHAR(1), 
		UPDATE_DATE DATE, 
		DOWNLOAD_DATE DATE, 
		IMPORT_DATE DATE, 
		SOURCESYSTEM_CD VARCHAR(50)

	 )';

execute 'CREATE INDEX idx_' || tempPatientMappingTableName || '_pid_id ON ' || tempPatientMappingTableName || '  ( PATIENT_ID, PATIENT_ID_SOURCE )';

execute 'CREATE INDEX idx_' || tempPatientMappingTableName || 'map_pid_id ON ' || tempPatientMappingTableName || '  
( PATIENT_ID, PATIENT_ID_SOURCE,PATIENT_MAP_ID, PATIENT_MAP_ID_SOURCE,  PATIENT_NUM )';
 
execute 'CREATE INDEX idx_' || tempPatientMappingTableName || 'stat_pid_id ON ' || tempPatientMappingTableName || '  
(PROCESS_STATUS_FLAG)';


    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_provider_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 

execute 'create table ' ||  tempProviderTableName || ' (
    PROVIDER_ID VARCHAR(50) NOT NULL, 
	PROVIDER_PATH VARCHAR(700) NOT NULL, 
	NAME_CHAR VARCHAR(2000), 
	PROVIDER_BLOB TEXT, 
	UPDATE_DATE DATE, 
	DOWNLOAD_DATE DATE, 
	IMPORT_DATE DATE, 
	SOURCESYSTEM_CD VARCHAR(50), 
	UPLOAD_ID NUMERIC(*,0)
	 )';
 execute 'CREATE INDEX idx_' || tempProviderTableName || '_ppath_id ON ' || tempProviderTableName || '  (PROVIDER_PATH)';

    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_table(temptablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 
	execute 'create table ' ||  tempTableName || '  (		
		encounter_id 		varchar(200) not null, 
        encounter_id_source varchar(50) not null,
		encounter_num  		NUMERIC(38,0),
		concept_cd 	 		VARCHAR(50) not null, 
        patient_num 		NUMERIC(38,0), 
		patient_id  		varchar(200) not null,
        patient_id_source  	varchar(50) not null,
		provider_id   		VARCHAR(50),
 		start_date   		DATE, 
		modifier_cd 		VARCHAR(100),
	    instance_num 		NUMERIC(18,0),
 		valtype_cd 			VARCHAR(50),
		tval_char 			varchar(255),
 		nval_num 			NUMERIC(18,5),
		valueflag_cd 		CHAR(50),
 		quantity_num 		NUMERIC(18,5),
		confidence_num 		NUMERIC(18,0),
 		observation_blob 	TEXT,
		units_cd 			VARCHAR(50),
 		end_date    		DATE,
		location_cd 		VARCHAR(50),
 		update_date  		DATE,
		download_date 		DATE,
 		import_date 		DATE,
		sourcesystem_cd 	VARCHAR(50) ,
 		upload_id 			INTEGER
	)';

    
    execute 'CREATE INDEX idx_' || tempTableName || '_pk ON ' || tempTableName || '  ( encounter_num,patient_num,concept_cd,provider_id,start_date,modifier_cd,instance_num)';
    execute 'CREATE INDEX idx_' || tempTableName || '_enc_pat_id ON ' || tempTableName || '  (encounter_id,encounter_id_source, patient_id,patient_id_source )';
    
    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_table(temptablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: create_temp_visit_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION create_temp_visit_table(temptablename character varying, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 
	-- Create temp table to store encounter/visit information
	execute 'create table ' ||  tempTableName || ' (
		encounter_id 			VARCHAR(200) not null,
		encounter_id_source 	VARCHAR(50) not null, 
		patient_id  			VARCHAR(200) not null,
		patient_id_source 		VARCHAR(50) not null,
		encounter_num	 		    NUMERIC(38,0), 
		inout_cd   			VARCHAR(50),
		location_cd 			VARCHAR(50),
		location_path 			VARCHAR(900),
 		start_date   			DATE, 
 		end_date    			DATE,
 		visit_blob 				TEXT,
 		update_date  			DATE,
		download_date 			DATE,
 		import_date 			DATE,
		sourcesystem_cd 		VARCHAR(50)
	)';

    execute 'CREATE INDEX idx_' || tempTableName || '_enc_id ON ' || tempTableName || '  ( encounter_id,encounter_id_source,patient_id,patient_id_source )';
    execute 'CREATE INDEX idx_' || tempTableName || '_patient_id ON ' || tempTableName || '  ( patient_id,patient_id_source )';
    
    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.create_temp_visit_table(temptablename character varying, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_concept_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 
	--Delete duplicate rows with same encounter and patient combination
	-- smuniraju: Rowid not supported in postgres, using combination of ctid (and gp_segment_id for greenplum)
	-- execute 'DELETE FROM ' || tempConceptTableName || ' t1 WHERE rowid > 
	-- 				   (SELECT  min(rowid) FROM ' || tempConceptTableName || ' t2
	-- 				     WHERE t1.concept_cd = t2.concept_cd 
    --                                         AND t1.concept_path = t2.concept_path
    --                                         )';
	execute 'DELETE FROM ' || tempConceptTableName || ' t1 WHERE ( ctid) not in ( 
			   SELECT   max(ctid) FROM ' || tempConceptTableName || ' t2
			   group by concept_path,concept_cd)';
						
    execute ' 	UPDATE concept_dimension cd set 
				name_char= temp.name_char,
				concept_blob= temp.concept_blob,
				update_date= temp.update_date,
				import_date = now(),
				DOWNLOAD_DATE=temp.DOWNLOAD_DATE,
				SOURCESYSTEM_CD=temp.SOURCESYSTEM_CD,
				UPLOAD_ID = '|| upload_id || '
				from ' || tempConceptTableName || ' temp
				where cd.concept_path = temp.concept_path
				and temp.update_date >= cd.update_date';
   
    --Create new patient(patient_mapping) if temp table patient_ide does not exists 
	-- in patient_mapping table.
	-- smuniraju: not exists results in co-related query.
	-- execute 'insert into concept_dimension  --(concept_cd,concept_path,name_char,concept_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
	-- 		    select concept_cd, concept_path, name_char,concept_blob, update_date,download_date,
    --          sysdate,sourcesystem_cd, ' || upload_id || '  
	--			from ' || tempConceptTableName || '  temp
	-- 			where not exists (select concept_cd from concept_dimension cd where cd.concept_path = temp.concept_path)';
	execute 'insert into concept_dimension  (concept_cd,concept_path,name_char,concept_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
			    select  temp.concept_cd, temp.concept_path, temp.name_char,temp.concept_blob, temp.update_date,temp.download_date, current_timestamp,temp.sourcesystem_cd, ' || upload_id || '  
				from ' || tempConceptTableName || '  temp left outer join concept_dimension cd
				on cd.concept_path = temp.concept_path
				where cd.concept_path is null';					
    
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;

$$;


ALTER FUNCTION i2b2demodata.insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_eid_map_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

DECLARE
 existingEncounterNum VARCHAR(32);
 maxEncounterNum NUMERIC;
 -- TYPE distinctEIdCurTyp IS CURSOR;
 -- distinctEidCur   distinctEIdCurTyp;
 distinctEidCur CURSOR;
 sql_stmt  VARCHAR(400); 
 disEncounterId VARCHAR(100); 
 disEncounterIdSource VARCHAR(100);

BEGIN
 sql_stmt := ' SELECT distinct encounter_id,encounter_id_source from ' || tempEidTableName ||' ';

-- smuniraju: rowid not supported in postgres/greenplum, instead using ctid (and gp_segment_id in greenplum)
-- execute ' delete  from ' || tempEidTableName ||  ' t1  where 
-- rowid > (select min(rowid) from ' || tempEidTableName || ' t2 
-- where t1.encounter_map_id = t2.encounter_map_id
-- and t1.encounter_map_id_source = t2.encounter_map_id_source
-- and t1.encounter_id = t2.encounter_id
-- and t1.encounter_id_source = t2.encounter_id_source) ';

 execute 'delete  from ' || tempEidTableName ||  ' t1  
		  where ( ctid) NOT IN (select  max(ctid) from ' || tempEidTableName || ' t2 
		  group by  encounter_map_id,encounter_map_id_source,encounter_id,encounter_id_source )';


 LOCK TABLE  encounter_mapping IN EXCLUSIVE MODE NOWAIT;
 select max(encounter_num) into maxEncounterNum from encounter_mapping ; 
 
if maxEncounterNum is null then 
  maxEncounterNum := 0;
end if;

  open distinctEidCur for EXECUTE(sql_stmt) ;
 
   loop
     FETCH distinctEidCur INTO disEncounterId, disEncounterIdSource;
      -- smuniraju: %NOTFOUND not supported in postgres.
	  -- EXIT WHEN distinctEidCur%NOTFOUND;
	 EXIT WHEN NOT FOUND;
      -- dbms_output.put_line(disEncounterId);
        
  if  disEncounterIdSource = 'HIVE'  THEN    
   begin
    --check if hive NUMERIC exist, if so assign that NUMERIC to reset of map_id's within that pid
    select encounter_num into existingEncounterNum from encounter_mapping where encounter_num = disEncounterId and encounter_ide_source = 'HIVE';
    
    EXCEPTION  
       when NO_DATA_FOUND THEN
           existingEncounterNum := null;
    end;
   
   if existingEncounterNum is not null then 
		-- smuniraju: NOT EXISTS clause reults in a co-related queries which are not supported in greenplum
        -- execute ' update ' || tempEidTableName ||' set encounter_num = encounter_id, process_status_flag = ''P''
        -- where encounter_id = ' || disEncounterId || ' and not exists (select 1 from encounter_mapping em where em.encounter_ide = encounter_map_id
        -- and em.encounter_ide_source = encounter_map_id_source)';		
		execute ' 	update ' || tempEidTableName ||' set 
					encounter_num = encounter_id::numeric, process_status_flag = ''P''
					from encounter_mapping em 
					where em.encounter_ide = encounter_map_id
					and em.encounter_ide_source = encounter_map_id_source
					and encounter_id = ' || disEncounterId || ' 
					and em.encounter_ide is null
					and em.encounter_ide_source is null ';
   else 
        -- generate new patient_num i.e. take max(_num) + 1 
        if maxEncounterNum < disEncounterId then 
            maxEncounterNum := disEncounterId;
        end if ;
		-- smuniraju : NOT EXISTS clause reults in a co-related queries which are not supported in greenplum
        -- execute ' update ' || tempEidTableName ||' set encounter_num = encounter_id, process_status_flag = ''P'' where 
        -- encounter_id = ' || disEncounterId || ' and encounter_id_source = ''HIVE'' and not exists (select 1 from encounter_mapping em where em.encounter_ide = encounter_map_id
        -- and em.encounter_ide_source = encounter_map_id_source)' ;		
		execute '   update ' || tempEidTableName ||' set 
					encounter_num = encounter_id::numeric, process_status_flag = ''P''
					from encounter_mapping em 
					where em.encounter_ide = encounter_map_id
					and em.encounter_ide_source = encounter_map_id_source
					and encounter_id = ' || disEncounterId || ' 
					and encounter_id_source = ''HIVE'' 
					and em.encounter_ide is null
					and em.encounter_ide_source is null ';      
   end if;    
   
   -- test if record fectched
   -- dbms_output.put_line(' HIVE ');

 else 
    begin
       select encounter_num into existingEncounterNum from encounter_mapping where encounter_ide = disEncounterId and 
        encounter_ide_source = disEncounterIdSource ; 

       -- test if record fetched. 
       EXCEPTION
           WHEN NO_DATA_FOUND THEN
           existingEncounterNum := null;
       end;
       if existingEncounterNum is not  null then 
			-- smuniraju: NOT EXISTS clause reults in a co-related queries which are not supported in greenplum
            -- execute ' update ' || tempEidTableName ||' set encounter_num = ' || existingEncounterNum || ' , process_status_flag = ''P''
            -- where encounter_id = ' || disEncounterId || ' and not exists (select 1 from encounter_mapping em where em.encounter_ide = encounter_map_id
			-- and em.encounter_ide_source = encounter_map_id_source)' ;
		execute ' update ' || tempEidTableName ||' set 
				  encounter_num = ' || existingEncounterNum || '::numeric , process_status_flag = ''P''
				  from encounter_mapping em 
				  where em.encounter_ide = encounter_map_id and em.encounter_ide_source = encounter_map_id_source
				  and encounter_id = ' || disEncounterId || ' 
				  and em.encounter_ide is null 
				  and em.encounter_ide_source is null' ;
       else 
            maxEncounterNum := maxEncounterNum + 1 ;
			
			--TODO : add update colunn
             execute ' insert into ' || tempEidTableName ||' (encounter_map_id,encounter_map_id_source,encounter_id,encounter_id_source,encounter_num,process_status_flag
             ,encounter_map_id_status,update_date,download_date,import_date,sourcesystem_cd) 
             values(' || maxEncounterNum || ',''HIVE'',' || maxEncounterNum || ',''HIVE'',' || maxEncounterNum ||',''P'',''A'',current_timestamp,current_timestamp,current_timestamp,''edu.harvard.i2b2.crc'')'; 
             
            -- smuniraju: NOT EXISTS clause reults in a co-related queries which are not supported in greenplum
	        -- execute ' update ' || tempEidTableName ||' set encounter_num =  ' || maxEncounterNum || ' , process_status_flag = ''P'' 
            -- where encounter_id = ' || disEncounterId || ' and  not exists (select 1 from 
            -- encounter_mapping em where em.encounter_ide = encounter_map_id
            -- and em.encounter_ide_source = encounter_map_id_source)' ;
			execute ' update ' || tempEidTableName ||' set 
					  encounter_num = ' || maxEncounterNum || ' , process_status_flag = ''P''
					  from encounter_mapping em 
					  where em.encounter_ide = encounter_map_id and em.encounter_ide_source = encounter_map_id_source
					  and encounter_id = ' || disEncounterId || ' 
					  and em.encounter_ide is null 
					  and em.encounter_ide_source is null' ;
            
       end if ;
 end if; 

END LOOP;
close distinctEidCur ;

-- smuniraju Postgres doesn't allow commit within procedures because it is explicity done upon 'END;'
-- commit;

 -- do the mapping update if the update date is old
   execute 'update encounter_mapping em set 
			encounter_num = temp.encounter_id::numeric,
			patient_ide = temp.patient_map_id ,
			patient_ide_source  = temp.patient_map_id_source ,
			encounter_ide_status = temp.encounter_map_id_status  ,
			update_date = temp.update_date,
			download_date = temp.download_date ,
			import_date = now() ,
			sourcesystem_cd  = temp.sourcesystem_cd ,
			upload_id = ' || upload_id || ' 
			from ' || tempEidTableName || ' temp
            where em.encounter_ide = temp.encounter_map_id 
			and em.encounter_ide_source = temp.encounter_map_id_source 
			and temp.encounter_id_source = ''HIVE'' and temp.process_status_flag is null  
			and coalesce(em.update_date,to_date(''01-JAN-1900'',''DD-MON-YYYY''))<= coalesce(temp.update_date,to_date(''01-JAN-1900'',''DD-MON-YYYY'')) ' ;

-- insert new mapping records i.e flagged P

execute ' insert into encounter_mapping (encounter_ide,encounter_ide_source,encounter_ide_status,encounter_num,patient_ide,patient_ide_source,update_date,download_date,import_date,sourcesystem_cd,upload_id) 
			select 	encounter_map_id,encounter_map_id_source,encounter_map_id_status,encounter_num,patient_map_id,patient_map_id_source,update_date,download_date,current_timestamp,sourcesystem_cd,' || upload_id || ' 
			from ' || tempEidTableName || '  
			where process_status_flag = ''P'' ' ; 

-- smuniraju Postgres doesn't allow commit within procedures because it is explicity done upon 'END;'
-- commit;
EXCEPTION
   WHEN OTHERS THEN
	  -- smuniraju
      /*if distinctEidCur%isopen then
          close distinctEidCur;
      end if;*/
	  RAISE EXCEPTION 'An error was encountered - % -ERROR- %', SQLSTATE, SQLERRM;
	  
	  begin
		close distinctEidCur;
		EXCEPTION
			WHEN OTHERS THEN
			RAISE NOTICE 'Error occurred when attempting to close cursor.';
	  end;	
      -- smuniraju Postgres doesn't allow rollback within procedures because it is explicity when a transaction fails.
      -- rollback;
      
end;
$$;


ALTER FUNCTION i2b2demodata.insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_encountervisit_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

DECLARE
maxEncounterNum NUMERIC; 
BEGIN 

    --Delete duplicate rows with same encounter and patient combination
	-- smuniraju
	-- execute  'DELETE FROM ' || tempTableName || ' t1 WHERE rowid > 
	-- 				   (SELECT  min(rowid) FROM ' || tempTableName || ' t2
	-- 				     WHERE t1.encounter_id = t2.encounter_id 
    --                   AND t1.encounter_id_source = t2.encounter_id_source
    --                   AND nvl(t1.patient_id,'''') = nvl(t2.patient_id,'''')
    --                   AND nvl(t1.patient_id_source,'''') = nvl(t2.patient_id_source,''''))';
	execute  'DELETE FROM ' || tempTableName || ' t1 
			  WHERE ( ctid) NOT IN (
					SELECT  max(ctid) FROM ' || tempTableName || ' t2
					GROUP BY  encounter_id,encounter_id_source)';
	
	 LOCK TABLE  encounter_mapping IN EXCLUSIVE MODE NOWAIT;
    -- select max(encounter_num) into maxEncounterNum from encounter_mapping ;

	--Create new patient(patient_mapping) if temp table patient_ide does not exists 
	-- in patient_mapping table.
	-- smuniraju
    --  execute  ' insert into encounter_mapping (encounter_ide,encounter_ide_source,encounter_num,patient_ide,patient_ide_source,encounter_ide_status, upload_id)
    --  	(select distinctTemp.encounter_id, distinctTemp.encounter_id_source, distinctTemp.encounter_id,  distinctTemp.patient_id,distinctTemp.patient_id_source,''A'',  '|| upload_id ||'
	-- 			from 
	-- 				(select distinct encounter_id, encounter_id_source,patient_id,patient_id_source from ' || tempTableName || '  temp
	-- 				where 
	-- 			     not exists (select encounter_ide from encounter_mapping em where em.encounter_ide = temp.encounter_id and em.encounter_ide_source = temp.encounter_id_source)
	-- 				 and encounter_id_source = ''HIVE'' )   distinctTemp) ' ;

	execute  ' insert into encounter_mapping (encounter_ide,encounter_ide_source,encounter_num,patient_ide,patient_ide_source,encounter_ide_status, upload_id) (
					select distinctTemp.encounter_id, distinctTemp.encounter_id_source, distinctTemp.encounter_id::numeric,  distinctTemp.patient_id,distinctTemp.patient_id_source,''A'',  '|| upload_id ||'
					from (
						select distinct encounter_id, encounter_id_source,patient_id,patient_id_source 
						from ' || tempTableName || ' temp left outer join encounter_mapping em
						on em.encounter_ide = temp.encounter_id and em.encounter_ide_source = temp.encounter_id_source
						where em.encounter_ide_source is null
						and  em.encounter_ide is null
						and encounter_id_source = ''HIVE'' )   distinctTemp) ' ;
	
	-- update patient_num for temp table
	-- smuniraju: Greenplum doesn't support sub query for setting a column value.
	-- update patient_num for temp table
	-- execute  ' UPDATE ' ||  tempTableName || ' SET encounter_num = (SELECT em.encounter_num
	-- 	     FROM encounter_mapping em
	-- 	     WHERE em.encounter_ide = '|| tempTableName ||'.encounter_id
    --       and em.encounter_ide_source = '|| tempTableName ||'.encounter_id_source 
	-- 	     and coalesce(em.patient_ide_source,'''') = coalesce('|| tempTableName ||'.patient_id_source,'''')
	-- 	     and coalesce(em.patient_ide,'''')= coalesce('|| tempTableName ||'.patient_id,''''))
	-- 	     WHERE EXISTS (SELECT em.encounter_num
	-- 	     FROM encounter_mapping em
	-- 	     WHERE em.encounter_ide = '|| tempTableName ||'.encounter_id
    --   	 and em.encounter_ide_source = '||tempTableName||'.encounter_id_source
	-- 	     and coalesce(em.patient_ide_source,'''') = coalesce('|| tempTableName ||'.patient_id_source,'''')
	-- 	     and coalesce(em.patient_ide,'''')= coalesce('|| tempTableName ||'.patient_id,''''))';	
		     
	execute  ' UPDATE ' ||  tempTableName || ' temp SET encounter_num = em.encounter_num
		     FROM encounter_mapping em
		     WHERE em.encounter_ide = '|| tempTableName ||'.encounter_id
             and em.encounter_ide_source = '|| tempTableName ||'.encounter_id_source 
		     and coalesce(em.patient_ide_source,'''') = coalesce(temp.patient_id_source,'''')
		     and coalesce(em.patient_ide,'''')= coalesce(temp.patient_id,'''')
		     and EXISTS (
				SELECT em.encounter_num
				FROM encounter_mapping em
				WHERE em.encounter_ide = '|| tempTableName ||'.encounter_id
				and em.encounter_ide_source = '||tempTableName||'.encounter_id_source
				and coalesce(em.patient_ide_source,'''') = coalesce(temp.patient_id_source,'''')
				and coalesce(em.patient_ide,'''')= coalesce(temp.patient_id,''''))';	

	 execute  'UPDATE visit_dimension vd set 
				inout_cd = temp.inout_cd,
				location_cd = temp.location_cd,
				location_path = temp.location_path,
				start_date = temp.start_date,
				end_date = temp.end_date,
				visit_blob = temp.visit_blob,
				update_date = temp.update_date,
				download_date = temp.download_date,
				import_date = now(),
				sourcesystem_cd = temp.sourcesystem_cd
				from ' || tempTableName || ' temp
				where vd.encounter_num = temp.encounter_num
				and temp.update_date >= vd.update_date';

	-- smuniraju
    -- execute  'insert into visit_dimension  (encounter_num,patient_num,START_DATE,END_DATE,INOUT_CD,LOCATION_CD,VISIT_BLOB,UPDATE_DATE,DOWNLOAD_DATE,IMPORT_DATE,SOURCESYSTEM_CD, UPLOAD_ID)
	--  	select temp.encounter_num, pm.patient_num, temp.START_DATE,temp.END_DATE,temp.INOUT_CD,temp.LOCATION_CD,temp.VISIT_BLOB,
	-- 		temp.update_date, temp.download_date, sysdate, -- import date temp.sourcesystem_cd, '|| upload_id ||'
	-- 		from ' || tempTableName || '  temp , patient_mapping pm 
	-- 		where temp.encounter_num is not null and 
	-- 	      	 not exists (select encounter_num from visit_dimension vd where vd.encounter_num = temp.encounter_num) and 
	-- 			 pm.patient_ide = temp.patient_id and pm.patient_ide_source = temp.patient_id_source
	-- ';
	execute  'insert into visit_dimension (encounter_num,patient_num,START_DATE,END_DATE,INOUT_CD,LOCATION_CD,VISIT_BLOB,UPDATE_DATE,DOWNLOAD_DATE,IMPORT_DATE,SOURCESYSTEM_CD, UPLOAD_ID)
				select temp.encounter_num, pm.patient_num, temp.START_DATE,temp.END_DATE,temp.INOUT_CD,temp.LOCATION_CD,temp.VISIT_BLOB,
				temp.update_date, temp.download_date, current_timestamp, -- import date temp.sourcesystem_cd, '|| upload_id ||'
				from ' || tempTableName || '  temp left outer join patient_mapping pm  
				on	pm.patient_ide = temp.patient_id and pm.patient_ide_source = temp.patient_id_source
				left outer join visit_dimension vd 
				on vd.encounter_num = temp.encounter_num
				where temp.encounter_num is not null 				
				and vd.encounter_num  is null'; 
				
-- smuniraju: Postgres doesn't allow commit within procedures because it is explicity done upon 'END;'	 
-- commit;
		        
EXCEPTION
	WHEN OTHERS THEN
		-- smuniraju: Postgres doesn't allow rollback within procedures because it is explicity when a transaction fails.	 
		-- rollback;
		Raise exception 'An error(-20001) was encountered - % -ERROR- %', SQLSTATE, SQLERRM;	
END;
$$;


ALTER FUNCTION i2b2demodata.insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_modifier_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 
	--Delete duplicate rows 
	-- smuniraju rowid not implemented in postgres
	-- execute  'DELETE FROM ' || tempModifierTableName || ' t1 WHERE rowid > 
	-- 				(SELECT  min(rowid) FROM ' || tempModifierTableName || ' t2
	-- 				 WHERE t1.modifier_cd = t2.modifier_cd 
    --               AND t1.modifier_path = t2.modifier_path)';
	execute  'DELETE FROM ' || tempModifierTableName || ' t1 WHERE ( ctid) NOT IN  
			   (SELECT   max(ctid) FROM ' || tempModifierTableName || ' t2
				GROUP BY  modifier_path,modifier_cd)';
						 
    execute 'UPDATE modifier_dimension cd set 
			name_char= temp.name_char,
			modifier_blob= temp.modifier_blob,
			update_date= temp.update_date,
			import_date = now(),
			DOWNLOAD_DATE=temp.DOWNLOAD_DATE,
			SOURCESYSTEM_CD=temp.SOURCESYSTEM_CD,
			UPLOAD_ID = '|| upload_id || '
			from ' || tempModifierTableName || ' temp
			where cd.modifier_path = temp.modifier_path
			and temp.update_date >= cd.update_date';

    --Create new modifier if temp table modifier_path does not exists 
	-- in modifier dimension table.
	-- smuniraju: not exists => co-related query
	-- execute  'insert into modifier_dimension  (modifier_cd,modifier_path,name_char,modifier_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
	-- 		    select  modifier_cd, modifier_path,
    --                     name_char,modifier_blob,
    --                     update_date,download_date,
    --                     sysdate,sourcesystem_cd,
    --                      ' || upload_id || '  from ' || tempModifierTableName || '  temp
	-- 				where not exists (select modifier_cd from modifier_dimension cd where cd.modifier_path = temp.modifier_path)					 
	-- 	';
	
	execute  'insert into modifier_dimension  (modifier_cd,modifier_path,name_char,modifier_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
			    select  modifier_cd, modifier_path, name_char,modifier_blob, update_date,download_date, current_timestamp, sourcesystem_cd,' || upload_id || '  
					from ' || tempModifierTableName || '  temp left outer join modifier_dimension cd
					on cd.modifier_path = temp.modifier_path 
					where cd.modifier_path is null)';
	 
EXCEPTION
	WHEN OTHERS THEN
		raise exception 'An error(-20001) was encountered - %-ERROR- %', SQLSTATE, SQLERRM;	
END;
$$;


ALTER FUNCTION i2b2demodata.insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_patient_map_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

BEGIN 
	
	-- Create new patient mapping entry for HIVE patient's if they are not already mapped in mapping table
	-- smuniraju: not exists => co-related
	-- execute 'insert into patient_mapping (
	-- 		select distinct temp.patient_id, temp.patient_id_source,''A'',temp.patient_id ,' || upload_id || '
	-- 		from ' || tempPatientTableName ||'  temp 
	-- 		where temp.patient_id_source = ''HIVE'' and 
   	-- 		not exists (
	--			select patient_ide from patient_mapping pm where pm.patient_num = temp.patient_id and pm.patient_ide_source = temp.patient_id_source) 
	-- 	)'; 
    
	execute 'insert into patient_mapping (patient_ide, patient_ide_source, patient_ide_status, patient_num, upload_id) (
				select distinct temp.patient_id, temp.patient_id_source,''A'',temp.patient_id::numeric ,' || upload_id || '
				from ' || tempPatientTableName ||'  temp left outer join patient_mapping pm
				on pm.patient_num = temp.patient_id and pm.patient_ide_source = temp.patient_id_source			
				where temp.patient_id_source = ''HIVE'' 
				and pm.patient_num is null 
				and pm.patient_ide_source is null)'; 
		
    --Create new visit for above inserted encounter's
	--If Visit table's encounter and patient num does match temp table,
	--then new visit information is created.
	execute 'UPDATE patient_dimension pd set 
			 VITAL_STATUS_CD= temp.VITAL_STATUS_CD,
			 BIRTH_DATE= temp.BIRTH_DATE,
			 DEATH_DATE= temp.DEATH_DATE,
			 SEX_CD= temp.SEX_CD,
			 AGE_IN_YEARS_NUM=temp.AGE_IN_YEARS_NUM,
			 LANGUAGE_CD=temp.LANGUAGE_CD,
			 RACE_CD=temp.RACE_CD,
			 MARITAL_STATUS_CD=temp.MARITAL_STATUS_CD,
			 RELIGION_CD=temp.RELIGION_CD,
			 ZIP_CD=temp.ZIP_CD,
			 STATECITYZIP_PATH =temp.STATECITYZIP_PATH,
			 PATIENT_BLOB=temp.PATIENT_BLOB,
			 UPDATE_DATE=temp.UPDATE_DATE,
			 DOWNLOAD_DATE=temp.DOWNLOAD_DATE,
			 SOURCESYSTEM_CD=temp.SOURCESYSTEM_CD,
			 UPLOAD_ID = '|| upload_id || '
			 from ' || tempPatientTableName || ' temp
			 where pd.patient_num = temp.patient_num
			 and temp.update_date > pd.update_date';
EXCEPTION
	WHEN OTHERS THEN
		RAISE EXCEPTION 'An error was encountered - % -ERROR- %', SQLSTATE, SQLERRM;	
END;

$$;


ALTER FUNCTION i2b2demodata.insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_pid_map_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

DECLARE
 existingPatientNum VARCHAR(32);
 maxPatientNum NUMERIC;
 --TYPE distinctPidCurTyp IS CURSOR;
 --distinctPidCurTyp refcursor;
 --distinctPidCur   distinctPidCurTyp;
 distinctPidCur CURSOR;
 sql_stmt  VARCHAR(400);
disPatientId VARCHAR(100); 
disPatientIdSource VARCHAR(100);

BEGIN
 sql_stmt := ' SELECT distinct patient_id,patient_id_source from ' || tempPidTableName ||' ';
 
  --delete the data if they miss 
  -- smuniraju: rowid not implemented in postgres/ greenplum
  -- execute ' delete  from ' || tempPidTableName ||  ' t1  
  --			where rowid > (select min(rowid) from ' || tempPidTableName || ' t2 
  -- 			where t1.patient_map_id = t2.patient_map_id
  -- 			and t1.patient_map_id_source = t2.patient_map_id_source) ';
  execute 'delete  from ' || tempPidTableName ||  ' t1  
		   where ( ctid) 
		    not in (select  max(ctid) from  ' || tempPidTableName ||  ' 
			group  BY patient_map_id,patient_map_id_source,patient_id,patient_id_source)';
  
  LOCK TABLE  patient_mapping IN EXCLUSIVE MODE NOWAIT;
  select max(patient_num) into maxPatientNum from patient_mapping ; 
 
 -- set max patient num to zero of the value is null
  if maxPatientNum is null then 
    maxPatientNum := 0;
  end if;

  open distinctPidCur for execute(sql_stmt);

  loop   
     FETCH distinctPidCur INTO disPatientId, disPatientIdSource;
      -- smuniraju: %NOTFOUND is not supported in POSTGRES
	  -- EXIT WHEN distinctPidCur%NOTFOUND;
	  EXIT WHEN NOT FOUND;    
        
	  if  disPatientIdSource = 'HIVE' THEN 
		begin
		 --check if hive NUMERIC exist, if so assign that NUMERIC to reset of map_id's within that pid
		 select patient_num into existingPatientNum from patient_mapping where patient_num = disPatientId and patient_ide_source = 'HIVE';
		   EXCEPTION  
			 when NO_DATA_FOUND THEN
			   existingPatientNum := null;
		end;
   
		if existingPatientNum is not null then 
			-- smuniraju: not exists results in corelated queries not supported by greenplum
			-- execute ' update ' || tempPidTableName ||' set patient_num = patient_id, process_status_flag = ''P''
			-- where patient_id = ' || disPatientId || ' and not exists (select 1 from patient_mapping pm where pm.patient_ide = patient_map_id
			-- and pm.patient_ide_source = patient_map_id_source)';
			execute 'update ' || tempPidTableName ||' temp set patient_num = patient_id::numeric, process_status_flag = ''P''
					 from patient_mapping pm 
					 where pm.patient_ide = temp.patient_map_id
					 and pm.patient_ide_source = temp.patient_map_id_source
					 and pm.patient_ide is null
					 and patient_id = ' || disPatientId || '';
		else 
			-- generate new patient_num i.e. take max(patient_num) + 1 
			if maxPatientNum < disPatientId then 
			   maxPatientNum := disPatientId;
			end if ;
	
		-- smuniraju: not exists results in corelated queries not supported by greenplum
		-- execute ' update ' || tempPidTableName ||' set patient_num = patient_id, process_status_flag = ''P'' where 
		-- patient_id = ' || disPatientId || ' and patient_id_source = ''HIVE'' and not exists (select 1 from patient_mapping pm where pm.patient_ide -- = patient_map_id and pm.patient_ide_source = patient_map_id_source)';
		execute 'update ' || tempPidTableName ||' temp set patient_num = patient_id::numeric, process_status_flag = ''P'' 
				 from patient_mapping pm
				 where pm.patient_ide = temp.patient_map_id
				 and pm.patient_ide_source = temp.patient_map_id_source
				 and pm.patient_ide is null and  pm.patient_ide_source is null
				 and patient_id = ' || disPatientId || ' and patient_id_source = ''HIVE'''; 
	end if;    
    
	  -- test if record fectched
	  -- dbms_output.put_line(' HIVE ');
	else 
		begin
		   select patient_num into existingPatientNum from patient_mapping where patient_ide = disPatientId and 
			patient_ide_source = disPatientIdSource ; 

		   -- test if record fetched. 
		   EXCEPTION
			   WHEN NO_DATA_FOUND THEN
			   existingPatientNum := null;
		   end;
		   if existingPatientNum is not null then 
				-- smuniraju: not exists results in corelated queries not supported by greenplum
				-- execute ' update ' || tempPidTableName ||' set patient_num = ' || existingPatientNum || ', process_status_flag = ''P''
				-- where patient_id = ' || disPatientId || ' and not exists (select 1 from patient_mapping pm where pm.patient_ide = patient_map_id
				-- and pm.patient_ide_source = patient_map_id_source)' ;
				execute 'update ' || tempPidTableName ||' temp set patient_num = ' || existingPatientNum || '::numeric, process_status_flag = ''P''
						 from patient_mapping pm 
						 where pm.patient_ide = temp.patient_map_id
						 and pm.patient_ide_source = temp.patient_map_id_source
						 and pm.patient_ide is null and pm.patient_ide_source is null
						 and patient_id = ' || disPatientId || '';
		   else 
				maxPatientNum := maxPatientNum + 1 ; 
				 execute 'insert into ' || tempPidTableName ||' (patient_map_id,patient_map_id_source,patient_id,patient_id_source,patient_num,process_status_flag
				 ,patient_map_id_status,update_date,download_date,import_date,sourcesystem_cd) 
				 values(' || maxPatientNum || ',''HIVE'',' || maxPatientNum || ',''HIVE'',' || maxPatientNum || ',''P'',''A'',current_timestamp,current_timestamp,current_timestamp,''edu.harvard.i2b2.crc'')'; 
			   
			   -- smuniraju: not exists results in corelated queries not supported by greenplum
			   -- execute 'update ' || tempPidTableName ||' set patient_num =  ' || maxPatientNum || ' , process_status_flag = ''P'' 
			   -- where patient_id = ' || disPatientId || ' and  not exists (select 1 from 
			   --  patient_mapping pm where pm.patient_ide = patient_map_id
			   --  and pm.patient_ide_source = patient_map_id_source)' ;
				execute 'update ' || tempPidTableName ||' temp set patient_num =  ' || maxPatientNum || ' , process_status_flag = ''P'' 
						 from patient_mapping pm 
						 where pm.patient_ide = temp.patient_map_id
						 and pm.patient_ide_source = temp.patient_map_id_source
						 and pm.patient_ide is null 
						 and pm.patient_ide_source is null
						 and patient_id = ' || disPatientId || ' ';						
		   end if ;
      -- dbms_output.put_line(' NOT HIVE ');
	end if; 
  END LOOP;
  close distinctPidCur ;
  -- smuniraju: Postgres doesn't allow commit and rollback within procedures because it is explicity done upon 'END;'	 
  -- commit;

  -- do the mapping update if the update date is old
  -- smuniraju: merge resulting in errors.
   /* execute ' merge into patient_mapping
      using ' || tempPidTableName ||' temp
      on (temp.patient_map_id = patient_mapping.patient_IDE 
  		  and temp.patient_map_id_source = patient_mapping.patient_IDE_SOURCE
	   ) when matched then 
  		update set patient_num = temp.patient_id,
    	patient_ide_status	= temp.patient_map_id_status  ,
    	update_date = temp.update_date,
    	download_date  = temp.download_date ,
		import_date = sysdate ,
    	sourcesystem_cd  = temp.sourcesystem_cd ,
		upload_id = ' || upload_id ||'  
    	where  temp.patient_id_source = ''HIVE'' and temp.process_status_flag is null  and
        nvl(patient_mapping.update_date,to_date(''1900-01-01'',''YYYY-MM-DD''))<= nvl(temp.update_date,to_date(''1900-01-01'',''YYYY-MM-DD'')) ' ;
	*/
  execute ' update patient_mapping pm set 
			patient_num = temp.patient_id::numeric,
			patient_ide_status	= temp.patient_map_id_status  ,
			update_date = temp.update_date,
			download_date  = temp.download_date ,
			import_date = now() ,
			sourcesystem_cd  = temp.sourcesystem_cd ,
			upload_id = ' || upload_id ||'  	
			from ' || tempPidTableName ||' temp
			where pm.patient_ide = temp.patient_map_id and pm.patient_ide_source = temp.patient_map_id_source
			and temp.patient_id_source = ''HIVE'' and temp.process_status_flag is null  and 
			coalesce(pm.update_date,to_date(''1900-01-01'',''YYYY-MM-DD''))<= coalesce(temp.update_date,to_date(''1900-01-01'',''YYYY-MM-DD'')) ' ;
	
  -- insert new mapping records i.e flagged P
  execute ' insert into patient_mapping (patient_ide,patient_ide_source,patient_ide_status,patient_num,update_date,download_date,import_date,sourcesystem_cd,upload_id) 
				select patient_map_id,patient_map_id_source,patient_map_id_status,patient_num,update_date,download_date,now(),sourcesystem_cd,' || upload_id ||' from '|| tempPidTableName || ' 
				where process_status_flag = ''P'' ' ; 
  -- smuniraju: Postgres doesn't allow commit and rollback within procedures because it is explicity done upon 'END;'	 
  -- commit;
  EXCEPTION
   WHEN OTHERS THEN
		RAISE EXCEPTION'An error was encountered - % -ERROR- %', SQLSTATE, SQLERRM;
		  -- postgres  doesn't support isOpen
		  -- if distinctPidCur%isopen then
		  --    close distinctPidCur;
		  -- end if;
	  begin
		close distinctPidCur;
		EXCEPTION
			WHEN OTHERS THEN
				RAISE NOTICE 'Error occured closing cursor.';
	  end;
      -- smuniraju: Postgres doesn't allow rollback within procedures because it is explicity when a transaction fails.
	  -- rollback;      
end;

$$;


ALTER FUNCTION i2b2demodata.insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: insert_provider_fromtemp(character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

BEGIN 
	--Delete duplicate rows with same encounter and patient combination
	-- smuniraju: rowid not supported
	-- execute 'DELETE FROM ' || tempProviderTableName || ' t1 WHERE rowid > 
	-- 				   (SELECT  min(rowid) FROM ' || tempProviderTableName || ' t2
	-- 				     WHERE t1.provider_id = t2.provider_id 
    --                                         AND t1.provider_path = t2.provider_path
    --                                         )';
	execute 'DELETE FROM ' || tempProviderTableName || ' t1 
			 WHERE ( ctid) NOT IN ( 
				SELECT  max(ctid)
				FROM ' || tempProviderTableName || ' t2
				GROUP BY  provider_path)';
	
 execute 'UPDATE patient_dimension set 
			provider_id = temp.provider_id,
			name_char = temp.name_char,
			provider_blob = provider_blob,
			IMPORT_DATE=now(),
			UPDATE_DATE=temp.UPDATE_DATE,
			DOWNLOAD_DATE=temp.DOWNLOAD_DATE,
			SOURCESYSTEM_CD=temp.SOURCESYSTEM_CD,
			UPLOAD_ID = '||  upload_id || '
			from provider_dimension pd 
			inner join ' || tempProviderTableName || ' temp
			on  pd.provider_path = temp.provider_path
			where temp.update_date >= pd.update_date) ';

   
    --Create new patient(patient_mapping) if temp table patient_ide does not exists 
	-- in patient_mapping table.
	-- smuniraju: not exists => co-related query.
	-- execute 'insert into provider_dimension  (provider_id,provider_path,name_char,provider_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
	-- 		    select  provider_id,provider_path, 
    --                     name_char,provider_blob,
    --                     update_date,download_date,
    --                     now(),sourcesystem_cd, ' || upload_id || '	                    
    --                      from ' || tempProviderTableName || '  temp
	-- 				where not exists (select provider_id from provider_dimension pd where pd.provider_path = temp.provider_path )';
	execute 'insert into provider_dimension  (provider_id,provider_path,name_char,provider_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
			    select  provider_id,provider_path, 
                        name_char,provider_blob,
                        update_date,download_date,
                        now(),sourcesystem_cd, ' || upload_id || '	                    
                        from ' || tempProviderTableName || '  temp left outer join provider_dimension pd 
						on pd.provider_path = temp.provider_path 
						where pd.provider_path is null';   
EXCEPTION
	WHEN OTHERS THEN
		RAISE EXCEPTION 'An error was encountered - % -ERROR- %', SQLSTATE, SQLERRM;	
END;

$$;


ALTER FUNCTION i2b2demodata.insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: remove_temp_table(character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION remove_temp_table(temptablename character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN 
	execute 'drop table ' || tempTableName || ' cascade';
	
EXCEPTION
	WHEN OTHERS THEN
		RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
END;
$$;


ALTER FUNCTION i2b2demodata.remove_temp_table(temptablename character varying) OWNER TO i2b2demodata;

--
-- Name: sp_xtab(character varying, integer, character varying); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION sp_xtab(v_variable character varying, v_protocol integer, v_subject character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE


/******************************************************************************
   NAME:       sf_xtab
   PURPOSE:    This function serves to flatten the SAS to Oracle Conversion via
               the SLM Process. 

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        5/14/2009   George Kuebrich

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     sf_xtab
      Sysdate:         5/14/2009
      Date and Time:   5/14/2009, 8:33:45 AM, and 5/14/2009 8:33:45 AM
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
sql_stmt varchar(4000);

BEGIN
   --tmpVar := null;
   sql_stmt := 'select distinct value into STRICT  tmpVar
     from sideshow_eav a,
          protocol b,
          variable c
    where a.protocol_id=b.protocol_id
      and a.protocol_id=c.protocol_id
      and a.protocol_id='||v_protocol|| 
    ' and a.variable_id=c.variable_id
      and a.subject_id='||v_subject||
    ' and c.variable_name in ('''||v_variable||''')';
      
   RAISE NOTICE '%', SQL_STMT;
  
   --RETURN tmpVar;
    EXCEPTION
     WHEN NO_DATA_FOUND THEN
       NULL;
     WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
       RAISE;
END sp_xtab; 
 
$$;


ALTER FUNCTION i2b2demodata.sp_xtab(v_variable character varying, v_protocol integer, v_subject character varying) OWNER TO i2b2demodata;

--
-- Name: sync_clear_concept_table(character varying, character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ DECLARE

DECLARE
interConceptTableName  varchar(400);

BEGIN 
	interConceptTableName := backupConceptTableName || '_inter';
	
		--Delete duplicate rows with same encounter and patient combination
		-- smuniraju
	-- execute 'DELETE FROM ' || tempConceptTableName || ' t1 WHERE rowid > 
	-- 				   (SELECT  min(rowid) FROM ' || tempConceptTableName || ' t2
	-- 				     WHERE t1.concept_cd = t2.concept_cd 
    --                                         AND t1.concept_path = t2.concept_path
    --                                         )';
	execute 'DELETE FROM ' || tempConceptTableName || ' t1 
	         WHERE ( ctid) NOT IN  
					   (SELECT   max(rowid) FROM ' || tempConceptTableName || ' t2
					     GROUP BY  concept_path,concept_cd)';
						 
    execute 'create table ' ||  interConceptTableName || ' (
    CONCEPT_CD          VARCHAR(50) NOT NULL,
	CONCEPT_PATH    	VARCHAR(700) NOT NULL,
	NAME_CHAR       	VARCHAR(2000) NULL,
	CONCEPT_BLOB        TEXT NULL,
	UPDATE_DATE         DATE NULL,
	DOWNLOAD_DATE       DATE NULL,
	IMPORT_DATE         DATE NULL,
	SOURCESYSTEM_CD     VARCHAR(50) NULL,
	UPLOAD_ID       	NUMERIC(38,0) NULL,
    CONSTRAINT '|| interConceptTableName ||'_pk  PRIMARY KEY(CONCEPT_PATH)
	 )';
    
    --Create new patient(patient_mapping) if temp table patient_ide does not exists 
	-- in patient_mapping table.
	execute 'insert into '|| interConceptTableName ||'  (concept_cd,concept_path,name_char,concept_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
			    select  concept_cd, substr(concept_path,1,700),
                        name_char,concept_blob,
                        update_date,download_date,
                        current_timestamp,sourcesystem_cd,
                         ' || uploadId || '  from ' || tempConceptTableName || '  temp ';
	--backup the concept_dimension table before creating a new one
	execute 'alter table concept_dimension rename to ' || backupConceptTableName  ||'' ;
    
	-- add index on upload_id 
    execute 'CREATE INDEX ' || interConceptTableName || '_uid_idx ON ' || interConceptTableName || '(UPLOAD_ID)';

    -- add index on upload_id 
    execute 'CREATE INDEX ' || interConceptTableName || '_cd_idx ON ' || interConceptTableName || '(concept_cd)';

    
    --backup the concept_dimension table before creating a new one
	execute 'alter table ' || interConceptTableName  || ' rename to concept_dimension' ;
 
EXCEPTION
	WHEN OTHERS THEN
		RAISE EXCEPTION 'An error was encountered - % -ERROR- %', SQLSTATE, SQLERRM;	
END;
$$;


ALTER FUNCTION i2b2demodata.sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: sync_clear_modifier_table(character varying, character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION sync_clear_modifier_table(tempmodifiertablename character varying, backupmodifiertablename character varying, uploadid numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


interModifierTableName  varchar(400);


BEGIN
	interModifierTableName := backupModifierTableName || '_inter';

	--Delete duplicate rows with same modifier_path and modifier cd
	EXECUTE 'DELETE FROM ' || tempModifierTableName || ' t1 WHERE oid >
					   (SELECT  min(oid) FROM ' || tempModifierTableName || ' t2
					     WHERE t1.modifier_cd = t2.modifier_cd
                                            AND t1.modifier_path = t2.modifier_path
                                            )';

    EXECUTE 'create table ' ||  interModifierTableName || ' (
        MODIFIER_CD          varchar(50) NOT NULL,
	MODIFIER_PATH    	varchar(700) NOT NULL,
	NAME_CHAR       	varchar(2000) NULL,
	MODIFIER_BLOB        text NULL,
	UPDATE_DATE         timestamp NULL,
	DOWNLOAD_DATE       timestamp NULL,
	IMPORT_DATE         timestamp NULL,
	SOURCESYSTEM_CD     varchar(50) NULL,
	UPLOAD_ID       	numeric(38,0) NULL,
    CONSTRAINT '|| interModifierTableName ||'_pk  PRIMARY KEY(MODIFIER_PATH)
	 )';

    --Create new patient(patient_mapping) if temp table patient_ide does not exists
	-- in patient_mapping table.
	EXECUTE 'insert into '|| interModifierTableName ||'  (modifier_cd,modifier_path,name_char,modifier_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
			    PERFORM  modifier_cd, substring(modifier_path from 1 for 700),
                        name_char,modifier_blob,
                        update_date,download_date,
                        LOCALTIMESTAMP,sourcesystem_cd,
                         ' || uploadId || '  from ' || tempModifierTableName || '  temp ';
	--backup the modifier_dimension table before creating a new one
	EXECUTE 'alter table modifier_dimension rename to ' || backupModifierTableName  ||'' ;

	-- add index on upload_id
    EXECUTE 'CREATE INDEX ' || interModifierTableName || '_uid_idx ON ' || interModifierTableName || '(UPLOAD_ID)';

    -- add index on upload_id
    EXECUTE 'CREATE INDEX ' || interModifierTableName || '_cd_idx ON ' || interModifierTableName || '(modifier_cd)';

    --backup the modifier_dimension table before creating a new one
	EXECUTE 'alter table ' || interModifierTableName  || ' rename to modifier_dimension' ;

EXCEPTION
	WHEN OTHERS THEN
		RAISE EXCEPTION 'An error was encountered - % -ERROR- %',SQLSTATE,SQLERRM;
END;
 
$$;


ALTER FUNCTION i2b2demodata.sync_clear_modifier_table(tempmodifiertablename character varying, backupmodifiertablename character varying, uploadid numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: sync_clear_provider_table(character varying, character varying, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ DECLARE 

DECLARE
interProviderTableName  varchar(400);

BEGIN 
	interProviderTableName := backupProviderTableName || '_inter';
	
	--Delete duplicate rows with same encounter and patient combination
	-- smuniraju: rowid not supported in postgres	
	-- execute 'DELETE FROM ' || tempProviderTableName || ' t1 WHERE rowid > 
	-- 				   (SELECT  min(rowid) FROM ' || tempProviderTableName || ' t2
	-- 				     WHERE t1.provider_id = t2.provider_id 
    --                                        AND t1.provider_path = t2.provider_path
    --                                         )';
	execute 'DELETE FROM ' || tempProviderTableName || ' t1 
			 WHERE ( ctid) NOT IN (
				SELECT  max(ctid) 
				FROM ' || tempProviderTableName || ' t2
				GROUP BY   provider_path,provider_id)';				
											
    execute 'create table ' ||  interProviderTableName || ' (
    PROVIDER_ID         VARCHAR(50) NOT NULL,
	PROVIDER_PATH       VARCHAR(700) NOT NULL,
	NAME_CHAR       	VARCHAR(850) NULL,
	PROVIDER_BLOB       TEXT NULL,
	UPDATE_DATE     	DATE NULL,
	DOWNLOAD_DATE       DATE NULL,
	IMPORT_DATE         DATE NULL,
	SOURCESYSTEM_CD     VARCHAR(50) NULL,
	UPLOAD_ID        	NUMERIC(38,0) NULL ,
    CONSTRAINT  ' || interProviderTableName || '_pk PRIMARY KEY(PROVIDER_PATH,provider_id)
	 )';
    
    --Create new patient(patient_mapping) if temp table patient_ide does not exists 
	-- in patient_mapping table.
	execute 'insert into ' ||  interProviderTableName || ' (provider_id,provider_path,name_char,provider_blob,update_date,download_date,import_date,sourcesystem_cd,upload_id)
			    select  provider_id,provider_path, 
                        name_char,provider_blob,
                        update_date,download_date,
                        now(),sourcesystem_cd, ' || uploadId || '
	                     from ' || tempProviderTableName || '  temp ';
					
	--backup the concept_dimension table before creating a new one
	execute 'alter table provider_dimension rename to ' || backupProviderTableName  ||'' ;
    
	-- add index on provider_id, name_char 
    execute 'CREATE INDEX ' || interProviderTableName || '_id_idx ON ' || interProviderTableName  || '(Provider_Id,name_char)';
    execute 'CREATE INDEX ' || interProviderTableName || '_uid_idx ON ' || interProviderTableName  || '(UPLOAD_ID)';

	--backup the concept_dimension table before creating a new one
	execute 'alter table ' || interProviderTableName  || ' rename to provider_dimension' ;
 
EXCEPTION
	WHEN OTHERS THEN
		RAISE EXCEPTION 'An error was encountered - % -ERROR- %', SQLSTATE, SQLERRM;	
END;

$$;


ALTER FUNCTION i2b2demodata.sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

--
-- Name: tf_trg_concept_dimension_cd(); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION tf_trg_concept_dimension_cd() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	 if NEW.CONCEPT_CD is null then
	 select nextval('tm_cz.CONCEPT_ID') into NEW.CONCEPT_CD;
	 end if;
	 RETURN NEW;
	 end;

$$;


ALTER FUNCTION i2b2demodata.tf_trg_concept_dimension_cd() OWNER TO i2b2demodata;

--
-- Name: tf_trg_encounter_num(); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION tf_trg_encounter_num() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.ENCOUNTER_NUM is null then
 select nextval('i2b2demodata.SEQ_ENCOUNTER_NUM') into NEW.ENCOUNTER_NUM ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION i2b2demodata.tf_trg_encounter_num() OWNER TO i2b2demodata;

--
-- Name: tf_trg_patient_dimension(); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION tf_trg_patient_dimension() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.PATIENT_NUM is null then
 select nextval('i2b2demodata.SEQ_PATIENT_NUM') into NEW.PATIENT_NUM ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION i2b2demodata.tf_trg_patient_dimension() OWNER TO i2b2demodata;

--
-- Name: update_observation_fact(character varying, numeric, numeric); Type: FUNCTION; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE FUNCTION update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN



--Delete duplicate records(encounter_ide,patient_ide,concept_cd,start_date,modifier_cd,provider_id)
-- smuniraju: rowid not implemented in postgres
-- execute 'DELETE FROM ' || upload_temptable_name ||'  t1 
--  where rowid > (select min(rowid) from ' || upload_temptable_name ||' t2 
--    where t1.encounter_id = t2.encounter_id  
--          and
--          t1.encounter_id_source = t2.encounter_id_source
--          and
--          t1.patient_id = t2.patient_id 
--          and 
--          t1.patient_id_source = t2.patient_id_source
--          and 
--          t1.concept_cd = t2.concept_cd                
--          and 
--          t1.start_date = t2.start_date
--          and 
--          nvl(t1.modifier_cd,''xyz'') = nvl(t2.modifier_cd,''xyz'')
--		  and 
--		  t1.instance_num = t2.instance_num
--          and 
--          t1.provider_id = t2.provider_id)';
execute 'DELETE FROM ' || upload_temptable_name ||'  
		 WHERE ( ctid) not in (
			SELECT  max(ctid) FROM ' || upload_temptable_name ||' 
			GROUP BY  encounter_id,encounter_id_source,patient_id,patient_id_source, concept_cd,start_date,modifier_cd,provider_id,instance_num ORDER BY encounter_id,encounter_id_source)';
          
--Delete records having null in start_date
execute 'DELETE FROM ' || upload_temptable_name ||'  t1           
 where t1.start_date is null';
           
           
--One time lookup on encounter_ide to get encounter_num 
-- smuniraju: Greenplum doesn't support sub query for assigning values.
-- execute 'UPDATE ' ||  upload_temptable_name
--  || ' SET encounter_num = (SELECT em.encounter_num
-- 		     FROM encounter_mapping em
-- 		     WHERE em.encounter_ide = ' || upload_temptable_name||'.encounter_id
--                   and em.encounter_ide_source = '|| upload_temptable_name||'.encounter_id_source) 
--                   WHERE EXISTS (SELECT em.encounter_num
-- 		     FROM encounter_mapping em
-- 		     WHERE em.encounter_ide = '|| upload_temptable_name||'.encounter_id
--		     and em.encounter_ide_source = '||upload_temptable_name||'.encounter_id_source)';		     

execute 'UPDATE ' ||  upload_temptable_name || ' SET encounter_num = em.encounter_num
	FROM encounter_mapping em
	WHERE em.encounter_ide = ' || upload_temptable_name||'.encounter_id
        and em.encounter_ide_source = '|| upload_temptable_name||'.encounter_id_source) 
        and EXISTS (
		SELECT em.encounter_num
		FROM encounter_mapping em
		WHERE em.encounter_ide = '|| upload_temptable_name||'.encounter_id
                and em.encounter_ide_source = '||upload_temptable_name||'.encounter_id_source)';	     

--One time lookup on patient_ide to get patient_num 
-- smuniraju: Greenplum doesn't support sub query for assigning values.
-- execute 'UPDATE ' ||  upload_temptable_name
--  || ' SET patient_num = (SELECT pm.patient_num
-- 		     FROM patient_mapping pm
-- 		     WHERE pm.patient_ide = '|| upload_temptable_name||'.patient_id
--                      and pm.patient_ide_source = '|| upload_temptable_name||'.patient_id_source
-- 	 	    )WHERE EXISTS (SELECT pm.patient_num 
-- 		     FROM patient_mapping pm
-- 		     WHERE pm.patient_ide = '|| upload_temptable_name||'.patient_id
--                      and pm.patient_ide_source = '||upload_temptable_name||'.patient_id_source)';		     

execute 'UPDATE ' ||  upload_temptable_name || ' SET patient_num = pm.patient_num
	FROM patient_mapping pm
	WHERE pm.patient_ide = '|| upload_temptable_name||'.patient_id
        and pm.patient_ide_source = '|| upload_temptable_name||'.patient_id_source
	and EXISTS (
		SELECT pm.patient_num 
		FROM patient_mapping pm
		WHERE pm.patient_ide = '|| upload_temptable_name||'.patient_id
                and pm.patient_ide_source = '||upload_temptable_name||'.patient_id_source)';		     

IF (appendFlag = 0) THEN
--Archive records which are to be deleted in observation_fact table
execute 'INSERT ALL INTO  archive_observation_fact 
		SELECT obsfact.*, ' || upload_id ||' archive_upload_id 
		FROM observation_fact obsfact
		WHERE obsfact.encounter_num IN 
			(SELECT temp_obsfact.encounter_num
			FROM  ' ||upload_temptable_name ||' temp_obsfact
                        group by temp_obsfact.encounter_num  
            )';


--Delete above archived row from observation_fact
execute 'DELETE  observation_fact 
		 WHERE EXISTS (
				SELECT archive.encounter_num
				FROM archive_observation_fact  archive
				where archive.archive_upload_id = '||upload_id ||'
                AND archive.encounter_num=observation_fact.encounter_num
				AND archive.concept_cd = observation_fact.concept_cd
				AND archive.start_date = observation_fact.start_date
         )';
END IF;

-- if the append is true, then do the update else do insert all
IF (appendFlag = 0) THEN

--Transfer all rows from temp_obsfact to observation_fact
execute 'INSERT ALL INTO observation_fact(encounter_num,concept_cd, patient_num,provider_id, start_date,modifier_cd,instance_num,valtype_cd,tval_char,nval_num,valueflag_cd,
quantity_num,confidence_num,observation_blob,units_cd,end_date,location_cd, update_date,download_date,import_date,sourcesystem_cd,
upload_id) 
SELECT encounter_num,concept_cd, patient_num,provider_id, start_date,modifier_cd,instance_num,valtype_cd,tval_char,nval_num,valueflag_cd,
quantity_num,confidence_num,observation_blob,units_cd,end_date,location_cd, update_date,download_date,current_timestamp import_date,sourcesystem_cd,
temp.upload_id 
FROM ' || upload_temptable_name ||' temp
where temp.patient_num is not null and  temp.encounter_num is not null';
ELSE				
	execute ' UPDATE observation_fact  set 
			valtype_cd = temp.valtype_cd,
            tval_char = temp.tval_char,
			nval_num = temp.nval_num ,
			valueflag_cd = temp.valueflag_cd,
			quantity_num = temp.quantity_num,
			confidence_num = temp.confidence_num ,
			observation_blob = temp.observation_blob,
			units_cd = temp.units_cd,
			end_date = temp.end_date,
			location_cd = temp.location_cd,
			update_date= temp.update_date,
			download_date = temp.download_date,
			import_date = now(),
			sourcesystem_cd = temp.sourcesystem_cd,
			UPLOAD_ID = ' || upload_id || '
			from observation_fact obsfact 
			inner join ' || upload_temptable_name || ' temp
			on  obsfact.encounter_num = temp.encounter_num 
			and obsfact.patient_num = temp.patient_num
			and obsfact.concept_cd = temp.concept_cd
			and obsfact.start_date = temp.start_date
			and obsfact.provider_id = temp.provider_id
			and obsfact.modifier_cd = temp.modifier_cd
			and obsfact.instance_num = temp.instance_num
			where coalesce(observation_fact.update_date,to_date(''1900-01-01'',''YYYY-MM-DD''))<= coalesce(temp.update_date,to_date(''1900-01-01'',''YYYY-MM-DD'')) ';
END IF;

EXCEPTION
	WHEN OTHERS THEN
		RAISE EXCEPTION 'An error was encountered - % -ERROR- % ', SQLSTATE, SQLERRM;	
END;
$$;


ALTER FUNCTION i2b2demodata.update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) OWNER TO i2b2demodata;

SET search_path = i2b2metadata, pg_catalog;

--
-- Name: add_ontology_node(character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE FUNCTION add_ontology_node(parent_path_src character varying, node_name character varying, is_leaf_src character varying, is_number character varying, prefix character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  declare
    max_basecode numeric;
    parent_path varchar(255);
    is_leaf varchar(30);
    ct numeric;
    hlevel numeric;
    concept_code varchar(30);
    xml varchar(1000);
    data_type varchar(30);
    sourcesyscd varchar(30);
  begin
  
------------------------------------------------------------
-- get parent path
------------------------------------------------------------  
    --parent_path := '&parent_path';
    
      select count(*) into ct
      from i2b2metadata.i2b2
      where c_fullname=parent_path_src;
      
      if (ct=0) then
        RAISE NOTICE 'Supplied path: % does not exist', parent_path_src;
        return;
      end if;
      
    if (substring(parent_path from length(parent_path) for 1)!='\') then
      parent_path := parent_path_src||'\';
    else parent_path := parent_path_src;
    end if;
   
    sourcesyscd := substr(parent_path, 2, instr(parent_path, '\', 2)-2);
    RAISE NOTICE 'parent path: %, source system code: %', parent_path,  sourcesyscd;
------------------------------------------------------------
-- get the name of the node
------------------------------------------------------------
  --node_name := '&node_name';
    RAISE NOTICE 'node name: %', node_name;
------------------------------------------------------------
-- find out whether the node supplied is a leaf or a folder
------------------------------------------------------------
  --is_leaf := '&IsLeaf_Y_N';
  ----------------------------------------------------------
  -- if node is a leaf, set attribute value to LA, set 
  -- concept code and find out what data type the leaf is
  ----------------------------------------------------------
    is_leaf := is_leaf_src;
    
    if (upper(is_leaf) = 'Y') then
      
      is_leaf := 'LA';
      
      PERFORM prefix||nextval('seq_i2b2_data_id')
      into concept_code ;
      
      --is_number :='&is_number';
      if (upper(is_number) = 'Y') then
        xml := '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>';
        data_type := 'N';
      elsif (upper(is_number) = 'N') then
        data_type := 'T';
      else 
        RAISE NOTICE 'IS_NUMBER prompt requires ''Y'' or ''N'' input';
        return;
      end if;
    elsif (upper(is_leaf) ='N') then 
      is_leaf := 'FA';
      data_type := 'T';
    else 
      RAISE NOTICE 'IS_LEAF prompt requires ''Y'' or ''N'' input';
      return;
    end if;
    RAISE NOTICE 'node type: %, data type: %, concept code: %', is_leaf, data_type, concept_code;
  
------------------------------------------------------------
-- obtail the proper level for the node by finding the 
-- level of its parent and adding one.
------------------------------------------------------------
    select c_hlevel+1 into hlevel
    from i2b2metadata.i2b2
    where upper(c_fullname)=upper(parent_path);
    RAISE NOTICE 'level: %', hlevel;
------------------------------------------------------------
-- add the new node into the i2b2 table
------------------------------------------------------------
    insert into i2b2demodata.i2b2(
    C_HLEVEL, C_FULLNAME, C_NAME
    , C_SYNONYM_CD, C_VISUALATTRIBUTES, C_TOTALNUM
    , C_BASECODE, C_METADATAXML, C_FACTTABLECOLUMN
    , C_TABLENAME, C_COLUMNNAME, C_COLUMNDATATYPE
    , C_OPERATOR, C_DIMCODE, C_COMMENT
    , C_TOOLTIP, UPDATE_DATE, DOWNLOAD_DATE
    , IMPORT_DATE, SOURCESYSTEM_CD, VALUETYPE_CD 
    )
    values (hlevel, parent_path||node_name||'\', node_name
    , 'N', is_leaf, 0
    , concept_code, xml, 'concept_cd'
    , 'concept_dimension', 'concept_path', data_type
    , 'LIKE', parent_path||node_name||'\', null
    , parent_path||node_name, LOCALTIMESTAMP, LOCALTIMESTAMP
    , LOCALTIMESTAMP, sourcesyscd, null);
    commit;
  end;
end;
 
$$;


ALTER FUNCTION i2b2metadata.add_ontology_node(parent_path_src character varying, node_name character varying, is_leaf_src character varying, is_number character varying, prefix character varying) OWNER TO i2b2metadata;

--
-- Name: tf_trg_i2b2_id(); Type: FUNCTION; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE FUNCTION tf_trg_i2b2_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.I2B2_ID is null then
 select nextval('i2b2metadata.I2B2_ID_SEQ') into NEW.I2B2_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION i2b2metadata.tf_trg_i2b2_id() OWNER TO i2b2metadata;

--
-- Name: tf_trg_i2b2_tag_id(); Type: FUNCTION; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE FUNCTION tf_trg_i2b2_tag_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.TAG_ID is null then
 select nextval('i2b2metadata.SEQ_I2B2_DATA_ID') into NEW.TAG_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION i2b2metadata.tf_trg_i2b2_tag_id() OWNER TO i2b2metadata;

--
-- Name: tf_trg_i2b2_tags_tag_id(); Type: FUNCTION; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE FUNCTION tf_trg_i2b2_tags_tag_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin      
    if NEW.TAG_ID is null 
    then          
        select nextval('i2b2metadata.seq_i2b2_tags_tag_id') into NEW.TAG_ID ;       
    end if; 
    RETURN NEW;  
end;
$$;


ALTER FUNCTION i2b2metadata.tf_trg_i2b2_tags_tag_id() OWNER TO i2b2metadata;

SET search_path = public, pg_catalog;

--
-- Name: assign_permissions_1(text, text, character, text); Type: FUNCTION; Schema: public; Owner: weymouth
--

CREATE FUNCTION assign_permissions_1(name text, schema_name text, type character, owner text) RETURNS aclitem
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF schema_name = owner OR type <> 'r' /* table */ THEN
        RETURN NULL;
    END IF;

    RETURN 'user ' || schema_name || '=arwdDxt/' || (SELECT current_user);
END;
$$;


ALTER FUNCTION public.assign_permissions_1(name text, schema_name text, type character, owner text) OWNER TO weymouth;

--
-- Name: assign_permissions_2(text, text, character, text); Type: FUNCTION; Schema: public; Owner: weymouth
--

CREATE FUNCTION assign_permissions_2(name text, schema_name text, type character, owner text) RETURNS aclitem[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    allPermissions text;
    result         aclitem[];
BEGIN
    allPermissions :=
        CASE type
            WHEN 'r' THEN 'arwdDxt'
            WHEN 'S' THEN 'rwU'
            WHEN 'v' THEN 'arwdDxt'
            WHEN 'f' THEN 'X'
            WHEN 'a' THEN 'X'
            WHEN 's' THEN 'UC'
            WHEN 'T' THEN 'C'
        END ||
        '/' || (SELECT current_user);

    IF owner IS NOT NULL THEN
        result := ARRAY[
            ('user ' || owner || '=' || allPermissions)::aclitem
        ];
    END IF;
    IF owner <> 'tm_cz' OR owner IS NULL THEN
        result := result || ('user tm_cz=' || allPermissions)::aclitem;
    END IF;

    RETURN result;
END;
$$;


ALTER FUNCTION public.assign_permissions_2(name text, schema_name text, type character, owner text) OWNER TO weymouth;

--
-- Name: assign_permissions_3(text, text, character, text); Type: FUNCTION; Schema: public; Owner: weymouth
--

CREATE FUNCTION assign_permissions_3(name text, schema_name text, type character, owner text) RETURNS aclitem
    LANGUAGE plpgsql
    AS $$
DECLARE
    dummy record;
BEGIN
    IF NOT schema_name = ANY(ARRAY['i2b2demodata', 'i2b2metadata', 'deapp',
            'searchapp', 'galaxy', 'biomart', 'amapp', 'fmapp', 'biomart_user']) THEN
        RETURN NULL;
    END IF;

    IF schema_name = 'searchapp' AND type = 'r' /* table */ THEN
        RETURN 'user biomart_user=arwdDxt/' || (SELECT current_user);
    END IF;

    IF type = 'r' /* table */ THEN
        SELECT *
        INTO dummy
        FROM public.biomart_write_tables B
        WHERE B.nschema = schema_name
            AND B.ntable = name;

        IF FOUND THEN
            -- append (insert), read (select), write (update), delete
            RETURN 'user biomart_user=arwd/' || (SELECT current_user);
        END IF;
    END IF;

    RETURN 'user biomart_user=' ||
            CASE type
                WHEN 'r' THEN 'r'
                WHEN 'S' THEN 'rwU' -- from the docs, w or U would suffice
                WHEN 'v' THEN 'r'
                WHEN 'f' THEN 'X'
                WHEN 'a' THEN 'X'
                WHEN 's' THEN 'U' -- usage only; not create
            END ||
        '/' || (SELECT current_user);
END;
$$;


ALTER FUNCTION public.assign_permissions_3(name text, schema_name text, type character, owner text) OWNER TO weymouth;

--
-- Name: assign_permissions_4(text, text, character, text); Type: FUNCTION; Schema: public; Owner: weymouth
--

CREATE FUNCTION assign_permissions_4(name text, schema_name text, type character, owner text) RETURNS aclitem[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    res aclitem[];
BEGIN
    SELECT
        array_accum(
                ('user ' || nuser || '=' || nperm || '/'
                        || (SELECT current_user))::aclitem)
    INTO res
    FROM
        public.ts_misc_permissions
    WHERE
        nschema = schema_name
        AND nname = name
        AND ntype = type;

    RETURN res;
END;
$$;


ALTER FUNCTION public.assign_permissions_4(name text, schema_name text, type character, owner text) OWNER TO weymouth;

--
-- Name: equal_aclitem_arrays(aclitem[], aclitem[]); Type: FUNCTION; Schema: public; Owner: weymouth
--

CREATE FUNCTION equal_aclitem_arrays(aclitems1 aclitem[], aclitems2 aclitem[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    ret boolean;
BEGIN
    -- aclexplode can't handle empty arrays
    IF aclitems1 = '{}'::aclitem[] THEN
        IF aclitems2 = aclitems1 THEN
            RETURN true;
        ELSE
            RETURN false;
        END IF;
    END IF;

    SELECT
        NOT EXISTS (
            SELECT
                A.grantee,
                A.privilege_type,
                COUNT(*)
            FROM
                (
                    SELECT
                        (R.rec).grantee,
                        (R.rec).privilege_type
                    FROM
                        (SELECT ACLEXPLODE(aclitems1)) AS R(rec)

                    UNION ALL

                    SELECT
                        (R.rec).grantee,
                        (R.rec).privilege_type
                    FROM
                        (SELECT ACLEXPLODE(aclitems2)) AS R(rec)
                ) A
            GROUP BY
                A.grantee,
                A.privilege_type
            HAVING
                COUNT(*) <> 2
         )
     INTO ret;

    RETURN ret;
END;
$$;


ALTER FUNCTION public.equal_aclitem_arrays(aclitems1 aclitem[], aclitems2 aclitem[]) OWNER TO weymouth;

--
-- Name: grant_aclitems(aclitem[], aclitem[], text, text); Type: FUNCTION; Schema: public; Owner: weymouth
--

CREATE FUNCTION grant_aclitems(new_aclitems aclitem[], old_aclitems aclitem[], type text, objname text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    grantee text;
    priv    text;
    command text;
    objtype text;
BEGIN
    objtype :=
        CASE type
            WHEN 'r' THEN 'TABLE'
            WHEN 'v' THEN 'TABLE'
            WHEN 'S' THEN 'SEQUENCE'
            WHEN 'f' THEN 'FUNCTION'
            WHEN 'a' THEN 'FUNCTION' -- It's actually AGGREGATE, but we have to reference to it as FUNCTION in DDL
            WHEN 's' THEN 'SCHEMA'
            WHEN 'T' THEN 'TABLESPACE'
            ELSE 'BAD TYPE: ' || type
        END;

    -- first revoke everything
    FOR grantee IN
            SELECT
                DISTINCT R.rolname
            FROM
                (
                    SELECT (R.rec).*
                    FROM
                        (
                            SELECT
                                aclexplode(old_aclitems)
                        ) AS R (rec)
                ) AS B
                INNER JOIN pg_roles R ON (B.grantee = R.oid) LOOP

        command := 'REVOKE ALL PRIVILEGES ON ' || objtype ||
                ' ' || objname || ' FROM ' || grantee;
        EXECUTE(command);
    END LOOP;

    -- then grant the permissions individually
    FOR grantee, priv IN
            SELECT
                R.rolname, B.privilege_type
            FROM
                (
                    SELECT (R.rec).*
                    FROM
                        (
                            SELECT
                                aclexplode(new_aclitems)
                        ) AS R (rec)
                ) AS B
                INNER JOIN pg_roles R ON (B.grantee = R.oid) LOOP

        command := 'GRANT ' || priv || ' ON ' || objtype ||
                ' ' || objname || ' TO ' || grantee;
        EXECUTE(command);
    END LOOP;
END;
$$;


ALTER FUNCTION public.grant_aclitems(new_aclitems aclitem[], old_aclitems aclitem[], type text, objname text) OWNER TO weymouth;

SET search_path = searchapp, pg_catalog;

--
-- Name: bio_clinical_trial_uid(character varying, character varying, character varying); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION bio_clinical_trial_uid(trial_number character varying, title character varying, condition character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN coalesce(TRIAL_NUMBER || '|', '') || coalesce(TITLE || '|', '') || coalesce(CONDITION, '');
END;
 
 
 
$$;


ALTER FUNCTION searchapp.bio_clinical_trial_uid(trial_number character varying, title character varying, condition character varying) OWNER TO searchapp;

--
-- Name: bio_compound_uid(character varying, character varying, character varying); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN coalesce(CAS_REGISTRY || '|', '') || coalesce(JNJ_NUMBER || '|', '') || coalesce(CNTO_NUMBER, '');
END;
 
 
 
 
 
$$;


ALTER FUNCTION searchapp.bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) OWNER TO searchapp;

--
-- Name: refresh_search_bio_mkr_correl_fast_mv(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION refresh_search_bio_mkr_correl_fast_mv() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN

  -- populate the fake "materialized view" (i.e. actually a table) by deleting everything from it and then re-populating
  -- eventually we need a smarter algorithm for doing this

    delete from searchapp.search_bio_mkr_correl_fast_mv;

    insert into searchapp.search_bio_mkr_correl_fast_mv
    (domain_object_id, asso_bio_marker_id, correl_type, value_metric,  mv_id)    
    select domain_object_id, asso_bio_marker_id, correl_type, value_metric,  mv_id
       from searchapp.search_bio_mkr_correl_fast_view;  

    return true;
END;
 
 
 
$$;


ALTER FUNCTION searchapp.refresh_search_bio_mkr_correl_fast_mv() OWNER TO searchapp;

--
-- Name: tf_trg_saved_faceted_search_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_saved_faceted_search_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.saved_faceted_search_id IS NULL THEN
		SELECT nextval('SEARCHAPP.SEQ_saved_faceted_search_id') INTO NEW.saved_faceted_search_id;
	END IF;
	IF NEW.create_dt IS NULL THEN
		NEW.create_dt := now();
	END IF;
	RETURN NEW;
END;
$$;


ALTER FUNCTION searchapp.tf_trg_saved_faceted_search_id() OWNER TO searchapp;

--
-- Name: tf_trg_search_a_u_sec_access_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_search_a_u_sec_access_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.SEARCH_AUTH_USER_SEC_ACCESS_ID is null then
          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_AUTH_USER_SEC_ACCESS_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trg_search_a_u_sec_access_id() OWNER TO searchapp;

--
-- Name: tf_trg_search_au_obj_access_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_search_au_obj_access_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.AUTH_SEC_OBJ_ACCESS_ID is null then
          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.AUTH_SEC_OBJ_ACCESS_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trg_search_au_obj_access_id() OWNER TO searchapp;

--
-- Name: tf_trg_search_au_prcpl_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_search_au_prcpl_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
 if(coalesce(NEW.ID::text, '') = '' or NEW.ID = -2000) then       
 select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.ID ;      
 end if;     RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trg_search_au_prcpl_id() OWNER TO searchapp;

--
-- Name: tf_trg_search_cust_fil_item_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_search_cust_fil_item_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin 
    if NEW.SEARCH_CUSTOM_FILTER_ITEM_ID is null then
        select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_CUSTOM_FILTER_ITEM_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trg_search_cust_fil_item_id() OWNER TO searchapp;

--
-- Name: tf_trg_search_custom_filter_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_search_custom_filter_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin 
    if NEW.SEARCH_CUSTOM_FILTER_ID is null then
        select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_CUSTOM_FILTER_ID ;

    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trg_search_custom_filter_id() OWNER TO searchapp;

--
-- Name: tf_trg_search_keyword_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_search_keyword_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.SEARCH_KEYWORD_ID is null then
          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_KEYWORD_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trg_search_keyword_id() OWNER TO searchapp;

--
-- Name: tf_trg_search_keyword_term_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_search_keyword_term_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.SEARCH_KEYWORD_TERM_ID is null then
          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_KEYWORD_TERM_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trg_search_keyword_term_id() OWNER TO searchapp;

--
-- Name: tf_trg_search_sec_acc_level_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_search_sec_acc_level_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.SEARCH_SEC_ACCESS_LEVEL_ID is null then
          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_SEC_ACCESS_LEVEL_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trg_search_sec_acc_level_id() OWNER TO searchapp;

--
-- Name: tf_trg_search_sec_obj_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_search_sec_obj_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.SEARCH_SECURE_OBJECT_ID is null then
          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_SECURE_OBJECT_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trg_search_sec_obj_id() OWNER TO searchapp;

--
-- Name: tf_trg_search_sec_obj_path_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_search_sec_obj_path_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if NEW.SEARCH_SECURE_OBJ_PATH_ID is null then
          select nextval('searchapp.SEQ_SEARCH_DATA_ID') into NEW.SEARCH_SECURE_OBJ_PATH_ID ;
    end if;
RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trg_search_sec_obj_path_id() OWNER TO searchapp;

--
-- Name: tf_trg_search_taxonomy_rels_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_search_taxonomy_rels_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.SEARCH_TAXONOMY_RELS_ID IS NULL THEN
		SELECT nextval('SEARCHAPP.SEQ_SEARCH_DATA_ID') INTO NEW.SEARCH_TAXONOMY_RELS_ID;
	END IF;
	RETURN NEW;
end;
$$;


ALTER FUNCTION searchapp.tf_trg_search_taxonomy_rels_id() OWNER TO searchapp;

--
-- Name: tf_trg_search_taxonomy_term_id(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_search_taxonomy_term_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.TERM_ID IS NULL THEN
		SELECT nextval('SEARCHAPP.SEQ_SEARCH_DATA_ID') INTO NEW.TERM_ID;
	END IF;
	RETURN NEW;
END;
$$;


ALTER FUNCTION searchapp.tf_trg_search_taxonomy_term_id() OWNER TO searchapp;

--
-- Name: tf_trg_upd_saved_faceted_search(); Type: FUNCTION; Schema: searchapp; Owner: searchapp
--

CREATE FUNCTION tf_trg_upd_saved_faceted_search() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.modified_dt IS NULL THEN
		NEW.modified_dt := now();
	END IF;
	RETURN NEW;
END;
$$;


ALTER FUNCTION searchapp.tf_trg_upd_saved_faceted_search() OWNER TO searchapp;

SET search_path = tm_cz, pg_catalog;

--
-- Name: _final_median(anyarray); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION _final_median(anyarray) RETURNS numeric
    LANGUAGE sql IMMUTABLE
    AS $_$
   SELECT AVG(val)
   FROM (
     SELECT val
     FROM unnest($1) val
     ORDER BY 1
     LIMIT  2 - MOD(array_upper($1, 1), 2)
     OFFSET CEIL(array_upper($1, 1) / 2.0) - 1
   ) sub;
$_$;


ALTER FUNCTION tm_cz._final_median(anyarray) OWNER TO tm_cz;

--
-- Name: _final_median(double precision[]); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION _final_median(double precision[]) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    AS $_$
   SELECT AVG(val)
   FROM (
     SELECT val
     FROM unnest($1) val
     ORDER BY 1
     LIMIT  2 - MOD(array_upper($1, 1), 2)
     OFFSET CEIL(array_upper($1, 1) / 2.0) - 1
   ) sub;
$_$;


ALTER FUNCTION tm_cz._final_median(double precision[]) OWNER TO tm_cz;

--
-- Name: bio_assay_analysis_uid(bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION bio_assay_analysis_uid(analysis_id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN

  -- $Id$
  -- Creates uid for bio_assay_analysis.

  RETURN 'BAA:' || coalesce(ANALYSIS_ID, -1);
END;

$_$;


ALTER FUNCTION tm_cz.bio_assay_analysis_uid(analysis_id bigint) OWNER TO tm_cz;

--
-- Name: bio_assay_analysis_uid(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION bio_assay_analysis_uid(analysis_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'BAA:' || coalesce(ANALYSIS_NAME, 'ERROR');
END bio_assay_analysis_uid;

$_$;


ALTER FUNCTION tm_cz.bio_assay_analysis_uid(analysis_name character varying) OWNER TO tm_cz;

--
-- Name: bio_assay_platform_uid(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION bio_assay_platform_uid(platform_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_assay_platform.

  RETURN 'BAP:' || coalesce(PLATFORM_NAME, 'ERROR');
END bio_assay_platform_uid;

$_$;


ALTER FUNCTION tm_cz.bio_assay_platform_uid(platform_name character varying) OWNER TO tm_cz;

--
-- Name: bio_asy_analysis_pltfm_uid(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION bio_asy_analysis_pltfm_uid(platform_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_asy_analysis_pltfm.

  RETURN 'BAAP:' || coalesce(PLATFORM_NAME, 'ERROR');
END bio_asy_analysis_pltfm_uid;
 
$_$;


ALTER FUNCTION tm_cz.bio_asy_analysis_pltfm_uid(platform_name character varying) OWNER TO tm_cz;

--
-- Name: bio_compound_uid(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION bio_compound_uid(jnj_number character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Function to create compound_uid.

  RETURN 'COM:' || JNJ_NUMBER;
END BIO_COMPOUND_UID;
 
$_$;


ALTER FUNCTION tm_cz.bio_compound_uid(jnj_number character varying) OWNER TO tm_cz;

--
-- Name: bio_curation_dataset_uid(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION bio_curation_dataset_uid(bio_curation_type character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_curation_dataset.

  RETURN 'BCD:' || coalesce(BIO_CURATION_TYPE, 'ERROR');
END BIO_CURATION_DATASET_UID;
 
$_$;


ALTER FUNCTION tm_cz.bio_curation_dataset_uid(bio_curation_type character varying) OWNER TO tm_cz;

--
-- Name: bio_disease_uid(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION bio_disease_uid(mesh_code character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates bio_disease_uid.

  RETURN 'DIS:' || coalesce(MESH_CODE, 'ERROR');
END BIO_DISEASE_UID;
 
$_$;


ALTER FUNCTION tm_cz.bio_disease_uid(mesh_code character varying) OWNER TO tm_cz;

--
-- Name: bio_experiment_uid(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION bio_experiment_uid(primary_id character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_experiment.

  RETURN 'EXP:' || coalesce(PRIMARY_ID, 'ERROR');
END bio_experiment_uid;
 
$_$;


ALTER FUNCTION tm_cz.bio_experiment_uid(primary_id character varying) OWNER TO tm_cz;

--
-- Name: bio_jub_oncol_data_uid(numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION bio_jub_oncol_data_uid(record_id numeric, bio_curation_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_jub_oncol_data.

  RETURN 'BJOD:' || coalesce(TO_CHAR(RECORD_ID), 'ERROR') || ':' || coalesce(BIO_CURATION_NAME, 'ERROR');
END BIO_JUB_ONCOL_DATA_UID;
 
$_$;


ALTER FUNCTION tm_cz.bio_jub_oncol_data_uid(record_id numeric, bio_curation_name character varying) OWNER TO tm_cz;

--
-- Name: bio_jub_oncol_sum_data_uid(numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION bio_jub_oncol_sum_data_uid(record_id numeric, bio_curation_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for bio_jub_oncol_sum_data.

  RETURN 'BJOS:' || coalesce(TO_CHAR(RECORD_ID), 'ERROR') || ':' || coalesce(BIO_CURATION_NAME, 'ERROR');
END BIO_JUB_ONCOL_SUM_DATA_UID;
 
$_$;


ALTER FUNCTION tm_cz.bio_jub_oncol_sum_data_uid(record_id numeric, bio_curation_name character varying) OWNER TO tm_cz;

--
-- Name: biomarker_gene_uid(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION biomarker_gene_uid(gene_id character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for biomarker_gene.

  RETURN 'GENE:' || coalesce(GENE_ID, 'ERROR');
END biomarker_gene_uid;
 
$_$;


ALTER FUNCTION tm_cz.biomarker_gene_uid(gene_id character varying) OWNER TO tm_cz;

--
-- Name: biomarker_pathway_uid(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION biomarker_pathway_uid(p_source character varying, pathway_id character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  -- $Id$
  -- Creates uid for biomarker_pathway.

  RETURN 'PATHWAY:'|| P_SOURCE || ':' || coalesce(PATHWAY_ID, 'ERROR');
END biomarker_pathway_uid;
 
$_$;


ALTER FUNCTION tm_cz.biomarker_pathway_uid(p_source character varying, pathway_id character varying) OWNER TO tm_cz;

--
-- Name: create_synonyms(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION create_synonyms(fromdb character varying, todb character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  cTableList CURSOR FOR
    SELECT
      UPPER(owner) AS OWNER,
      UPPER(table_name) AS TABLE_NAME
    from
      all_tables
    order by owner, table_name;

  dbCount bigint;
  sourceDB varchar(200);
  targetDB varchar(200);

  dynamicSQL varchar(2000);


BEGIN
  -------------------------------------------------------------------------------
    --Create or replace Synonyms Point to DB A (TO) From DB B (FROM)
    --Input: From DB, TO DB
    --Output: Nothing
   -- KCR@20090310 - First rev.
   -------------------------------------------------------------------------------

/* CANT READ FROM DBA_TABLESPACES
    --Check that DB's exist
    select count(*) into dbCount from dba_tablespaces where tablespace_name = upper(fromDB);
    if dbCOunt > 1
      then
      dbms_output.put_line('From DB is invalid!: ' || fromDB);
   end if;

    if dbCount > 1
      then
      dbms_output.put_line('TO DB is invalid!: ' || toDB);
   end if;
*/

  sourceDB := UPPER(fromDB);
  targetDB := UPPER(toDB);



    --Loop through full list of results (All table for all schemas)
    for r_cTableList in cTableList
    loop
      --if The current owner(DB) matched the toDB then begin creating Synonyms.
      if r_cTableList.owner = targetDB
        then
        dynamicSQL := 'CREATE or REPLACE  OR REPLACE SYNONYM "' || sourceDB || '"."' || r_cTableList.table_name || '" FOR "' || targetDB || '"."' || r_cTableList.table_name || '"';
        RAISE NOTICE '%', dynamicSQL;
        EXECUTE dynamicSQL;
     end if;
    commit;
    end loop; --Loops through full resultset

END;
 
$$;


ALTER FUNCTION tm_cz.create_synonyms(fromdb character varying, todb character varying) OWNER TO tm_cz;

--
-- Name: cum_normal_dist(double precision, double precision, double precision); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION cum_normal_dist(foldchg double precision, mu double precision, sigma double precision) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

 -------------------------------------------------------------------------------
  -- param foldChg: fold change ratio from from analysis_data table
  -- param mu: mean of all analsyis_data records for a given analysis
  -- param sigma: std dev of all analsyis_data records for a given analysis
  -------------------------------------------------------------------------------

  -- temporary vars
  t1 DOUBLE PRECISION;

  -- fractional error dist input
  fract_error_input DOUBLE PRECISION;

  -- return result (i.e. Prob [X<=x])
  ans DOUBLE PRECISION;

BEGIN
  SELECT (foldChg-mu)/sigma INTO t1;
  SELECT t1/SQRT(2) INTO fract_error_input;
  SELECT 0.5 * (1.0 + tm_cz.fract_error_dist(fract_error_input)) INTO ans;
  return ans;
END
$$;


ALTER FUNCTION tm_cz.cum_normal_dist(foldchg double precision, mu double precision, sigma double precision) OWNER TO tm_cz;

--
-- Name: cz_audit_example(bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION cz_audit_example(currentjobid bigint) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

  --Audit variables
  newJobFlag integer(1);
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;

BEGIN
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    RAISE NOTICE '%%', 'Here' ,  to_char(jobID);
    cz_start_audit (procedureName, databaseName, jobID);
    RAISE NOTICE '%%', 'Here2' ,  to_char(jobID);
  END IF;

  --Step Audit
  cz_write_audit (jobID, databaseName, procedureName, 'Start loading some data', SQL%ROWCOUNT, 1, 'PASS');

  update cz_job_master set job_name = job_name;

  --Step Audit
  cz_write_audit (jobID, databaseName, procedureName, '# of rows on the cz_job_master table', SQL%ROWCOUNT, 2, 'PASS');


  cz_write_info (jobID, 1, 39, procedureName, 'Writing a message');



  --invalid statement
  insert into az_test_run(dw_version_id)
    values('a');


  --Step Audit
  cz_write_audit (jobID, databaseName, procedureName, 'Should have caused an error!', SQL%ROWCOUNT, 3, 'PASS');


  ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');

END;
 
$_$;


ALTER FUNCTION tm_cz.cz_audit_example(currentjobid bigint) OWNER TO tm_cz;

--
-- Name: cz_end_audit(numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION cz_end_audit(jobid numeric, jobstatus character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
declare
	endDate timestamp;
	rtnCd	numeric;

BEGIN
  
	select current_timestamp into endDate;
  
	begin
	update tm_cz.cz_job_master
		set 
			active='N',
			end_date = endDate,
			time_elapsed_secs = coalesce(((DATE_PART('day', endDate - START_DATE) * 24 + 
				   DATE_PART('hour', endDate - START_DATE)) * 60 +
				   DATE_PART('minute', endDate - START_DATE)) * 60 +
				   DATE_PART('second', endDate - START_DATE),0),
			job_status = jobStatus		
		where active='Y' 
		and job_id=jobID;
	end;
	
	return 1;
	
	exception 
	when OTHERS then
		--raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
		select tm_cz.cz_write_error(jobId,0,SQLSTATE,SQLERRM,null) into rtnCd;
		return -16;
END;
$$;


ALTER FUNCTION tm_cz.cz_end_audit(jobid numeric, jobstatus character varying) OWNER TO tm_cz;

--
-- Name: cz_error_handler(numeric, character varying, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION cz_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
	databaseName VARCHAR(100);
	--errorNumber		character varying;	--	PostgreSQL SQLSTATE is alphanumeric
	--errorNumber NUMBER(18,0);
	--errorMessage VARCHAR(1000);
	errorStack VARCHAR(4000);
	errorBackTrace VARCHAR(4000);
	stepNo numeric(18,0);
	
	rtnCd	integer;

BEGIN
	--Get DB Name
	select database_name INTO databaseName
	from tm_cz.cz_job_master 
	where job_id=jobID;

	--Get Latest Step
	select max(step_number) into stepNo from tm_cz.cz_job_audit where job_id = jobID;
  
	--Get all error info, passed in as parameters, only available from EXCEPTION block
	--errorNumber := SQLSTATE;
	--errorMessage := SQLERRM;
	
	--	No corresponding functionality in PostgreSQL
	--errorStack := dbms_utility.format_error_stack;
	--errorBackTrace := dbms_utility.format_error_backtrace;

	--Update the audit step for the error
	select tm_cz.cz_write_audit(jobID, databaseName,procedureName, 'Job Failed: See error log for details',1, stepNo, 'FAIL') into rtnCd;
  
	--write out the error info
	select tm_cz.cz_write_error(jobID, errorNumber, errorMessage, errorStack, errorBackTrace) into rtnCd;
	
	return 1;

END;

$$;


ALTER FUNCTION tm_cz.cz_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) OWNER TO tm_cz;

--
-- Name: cz_info_handler(numeric, numeric, numeric, character varying, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION cz_info_handler(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying, stepnumber character varying) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE 
	databaseName VARCHAR(100);
	rtnCd	numeric;
BEGIN

	select database_name INTO databaseName
  	from tm_cz.cz_job_master 
	where job_id=jobID;
    
  select tm_cz.cz_write_audit( jobID, databaseName, messageProcedure, 'Step contains more details', 0, stepNumber, 'Information' ) into rtnCd;
  select tm_cz.cz_write_info(jobID, messageID, messageLine, messageProcedure, infoMessage ) into rtnCd;

return rtnCd;
  
END;
$$;


ALTER FUNCTION tm_cz.cz_info_handler(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying, stepnumber character varying) OWNER TO tm_cz;

--
-- Name: cz_start_audit(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION cz_start_audit(jobname character varying, databasename character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
declare
	rtnCd	integer;
	jobId	numeric;
BEGIN
	begin
		insert into tm_cz.cz_job_master
			(start_date, 
			active, 
			database_name,
			job_name,
			job_status) 
		VALUES(
			CURRENT_TIMESTAMP,
			'Y', 
			databaseName,
			jobName,
			'Running')
	  RETURNING job_id INTO jobID;
	end;
  
  return jobID;
  
  exception 
	when OTHERS then
		select tm_cz.cz_write_error(jobId,0,SQLSTATE,SQLERRM,null) into rtnCd;
		return -16;

END;

$$;


ALTER FUNCTION tm_cz.cz_start_audit(jobname character varying, databasename character varying) OWNER TO tm_cz;

--
-- Name: cz_start_audit(character varying, character varying, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION cz_start_audit(jobname character varying, databasename character varying, jobid bigint) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
declare
	rtnCd	integer;
BEGIN
	begin
		insert into tm_cz.cz_job_master
			(start_date, 
			active, 
			database_name,
			job_name,
			job_status) 
		VALUES(
			CURRENT_TIMESTAMP,
			'Y', 
			databaseName,
			jobName,
			'Running')
	  RETURNING job_id INTO jobID;
	end;
  
  return jobID;
  
  exception 
	when OTHERS then
		select tm_cz.cz_write_error(jobId,SQLERRML,SQLSTATE,SQLERRM,null,null) into rtnCd;
		return -16;

END;

$$;


ALTER FUNCTION tm_cz.cz_start_audit(jobname character varying, databasename character varying, jobid bigint) OWNER TO tm_cz;

--
-- Name: cz_write_audit(numeric, character varying, character varying, character varying, numeric, numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION cz_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
DECLARE
        lastTime timestamp;
        currTime timestamp;
        elapsedSecs        numeric;
        rtnCd                numeric;
        
BEGIN

        select max(job_date)
    into lastTime
    from tm_cz.cz_job_audit
    where job_id = jobID;
        
        --        clock_timestamp() is the current system time
        
        select clock_timestamp() into currTime;

        elapsedSecs :=        coalesce(((DATE_PART('day', currTime - lastTime) * 24 + 
                                   DATE_PART('hour', currTime - lastTime)) * 60 +
                                   DATE_PART('minute', currTime - lastTime)) * 60 +
                                   DATE_PART('second', currTime - lastTime),0);

        begin
        insert         into tm_cz.cz_job_audit
        (job_id
        ,database_name
         ,procedure_name
         ,step_desc
        ,records_manipulated
        ,step_number
        ,step_status
    ,job_date
    ,time_elapsed_secs
        )
        values(
                 jobId,
                databaseName,
                procedureName,
                stepDesc,
                recordsManipulated,
                stepNumber,
                stepStatus,
                currTime,
                elapsedSecs);
        exception 
        when OTHERS then
                --raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
                select tm_cz.cz_write_error(jobId,0,SQLSTATE,SQLERRM,null) into rtnCd;
                return -16;
        end;
        
        return 1;
END;
$$;


ALTER FUNCTION tm_cz.cz_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) OWNER TO tm_cz;

--
-- Name: cz_write_error(numeric, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION cz_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

BEGIN

	begin
	insert into tm_cz.cz_job_error(
		job_id,
		error_number,
		error_message,
		error_stack,
		error_backtrace,
		seq_id)
	select
		jobID,
		errorNumber,
		errorMessage,
		errorStack,
		errorBackTrace,
		max(seq_id) 
  from tm_cz.cz_job_audit 
  where job_id=jobID;
  
  end;
  
  return 1;
 
  exception 
	when OTHERS then
		raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
		return -16; 

END;
$$;


ALTER FUNCTION tm_cz.cz_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) OWNER TO tm_cz;

--
-- Name: cz_write_info(numeric, numeric, numeric, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION cz_write_info(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$

BEGIN
    begin
	insert into tm_cz.cz_job_message
    (
      job_id,
      message_id,
      message_line,
      message_procedure,
      info_message,
      seq_id
    )
	select
      jobID,
      messageID,
      messageLine,
      messageProcedure,
      infoMessage,
      max(seq_id)
  from
    tm_cz.cz_job_audit
  where
    job_id = jobID;
    end;
  
  COMMIT;
  return 1;

END;

$$;


ALTER FUNCTION tm_cz.cz_write_info(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying) OWNER TO tm_cz;

--
-- Name: czf_init_cap(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czf_init_cap(text_to_parse character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

   start_pos 		integer;
   end_pos   		integer;
   string_length 	integer;
   string_tokens 	varchar(32676);
   counter 			integer;
   token_value 		varchar(1000);
   text_delimiter 	char(1);
   noInitCap 		boolean;

   --	create array to hold strings that will not be initcapped

	type excluded_aat is table of category_path_excluded_words%ROWTYPE index by integer;
	excludedText excluded_aat;
	exclCt integer;

   --	text to return
   initcap_text varchar(1000);


BEGIN
  -------------------------------------------------------------------------------
   -- Performs custom initcap for category paths where specific text strings are
   -- excluded from the process.  Strings are delimited by a space.  The \ in
   -- the category path are converted to ' \ ' before parsing.

   -- JEA@20091001 - First rev.
   -- Copyright ? 2009 Recombinant Data Corp.
   -------------------------------------------------------------------------------

	--	Load exclusion text

	select excluded_text
		bulk collect into excludedText
		from category_path_excluded_words;

	--	Add a delimiter to the end of the string so we dont lose last value and
	--	surround \ with spaces

	text_delimiter := ' ';
	string_tokens := replace(text_to_parse,'\',' \ ') || text_delimiter;

	--get length of string
	string_length := length(string_tokens);

	--set start and end for first token
	start_pos := 1;
	end_pos   := instr(string_tokens,text_delimiter,1,1);
	counter := 1;

	LOOP
		--	Get substring
		token_value := substr(string_tokens, start_pos, end_pos - start_pos);

		--	check if token_value is in excludedText, if yes, set indicator

		noInitCap := false;
		exclCt := excludedText.FIRST;

		while ((exclCt IS NOT NULL AND exclCt::text <> '') and not noInitCap)
		loop
			if token_value = excludedText(exclCt).excluded_text then
				noInitCap := true;
			end if;
			exclCt := excludedText.NEXT (exclCt);
		end loop;

		if noInitCap then
			initcap_text := initcap_text || token_value || ' ';
		else
			initcap_text := initcap_text || initcap(token_value) || ' ';
		end if;

		--Check to see if we are done
		IF end_pos = string_length
		THEN
			initcap_text := replace(rtrim(initcap_text,' '),' \ ','\');
			EXIT;
		ELSE
			-- Increment Start Pos and End Pos
			start_pos := end_pos + 1;
			--	increment counter
			counter := counter + 1;
			end_pos := instr(string_tokens, text_delimiter,1, counter);

		END IF;
  END LOOP;

  return initcap_text;

END CZF_INIT_CAP;
 
$$;


ALTER FUNCTION tm_cz.czf_init_cap(text_to_parse character varying) OWNER TO tm_cz;

--
-- Name: czf_num_occurances(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czf_num_occurances(input_str character varying, search_str character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

  num integer;

BEGIN
  num := 0;
  while instr(input_str, search_str, 1, num + 1) > 0 loop
    num := num + 1;
  end loop;
  return num;
end;
 
$$;


ALTER FUNCTION tm_cz.czf_num_occurances(input_str character varying, search_str character varying) OWNER TO tm_cz;

--
-- Name: czf_parse_nth_value(character varying, numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czf_parse_nth_value(pvalue character varying, location numeric, delimiter character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

   v_posA integer;
   v_posB integer;


BEGIN

   if location = 1 then
      v_posA := 1; -- Start at the beginning
   else
      v_posA := instr (pValue, delimiter, 1, location - 1);
      if v_posA = 0 then
         return null; --No values left.
      end if;
      v_posA := v_posA + length(delimiter);
   end if;

   v_posB := instr (pValue, delimiter, 1, location);
   if v_posB = 0 then -- Use the end of the file
      return substring(pValue from v_posA);
   end if;

   return substr (pValue, v_posA, v_posB - v_posA);

end;
 
$$;


ALTER FUNCTION tm_cz.czf_parse_nth_value(pvalue character varying, location numeric, delimiter character varying) OWNER TO tm_cz;

--
-- Name: czx_array_sort(anyarray); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czx_array_sort(anyarray) RETURNS anyarray
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $_$   
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
SELECT ARRAY(   
    SELECT $1[s.i] AS "foo"   
    FROM   
        generate_series(array_lower($1,1), array_upper($1,1)) AS s(i)   
    ORDER BY foo   
);   
$_$;


ALTER FUNCTION tm_cz.czx_array_sort(anyarray) OWNER TO tm_cz;

--
-- Name: czx_end_audit(numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czx_end_audit(jobid numeric, jobstatus character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

declare
	endDate timestamp;
	rtnCd	numeric;

BEGIN
  
	select clock_timestamp() into endDate;
  
	begin
	update tm_cz.cz_job_master
		set 
			active='N',
			end_date = endDate,
			time_elapsed_secs = coalesce(((DATE_PART('day', endDate - START_DATE) * 24 + 
				   DATE_PART('hour', endDate - START_DATE)) * 60 +
				   DATE_PART('minute', endDate - START_DATE)) * 60 +
				   DATE_PART('second', endDate - START_DATE),0),
			job_status = jobStatus		
		where active='Y' 
		and job_id=jobID;
	end;
	
	return 1;
	
	exception 
	when OTHERS then
		--raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
		select tm_cz.cz_write_error(jobId,SQLSTATE,SQLERRM,null,null) into rtnCd;
		return -16;
END;
$$;


ALTER FUNCTION tm_cz.czx_end_audit(jobid numeric, jobstatus character varying) OWNER TO tm_cz;

--
-- Name: czx_error_handler(numeric, character varying, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czx_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
	databaseName VARCHAR(100);
	--errorNumber		character varying;	--	PostgreSQL SQLSTATE is alphanumeric
	--errorNumber NUMBER(18,0);
	--errorMessage VARCHAR(1000);
	errorStack VARCHAR(4000);
	errorBackTrace VARCHAR(4000);
	stepNo numeric(18,0);
	
	rtnCd	integer;

BEGIN
	--Get DB Name
	select database_name INTO databaseName
	from tm_cz.cz_job_master 
	where job_id=jobID;

	--Get Latest Step
	select max(step_number) into stepNo from tm_cz.cz_job_audit where job_id = jobID;
  
	--Get all error info, passed in as parameters, only available from EXCEPTION block
	--errorNumber := SQLSTATE;
	--errorMessage := SQLERRM;
	
	--	No corresponding functionality in PostgreSQL
	--errorStack := dbms_utility.format_error_stack;
	--errorBackTrace := dbms_utility.format_error_backtrace;

	--Update the audit step for the error
	select tm_cz.czx_write_audit(jobID, databaseName,procedureName, 'Job Failed: See error log for details',1, stepNo, 'FAIL') into rtnCd;
  
	--write out the error info
	select tm_cz.czx_write_error(jobID, errorNumber, errorMessage, errorStack, errorBackTrace) into rtnCd;
	
	return 1;

END;

$$;


ALTER FUNCTION tm_cz.czx_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) OWNER TO tm_cz;

--
-- Name: czx_info_handler(numeric, numeric, numeric, character varying, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czx_info_handler(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying, stepnumber character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

declare

  databaseName VARCHAR(100);
  rtnCd			numeric;
BEGIN

	select 
    database_name INTO databasename
  from 
    tm_cz.cz_job_master 
	where 
    job_id=jobID;
    
  select tm_cz.czx_write_audit( jobID, databaseName, messageProcedure, 'Step contains more details', 0, stepNumber, 'Information' ) into rtnCd;

  select tm_cz.czx_write_info(jobID, messageID, messageLine, messageProcedure, infoMessage ) into rtnCd;
  return rtnCd;
  
END;
$$;


ALTER FUNCTION tm_cz.czx_info_handler(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying, stepnumber character varying) OWNER TO tm_cz;

--
-- Name: czx_percentile_cont(real[], real); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czx_percentile_cont(myarray real[], percentile real) RETURNS real
    LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$   
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/ 
DECLARE   
  ary_cnt INTEGER;   
  row_num real;   
  crn real;   
  frn real;   
  calc_result real;   
  new_array real[];   
BEGIN   
  ary_cnt = array_length(myarray,1);   
  row_num = 1 + ( percentile * ( ary_cnt - 1 ));   
  new_array = tm_cz.czx_array_sort(myarray);   
     
  crn = ceiling(row_num);   
  frn = floor(row_num);   
         
      if crn = frn and frn = row_num then   
    calc_result = new_array[row_num];   
  else   
    calc_result = (crn - row_num) * new_array[frn]   
            + (row_num - frn) * new_array[crn];   
  end if;   
     
  RETURN calc_result;   
END;   
$$;


ALTER FUNCTION tm_cz.czx_percentile_cont(myarray real[], percentile real) OWNER TO tm_cz;

--
-- Name: czx_start_audit(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czx_start_audit(jobname character varying, databasename character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
declare
	rtnCd	integer;
	jobId	numeric;
BEGIN
	begin
		insert into tm_cz.cz_job_master
			(start_date, 
			active, 
			database_name,
			job_name,
			job_status) 
		VALUES(
			CLOCK_TIMESTAMP(),
			'Y', 
			databaseName,
			jobName,
			'Running')
	  RETURNING job_id INTO jobID;
	end;
  
  return jobID;
  
  exception 
	when OTHERS then
		select tm_cz.czx_write_error(jobId,'0',SQLERRML,SQLSTATE,SQLERRM) into rtnCd;
		return -16;

END;

$$;


ALTER FUNCTION tm_cz.czx_start_audit(jobname character varying, databasename character varying) OWNER TO tm_cz;

--
-- Name: czx_table_index_maint(character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czx_table_index_maint(p_run_type character varying, p_schema character varying, p_table character varying DEFAULT 'ALL'::character varying, currentjobid numeric DEFAULT NULL::numeric) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, deapp, i2b2demodata, pg_temp
    AS $$
/*
 *   Copyright 2012-2013 The Regents of the University of Colorado
 *
 *   Licensed under the Apache License, Version 2.0 (the "License")
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */
declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	
	v_ct		int;
	v_index		record;
	v_sql		varchar(4000);
  
begin

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	databaseName := 'tm_cz';
	procedureName := 'czx_table_index_maint';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done') into rtnCd;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,' run_type: ' || p_run_type || ' schema: ' || p_schema ||  ' table: ' || p_table,0,stepCt,'Done') into rtnCd;


	if p_run_type not in ('DROP','ADD','SAVE') then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Invalid run_type',0,stepCt,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return 16;
	end if;
	
	if p_schema is null or p_schema = '' then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Schema name missing',0,stepCt,'Done') into rtnCd;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return 16;
	end if;
	
	select count(*) into v_ct
	from tm_cz.table_index
	where schema_name = p_schema
	  and case when p_run_type = 'ALL' then 1
	           else case when table_name = p_table then 1
			             else 0
						 end
			   end = 1;
	
	if v_ct = 0 then
		if p_run_type != 'SAVE' then
			if p_table = 'ALL' then
				stepCt := stepCt + 1;
				select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'No saved indexes foound for schema',0,stepCt,'Done') into rtnCd;
			else
				stepCt := stepCt + 1;
				select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'No saved indexes found for table',0,stepCt,'Done') into rtnCd;
			end if;
			select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return 16;
		end if;
	end if;
	
	--	SAVE indexes
	
	if p_run_type = 'SAVE' then
	
		--	check that indexes exist for supplied schema name
		
		select count(*) into v_ct
		from pg_class a
		inner join pg_index b
			  on  a.oid = b.indexrelid 
		inner join pg_class c
			  on  b.indrelid = c.oid
		inner join pg_attribute d
			  on  c.oid = d.attrelid 
			  and d.attnum = any(b.indkey)
		inner join pg_namespace n
			  on n.oid = a.relnamespace
		where a.relname not like 'pg_%'
		  and n.nspname = p_schema
		  and case when p_table = 'ALL' then 1
				   else case when p_table = c.relname then 1
							 else 0 end
					end = 1;
	
	if v_ct = 0 then
		if p_table = 'ALL' then
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'No indexes foound for schema',0,stepCt,'Done') into rtnCd;
		else
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'No indexes found for table',0,stepCt,'Done') into rtnCd;
		end if;
		select tm_cz.czx_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return 16;
	end if;
	
		--	delete existing indexes for schema tables from cz.table_maint
		
		begin
		delete from tm_cz.table_index
		where schema_name = p_schema
		  and case when p_table = 'ALL' then 1
				   else case when p_table = table_name then 1
							 else 0 end
				   end = 1;
		get diagnostics rowCt := ROW_COUNT;
		exception 
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return 16;
		end;
		stepCt := stepCt + 1; 
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Deleted existing indexes for ' ||
				case when p_table = 'ALL' then p_schema else p_table end,rowCt,stepCt,'Done') into rtnCd;
		
		--	insert indexes for schema tables into cz.table_index
		
		begin
		insert into tm_cz.table_index
		(schema_name
		,table_name
		,index_name
		,index_sql
		)
		select distinct n.nspname as schema_name
			  ,c.relname as table_name
			  ,a.relname as index_name
			  ,pg_get_indexdef(b.indexrelid) as index_sql
		from pg_class a
		inner join pg_index b
			  on  a.oid = b.indexrelid 
		inner join pg_class c
			  on  b.indrelid = c.oid
		inner join pg_attribute d
			  on  c.oid = d.attrelid 
			  and d.attnum = any(b.indkey)
		inner join pg_namespace n
			  on n.oid = a.relnamespace
		where a.relname not like 'pg_%'
		  and n.nspname = p_schema
		  and case when p_table = 'ALL' then 1
				   else case when p_table = c.relname then 1
							 else 0 end
				   end = 1
		order by schema_name, table_name, index_name;
		get diagnostics rowCt := ROW_COUNT;
		exception 
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return 16;
		end;
		stepCt := stepCt + 1; 
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted indexes for ' ||
				case when p_table = 'ALL' then p_schema else p_table end,rowCt,stepCt,'Done') into rtnCd;
	else 
		--	drop indexes for DROP or ADD
		
		for v_index in (select * from tm_cz.table_index 
						where schema_name = p_schema 
						  and case when p_table = 'ALL' then 1
								   else case when p_table = table_name then 1
											 else 0
											 end
								   end = 1)
		loop
			v_sql = 'drop index if exists ' || v_index.schema_name || '.' || v_index.index_name || ' cascade';
			begin
			execute v_sql;
			get diagnostics rowCt := ROW_COUNT;
			--exception 
			--when others then
			--	errorNumber := SQLSTATE;
			--	errorMessage := SQLERRM;
				--Handle errors.
			--	select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
			--	select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			--	return 16;
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Dropped index ' || v_index.index_name || ' for ' ||
				case when p_table = 'ALL' then p_schema else p_table end,rowCt,stepCt,'Done') into rtnCd;
			
			if p_run_type = 'ADD' then
				--	add indexes for schema
				v_sql = v_index.index_sql;
				begin
				execute v_sql;
				get diagnostics rowCt := ROW_COUNT;
				exception 
				when others then
					stepCt := stepCt + 1;
					select tm_cz.czx_write_audit(jobId,databaseName,procedureName,v_index.index_sql || ': ' || sqlerrm,0,stepCt,'Done') into rtnCd;
					errorNumber := SQLSTATE;
					errorMessage := SQLERRM;
					--Handle errors.
					select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
					--End Proc
					select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
					return 16;
				end;
				stepCt := stepCt + 1;
				select tm_cz.czx_write_audit(jobId,databaseName,procedureName, 'Added index ' || v_index.index_name || ' on ' || p_schema || '.' || v_index.table_name,0,stepCt,'Done') into rtnCd;
			end if;
		end loop;
	end if;

    ---Cleanup OVERALL JOB if this proc is being run standalone

	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
	

end
$$;


ALTER FUNCTION tm_cz.czx_table_index_maint(p_run_type character varying, p_schema character varying, p_table character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: czx_write_audit(numeric, character varying, character varying, character varying, numeric, numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czx_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
DECLARE
	lastTime timestamp;
	currTime timestamp;
	elapsedSecs	numeric;
	rtnCd		numeric;
	
BEGIN

	select max(job_date)
    into lastTime
    from tm_cz.cz_job_audit
    where job_id = jobID;
	
	--	clock_timestamp() is the current system time
	
	select clock_timestamp() into currTime;

	elapsedSecs :=	coalesce(((DATE_PART('day', currTime - lastTime) * 24 + 
				   DATE_PART('hour', currTime - lastTime)) * 60 +
				   DATE_PART('minute', currTime - lastTime)) * 60 +
				   DATE_PART('second', currTime - lastTime),0);

	begin
	insert into tm_cz.cz_job_audit
	(job_id
	,database_name
 	,procedure_name
 	,step_desc
	,records_manipulated
	,step_number
	,step_status
    ,job_date
    ,time_elapsed_secs
	)
	values(
 		jobId,
		databaseName,
		procedureName,
		stepDesc,
		recordsManipulated,
		stepNumber,
		stepStatus,
		currTime,
		elapsedSecs);
	exception 
	when OTHERS then
		--raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
		select tm_cz.czx_write_error(jobId,'0'::character varying(10),SQLERRM::character varying(1000),SQLSTATE::character varying(1000),SQLERRM::character varying(1000)) into rtnCd;
		return -16;
	end;
	
	raise notice 'step: %', stepDesc;
	
	return 1;
END;
$$;


ALTER FUNCTION tm_cz.czx_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) OWNER TO tm_cz;

--
-- Name: czx_write_error(numeric, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czx_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

BEGIN

	begin
	insert into tm_cz.cz_job_error(
		job_id,
		error_number,
		error_message,
		error_stack,
		error_backtrace,
		seq_id)
	select
		jobID,
		errorNumber,
		errorMessage,
		errorStack,
		errorBackTrace,
		max(seq_id) 
  from tm_cz.cz_job_audit 
  where job_id=jobID;
  
  end;
  
  return 1;
 
  exception 
	when OTHERS then
		raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
		return -16; 

END;
$$;


ALTER FUNCTION tm_cz.czx_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) OWNER TO tm_cz;

--
-- Name: czx_write_info(numeric, numeric, numeric, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION czx_write_info(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

declare

	rtnCd	numeric;
	
BEGIN

	begin
	insert into tm_cz.cz_job_message
    (
      job_id,
      message_id,
      message_line,
      message_procedure,
      info_message,
      seq_id
    )
	select
      jobID,
      messageID,
      messageLine,
      messageProcedure,
      infoMessage,
      max(seq_id)
  from
    tm_cz.cz_job_audit
  where
    job_id = jobID;
  	exception 
	when OTHERS then
		--raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
		select tm_cz.cz_write_error(jobId,SQLSTATE,SQLERRM,null,null) into rtnCd;
		return -16;
	end;
	
	return 1;

END;
$$;


ALTER FUNCTION tm_cz.czx_write_info(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying) OWNER TO tm_cz;

--
-- Name: data_export(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION data_export() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

--Iterate through a cursor of all patient IDs
--Dynamically build a sql statement
--Run the statement returning the results

cPatients CURSOR FOR
  SELECT distinct a.patient_num
    FROM observation_fact a
  join i2b2 b
    on a.concept_cd = b.c_basecode
  where c_fullname like '%BRC Depression Study%'
    and c_visualattributes not like '%H%'
  order by patient_num;

  dynamicSQL varchar(32767);
  dynamicSQL2 varchar(32767);


BEGIN
  dynamicSQL := 'select c_name ,c_fullname ';
  dynamicSQL2 := 'select c_name ,c_fullname ';

  FOR r_cPatients in cPatients Loop

    dynamicSQL  := dynamicSQL  || ',max(decode(patient_num,' || cast(r_cPatients.patient_num as varchar) || ',tval_char,null)) "' || cast(r_cPatients.patient_num as varchar) || '"';
    dynamicSQL2 := dynamicSQL2 || ',max(decode(patient_num,' || cast(r_cPatients.patient_num as varchar) || ',cast(nval_num as varchar(20)),null)) "' || cast(r_cPatients.patient_num as varchar) || '"';

  END LOOP;

  dynamicSQL := dynamicSQL || ' from observation_fact a join i2b2 b on a.concept_cd = b.c_basecode where c_fullname like ''%BRC Depression Study%'' and c_columndatatype = ''T'' and c_visualattributes not like ''%H%'' group by c_name, c_fullname';
  dynamicSQL2 := dynamicSQL2 || ' from observation_fact a join i2b2 b on a.concept_cd = b.c_basecode where c_fullname like ''%BRC Depression Study%'' and c_columndatatype = ''N'' and c_visualattributes not like ''%H%'' group by c_name, c_fullname order by c_fullname';

  EXECUTE(dynamicSQL || ' UNION ALL ' || dynamicsql2);

  RAISE NOTICE '%', dynamicSQL;-- || ' UNION ALL ' || dynamicsql2);
  RAISE NOTICE 'UNION ALL';
  RAISE NOTICE '%', dynamicsql2;
END;
 
$$;


ALTER FUNCTION tm_cz.data_export() OWNER TO tm_cz;

--
-- Name: drop_table(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION drop_table(tabowner character varying, tabname character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

    temp integer:=0;
    drp_stmt varchar(200):=null;

    
BEGIN
      select
        count(*)
      into
        temp
      from
        all_tables
      where
        upper(TABLE_NAME) = upper(TabName)
      and
        upper(OWNER) = upper(TabOwner);

      if temp = 1 then
        drp_stmt := 'Drop Table ' || TabOwner || '.' || TabName;
        EXECUTE drp_stmt;
        commit;
      end if;

    EXCEPTION
      WHEN OTHERS THEN
      RAISE EXCEPTION 'An error was encountered - % -ERROR- %',SQLSTATE,SQLERRM;

END DROP_TABLE;

$$;


ALTER FUNCTION tm_cz.drop_table(tabowner character varying, tabname character varying) OWNER TO tm_cz;

--
-- Name: dropsyn(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION dropsyn() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

 s_cur CURSOR FOR
 SELECT synonym_name
 FROM user_synonyms;

 RetVal  bigint;
 sqlstr  varchar(200);

BEGIN
  FOR s_rec IN s_cur LOOP
    sqlstr := 'DROP SYNONYM ' || s_rec.synonym_name;

    EXECUTE sqlstr;
    COMMIT;
  END LOOP;
END dropsyn;

$$;


ALTER FUNCTION tm_cz.dropsyn() OWNER TO tm_cz;

--
-- Name: find_user(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION find_user(user_type character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
declare
	userName	character varying;
BEGIN

	if user_type = 'S' then
		select session_user into userName;
	else
		select current_user into userName;
	end if;

  
	return userName;
  

END;

$$;


ALTER FUNCTION tm_cz.find_user(user_type character varying) OWNER TO tm_cz;

--
-- Name: fract_error_dist(double precision); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION fract_error_dist(norminput double precision) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

  -- temp var
  t1 DOUBLE PRECISION;

  -- exponent input to next equation
  exponent_input DOUBLE PRECISION;

  ans DOUBLE PRECISION;

  fractError DOUBLE PRECISION;

BEGIN
  t1 := 1.0 / (1.0 + 0.5 * ABS(normInput));
  exponent_input := -normInput*normInput - 1.26551223 +
                           t1*(1.00002368 + t1*(0.37409196 + t1*(0.09678418 + t1*(-0.18628806 + t1*(0.27886807 + t1*(-1.13520398 + t1*(1.48851587 + t1*(-0.82215223 + t1*(0.17087277)))))))));

  -- Horner's method
  BEGIN
    ans := 1 - t1 * EXP(exponent_input);
  EXCEPTION
  WHEN numeric_value_out_of_range THEN --underflow or overflow
    IF exponent_input < 0 THEN
      ans := 1 - t1 * 0::double precision;
    ELSE
      ans := 1 - t1 * 'Infinity'::double precision;
    END IF;
  END;

  -- handle sign
  IF normInput>0 THEN fractError:= ans; ELSE fractError:= -ans; END IF;
  return fractError;
END
$$;


ALTER FUNCTION tm_cz.fract_error_dist(norminput double precision) OWNER TO tm_cz;

--
-- Name: i2b2_add_node(character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_add_node(trialid character varying, path character varying, path_name character varying, currentjobid numeric) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, i2b2demodata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

  root_node		varchar(2000);
  root_level	integer;
  rtnCd			integer;
  
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
  
BEGIN
    
	stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_ADD_NODE';
	
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobId;
	END IF;
  
	select tm_cz.parse_nth_value(path, 2, '\') into root_node;
	
	select c_hlevel into root_level
	from i2b2metadata.table_access
	where c_name = root_node;
  
	if path = ''  or path = '%' or path_name = ''
	then 
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Path or Path name missing, no action taken',0,stepCt,'Done') into rtnCd;
		return 1;
	end if;
	

	--Delete existing data.

	DELETE FROM i2b2demodata.OBSERVATION_FACT 
	WHERE concept_cd IN (SELECT C_BASECODE FROM i2b2metadata.I2B2 WHERE C_FULLNAME = PATH);
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Deleted any concepts for path from I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--CONCEPT DIMENSION
	DELETE FROM i2b2demodata.CONCEPT_DIMENSION
	WHERE CONCEPT_PATH = path;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Deleted any concepts for path from I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCd;
    
	--I2B2
	DELETE FROM i2b2metadata.i2b2
	WHERE C_FULLNAME = PATH;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Deleted path from I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

	--	Insert new node
	
	--CONCEPT DIMENSION
	INSERT INTO i2b2demodata.CONCEPT_DIMENSION
	(CONCEPT_CD, CONCEPT_PATH, NAME_CHAR,  UPDATE_DATE,  DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD)
	VALUES
	(cast(nextval('i2b2demodata.concept_id') as varchar),
	path,
	path_name,
	current_timestamp,
	current_timestamp,
	current_timestamp,
	TrialID
	);
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted concept for path into I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCD;

	--I2B2
	INSERT INTO i2b2metadata.I2B2
	(c_hlevel, C_FULLNAME, C_NAME, C_VISUALATTRIBUTES, c_synonym_cd, C_FACTTABLECOLUMN, C_TABLENAME, C_COLUMNNAME,
	C_DIMCODE, C_TOOLTIP, UPDATE_DATE, DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD, c_basecode, C_OPERATOR, c_columndatatype, c_comment,
	m_applied_path)
	SELECT 
	(length(concept_path) - coalesce(length(replace(concept_path, '\','')),0)) / length('\') - 2 + root_level,
	CONCEPT_PATH,
	NAME_CHAR,
	'FA',
	'N',
	'CONCEPT_CD',
	'CONCEPT_DIMENSION',
	'CONCEPT_PATH',
	CONCEPT_PATH,
	CONCEPT_PATH,
	current_timestamp,
	current_timestamp,
	current_timestamp,
	SOURCESYSTEM_CD,
	CONCEPT_CD,
	'LIKE',
	'T',
	case when TrialID is null then null else 'trial:' || TrialID end,
	'@'
	FROM i2b2demodata.CONCEPT_DIMENSION
	WHERE 
	CONCEPT_PATH = path;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted path into I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;
		
      ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCD;
	END IF;

	return 1;
	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

  
END;

$$;


ALTER FUNCTION tm_cz.i2b2_add_node(trialid character varying, path character varying, path_name character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_add_root_node(character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_add_root_node(root_node character varying, currentjobid numeric) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
DECLARE	
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);

	rootNode		varchar(200);
	rootPath		varchar(200);
	errorNumber		character varying;
	errorMessage	character varying;
	
	rtnCd			integer;
	
Begin
	rootNode := root_node;
	rootPath := '\' || rootNode || '\';

    stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_ADD_ROOT_NODE';
	

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobId;
	END IF;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Start ' || procedureName,0,stepCt,'Done') into rtnCd;
	
	begin
	
	insert into i2b2metadata.table_access
	(c_table_cd
	,c_table_name
	,c_protected_access
	,c_hlevel
	,c_fullname
	,c_name
	,c_synonym_cd
	,c_visualattributes
	,c_totalnum
	,c_basecode
	,c_metadataxml
	,c_facttablecolumn
	,c_dimtablename
	,c_columnname
	,c_columndatatype
	,c_operator
	,c_dimcode
	,c_comment
	,c_tooltip
	,c_entry_date
	,c_change_date
	,c_status_cd
	,valuetype_cd
	)
	select rootNode as c_table_cd
		  ,'i2b2' as c_table_name
		  ,'N' as protected_access
		  ,0 as c_hlevel
		  ,rootPath as c_fullname
		  ,rootNode as c_name
		  ,'N' as c_synonym_cd
		  ,'CA' as c_visualattributes
		  ,null as c_totalnum
		  ,null as c_basecode
		  ,null as c_metadataxml
		  ,'concept_cd' as c_facttablecolumn
		  ,'concept_dimension' as c_dimtablename
		  ,'concept_path' as c_columnname
		  ,'T' as c_columndatatype
		  ,'LIKE' as c_operator
		  ,rootPath as c_dimcode
		  ,null as c_comment
		  ,rootPath as c_tooltip
		  ,current_timestamp as c_entry_date
		  ,null as c_change_date
		  ,null as c_status_cd
		  ,null as valuetype_cd
	where not exists
		(select 1 from i2b2metadata.table_access x
		 where x.c_table_cd = rootNode);
	get diagnostics rowCt := ROW_COUNT;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert to table_access',rowCt,stepCt,'Done') into rtnCd;	

	--	insert root_node into i2b2
	
	insert into i2b2metadata.i2b2
	(c_hlevel
	,c_fullname
	,c_name
	,c_synonym_cd
	,c_visualattributes
	,c_totalnum
	,c_basecode
	,c_metadataxml
	,c_facttablecolumn
	,c_tablename
	,c_columnname
	,c_columndatatype
	,c_operator
	,c_dimcode
	,c_comment
	,c_tooltip
	,m_applied_path
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,valuetype_cd
	,m_exclusion_cd
	,c_path
	,c_symbol
	--,i2b2_id
	)
	select 0 as c_hlevel
		  ,rootPath as c_fullname
		  ,rootNode as c_name
		  ,'N' as c_synonym_cd
		  ,'CA' as c_visualattributes
		  ,null as c_totalnum
		  ,null as c_basecode
		  ,null as c_metadataxml
		  ,'concept_cd' as c_facttablecolumn
		  ,'concept_dimension' as c_tablename
		  ,'concept_path' as c_columnname
		  ,'T' as c_columndatatype
		  ,'LIKE' as c_operator
		  ,rootPath as c_dimcode
		  ,null as c_comment
		  ,rootPath as c_tooltip
		  ,'@' as m_applied_path
		  ,current_timestamp as update_date
		  ,null as download_date
		  ,current_timestamp as import_date
		  ,null as sourcesystem_cd
		  ,null as valuetype_cd
		  ,null as m_exclusion_cd
		  ,null as c_path
		  ,null as c_symbol
		  --	add trigger on i2b2 insert
		  --,nextval('i2b2metadata.i2b2_id_seq')
		  --,I2B2_ID_SEQ.nextval as i2b2_id
	where not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where x.c_name = rootNode);
	get diagnostics rowCt := ROW_COUNT;
		  
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert root_node ' || rootNode || ' to i2b2',rowCt,stepCt,'Done') into rtnCd;
    
	end;
			
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done') into rtnCD;
	
	--Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	
END;

$$;


ALTER FUNCTION tm_cz.i2b2_add_root_node(root_node character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_add_snp_biomarker_nodes(character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_add_snp_biomarker_nodes(trial_id character varying, ont_path character varying, currentjobid numeric DEFAULT (-1)) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

	--	Adds SNP platform and sample type nodes into Biomarker Data ontology and adds rows into observation_fact for
	--	each subject/concept combination
	
	--	JEA@20110120	New
	--	JEA@@0111218	Remove hard-coded "Biomarker Data" node, use what's supplied in ont_path

	TrialID	varchar(100);
	ontPath		varchar(500);
  
	RootNode	varchar(300);
	pExists 	integer;
	platformTitle	varchar(200);
	tText		varchar(1000);
	ontLevel	integer;
	nodeName	varchar(200);
    
	--Audit variables
	newJobFlag integer(1);
	databaseName varchar(100);
	procedureName varchar(100);
	jobID numeric;
	stepCt integer;
	
	--	raise exception if platform not in de_gpl_info
	
	missing_GPL exception;
	
--	cursor to add platform-level nodes, need to be inserted before de_subject_sample_mapping

	addPlatform CURSOR FOR
	SELECT distinct REGEXP_REPLACE(ont_path || '\' || g.title || '\' ,
                  '(\\){2,}', '\') as path
		   ,g.title
	from de_subject_snp_dataset s
		,de_gpl_info g
	where s.trial_name = TrialId
	  and coalesce(s.platform_name,'GPL570') = g.platform
	  and upper(g.organism) = 'HOMO SAPIENS';
	
--	cursor to add sample-level nodes

	addSample CURSOR FOR
	SELECT distinct REGEXP_REPLACE(ont_path || '\' || g.title || '\' ||
                    s.sample_type || '\',	'(\\){2,}', '\') as sample_path
		   ,s.sample_type as sample_name
	from de_subject_snp_dataset s
		,de_gpl_info g
	where s.trial_name = TrialId
	  and coalesce(s.platform_name,'GPL570') = g.platform
	  and upper(g.organism) = 'HOMO SAPIENS'
	  and (s.sample_type IS NOT NULL AND s.sample_type::text <> '');
	  

BEGIN
	TrialID := upper(trial_id); 
	ontPath := ont_path;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
    	
	stepCt := 0;
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_add_snp_node',0,stepCt,'Done');
	stepCt := stepCt + 1;

	--	determine last node in ontPath
	
	PERFORM length(ontPath)-length(replace(ontPath,'\','')) into ontLevel ;
	PERFORM parse_nth_value(ontPath,ontLevel,'\') into nodeName ;
	
	--	add the high level \ node if it doesn't exist (first time loading data)
  
	select count(*)
	into pExists
	from i2b2
	where c_fullname = REGEXP_REPLACE(ont_path || '\','(\\){2,}', '\');
  
	if pExists = 0 then 
		i2b2_add_node(TrialId, REGEXP_REPLACE(ont_path || '\','(\\){2,}', '\'), nodeName, jobID);
        stepCt := stepCt + 1;
	    cz_write_audit(jobId,databaseName,procedureName,'Add node for ontPath',0,stepCt,'Done');
	end if;

    --	check if a node exists for the platform, if yes, then delete existing data, make sure all platforms in de_subject_snp_dataset have an
	--	entry in de_gpl_info, if not, raise exception
	
	select count(*) into pExists
	from de_subject_snp_dataset s
		,de_gpl_info g
	where s.trial_name = TrialId
	  and coalesce(s.platform_name,'GPL570') = g.platform(+)
	  and  'HOMO SAPIENS' = upper(g.organism(+))
	  and coalesce(g.platform::text, '') = '';
	  
	if pExists > 0
		then raise missing_GPL;
	end if;

	--	add SNP platform nodes
	
	for r_addPlatform in addPlatform Loop
	
		i2b2_delete_all_nodes(REGEXP_REPLACE(ont_path || '\','(\\){2,}', '\') || r_addPlatform.title || '\', jobID);
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete existing SNP Platform for trial in I2B2METADATA i2b2',0,stepCt,'Done');
		
		i2b2_add_node(TrialId, r_addPlatform.path, r_addPlatform.title, jobId);
		tText := 'Added Platform: ' || r_addPlatform.path || '  Name: ' || r_addPlatform.title;
		stepCt := stepCt + 1;
	    cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');
	end loop;

	cz_write_audit(jobId,databaseName,procedureName,'Added SNP Platform nodes',0,stepCt,'Done');
	stepCt := stepCt + 1;
	commit;
	       
	--	Insert the sample-level nodes
	
	for r_addSample in addSample Loop
	
		i2b2_add_node(TrialId, r_addSample.sample_path, r_addSample.sample_name, jobId);
		tText := 'Added Sample: ' || r_addSample.sample_path || '  Name: ' || r_addSample.sample_name;
	    cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');
		stepCt := stepCt + 1;

	end loop;		  
	
--	Insert records for patients into observation_fact

	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    PERFORM p.patient_num
		  ,t.concept_cd
		  ,t.sourcesystem_cd
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null	--	not numeric for Proteomics
		  ,t.sourcesystem_cd
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  concept_dimension t
		 ,de_subject_snp_dataset p
		 ,de_gpl_info g
    where p.trial_name =  TrialId
	  and coalesce(p.platform_name,'GPL570') = g.platform
	  and upper(g.organism) = 'HOMO SAPIENS'
	  and t.concept_path = REGEXP_REPLACE(ont_path || '\','(\\){2,}', '\') || g.title || '\' || p.sample_type || '\'
    group by p.patient_num
			,t.concept_cd
			,t.sourcesystem_cd;
	cz_write_audit(jobId,databaseName,procedureName,'Insert trial into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	stepCt := stepCt + 1;
    commit;
	
	--	update concept_cd in de_subject_snp_dataset
	
	update de_subject_snp_dataset d
	set concept_cd = (select t.concept_cd
					  from de_subject_snp_dataset p
						  ,de_gpl_info g
						  ,concept_dimension t
					  where d.subject_snp_dataset_id = p.subject_snp_dataset_id
						and coalesce(p.platform_name,'GPL570') = g.platform
						and upper(g.organism) = 'HOMO SAPIENS'
						and t.concept_path = REGEXP_REPLACE(ont_path || '\','(\\){2,}', '\') || g.title || '\' || p.sample_type || '\'
					  )
	where d.trial_name = TrialId;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update concept_cd in DEAPP de_subject_snp_dataset',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
--	Update visual attributes for leaf active (default is folder)

	update i2b2 a
    set c_visualattributes = 'LA'
    where 1 = (select count(*)
			   from i2b2 b
			   where b.c_fullname like (a.c_fullname || '%'))
      and a.c_fullname like REGEXP_REPLACE(ont_path || '\','(\\){2,}', '\') || '%';
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update leaf active attribute for trial in I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    commit;
	
--	fill in tree

	--	get top level for study, this will be used for fill-in and create_concept_counts
	--	if this fails, check to make sure the trialId is not a sourcesystem_cd at an higher level than the study
	
	select b.c_fullname into nodeName
	from i2b2 b
	where b.c_hlevel =
		 (select min(x.c_hlevel) from i2b2 x
		  where b.sourcesystem_cd = x.sourcesystem_cd)
	  and ontPath like b.c_fullname || '%'
	  and b.sourcesystem_cd = TrialId;

	i2b2_fill_in_tree(TrialID,REGEXP_REPLACE(nodeName || '\','(\\){2,}', '\'), jobID);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Fill in tree for Biomarker Data for trial',SQL%ROWCOUNT,stepCt,'Done');
  
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Biomarker level because there may be multiple platforms and patient count can vary
  
    i2b2_create_concept_counts(REGEXP_REPLACE(nodeName || '\','(\\){2,}', '\'),jobID );
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done');

  --Reload Security: Inserts one record for every I2B2 record into the security table

    i2b2_load_security_data(jobId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done');

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_protein_data',0,stepCt,'Done');
		
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION

  WHEN missing_GPL  then
	--	put message in log
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'One or more GPL platforms in de_subject_snp_dataset is not in de_gpl_info',0,stepCt,'Done');

    --End Proc
    cz_end_audit (jobID, 'FAIL');

  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL'); 

END;
 
$_$;


ALTER FUNCTION tm_cz.i2b2_add_snp_biomarker_nodes(trial_id character varying, ont_path character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_backout_trial(character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_backout_trial(trialid character varying, path_string character varying, currentjobid numeric) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, i2b2demodata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	rtnCd			integer;
	pExists			integer;
	sqlTxt			character varying;
	v_partition_id	text;
  
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
  
BEGIN
    
	stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2b2_back_out_trial';
	
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobId;
	END IF;
  
	--	delete all i2b2 nodes
	
	select tm_cz.i2b2_delete_all_nodes(path_string,jobId) into rtnCd;
	
/*
	--	delete any i2b2_tag data
	
	begin
	delete from i2b2metadata.i2b2_tags
	where path like path_string || '%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_tags',rowCt,stepCt,'Done') into rtnCd;
*/

	--	delete clinical data
	
	begin
	delete from tm_lz.lz_src_clinical_data
	where study_id = trialId;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from lz_src_clinical_data',rowCt,stepCt,'Done') into rtnCd;

	--	delete observation_fact SECURITY data, do before patient_dimension delete
	
	begin
	delete from i2b2demodata.observation_fact f
	where f.concept_cd = 'SECURITY'
	  and f.patient_num in
	     (select distinct p.patient_num from i2b2demodata.patient_dimension p
		  where p.sourcesystem_cd like trialId || ':%');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete SECURITY data for trial from I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--	delete patient data
	
	begin
	delete from i2b2demodata.patient_dimension
	where sourcesystem_cd like trialId || ':%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	begin
	delete from i2b2demodata.patient_trial
	where trial=  trialId;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',rowCt,stepCt,'Done') into rtnCd;

	--	delete gene expression data
	
	select count(*) into pExists
	from deapp.de_subject_sample_mapping
	where trial_name = TrialId
	  and platform = 'MRNA_AFFYMETRIX'
	  and trial_name = TrialId
	  and coalesce(omic_source_study,trial_name) = TrialId;

	if pExists > 0 then
		/*
		select distinct partition_id::text into v_partition_id
		from deapp.de_subject_sample_mapping
		where trial_name = TrialId
		  and platform = 'MRNA_AFFYMETRIX'
		  and coalesce(omic_source_study,trial_name) = TrialId;
		  
		sqlTxt := 'drop table deapp.de_subject_microarray_data_' || v_partition_id;
		execute sqlTxt;
		*/
		begin
		delete from deapp.de_subject_microarray_data 
		where trial_name = TrialID;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Drop partition table for de_subject_microarray_data',rowCt,stepCt,'Done') into rtnCd;
		
		begin
		delete from deapp.de_subject_sample_mapping
		where trial_name = TrialID
		  and platform = 'MRNA_AFFYMETRIX';
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
		
	end if;
	
      ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCD;
	END IF;

	return 1;
	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

  
END;

$$;


ALTER FUNCTION tm_cz.i2b2_backout_trial(trialid character varying, path_string character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_bulk_add_search_term(bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_bulk_add_search_term(currentjobid bigint DEFAULT NULL::bigint) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research null, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	--Audit variables
	newJobFlag integer(1);
	databaseName varchar(100);
	procedureName varchar(100);
	jobID bigint;
	stepCt bigint;

	v_keyword_term	varchar(500);
  v_display_category varchar(500);
  v_data_category varchar(500);
  v_prefix varchar(20);
  v_unique_ID varchar(500);
  v_source_cd varchar(500);
  v_parent_term varchar(500);
  v_bio_data_id bigint;
  
	sqlText			varchar(2000);
	Parent_Id 		integer;
	new_Term_Id 	integer;
	keyword_id 		integer;
	Lcount 			integer; 
	Ncount 			integer;
  
	--v_category_display	varchar2(200);

  	type keyword_rec  is record
	(keywordName		varchar(500)),
   dataCategory varchar(500),
   UIDPrefix varchar(20),
   uniqueID varchar(500),
   sourceCd varchar(500),
   parentTerm varchar(500),
   bio_data_id bigint
	);

	type keyword_table is table of keyword_rec; 
	keyword_array keyword_table;
	
  

BEGIN

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
    	
	--stepCt := 0;
  
	--cz_write_audit(jobId,databaseName,procedureName,'Start Procedure',SQL%ROWCOUNT,stepCt,'Done');
	--Stepct := Stepct + 1;	
  
	  select keyword, display_category, data_category, UID_prefix, unique_id, source_cd, parent_term, bio_data_id
    bulk collect into keyword_array
  	from tm_lz.lt_src_search_keyword
    where (keyword IS NOT NULL AND keyword::text <> '');

 
	for i in keyword_array.first .. keyword_array.last
	loop
		v_keyword_term := keyword_array(i).keywordName;
    v_display_category := keyword_array(i).displayCategory;
    v_data_category := keyword_array(i).dataCategory;
    v_prefix := keyword_array(i).UIDPrefix;
    v_unique_ID := keyword_array(i).uniqueID;
    v_source_cd := keyword_array(i).sourceCd;
    v_parent_term := keyword_array(i).parentTerm;
    v_bio_data_id := keyword_array(i).bio_data_id;
    
    --dbms_output.put_line('keyword: ' || v_keyword_term);


		if (coalesce(v_display_category::text, '') = '') then
			v_display_category := v_data_category;
    end if;


    if (coalesce(v_unique_ID::text, '') = '') then
      if ((v_prefix IS NOT NULL AND v_prefix::text <> '')) then
        v_unique_ID := v_prefix || ':' || v_data_category || ':' || v_keyword_term;
      end if;
    end if;
   

		-- Insert taxonomy term into searchapp.search_keyword
		-- (searches Search_Keyword with the parent term to find the category to use)
		Insert Into Searchapp.Search_Keyword 
		(Data_Category
		,Keyword
		,Unique_Id
		,Source_Code
		,Display_Data_Category
    ,Bio_data_id)
		PERFORM v_data_category
			  ,v_keyword_term
			  ,v_unique_ID
			  ,v_source_cd
			  ,v_display_category
        ,v_bio_data_id
		
		where not exists
			(select 1 from searchapp.search_keyword x
			 where upper(x.data_category) = upper(v_data_category)
			   and upper(x.keyword) = upper(v_keyword_term)
         and upper(x.bio_data_id) = upper(v_bio_data_id));
		Cz_Write_Audit(Jobid,Databasename,Procedurename,v_keyword_term || ' added to Searchapp.Search_Keyword',Sql%Rowcount,Stepct,'Done');
		Stepct := Stepct + 1;	
		commit;
  
		-- Get the ID of the new term in Search_Keyword
		Select Search_Keyword_Id  Into keyword_Id 
		From  Searchapp.Search_Keyword 
		Where Upper(Keyword) = Upper(v_keyword_term)
		and upper(data_category) = upper(v_data_category)
    and upper(bio_data_id) = upper(v_bio_data_id);
		Cz_Write_Audit(Jobid,Databasename,Procedurename,'New search keyword ID stored in Keyword_Id',Sql%Rowcount,Stepct,'Done');
		Stepct := Stepct + 1;	
		
		-- Insert the new term into Searchapp.Search_v_keyword_term 
		insert into searchapp.search_keyword_term 
		(keyword_term
		,search_keyword_id
		,rank
		,term_length)
		PERFORM UPPER(v_keyword_term)
			  ,Keyword_Id
			  ,1
			  ,Length(v_keyword_term) 
		
		where not exists
			(select 1 from searchapp.search_keyword_term x
			 where upper(x.keyword_term) = upper(v_keyword_term)
			   and x.search_keyword_id = Keyword_Id);
		Cz_Write_Audit(Jobid,Databasename,Procedurename,'Term added to Searchapp.Search_v_keyword_term',Sql%Rowcount,Stepct,'Done');
		Stepct := Stepct + 1;	
		commit;

	end loop;

	Cz_Write_Audit(Jobid,Databasename,Procedurename,'End '|| procedureName,0,Stepct,'Done');
	Stepct := Stepct + 1;  

 
     ---Cleanup OVERALL JOB if this proc is being run standalone    
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;
  
    EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
  
END;
 
$_$;


ALTER FUNCTION tm_cz.i2b2_bulk_add_search_term(currentjobid bigint) OWNER TO tm_cz;

--
-- Name: i2b2_create_concept_counts(character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_create_concept_counts(path character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2demodata, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;
  
BEGIN
     
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_CREATE_CONCEPT_COUNTS';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
	END IF;
    	
	stepCt := 0;
  
	begin
	delete from i2b2demodata.concept_counts
	where concept_path like path || '%' escape '`';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete counts for trial from I2B2DEMODATA concept_counts',rowCt,stepCt,'Done') into rtnCd;

	--	Join each node (folder or leaf) in the path to it's leaf in the work table to count patient numbers

	begin
	insert into i2b2demodata.concept_counts
	(concept_path
	,parent_concept_path
	,patient_count
	)
	select fa.c_fullname
		  ,ltrim(SUBSTR(fa.c_fullname, 1,instr(fa.c_fullname, '\',-1,2)))
		  ,count(distinct tpm.patient_num)
	from i2b2metadata.i2b2 fa
	    ,i2b2metadata.i2b2 la
		,i2b2demodata.observation_fact tpm
		,i2b2demodata.patient_dimension p
	where fa.c_fullname like path || '%' escape '`'
	  and substr(fa.c_visualattributes,2,1) != 'H'
	  and la.c_fullname like fa.c_fullname || '%' escape '`'
	  and la.c_visualattributes like 'L%'
	  and tpm.patient_num = p.patient_num
	  and la.c_basecode = tpm.concept_cd   -- outer join in oracle ???
	group by fa.c_fullname
			,ltrim(SUBSTR(fa.c_fullname, 1,instr(fa.c_fullname, '\',-1,2)));
	get diagnostics rowCt := ROW_COUNT;		
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert counts for trial into I2B2DEMODATA concept_counts',rowCt,stepCt,'Done') into rtnCd;
	
	--SET ANY NODE WITH MISSING OR ZERO COUNTS TO HIDDEN

	begin
	update i2b2metadata.i2b2
	set c_visualattributes = substr(c_visualattributes,1,1) || 'H' || substr(c_visualattributes,3,1)
	where c_fullname like path || '%' escape '`'
	  and (not exists
			 (select 1 from concept_counts nc
				  where c_fullname = nc.concept_path)
				 or
			 exists
				 (select 1 from concept_counts zc
				  where c_fullname = zc.concept_path
					and zc.patient_count = 0)
			  )
		and c_name != 'SECURITY';
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Nodes hidden with missing/zero counts for trial into I2B2DEMODATA concept_counts',rowCt,stepCt,'Done') into rtnCd;
		
	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_create_concept_counts(path character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_create_external_tables(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_create_external_tables(tpmextfn character varying, catgextfn character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE


sqltxt varchar(5000);


BEGIN

--  recreate CATEGORY_EXTRNL tabls with CATGExtFN parameter (filename in external file system)

sqltxt:='drop table i2b2_lz.category_extrnl';

  EXECUTE sqltxt;

sqltxt:='CREATE or REPLACE  TABLE "I2B2_LZ"."CATEGORY_EXTRNL"
   ( "STUDY_ID" varchar(100 BYTE),
	"CATEGORY_CD" varchar(100 BYTE),
	"CATEGORY_PATH" varchar(250 BYTE)
   )
   ORGANIZATION EXTERNAL
    ( TYPE ORACLE_LOADER
      DEFAULT DIRECTORY "BIOMART_LZ"
      ACCESS PARAMETERS
      ( records delimited by newline nologfile skip 1
        fields terminated by 0X"09"
        MISSING FIELD VALUES ARE NULL
            )
      LOCATION
       ( ' || '''' || CATGExtFn || '''' || '))';

   EXECUTE sqltxt;

--  recreate TIME_POINT_MEASUREMENT_EXTRNL tabls with TPMExtFN parameter (filename in external file system)

sqltxt:='drop table i2b2_lz.time_point_measurement_extrnl';

  EXECUTE sqltxt;

sqltxt:='    CREATE or REPLACE  TABLE "I2B2_LZ"."TIME_POINT_MEASUREMENT_EXTRNL"
   ("STUDY_ID" varchar(25 BYTE),
	"USUBJID" varchar(50 BYTE),
	"SITE_ID" varchar(10 BYTE),
	"SUBJECT_ID" varchar(10 BYTE),
	"VISIT_NAME" varchar(100 BYTE),
	"DATASET_NAME" varchar(500 BYTE),
	"SAMPLE_TYPE" varchar(100 BYTE),
	"DATA_LABEL" varchar(500 BYTE),
	"DATA_VALUE" varchar(500 BYTE),
	"CATEGORY_CD" varchar(100 BYTE),
	"PERIOD" varchar(100 BYTE)
   )
   ORGANIZATION EXTERNAL
    ( TYPE ORACLE_LOADER
      DEFAULT DIRECTORY "BIOMART_LZ"
      ACCESS PARAMETERS
      ( records delimited by newline nologfile skip 1
        fields terminated by 0X"09"
        MISSING FIELD VALUES ARE NULL
            )
      LOCATION ( ' || '''' || TPMExtFn || '''' ||  ') )';

    EXECUTE sqltxt;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_create_external_tables(tpmextfn character varying, catgextfn character varying) OWNER TO tm_cz;

--
-- Name: i2b2_create_security_for_trial(character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_create_security_for_trial(trial_id character varying, secured_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2demodata, i2b2metadata, searchapp, biomart, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;

	TrialID varchar(100);
	securedStudy varchar(5);
	pExists			integer;
	v_bio_experiment_id	numeric(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_CREATE_SECURITY_FOR_TRIAL';
	
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobId;
	END IF;

	stepCt := 0;
  
	begin
	delete from i2b2demodata.observation_fact
	where sourcesystem_cd = TrialID
	  and concept_cd = 'SECURITY';
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into i2b2demodata.observation_fact
    (encounter_num
        ,patient_num
	,concept_cd
        ,start_date
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select patient_num
                  ,patient_num
		  ,'SECURITY'
                  ,current_timestamp
		  ,'@'
		  ,TrialId
		  ,'T'
		  ,case when securedStudy = 'N' then 'EXP:PUBLIC' else 'EXP:' || trialID end
		  ,'@'
		  ,'@'
		  ,current_timestamp
		  ,current_timestamp
		  ,current_timestamp
		  --,sourcesystem_cd
		  ,TrialId
		  ,1
	from i2b2demodata.patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert patients to patient_trial table
	
	begin
	delete from i2b2demodata.patient_trial
	where trial  = TrialID;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   case when securedStudy = 'N' then 'EXP:PUBLIC' else 'EXP:' || trialID end
	from i2b2demodata.patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',rowCt,stepCt,'Done') into rtnCd;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
				begin
				insert into biomart.bio_experiment
				(title, accession, etl_id)
				select 'Metadata not available'
					  ,TrialId
					  ,'METADATA:' || TrialId;
				get diagnostics rowCt := ROW_COUNT;	
				exception
				when others then
					errorNumber := SQLSTATE;
					errorMessage := SQLERRM;
					--Handle errors.
					select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
					--End Proc
					select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
					return -16;	
				end;
				stepCt := stepCt + 1;
				select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',rowCt,stepCt,'Done') into rtnCd;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			begin
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			get diagnostics rowCt := ROW_COUNT;	
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',rowCt,stepCt,'Done') into rtnCd;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			begin
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			get diagnostics rowCt := ROW_COUNT;	
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',rowCt,stepCt,'Done') into rtnCd;
		end if;		
	end if;
     
 
    ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_create_security_for_trial(trial_id character varying, secured_study character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_create_stage_tables(bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_create_stage_tables(bigint) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	newJobFlag 	int4;
	databaseName 	varchar(100);
	procedureName varchar(100);
	jobID 		numeric(18,0);
	stepCt 		numeric(18,0);
	rowCount	numeric(18,0);
	rtnCd integer;
	--	Define the abstract result set record
	
	r_stage_table		record;
	r_stage_column		record;
	
	--	Variables

	tText 			varchar(2000);
	pExists			int4;
	release_table	varchar(50);
	v_sqlerrm		varchar(1000);
	
	
	BEGIN	
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := -1;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_CREATE_STAGE_TABLES';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		jobId := tm_cz.czx_start_audit (procedureName, databaseName);
	END IF;
    	
	stepCt := 0;	
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done')into rtnCd;
	
	for r_stage_table in
		select upper(table_owner) as table_owner
			  ,upper(table_name) as table_name
			  ,upper(study_specific) as study_specific
			  ,upper(stage_table_name) as stage_table_name
		from tm_cz.migrate_tables
	loop
		release_table := r_stage_table.stage_table_name;

		select count(*) into pExists
		from _v_table
		where schema = 'TM_STAGE'
		  and tablename = release_table;	
	  
		if pExists > 0 then
			tText := 'drop table tm_stage.' || release_table;
			execute immediate tText;
		end if;

		tText := 'create table tm_stage.' || release_table || ' (';
		
		for r_stage_column in
			select attname as column_name
				  ,format_type
			from _v_relation_column 
			where name=upper(r_stage_table.table_name)
			order by attnum asc
		loop
			tText := tText || r_stage_column.column_name || ' ' || r_stage_column.format_type || ',';	
		end loop;
		
		if r_stage_table.study_specific = 'Y' then
			tText := tText || 'release_study varchar(200))';
		else
			tText := trim(trailing ',' from tText) || ')';
		end if;
		execute immediate tText;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Created '|| release_table,0,stepCt,'Done')into rtnCd;
			
	end loop;
	
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End i2b2_create_release_tablese',0,stepCt,'Done')into rtnCd;
	stepCt := stepCt + 1;
	
	    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    select tm_cz.czx_end_audit (jobID, 'SUCCESS')into rtnCd;
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
	v_sqlerrm := substr(SQLERRM,1,1000);
	raise notice 'error: %', v_sqlerrm;
    --Handle errors.
    select tm_cz.czx_error_handler (jobID, procedureName,v_sqlerrm)into rtnCd;
    --End Proc
    select tm_cz.czx_end_audit (jobID, 'FAIL')into rtnCd;
	
END;
$$;


ALTER FUNCTION tm_cz.i2b2_create_stage_tables(bigint) OWNER TO tm_cz;

--
-- Name: i2b2_delete_1_node(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_delete_1_node(path character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2demodata, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;
	
BEGIN

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
	END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_delete_1_node: ' || path,0,stepCt,'Done') into rtnCd;
	
	if coalesce(path,'') = ''  or path = '%' 
	then 
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Path missing, no action taken',0,stepCt,'Done') into rtnCd;
		return 1;
	end if;
	
    --I2B2
	begin
    delete from i2b2demodata.observation_fact 
    where concept_cd in (select c_basecode from i2b2metadata.i2b2 where c_fullname = path);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;

      --CONCEPT DIMENSION
	begin
    delete from i2b2demodata.concept_dimension
    WHERE CONCEPT_PATH = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data from concept_dimension',rowCt,stepCt,'Done') into rtnCd;
    
    --I2B2
	begin
    delete from i2b2metadata.i2b2
    where c_fullname = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data from i2b2',rowCt,stepCt,'Done') into rtnCd;
	
	--i2b2_secure
	begin
    delete from i2b2metadata.i2b2_secure
    where c_fullname = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data from i2b2_secure',rowCt,stepCt,'Done') into rtnCd;

	--concept_counts
	begin
    delete from i2b2demodata.concept_counts
    where concept_path = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data from concept_counts',rowCt,stepCt,'Done') into rtnCd;
		
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_delete_1_node',rowCt,stepCt,'Done') into rtnCd;
	
	return 1;
  
END;

$$;


ALTER FUNCTION tm_cz.i2b2_delete_1_node(path character varying) OWNER TO tm_cz;

--
-- Name: i2b2_delete_all_nodes(character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_delete_all_nodes(path character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2demodata, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;

Begin

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	
	databaseName := 'TM_CZ';
	procedureName := 'I2B2_DELETE_ALL_NODES';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
	END IF;
 
	if path != ''  and path != '%'
	then 
		-- observation_fact
		begin
		DELETE FROM i2b2demodata.OBSERVATION_FACT 
		WHERE 
		concept_cd IN (SELECT C_BASECODE FROM i2b2metadata.I2B2 WHERE C_FULLNAME LIKE PATH || '%' escape '`');
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

		--CONCEPT DIMENSION
		begin
		DELETE FROM i2b2demodata.CONCEPT_DIMENSION
		WHERE CONCEPT_PATH LIKE path || '%' escape '`';
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCd;
    
		--I2B2
		begin
		DELETE FROM i2b2metadata.i2b2
		WHERE C_FULLNAME LIKE PATH || '%' escape '`';
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;
  
		--i2b2_secure
		begin
		DELETE FROM i2b2metadata.i2b2_secure
		WHERE C_FULLNAME LIKE PATH || '%' escape '`';
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_secure',rowCt,stepCt,'Done') into rtnCd;

		--concept_counts
		begin
		DELETE FROM i2b2demodata.concept_counts
		WHERE concept_path LIKE PATH || '%' escape '`';
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_counts',rowCt,stepCt,'Done') into rtnCd;
   
	end if;
	
	return 1;
END;

$$;


ALTER FUNCTION tm_cz.i2b2_delete_all_nodes(path character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_extend_clinical_data(character varying, character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_extend_clinical_data(trial_id character varying, top_node character varying, secure_study character varying DEFAULT 'N'::character varying, highlight_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
-- This function is very simular to "i2b2_load_clinical_data()" except that this
-- function doesnot delete existing clinical data in the tables.
-- With this function you can "extend" the already existing clinical data for a study.
-- Note: You can not modify already existing data in de database with this function
--       It probably a good idea to combine this function with "i2b2_load_clinical_data()"
--       and do some refactoring on the way.

Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	
	topNode			varchar(2000);
	topLevel		numeric(10,0);
	root_node		varchar(2000);
	root_level		integer;
	study_name		varchar(2000);
	TrialID			varchar(100);
	secureStudy		varchar(200);
	etlDate			timestamp;
	tPath			varchar(2000);
	pCount			integer;
	pExists			integer;
	rtnCode			integer;
	tText			varchar(2000);
  
	addNodes CURSOR is
	select DISTINCT leaf_node, node_name
	from  tm_wz.wt_trial_nodes a;
   
	--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

	delNodes CURSOR is
	select distinct c_fullname 
	from  i2b2metadata.i2b2
	where c_fullname like topNode || '%' escape '`'
      and substr(c_visualattributes,2,1) = 'H';
	  
	--	cursor to determine if any leaf nodes exist in i2b2 that are not used in this reload (node changes from text to numeric or numeric to text)
	  
	delUnusedLeaf cursor is
	select l.c_fullname
	from i2b2metadata.i2b2 l
	where l.c_visualattributes like 'L%'
	  and l.c_fullname like topNode || '%' escape '`'
	  and l.c_fullname not in
		 (select t.leaf_node 
		  from tm_wz.wt_trial_nodes t
		  union
		  select m.c_fullname
		  from deapp.de_subject_sample_mapping sm
			  ,i2b2metadata.i2b2 m
		  where sm.trial_name = TrialId
		    and sm.concept_code = m.c_basecode
			and m.c_visualattributes like 'L%');
BEGIN
  
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_CLINICAL_DATA';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
	END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	tText := 'Start i2b2_extend_clinical_data for ' || TrialId;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done') into rtnCd;
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\', 'g');
	
	--	figure out how many nodes (folders) are at study name and above
	--	\Public Studies\Clinical Studies\Pancreatic_Cancer_Smith_GSE22780\: topLevel = 4, so there are 3 nodes
	--	\Public Studies\GSE12345\: topLevel = 3, so there are 2 nodes
	
	select length(topNode)-length(replace(topNode,'\','')) into topLevel;
	
	if topLevel < 3 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Path specified in top_node must contain at least 2 nodes',0,stepCt,'Done') into rtnCd;	
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end if;	
	
	--	delete any existing data from lz_src_clinical_data and load new data
	begin
	delete from tm_lz.lz_src_clinical_data
	where study_id = TrialId;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from lz_src_clinical_data',rowCt,stepCt,'Done') into rtnCd;
	
	begin
	insert into tm_lz.lz_src_clinical_data
	(study_id
	,site_id
	,subject_id
	,visit_name
	,data_label
        ,modifier_cd
	,data_value
        ,units_cd
        ,date_timestamp
	,category_cd
	,etl_job_id
	,etl_date
	,ctrl_vocab_code)
	select study_id
		  ,site_id
		  ,subject_id
		  ,visit_name
		  ,data_label
                  ,modifier_cd
		  ,data_value
                  ,units_cd
                  ,date_timestamp
		  ,category_cd
		  ,jobId
		  ,etlDate
		  ,ctrl_vocab_code
	from tm_lz.lt_src_clinical_data;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert data into lz_src_clinical_data',rowCt,stepCt,'Done') into rtnCd;
		
	--	truncate tm_wz.wrk_clinical_data and load data from external file
	
	execute ('truncate table tm_wz.wrk_clinical_data');
	
	--	insert data from lt_src_clinical_data to tm_wz.wrk_clinical_data
	
	begin
	insert into tm_wz.wrk_clinical_data
	(study_id
	,site_id
	,subject_id
	,visit_name
	,data_label
        ,modifier_cd
	,data_value
        ,units_cd
        ,date_timestamp
	,category_cd
	,ctrl_vocab_code
	)
	select study_id
		  ,site_id
		  ,subject_id
		  ,visit_name
		  ,data_label
                  ,modifier_cd
		  ,data_value
                  ,units_cd
                  ,date_timestamp
		  ,category_cd
		  ,ctrl_vocab_code
	from tm_lz.lt_src_clinical_data;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Load lt_src_clinical_data to work table',rowCt,stepCt,'Done') into rtnCd;

	-- Get root_node from topNode
  
	select tm_cz.parse_nth_value(topNode, 2, '\') into root_node;
	
	select count(*) into pExists
	from i2b2metadata.table_access
	where c_name = root_node;
	
	select count(*) into pCount
	from i2b2metadata.i2b2
	where c_name = root_node;
	
	if pExists = 0 or pCount = 0 then
		select tm_cz.i2b2_add_root_node(root_node, jobId) into rtnCd;
	end if;
	
	select c_hlevel into root_level
	from i2b2metadata.table_access
	where c_name = root_node;
	
	-- Get study name from topNode
  
	select tm_cz.parse_nth_value(topNode, topLevel, '\') into study_name;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount;

	if pCount > 2 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Adding upper-level nodes',0,stepCt,'Done') into rtnCd;
		select tm_cz.i2b2_fill_in_tree(null, tPath, jobId) into rtnCd;
	end if;

	select count(*) into pExists
	from i2b2metadata.i2b2
	where c_fullname = topNode;
	
	--	add top node for study
	
	if pExists = 0 then
		select tm_cz.i2b2_add_node(TrialId, topNode, study_name, jobId) into rtnCd;
	end if;
  
	--	Set data_type, category_path, and usubjid 
  
	update tm_wz.wrk_clinical_data
	set data_type = 'T'
	   ,category_path = replace(replace(category_cd,'_',' '),'+','\')
	   ,usubjid = REGEXP_REPLACE(TrialID || ':' || coalesce(site_id,'') || ':' || subject_id,
                   '(::){1,}', ':', 'g'); 
	 get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set columns in tm_wz.wrk_clinical_data',rowCt,stepCt,'Done') into rtnCd;

	--	Delete rows where data_value is null
  
	begin
	delete from tm_wz.wrk_clinical_data
	where data_value is null;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete null data_values in tm_wz.wrk_clinical_data',rowCt,stepCt,'Done') into rtnCd;
	
	--Remove Invalid pipes in the data values.
	--RULE: If Pipe is last or first, delete it
	--If it is in the middle replace with a dash

	begin
	update tm_wz.wrk_clinical_data
	set data_value = replace(trim('|' from data_value), '|', '-')
	where data_value like '%|%';
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Remove pipes in data_value',rowCt,stepCt,'Done') into rtnCd;
 
	--Remove invalid Parens in the data
	--They have appeared as empty pairs or only single ones.
  
	begin
	update tm_wz.wrk_clinical_data
	set data_value = replace(data_value,'(', '')
	where data_value like '%()%'
	   or data_value like '%( )%'
	   or (data_value like '%(%' and data_value NOT like '%)%');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 1',rowCt,stepCt,'Done') into rtnCd;
	
	begin
	update tm_wz.wrk_clinical_data
	set data_value = replace(data_value,')', '')
	where data_value like '%()%'
	   or data_value like '%( )%'
	   or (data_value like '%)%' and data_value NOT like '%(%');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 2',rowCt,stepCt,'Done') into rtnCd;

	--Replace the Pipes with Commas in the data_label column
	begin
	update tm_wz.wrk_clinical_data
    set data_label = replace (data_label, '|', ',')
    where data_label like '%|%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Replace pipes with comma in data_label',rowCt,stepCt,'Done') into rtnCd;

	--	set visit_name to null when there's only a single visit_name for the catgory
	
	begin
	update tm_wz.wrk_clinical_data tpm
	set visit_name=null
	where (tpm.category_cd) in
		  (select x.category_cd
		   from tm_wz.wrk_clinical_data x
		   group by x.category_cd
		   having count(distinct upper(x.visit_name)) = 1);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set single visit_name to null',rowCt,stepCt,'Done') into rtnCd;
	
	--	set data_label to null when it duplicates the last part of the category_path
	--	Remove data_label from last part of category_path when they are the same

	begin
	update tm_wz.wrk_clinical_data tpm
	--set data_label = null
	set category_path=substr(tpm.category_path,1,tm_cz.instr(tpm.category_path,'\',-2,1)-1)
	   ,category_cd=substr(tpm.category_cd,1,tm_cz.instr(tpm.category_cd,'+',-2,1)-1)
	where (tpm.category_cd, tpm.data_label) in
		  (select distinct t.category_cd
				 ,t.data_label
		   from tm_wz.wrk_clinical_data t
		   where upper(substr(t.category_path,tm_cz.instr(t.category_path,'\',-1,1)+1,length(t.category_path)-tm_cz.instr(t.category_path,'\',-1,1))) 
			     = upper(t.data_label)
		     and t.data_label is not null)
	  and tpm.data_label is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set data_label to null when found in category_path',rowCt,stepCt,'Done') into rtnCd;

	--	set visit_name to null if same as data_label
	
	begin
	update tm_wz.wrk_clinical_data t
	set visit_name=null
	where (t.category_cd, t.visit_name, t.data_label) in
	      (select distinct tpm.category_cd
				 ,tpm.visit_name
				 ,tpm.data_label
		  from tm_wz.wrk_clinical_data tpm
		  where tpm.visit_name = tpm.data_label);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when found in data_label',rowCt,stepCt,'Done') into rtnCd;

	--	set visit_name to null if same as data_value
	
	begin
	update tm_wz.wrk_clinical_data t
	set visit_name=null
	where (t.category_cd, t.visit_name, t.data_value) in
	      (select distinct tpm.category_cd
				 ,tpm.visit_name
				 ,tpm.data_value
		  from tm_wz.wrk_clinical_data tpm
		  where tpm.visit_name = tpm.data_value);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when found in data_value',rowCt,stepCt,'Done') into rtnCd;

	--	set visit_name to null if only DATALABEL in category_cd
	
	begin
	update tm_wz.wrk_clinical_data t
	set visit_name=null
	where t.category_cd like '%DATALABEL%'
	  and t.category_cd not like '%VISITNAME%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when only DATALABE in category_cd',rowCt,stepCt,'Done') into rtnCd;
	
	--	change any % to Pct and & and + to ' and ' and _ to space in data_label only
	
	begin
	update tm_wz.wrk_clinical_data
	set data_label=replace(replace(replace(replace(data_label,'%',' Pct'),'&',' and '),'+',' and '),'_',' ')
	   ,data_value=replace(replace(replace(data_value,'%',' Pct'),'&',' and '),'+',' and ')
	   ,category_cd=replace(replace(category_cd,'%',' Pct'),'&',' and ')
	   ,category_path=replace(replace(category_path,'%',' Pct'),'&',' and ');
	   exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

  --Trim trailing and leadling spaces as well as remove any double spaces, remove space from before comma, remove trailing comma

	begin
	update tm_wz.wrk_clinical_data
	set data_label  = trim(trailing ',' from trim(replace(replace(data_label,'  ', ' '),' ,',','))),
		data_value  = trim(trailing ',' from trim(replace(replace(data_value,'  ', ' '),' ,',','))),
--		sample_type = trim(trailing ',' from trim(replace(replace(sample_type,'  ', ' '),' ,',','))),
		visit_name  = trim(trailing ',' from trim(replace(replace(visit_name,'  ', ' '),' ,',',')));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Remove leading, trailing, double spaces',rowCt,stepCt,'Done') into rtnCd;

    --1. DETERMINE THE DATA_TYPES OF THE FIELDS
	--	replaced cursor with update, used temp table to store category_cd/data_label because correlated subquery ran too long
	
	execute ('truncate table tm_wz.wt_num_data_types');

	begin
	insert into tm_wz.wt_num_data_types
	(category_cd
	,data_label
	,visit_name
	)
    select category_cd,
           data_label,
           visit_name
    from tm_wz.wrk_clinical_data
    where data_value is not null
    group by category_cd
	        ,data_label
            ,visit_name
      having sum(tm_cz.is_numeric(data_value)) = 0;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert numeric data into WZ wt_num_data_types',rowCt,stepCt,'Done') into rtnCd;

	--	Check if any duplicate records of key columns (site_id, subject_id, visit_name, data_label, category_cd) for numeric data
	--	exist.  Raise error if yes
	
	execute ('truncate table tm_wz.wt_clinical_data_dups');
	
	begin
	insert into tm_wz.wt_clinical_data_dups
	(site_id
	,subject_id
	,visit_name
	,data_label
	,category_cd
        ,modifier_cd)
	select w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd, w.modifier_cd
	from tm_wz.wrk_clinical_data w
	where exists
		 (select 1 from tm_wz.wt_num_data_types t
		 where coalesce(w.category_cd,'@') = coalesce(t.category_cd,'@')
		   and coalesce(w.data_label,'@') = coalesce(t.data_label,'@')
		   and coalesce(w.visit_name,'@') = coalesce(t.visit_name,'@')
		  )
	group by w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd, w.modifier_cd
	having count(*) > 1;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Check for duplicate key columns',rowCt,stepCt,'Done') into rtnCd;
			  
	if rowCt > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Duplicate values found in key columns',0,stepCt,'Done') into rtnCd;	
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end if;
	
	--	check for multiple visit_names for category_cd, data_label, data_value
	
     select max(case when x.null_ct > 0 and x.non_null_ct > 0
					 then 1 else 0 end) into pCount
      from (select category_cd, data_label, data_value
				  ,sum(case when visit_name is null then 1 else 0 end) as null_ct
				  ,sum(case when visit_name is null then 0 else 1 end) as non_null_ct
			from tm_lz.lt_src_clinical_data
			where (category_cd like '%VISITNAME%' or
				   category_cd not like '%DATALABEL%')
			group by category_cd, data_label, data_value) x;
	get diagnostics rowCt := ROW_COUNT;  
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Check for multiple visit_names for category/label/value ',rowCt,stepCt,'Done') into rtnCd;
			  
	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Multiple visit names for category/label/value',0,stepCt,'Done') into rtnCd;	
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end if;
		
	begin
	update tm_wz.wrk_clinical_data t
	set data_type='N'
	where exists
	     (select 1 from tm_wz.wt_num_data_types x
	      where coalesce(t.category_cd,'@') = coalesce(x.category_cd,'@')
			and coalesce(t.data_label,'**NULL**') = coalesce(x.data_label,'**NULL**')
			and coalesce(t.visit_name,'**NULL**') = coalesce(x.visit_name,'**NULL**')
		  );
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated data_type flag for numeric data_types',rowCt,stepCt,'Done') into rtnCd;

	-- Build all needed leaf nodes in one pass for both numeric and text nodes
 
	execute ('truncate table tm_wz.wt_trial_nodes');
	
	begin
	insert into tm_wz.wt_trial_nodes
	(leaf_node
	,category_cd
	,visit_name
	,data_label
	,data_value
	,data_type
	)
    select DISTINCT 
    Case 
	--	Text data_type (default node)
	When a.data_type = 'T'
	     then case when a.category_path like '%DATALABEL%' and a.category_path like '%VISITNAME%'
		      then regexp_replace(topNode || replace(replace(coalesce(a.category_path,''),'DATALABEL',coalesce(a.data_label,'')),'VISITNAME',coalesce(a.visit_name,'')) || '\' || coalesce(a.data_value,'') || '\','(\\){2,}', '\', 'g')
			  when a.category_path like '%DATALABEL%'
			  then regexp_replace(topNode || replace(coalesce(a.category_path,''),'DATALABEL',coalesce(a.data_label,'')) || '\' || coalesce(a.data_value,'') || '\','(\\){2,}', '\', 'g')
			  else REGEXP_REPLACE(topNode || coalesce(a.category_path,'') || 
                   '\'  || coalesce(a.data_label,'') || '\' || coalesce(a.data_value,'') || '\' || coalesce(a.visit_name,'') || '\',
                   '(\\){2,}', '\', 'g') 
			  end
	--	else is numeric data_type and default_node
	else case when a.category_path like '%DATALABEL%' and a.category_path like '%VISITNAME%'
		      then regexp_replace(topNode || replace(replace(coalesce(a.category_path,''),'DATALABEL',coalesce(a.data_label,'')),'VISITNAME',coalesce(a.visit_name,'')) || '\','(\\){2,}', '\', 'g')
			  when a.category_path like '%DATALABEL%'
			  then regexp_replace(topNode || replace(coalesce(a.category_path,''),'DATALABEL',coalesce(a.data_label,'')) || '\','(\\){2,}', '\', 'g')
			  else REGEXP_REPLACE(topNode || coalesce(a.category_path,'') || 
                   '\'  || coalesce(a.data_label,'') || '\' || coalesce(a.visit_name,'') || '\',
                   '(\\){2,}', '\', 'g')
			  end
	end as leaf_node,
    a.category_cd,
    a.visit_name,
	a.data_label,
	case when a.data_type = 'T' then a.data_value else null end as data_value
    ,a.data_type
	from  tm_wz.wrk_clinical_data a;
	get diagnostics rowCt := ROW_COUNT; 
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes for trial',rowCt,stepCt,'Done') into rtnCd;

	--	set node_name
	
	begin
	update tm_wz.wt_trial_nodes
	set node_name=tm_cz.parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT; 
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated node name for leaf nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert subjects into patient_dimension if needed
	
	execute ('truncate table tm_wz.wt_subject_info');

	begin
	insert into tm_wz.wt_subject_info
	(usubjid,
     age_in_years_num,
     sex_cd,
     race_cd
    )
	select a.usubjid,
	      coalesce(max(case when upper(a.data_label) = 'AGE'
					   then case when tm_cz.is_numeric(a.data_value) = 1 then 0 else a.data_value::integer end
		               when upper(a.data_label) like '%(AGE)' 
					   then case when tm_cz.is_numeric(a.data_value) = 1 then 0 else a.data_value::integer end
					   else null end),0) as age,
		  coalesce(max(case when upper(a.data_label) = 'SEX' then a.data_value
		           when upper(a.data_label) like '%(SEX)' then a.data_value
				   when upper(a.data_label) = 'GENDER' then a.data_value
				   else null end),'Unknown') as sex,
		  max(case when upper(a.data_label) = 'RACE' then a.data_value
		           when upper(a.data_label) like '%(RACE)' then a.data_value
				   else null end) as race
	from tm_wz.wrk_clinical_data a
	group by a.usubjid;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert subject information into temp table',rowCt,stepCt,'Done') into rtnCd;


        --  check if there are observation in the upload which already exist in database
        --         (is there already an observation for given patient and concept)


with maps as (select td.leaf_node, usubjid from tm_wz.wrk_clinical_data cd, tm_wz.wt_trial_nodes td where cd.data_label = td.data_label)
select count(*) into pExists from i2b2demodata.observation_fact of where (of.patient_num, of.concept_cd) IN
                           (select pd.patient_num, cd.concept_cd from i2b2demodata.patient_dimension pd 
                                                                      INNER JOIN maps on pd.sourcesystem_cd = maps.usubjid
                                                                      INNER JOIN i2b2demodata.concept_dimension cd on cd.concept_path = maps.leaf_node);

        if pExists > 0 then
                  stepCt := stepCt + 1;
                  select tm_cz.cz_write_audit(jobId,databaseName, procedureName,
				'You cannot overwrite existing observations when adding.', pExists, stepCt, 'Done') into rtnCd;    
                  select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
                  select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
                  return -16;     
        end if; 

	--  check if data to be added is of the same data-type (numeric/text) as possible already existing
        --  observations of the concept
	
	begin
		with exist_cc as (select distinct concept_cd, valtype_cd from i2b2demodata.observation_fact of
                  where of.concept_cd IN
                     (select cd.concept_cd from i2b2demodata.concept_dimension cd, tm_wz.wt_trial_nodes td
			where cd.concept_path = td.leaf_node))
                select count(*) into pCount from exist_cc, i2b2demodata.observation_fact of 
			where exist_cc.concept_cd = of.concept_cd 
				and exist_cc.valtype_cd != of.valtype_cd;
		if pCount > 0 then
                  stepCt := stepCt + 1;
                  select tm_cz.cz_write_audit(jobId,databaseName, procedureName,
				'You cannot upload different datatype for concept then already in database.', pCount, stepCt, 'Done') into rtnCd;    
                  select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
                  select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
                  return -16;     
 		end if;
	end;


	--	insert new subjects into patient_dimension
	
	begin
	insert into i2b2demodata.patient_dimension
    (patient_num,
     sex_cd,
     age_in_years_num,
     race_cd,
     update_date,
     download_date,
     import_date,
     sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num'),
		   t.sex_cd,
		   t.age_in_years_num,
		   t.race_cd,
		   current_timestamp,
		   current_timestamp,
		   current_timestamp,
		   t.usubjid
    from tm_wz.wt_subject_info t
	where t.usubjid in 
		 (select distinct cd.usubjid from tm_wz.wt_subject_info cd
		  except
		  select distinct pd.sourcesystem_cd from i2b2demodata.patient_dimension pd
		  where pd.sourcesystem_cd like TrialId || ':%');
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert new subjects into patient_dimension',rowCt,stepCt,'Done') into rtnCd;
		
	
	--	bulk insert leaf nodes
	begin
	with ncd as (select t.leaf_node, t.node_name from tm_wz.wt_trial_nodes t)
	update i2b2demodata.concept_dimension
	set name_char=ncd.node_name
	from ncd
	where concept_path = ncd.leaf_node;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update name_char in concept_dimension for changed names',rowCt,stepCt,'Done') into rtnCd;
	
	begin
	insert into i2b2demodata.concept_dimension
    (concept_cd
	,concept_path
	,name_char
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	)
    select nextval('i2b2demodata.concept_id')
	     ,x.leaf_node
		 ,x.node_name
		 ,current_timestamp
		 ,current_timestamp
		 ,current_timestamp
		 ,TrialId
	from (select distinct c.leaf_node
				,c.node_name::text as node_name
		  from tm_wz.wt_trial_nodes c
		  where not exists
			(select 1 from i2b2demodata.concept_dimension x
			where c.leaf_node = x.concept_path)
		 ) x;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted new leaf nodes into I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCd;
	
			   
	begin
	insert into i2b2metadata.i2b2
    (c_hlevel
	,c_fullname
	,c_name
	,c_visualattributes
	,c_synonym_cd
	,c_facttablecolumn
	,c_tablename
	,c_columnname
	,c_dimcode
	,c_tooltip
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,c_basecode
	,c_operator
	,c_columndatatype
	,c_comment
	,m_applied_path
	,c_metadataxml
	)
    select (length(c.concept_path) - coalesce(length(replace(c.concept_path, '\','')),0)) / length('\') - 2 + root_level
		  ,c.concept_path
		  ,c.name_char
		  ,'LA'
		  ,'N'
		  ,'CONCEPT_CD'
		  ,'CONCEPT_DIMENSION'
		  ,'CONCEPT_PATH'
		  ,c.concept_path
		  ,c.concept_path
		  ,current_timestamp
		  ,current_timestamp
		  ,current_timestamp
		  ,c.sourcesystem_cd
		  ,c.concept_cd
		  ,'LIKE'
		  ,'T'
		  ,'trial:' || TrialID 
		  ,'@'
		  ,case when t.data_type = 'T' then null
		   else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
		   end
    from i2b2demodata.concept_dimension c
		,tm_wz.wt_trial_nodes t
    where c.concept_path = t.leaf_node
	  and not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where c.concept_path = x.c_fullname);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted leaf nodes into I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

	
    --Insert into observation_fact
	
	begin
	insert into i2b2demodata.observation_fact
	(encounter_num,
     patient_num,
     concept_cd,
     start_date,
     modifier_cd,
     valtype_cd,
     tval_char,
     nval_num,
     units_cd,
     sourcesystem_cd,
     import_date,
     valueflag_cd,
     provider_id,
     location_cd,
     instance_num
	)
	select distinct c.patient_num,
		   c.patient_num,
		   i.c_basecode,
		   coalesce(a.date_timestamp, 'infinity'),
		   coalesce(a.modifier_cd, '@'),
		   a.data_type,
		   case when a.data_type = 'T' then a.data_value
				else 'E'  --Stands for Equals for numeric types
				end,
		   case when a.data_type = 'N' then a.data_value::numeric
				else null --Null for text types
				end,
                   a.units_cd,
		   a.study_id, 
		   current_timestamp, 
		   '@',
		   '@',
		   '@',
                   1
	from tm_wz.wrk_clinical_data a
		,i2b2demodata.patient_dimension c
		,tm_wz.wt_trial_nodes t
		,i2b2metadata.i2b2 i
	where a.usubjid = c.sourcesystem_cd
	  and coalesce(a.category_cd,'@') = coalesce(t.category_cd,'@')
	  and coalesce(a.data_label,'**NULL**') = coalesce(t.data_label,'**NULL**')
	  and coalesce(a.visit_name,'**NULL**') = coalesce(t.visit_name,'**NULL**')
	  and case when a.data_type = 'T' then a.data_value else '**NULL**' end = coalesce(t.data_value,'**NULL**')
	  and t.leaf_node = i.c_fullname
	  and not exists		-- don't insert if lower level node exists
		 (select 1 from tm_wz.wt_trial_nodes x
		  where x.leaf_node like t.leaf_node || '%_' escape '`')
	  and a.data_value is not null;
	get diagnostics rowCt := ROW_COUNT; 
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;


	-- final procs
  
	select tm_cz.i2b2_fill_in_tree(TrialId, topNode, jobID) into rtnCd;
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
		

	select tm_cz.i2b2_create_concept_counts(topNode, jobID) into rtnCd;
	
	--	delete each node that is hidden after create concept counts
	
	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		select tm_cz.i2b2_delete_1_node(r_delNodes.c_fullname) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;

	END LOOP;  	

	select tm_cz.i2b2_create_security_for_trial(TrialId, secureStudy, jobID) into rtnCd;
	select tm_cz.i2b2_load_security_data(jobID) into rtnCd;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_extend_clinical_data',0,stepCt,'Done') into rtnCd;
	
	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
/*	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
*/
END;

$$;


ALTER FUNCTION tm_cz.i2b2_extend_clinical_data(trial_id character varying, top_node character varying, secure_study character varying, highlight_study character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_fill_in_tree(character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_fill_in_tree(trial_id character varying, path character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2demodata, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;
	
    TrialID varchar(100);
	auditText varchar(4000);
	root_node varchar(1000);
	node_name varchar(1000);
	v_count numeric;
  
  --Get the nodes
  cNodes CURSOR for
    --Trimming off the last node as it would never need to be added.
    select distinct substr(c_fullname, 1,instr(c_fullname,'\',-2,1)) as c_fullname
    from i2b2metadata.i2b2 
    where c_fullname like path || '%' escape '`';

  
BEGIN
  TrialID := upper(trial_id);
  
    stepCt := 0;
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  databaseName := 'TM_CZ';
  procedureName := 'I2B2_FILL_IN_TREE';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
  END IF;
  
  --start node with the first slash

  --Iterate through each node
  FOR r_cNodes in cNodes Loop
    root_node := '\';
    --Determine how many nodes there are
    --Iterate through, Start with 2 as one will be null from the parser
    
    for loop_counter in 2 .. (length(r_cNodes.c_fullname) - coalesce(length(replace(r_cNodes.c_fullname, '\','')),0)) / length('\')
    LOOP
		--Determine Node:
		node_name := tm_cz.parse_nth_value(r_cNodes.c_fullname, loop_counter, '\');
		root_node :=  root_node || node_name || '\';
    
        --Check if node exists. If it does not, add it.
        select count(*) into v_count 
        from i2b2metadata.i2b2
        where c_fullname = root_node;

        --If it doesn't exist, add it
        if v_count = 0 then
			auditText := 'Inserting ' || root_node;
			stepCt := stepCt + 1;
			select tm_cz.cz_write_audit(jobId,databaseName,procedureName,auditText,0,stepCt,'Done') into rtnCD;
            select tm_cz.i2b2_add_node(trial_id, root_node, node_name, jobId) into rtnCd;
        end if;
      
    END LOOP;

    --RESET VARIABLES
    root_node := '';
    node_name := '';
  END LOOP;
  
      ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCD;
  END IF;
  
  return 1;

	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

  
END;

$$;


ALTER FUNCTION tm_cz.i2b2_fill_in_tree(trial_id character varying, path character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_hide_node(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_hide_node(path character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, i2b2demodata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;
	
begin

    stepCt := 0;
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'tm_cz';
	procedureName := 'i2b2_hide_node';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
	END IF;
	
	if path = ''  or path = '%' or path_name = ''
	then 
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Path or Path name missing, no action taken',0,stepCt,'Done') into rtnCd;
		return 1;
	end if;

	begin
	update i2b2metadata.i2b2 b
	set c_visualattributes=substr(b.c_visualattributes,1,1) || 'H' || substr(b.c_visualattributes,3,1)
	where c_fullname like path || '%' escape '`';
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Nodes hidden in i2b2metadata.i2b2',rowCt,stepCt,'Done') into rtnCd;

	
	begin
	delete from i2b2demodata.concept_counts
	where concept_path like path || '%' escape '`';
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Deleted hidden nodes from i2b2demodata.concept_counts',rowCt,stepCt,'Done') into rtnCd;

	--	reload i2b2_secure for hidden nodes
	
	select tm_cz.load_security_data(jobId) into rtnCd;
	
	return 1;
  
END;

$$;


ALTER FUNCTION tm_cz.i2b2_hide_node(path character varying) OWNER TO tm_cz;

--
-- Name: i2b2_link_additional_data(bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_link_additional_data(bigint) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER
    AS $_$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
	--	alias for parameters
	currentJobID alias for $1;
	
	pexists			INTEGER;
	subjCt			INTEGER;
	bslash			char(1);
	rtnCd	INTEGER;
	--Audit variables
	newJobFlag INTEGER;
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID numeric(18,0);
	stepCt numeric(18,0);
	rowCount	numeric(18,0);
	v_sqlerrm	varchar(1000);

BEGIN

	stepCt := 0;
	rowCount := 0;
	bslash := '\\';

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LINK_ADDITIONAL_DATA';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		jobId := tm_cz.czx_start_audit (procedureName, databaseName);
	END IF;

	stepCt := stepCt + 1;
	SELECT tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done')into rtnCd;
	
	select count(*) into pExists
	from (select t.platform, bcr.location
		  from tm_lz.lt_src_mrna_subj_samp_map t
		  left outer join biomart.bio_content_repository bcr
			   on  upper(t.platform) = upper(bcr.repository_type)
		  where bcr.location is null
		    and not exists
				(select 1 from deapp.de_gpl_info g
				 where t.platform = g.platform)) as samp;
		  
	if pExists > 0 then
		stepCt := stepCt + 1;
		SELECT tm_cz.czx_write_audit(jobId,databaseName,procedureName,'At least one platform in lt_src_mrna_subj_samp_map does not exist in bio_content_repository',0,stepCt,'Done')into rtnCd;
		return 16;
	end if;
	
	--	check to make sure subject map to patient_dimension
	
	select count(*) into subjCt
	from tm_lz.lt_src_mrna_subj_samp_map t
	where not exists
		 (select 1 from deapp.de_gpl_info g
		  where t.platform = g.platform);
	
	select count(*) into pExists
	from tm_lz.lt_src_mrna_subj_samp_map t
		,i2b2demodata.patient_dimension pd
	where REGEXP_REPLACE(t.trial_name || ':' || coalesce(t.site_id,'') || ':' || t.subject_id,
                   '(::){1,}', ':') = pd.sourcesystem_cd
	  and not exists
		 (select 1 from deapp.de_gpl_info g
		  where t.platform = g.platform);
	stepCt := stepCt + 1;
	SELECT tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Check patient mapping',SQL%ROWCOUNT,stepCt,'Done')into rtnCd;
	
	if pExists < subjCt then
		stepCt := stepCt + 1;
		SELECT tm_cz.czx_write_audit(jobId,databaseName,procedureName,'One or more subject in subject_sample map file are not mapped to patients',0,stepCt,'Done')into rtnCd;
		return 16;
	end if;

	--	insert additional data into bio_content
	
	insert into biomart.bio_content
	(file_name			-- filename value in sample_cd without extension
	,repository_id		-- bio_content_repo_id
	,location			-- study_id
	,title				-- null
	,abstract			-- null
	,file_type			-- 'Data'
	,etl_id				-- null
	,etl_id_c			-- study_id
	,study_name			-- study_id
	,cel_location		-- url for site, example http://157.206.120.144:7070/CEL/BSI201_20070102/
	,cel_file_suffix	-- filename extension (everything to right of first .)
	)
	select distinct substr(t.sample_cd,1,instr(t.sample_cd,'.')-1) as file_name
	,bc.bio_content_repo_id
	,t.trial_name as location
	,null as title
	,null as abstract
	,'Data' as file_type
	,null as etl_id
	,t.trial_name as etl_id_c
	,t.trial_name as study_name
	,bc.location || '/' || t.trial_name || '/' as cel_location
	,substr(t.sample_cd,instr(t.sample_cd,'.')) as cel_file_suffix
	from tm_lz.lt_src_mrna_subj_samp_map t
		,biomart.bio_content_repository bc
	where upper(bc.repository_type) = upper(t.platform)
	  --and t.platform not in (select distinct x.platform from de_gpl_info x)
	  and not exists
		 (select 1 from biomart.bio_content x
		  where substr(t.sample_cd,1,instr(t.sample_cd,'.')-1) = x.file_name
		    and bc.bio_content_repo_id = x.repository_id
			and t.trial_name = x.location
			and bc.location || '/' || t.trial_name = x.cel_location
			and substr(t.sample_cd,instr(t.sample_cd,'.')) = x.cel_file_suffix);
	stepCt := stepCt + 1;
	SELECT tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add additional data links to bio_content',SQL%ROWCOUNT,stepCt,'Done')into rtnCd;
			
	--	insert into bio_experiment if needed

	insert into biomart.bio_experiment
	(bio_experiment_type
	,title
	,etl_id
	,accession)
	select distinct 'Experiment'
	,'Metadata not available'
	,'METADATA:' || t.trial_name
	,t.trial_name
	from tm_lz.lt_src_mrna_subj_samp_map t
	where not exists 
		(select 1 from biomart.bio_experiment x
		 where t.trial_name = x.accession);
	stepCt := stepCt + 1;
	SELECT tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Added trial to bio_experiment if needed',SQL%ROWCOUNT,stepCt,'Done')into rtnCd;

	--	insert into bio_content_reference
	
	insert into biomart.bio_content_reference
	(bio_content_id
	,bio_data_id	
	,content_reference_type
	,etl_id
	,etl_id_c
	)
	select distinct bc.bio_file_content_id
	,be.bio_experiment_id
	,'Data'
	,null
	,'METADATA:' || sm.trial_name
	from tm_lz.lt_src_mrna_subj_samp_map sm
		,biomart.bio_content bc
		,biomart.bio_experiment be
	where sm.trial_name = bc.etl_id_c
	and sm.trial_name = be.accession
	and bc.file_type = 'Data'
	and not exists
	  (select 1 from biomart.bio_content_reference x
	   where x.bio_content_id = bc.bio_file_content_id
		 and x.bio_data_id = be.bio_experiment_id
		 and x.content_reference_type = 'Data');
	stepCt := stepCt + 1;
	SELECT tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Added data to bio_content_reference',SQL%ROWCOUNT,stepCt,'Done')into rtnCd;

	--	insert records into de_subject_sample_mapping with dummy concept codes (-1)

	insert into deapp.de_subject_sample_mapping
	select distinct pd.patient_num as patient_id
		  ,null as site_id
		  ,t.subject_id
		  ,null as subject_type
		  ,-1 as concept_cd
		  ,-1 as assay_id
		  ,null as patient_uid
		  ,null as sample_type
		  ,null as assay_uid
		  ,t.trial_name as trial_name
		  ,null as timepoint
		  ,-1 as timepoint_cd
		  ,-1 as sample_type_cd
		  ,-1 as tissue_type_cd
		  ,t.platform as platform
		  ,-1 as platform_cd
		  ,null as tissue_type
		  ,null as data_uid
		  ,null as gpl_id
		  ,null as rbm_panel
		  ,null as sample_id
		  ,substr(t.sample_cd,1,instr(t.sample_cd,'.')-1) as sample_cd
		  ,null as category_cd
		  ,'ADDL' as source_cd
		  ,t.trial_name as omic_source_study
		  ,pd.patient_num as omic_patient_num
	from tm_lz.lt_src_mrna_subj_samp_map t
		,i2b2demodata.patient_dimension pd
	where REGEXP_REPLACE(t.trial_name || ':' || coalesce(t.site_id,'') || ':' || t.subject_id,
                   '(::){1,}', ':') = pd.sourcesystem_cd
	  and not exists
		  (select 1 from deapp.de_gpl_info g
		   where t.platform = g.platform);
	pExists := SQL%ROWCOUNT;
	stepCt := stepCt + 1;
	SELECT tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert additional data records into de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done')into rtnCd;

	stepCt := stepCt + 1;
	SELECT tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done')into rtnCd;
	
       ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		SELECT tm_cz.czx_end_audit (jobID, 'SUCCESS')into rtnCd;
	END IF;

	return 0;
	
	EXCEPTION
	WHEN OTHERS THEN
		v_sqlerrm := substr(SQLERRM,1,1000);
		raise notice 'error: %', v_sqlerrm;
		--Handle errors.
		SELECT tm_cz.czx_error_handler (jobID, procedureName,v_sqlerrm)into rtnCd;
		-- End Proc
		SELECT tm_cz.czx_end_audit (jobID, 'FAIL')into rtnCd;
		return 16;

END;
$_$;


ALTER FUNCTION tm_cz.i2b2_link_additional_data(bigint) OWNER TO tm_cz;

--
-- Name: i2b2_load_annotation_deapp(numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_annotation_deapp(currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, deapp, biomart, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	
	gplId			character varying;

BEGIN

	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_ANNOTATION_DEAPP';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_annotation_deapp',0,stepCt,'Done') into rtnCd;

	--	get GPL id from external table
	
	select distinct gpl_id into gplId from tm_lz.lt_src_deapp_annot;
		
	--	delete any existing data from annotation_deapp
	
	begin
	delete from tm_cz.annotation_deapp
	where gpl_id = gplId;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from annotation_deapp',rowCt,stepCt,'Done') into rtnCd;

	--	delete any existing data from deapp.de_mrna_annotation
	
	begin
	delete from deapp.de_mrna_annotation
	where gpl_id = gplId;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;

	--	update organism for existing probesets in probeset_deapp
	
	begin
	with upd as (select distinct t.gpl_id, t.probe_id, t.organism from tm_lz.lt_src_deapp_annot t)
	update tm_cz.probeset_deapp
	set organism=upd.organism
	from upd
	where platform = upd.gpl_id
	  and probeset = upd.probe_id
	and exists
		 (select 1 from tm_lz.lt_src_deapp_annot x
		  where platform = x.gpl_id
		    and probeset = x.probe_id);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update organism in probeset_deapp',rowCt,stepCt,'Done') into rtnCd;
			
	--	insert any new probesets into probeset_deapp
	
	begin
	insert into tm_cz.probeset_deapp
	(probeset
	,organism
	,platform)
	select distinct probe_id
		  ,coalesce(organism,'Homo sapiens')
	      ,gpl_id
	from tm_lz.lt_src_deapp_annot t
	where not exists
		 (select 1 from tm_cz.probeset_deapp x
		  where t.gpl_id = x.platform
		    and t.probe_id = x.probeset
			and coalesce(t.organism,'Homo sapiens') = coalesce(x.organism,'Homo sapiens'));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert new probesets into probeset_deapp',rowCt,stepCt,'Done') into rtnCd;
		
	--	insert data into annotation_deapp
	
	begin
	insert into tm_cz.annotation_deapp
	(gpl_id
	,probe_id
	,gene_symbol
	,gene_id
	,probeset_id
	,organism)
	select distinct d.gpl_id
	,d.probe_id
	,d.gene_symbol
	,d.gene_id
	,p.probeset_id
	,coalesce(d.organism,'Homo sapiens')
	from tm_lz.lt_src_deapp_annot d
	,tm_cz.probeset_deapp p
	where d.probe_id = p.probeset
	  and d.gpl_id = p.platform
	  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into REFERENCE annotation_deapp',rowCt,stepCt,'Done') into rtnCd;
		
	--	insert data into deapp.de_mrna_annotation
	
	begin
	insert into deapp.de_mrna_annotation
	(gpl_id
	,probe_id
	,gene_symbol
	,gene_id
	,probeset_id
	,organism)
	select distinct d.gpl_id
	,d.probe_id
	,d.gene_symbol
	,case when d.gene_id is null then null else d.gene_id::numeric end as gene_id
	,p.probeset_id
	,coalesce(d.organism,'Homo sapiens')
	from tm_lz.lt_src_deapp_annot d
	,tm_cz.probeset_deapp p
	where d.probe_id = p.probeset
	  and d.gpl_id = p.platform
	  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens');
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;
		
	--	update gene_id if null
	
	begin
	with upd as (select b.bio_marker_name as gene_symbol, b.organism, min(b.primary_external_id::numeric) as gene_id 
				 from biomart.bio_marker b
				 where upper(b.bio_marker_type) = 'GENE'
				 group by b.bio_marker_name, b.organism)
	update deapp.de_mrna_annotation a
	set gene_id=upd.gene_id
	from upd
	where a.gpl_id = gplId
	  and a.gene_id is null
	  and a.gene_symbol is not null
	  and a.gene_symbol = upd.gene_symbol
	  and upper(a.organism) = upper(upd.organism)
	  and exists
		 (select 1 from biomart.bio_marker x
		  where a.gene_symbol = x.bio_marker_name
			and upper(x.organism) = upper(a.organism)
			and upper(x.bio_marker_type) = 'GENE');
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;		
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated missing gene_id in de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;
	
	--	update gene_symbol if null
	
	begin
	with upd as (select b.primary_external_id::numeric as gene_id, b.organism, min(b.bio_marker_name) as gene_symbol
				 from biomart.bio_marker b
				 where upper(b.bio_marker_type) = 'GENE'
				 group by b.primary_external_id, b.organism)
	update deapp.de_mrna_annotation a
	set gene_symbol=upd.gene_symbol
	from upd
	where a.gpl_id = gplId
	  and a.gene_symbol is null
	  and a.gene_id is not null
	  and a.gene_id = upd.gene_id
	  and a.organism = upd.organism
	  and exists
		 (select 1 from biomart.bio_marker x
		  where a.gene_id::varchar = x.primary_external_id
			and upper(x.organism) = upper(a.organism)
			and upper(x.bio_marker_type) = 'GENE');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;		
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated missing gene_id in de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert probesets into biomart.bio_assay_feature_group
	
	begin
	insert into biomart.bio_assay_feature_group
	(feature_group_name
	,feature_group_type)
	select distinct t.probeset, 'PROBESET'
	from tm_cz.probeset_deapp t
	where t.platform = gplId
	  and not exists
		 (select 1 from biomart.bio_assay_feature_group x
		  where t.probeset = x.feature_group_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert probesets into biomart.bio_assay_feature_group',rowCt,stepCt,'Done') into rtnCd;
		  
	--	insert probesets into biomart.bio_assay_data_annotation
	
	begin
	insert into biomart.bio_assay_data_annotation
	(bio_assay_feature_group_id
	,bio_marker_id)
	select distinct fg.bio_assay_feature_group_id
		  ,coalesce(bgs.bio_marker_id,bgi.bio_marker_id)
	from deapp.de_mrna_annotation t
	inner join biomart.bio_assay_feature_group fg
		  on  t.probe_id = fg.feature_group_name
	left outer join biomart.bio_marker bgs
		  on  t.gene_symbol = bgs.bio_marker_name
		  and upper(coalesce(t.organism,'Homo sapiens')) = upper(bgs.organism)
	left outer join biomart.bio_marker bgi
		  on   cast(t.gene_id AS varchar(200)) = bgi.primary_external_id
		  and upper(coalesce(t.organism,'Homo sapiens')) = upper(bgi.organism)
	where t.gpl_id = gplId
	  and (t.gene_symbol is not null or t.gene_id is not null)
	  and coalesce(bgs.bio_marker_id,bgi.bio_marker_id,-1) > 0
	  and not exists
		 (select 1 from biomart.bio_assay_data_annotation x
		  where fg.bio_assay_feature_group_id = x.bio_assay_feature_group_id
		    and coalesce(bgs.bio_marker_id,bgi.bio_marker_id,-1) = x.bio_marker_id);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert probesets/genes into biomart.bio_assay_data_annotation',rowCt,stepCt,'Done') into rtnCd;

	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_annotation_deapp',0,stepCt,'Done') into rtnCd;
	
       ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_load_annotation_deapp(currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_load_chrom_region(character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_chrom_region(platform_title character varying DEFAULT ''::character varying, genome_release character varying DEFAULT ''::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql
    SET search_path TO tm_cz, deapp
    AS $$

Declare
	--Audit variables
	newJobFlag		integer;
	databaseName 		VARCHAR(100);
	procedureName 		VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage		character varying;
	rtnCd			integer;

	gplId			character varying;
	organismId		character varying;
	sqlText			varchar(1000);

BEGIN
	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_CHROM_REGION';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a sinde_gle procedure run and we need to create it
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_chrom_region',0,stepCt,'Done') into rtnCd;

-- The data should already be in the landing zone (tm_lz.lt_chromosomal_region)


-- We now do some basic check's:
	-- + is chromosomal_region already in deapp.de_chromosomal_region (gpl_id/region_name)
	--   if true then remove these lines?
	-- + ...


-- insert region definitions into deapp-schema

	-- First remove previous definitions for gpl_id
	select distinct gpl_id INTO gplId FROM tm_lz.lt_chromosomal_region;

	begin
	delete from deapp.de_chromosomal_region
	where gpl_id = gplId;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from deapp.de_chromosomal_region for plaform: ' || gplId,rowCt,stepCt,'Done') into rtnCd;

	begin
	delete from deapp.de_gpl_info
	where platform = gplId;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from deapp.de_gpl_info for platform: ' || gplID,rowCt,stepCt,'Done') into rtnCd;


        -- Insert platform into deapp.de_gpl_info
	if (length(platform_title) = 0)
	then
		platform_title = gplId;
        end if;

	select distinct organism INTO organismId FROM tm_lz.lt_chromosomal_region;
	begin
	insert into deapp.de_gpl_info 
	(
		platform
		, title
		, organism
		, annotation_date
		, marker_type
                , release_nbr
	)
	values (gplId, platform_title, organismId, current_timestamp, 'Chromosomal', genome_release);
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Load platform info into deapp.de_gpl_info for platform: ' || gplID,rowCt,stepCt,'Done') into rtnCd;


	-- Next insert the new definitions
	BEGIN	
	insert into deapp.de_chromosomal_region 
  	(     GPL_ID
	    , REGION_NAME
	    , CHROMOSOME
	    , START_BP
	    , END_BP
	    , NUM_PROBES
	    , CYTOBAND
	    , GENE_SYMBOL
	    , GENE_ID
	    , ORGANISM
	)
	select    lz.GPL_ID
	        , lz.REGION_NAME
	    	, lz.CHROMOSOME
	    	, lz.START_BP
	    	, lz.END_BP
	    	, lz.NUM_PROBES
	    	, lz.CYTOBAND
	    	, lz.GENE_SYMBOL
	    	, lz.GENE_ID
	    	, lz.ORGANISM
	from tm_lz.lt_chromosomal_region lz;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Load chromosomal region data into deapp.de_chromosomal_region for platform: ' || gplId,rowCt,stepCt,'Done') into rtnCd;


--	update gene_id if null
	
	begin
	with upd as (select b.bio_marker_name as gene_symbol, b.organism, min(b.primary_external_id::numeric) as gene_id 
			 from biomart.bio_marker b
			 where upper(b.bio_marker_type) = 'GENE'
			 group by b.bio_marker_name, b.organism)
	update deapp.de_chromosomal_region a
	set gene_id=upd.gene_id
	from upd
	where a.gpl_id = gplId
	      and a.gene_id is null
	      and a.gene_symbol is not null
	      and a.gene_symbol = upd.gene_symbol
	      and upper(a.organism) = upper(upd.organism)
	      and exists
		 (select 1 from biomart.bio_marker x
		  where a.gene_symbol = x.bio_marker_name
			and upper(x.organism) = upper(a.organism)
			and upper(x.bio_marker_type) = 'GENE');
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;		
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated missing gene_id in de_chromosomal_region',rowCt,stepCt,'Done') into rtnCd;


	--	update gene_symbol if null
	
	begin
	with upd as (select b.primary_external_id::numeric as gene_id, b.organism, min(b.bio_marker_name) as gene_symbol
			 from biomart.bio_marker b
			 where upper(b.bio_marker_type) = 'GENE'
			 group by b.primary_external_id, b.organism)
	update deapp.de_chromosomal_region a
	set gene_symbol=upd.gene_symbol
	from upd
	where a.gpl_id = gplId
	      and a.gene_symbol is null
	      and a.gene_id is not null
	      and a.gene_id = upd.gene_id
	      and a.organism = upd.organism
	      and exists
		 (select 1 from biomart.bio_marker x
		  where a.gene_id::varchar = x.primary_external_id
			and upper(x.organism) = upper(a.organism)
			and upper(x.bio_marker_type) = 'GENE');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;		
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated missing gene_symbol in de_chromosomal_region',rowCt,stepCt,'Done') into rtnCd;


-- wrapping up
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_chrom_region',0,stepCt,'Done') into rtnCd;

       ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_load_chrom_region(platform_title character varying, genome_release character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_load_clinical_data(character varying, character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_clinical_data(trial_id character varying, top_node character varying, secure_study character varying DEFAULT 'N'::character varying, highlight_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	
	topNode			varchar(2000);
	topLevel		numeric(10,0);
	root_node		varchar(2000);
	root_level		integer;
	study_name		varchar(2000);
	TrialID			varchar(100);
	secureStudy		varchar(200);
	etlDate			timestamp;
	tPath			varchar(2000);
	pCount			integer;
	pExists			integer;
	rtnCode			integer;
	tText			varchar(2000);
  
	addNodes CURSOR is
	select DISTINCT leaf_node, node_name
	from  tm_wz.wt_trial_nodes a;
   
	--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

	delNodes CURSOR is
	select distinct c_fullname 
	from  i2b2metadata.i2b2
	where c_fullname like topNode || '%' escape '`'
      and substr(c_visualattributes,2,1) = 'H';
	  
	--	cursor to determine if any leaf nodes exist in i2b2 that are not used in this reload (node changes from text to numeric or numeric to text)
	  
	delUnusedLeaf cursor is
	select l.c_fullname
	from i2b2metadata.i2b2 l
	where l.c_visualattributes like 'L%'
	  and l.c_fullname like topNode || '%' escape '`'
	  and l.c_fullname not in
		 (select t.leaf_node 
		  from tm_wz.wt_trial_nodes t
		  union
		  select m.c_fullname
		  from deapp.de_subject_sample_mapping sm
			  ,i2b2metadata.i2b2 m
		  where sm.trial_name = TrialId
		    and sm.concept_code = m.c_basecode
			and m.c_visualattributes like 'L%');
BEGIN
  
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_CLINICAL_DATA';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
	END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	tText := 'Start i2b2_load_clinical_data for ' || TrialId;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done') into rtnCd;
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\', 'g');
	
	--	figure out how many nodes (folders) are at study name and above
	--	\Public Studies\Clinical Studies\Pancreatic_Cancer_Smith_GSE22780\: topLevel = 4, so there are 3 nodes
	--	\Public Studies\GSE12345\: topLevel = 3, so there are 2 nodes
	
	select length(topNode)-length(replace(topNode,'\','')) into topLevel;
	
	if topLevel < 3 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Path specified in top_node must contain at least 2 nodes',0,stepCt,'Done') into rtnCd;	
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end if;	
	
	--	delete any existing data from lz_src_clinical_data and load new data
	begin
	delete from tm_lz.lz_src_clinical_data
	where study_id = TrialId;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from lz_src_clinical_data',rowCt,stepCt,'Done') into rtnCd;
	
	begin
	insert into tm_lz.lz_src_clinical_data
	(study_id
	,site_id
	,subject_id
	,visit_name
	,data_label
	,data_value
	,category_cd
	,etl_job_id
	,etl_date
	,ctrl_vocab_code)
	select study_id
		  ,site_id
		  ,subject_id
		  ,visit_name
		  ,data_label
		  ,data_value
		  ,category_cd
		  ,jobId
		  ,etlDate
		  ,ctrl_vocab_code
	from tm_lz.lt_src_clinical_data;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert data into lz_src_clinical_data',rowCt,stepCt,'Done') into rtnCd;
		
	--	truncate tm_wz.wrk_clinical_data and load data from external file
	
	execute ('truncate table tm_wz.wrk_clinical_data');
	
	--	insert data from lt_src_clinical_data to tm_wz.wrk_clinical_data
	
	begin
	insert into tm_wz.wrk_clinical_data
	(study_id
	,site_id
	,subject_id
	,visit_name
	,data_label
	,data_value
	,category_cd
	,ctrl_vocab_code
	)
	select study_id
		  ,site_id
		  ,subject_id
		  ,visit_name
		  ,data_label
		  ,data_value
		  ,category_cd
		  ,ctrl_vocab_code
	from tm_lz.lt_src_clinical_data;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Load lt_src_clinical_data to work table',rowCt,stepCt,'Done') into rtnCd;

	-- Get root_node from topNode
  
	select tm_cz.parse_nth_value(topNode, 2, '\') into root_node;
	
	select count(*) into pExists
	from i2b2metadata.table_access
	where c_name = root_node;
	
	select count(*) into pCount
	from i2b2metadata.i2b2
	where c_name = root_node;
	
	if pExists = 0 or pCount = 0 then
		select tm_cz.i2b2_add_root_node(root_node, jobId) into rtnCd;
	end if;
	
	select c_hlevel into root_level
	from i2b2metadata.table_access
	where c_name = root_node;
	
	-- Get study name from topNode
  
	select tm_cz.parse_nth_value(topNode, topLevel, '\') into study_name;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount;

	if pCount > 2 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Adding upper-level nodes',0,stepCt,'Done') into rtnCd;
		select tm_cz.i2b2_fill_in_tree(null, tPath, jobId) into rtnCd;
	end if;

	select count(*) into pExists
	from i2b2metadata.i2b2
	where c_fullname = topNode;
	
	--	add top node for study
	
	if pExists = 0 then
		select tm_cz.i2b2_add_node(TrialId, topNode, study_name, jobId) into rtnCd;
	end if;
  
	--	Set data_type, category_path, and usubjid 
  
	update tm_wz.wrk_clinical_data
	set data_type = 'T'
	   ,category_path = replace(replace(category_cd,'_',' '),'+','\')
	   ,usubjid = REGEXP_REPLACE(TrialID || ':' || coalesce(site_id,'') || ':' || subject_id,
                   '(::){1,}', ':', 'g'); 
	 get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set columns in tm_wz.wrk_clinical_data',rowCt,stepCt,'Done') into rtnCd;

	--	Delete rows where data_value is null
  
	begin
	delete from tm_wz.wrk_clinical_data
	where data_value is null;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete null data_values in tm_wz.wrk_clinical_data',rowCt,stepCt,'Done') into rtnCd;
	
	--Remove Invalid pipes in the data values.
	--RULE: If Pipe is last or first, delete it
	--If it is in the middle replace with a dash

	begin
	update tm_wz.wrk_clinical_data
	set data_value = replace(trim('|' from data_value), '|', '-')
	where data_value like '%|%';
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Remove pipes in data_value',rowCt,stepCt,'Done') into rtnCd;
 
	--Remove invalid Parens in the data
	--They have appeared as empty pairs or only single ones.
  
	begin
	update tm_wz.wrk_clinical_data
	set data_value = replace(data_value,'(', '')
	where data_value like '%()%'
	   or data_value like '%( )%'
	   or (data_value like '%(%' and data_value NOT like '%)%');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 1',rowCt,stepCt,'Done') into rtnCd;
	
	begin
	update tm_wz.wrk_clinical_data
	set data_value = replace(data_value,')', '')
	where data_value like '%()%'
	   or data_value like '%( )%'
	   or (data_value like '%)%' and data_value NOT like '%(%');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 2',rowCt,stepCt,'Done') into rtnCd;

	--Replace the Pipes with Commas in the data_label column
	begin
	update tm_wz.wrk_clinical_data
    set data_label = replace (data_label, '|', ',')
    where data_label like '%|%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Replace pipes with comma in data_label',rowCt,stepCt,'Done') into rtnCd;

	--	set visit_name to null when there's only a single visit_name for the catgory
	
	begin
	update tm_wz.wrk_clinical_data tpm
	set visit_name=null
	where (tpm.category_cd) in
		  (select x.category_cd
		   from tm_wz.wrk_clinical_data x
		   group by x.category_cd
		   having count(distinct upper(x.visit_name)) = 1);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set single visit_name to null',rowCt,stepCt,'Done') into rtnCd;
	
	--	set data_label to null when it duplicates the last part of the category_path
	--	Remove data_label from last part of category_path when they are the same

	begin
	update tm_wz.wrk_clinical_data tpm
	--set data_label = null
	set category_path=substr(tpm.category_path,1,tm_cz.instr(tpm.category_path,'\',-2,1)-1)
	   ,category_cd=substr(tpm.category_cd,1,tm_cz.instr(tpm.category_cd,'+',-2,1)-1)
	where (tpm.category_cd, tpm.data_label) in
		  (select distinct t.category_cd
				 ,t.data_label
		   from tm_wz.wrk_clinical_data t
		   where upper(substr(t.category_path,tm_cz.instr(t.category_path,'\',-1,1)+1,length(t.category_path)-tm_cz.instr(t.category_path,'\',-1,1))) 
			     = upper(t.data_label)
		     and t.data_label is not null)
	  and tpm.data_label is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set data_label to null when found in category_path',rowCt,stepCt,'Done') into rtnCd;

	--	set visit_name to null if same as data_label
	
	begin
	update tm_wz.wrk_clinical_data t
	set visit_name=null
	where (t.category_cd, t.visit_name, t.data_label) in
	      (select distinct tpm.category_cd
				 ,tpm.visit_name
				 ,tpm.data_label
		  from tm_wz.wrk_clinical_data tpm
		  where tpm.visit_name = tpm.data_label);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when found in data_label',rowCt,stepCt,'Done') into rtnCd;

	--	set visit_name to null if same as data_value
	
	begin
	update tm_wz.wrk_clinical_data t
	set visit_name=null
	where (t.category_cd, t.visit_name, t.data_value) in
	      (select distinct tpm.category_cd
				 ,tpm.visit_name
				 ,tpm.data_value
		  from tm_wz.wrk_clinical_data tpm
		  where tpm.visit_name = tpm.data_value);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when found in data_value',rowCt,stepCt,'Done') into rtnCd;

	--	set visit_name to null if only DATALABEL in category_cd
	
	-- TR: disabled!!!!
	/*
	begin
	update tm_wz.wrk_clinical_data t
	set visit_name=null
	where t.category_cd like '%DATALABEL%'
	  and t.category_cd not like '%VISITNAME%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when only DATALABE in category_cd',rowCt,stepCt,'Done') into rtnCd; */
	
	--	change any % to Pct and & and + to ' and ' and _ to space in data_label only
	
	begin
	update tm_wz.wrk_clinical_data
	set data_label=replace(replace(replace(replace(data_label,'%',' Pct'),'&',' and '),'+',' and '),'_',' ')
	   ,data_value=replace(replace(replace(data_value,'%',' Pct'),'&',' and '),'+',' and ')
	   ,category_cd=replace(replace(category_cd,'%',' Pct'),'&',' and ')
	   ,category_path=replace(replace(category_path,'%',' Pct'),'&',' and ');
	   exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

  --Trim trailing and leadling spaces as well as remove any double spaces, remove space from before comma, remove trailing comma

	begin
	update tm_wz.wrk_clinical_data
	set data_label  = trim(trailing ',' from trim(replace(replace(data_label,'  ', ' '),' ,',','))),
		data_value  = trim(trailing ',' from trim(replace(replace(data_value,'  ', ' '),' ,',','))),
--		sample_type = trim(trailing ',' from trim(replace(replace(sample_type,'  ', ' '),' ,',','))),
		visit_name  = trim(trailing ',' from trim(replace(replace(visit_name,'  ', ' '),' ,',',')));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Remove leading, trailing, double spaces',rowCt,stepCt,'Done') into rtnCd;

    --1. DETERMINE THE DATA_TYPES OF THE FIELDS
	--	replaced cursor with update, used temp table to store category_cd/data_label because correlated subquery ran too long
	
	execute ('truncate table tm_wz.wt_num_data_types');

	begin
	insert into tm_wz.wt_num_data_types
	(category_cd
	,data_label
	,visit_name
	)
    select category_cd,
           data_label,
           visit_name
    from tm_wz.wrk_clinical_data
    where data_value is not null
    group by category_cd
	        ,data_label
            ,visit_name
      having sum(tm_cz.is_numeric(data_value)) = 0;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert numeric data into WZ wt_num_data_types',rowCt,stepCt,'Done') into rtnCd;

	--	Check if any duplicate records of key columns (site_id, subject_id, visit_name, data_label, category_cd) for numeric data
	--	exist.  Raise error if yes
	
	execute ('truncate table tm_wz.wt_clinical_data_dups');
	
	begin
	insert into tm_wz.wt_clinical_data_dups
	(site_id
	,subject_id
	,visit_name
	,data_label
	,category_cd)
	select w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd
	from tm_wz.wrk_clinical_data w
	where exists
		 (select 1 from tm_wz.wt_num_data_types t
		 where coalesce(w.category_cd,'@') = coalesce(t.category_cd,'@')
		   and coalesce(w.data_label,'@') = coalesce(t.data_label,'@')
		   and coalesce(w.visit_name,'@') = coalesce(t.visit_name,'@')
		  )
	group by w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd
	having count(*) > 1;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Check for duplicate key columns',rowCt,stepCt,'Done') into rtnCd;
			  
	if rowCt > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Duplicate values found in key columns',0,stepCt,'Done') into rtnCd;	
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end if;
	
	--	check for multiple visit_names for category_cd, data_label, data_value
	
     select max(case when x.null_ct > 0 and x.non_null_ct > 0
					 then 1 else 0 end) into pCount
      from (select category_cd, data_label, data_value
				  ,sum(case when visit_name is null then 1 else 0 end) as null_ct
				  ,sum(case when visit_name is null then 0 else 1 end) as non_null_ct
			from tm_lz.lt_src_clinical_data
			where (category_cd like '%VISITNAME%' or
				   category_cd not like '%DATALABEL%')
			group by category_cd, data_label, data_value) x;
	get diagnostics rowCt := ROW_COUNT;  
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Check for multiple visit_names for category/label/value ',rowCt,stepCt,'Done') into rtnCd;
			  
	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Multiple visit names for category/label/value',0,stepCt,'Done') into rtnCd;	
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end if;
		
	begin
	update tm_wz.wrk_clinical_data t
	set data_type='N'
	where exists
	     (select 1 from tm_wz.wt_num_data_types x
	      where coalesce(t.category_cd,'@') = coalesce(x.category_cd,'@')
			and coalesce(t.data_label,'**NULL**') = coalesce(x.data_label,'**NULL**')
			and coalesce(t.visit_name,'**NULL**') = coalesce(x.visit_name,'**NULL**')
		  );
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated data_type flag for numeric data_types',rowCt,stepCt,'Done') into rtnCd;

	-- Build all needed leaf nodes in one pass for both numeric and text nodes
 
	execute ('truncate table tm_wz.wt_trial_nodes');
	
	begin
	insert into tm_wz.wt_trial_nodes
	(leaf_node
	,category_cd
	,visit_name
	,data_label
	,data_value
	,data_type
	)
    select DISTINCT 
    Case 
	--	Text data_type (default node)
	When a.data_type = 'T'
	     then case 
		    when a.category_path like '%DATALABEL%' and a.category_path like '%DATAVALUE%' and a.category_path like '%VISITNAME%'
				then regexp_replace(topNode || replace(replace(replace(coalesce(a.category_path, ''),'DATALABEL',coalesce(a.data_label, '')),'VISITNAME',coalesce(a.visit_name, '')), 'DATAVALUE',coalesce(a.data_value, ''))  || '\','(\\){2,}', '\')
		 	when a.category_path like '%DATALABEL%' and a.category_path like '%VISITNAME%'
				then regexp_replace(topNode || replace(replace(coalesce(a.category_path, ''),'DATALABEL',coalesce(a.data_label, '')),'VISITNAME',coalesce(a.visit_name, '')) || '\' || coalesce(a.data_value, '') || '\','(\\){2,}', '\')
			when a.CATEGORY_PATH like '%DATALABEL%'
				then case
				when a.category_path like '%\VISITNFST' -- TR: support visit first
					then regexp_replace(topNode || replace(replace(coalesce(a.category_path, ''),'\VISITNFST', ''), 'DATALABEL',coalesce(a.data_label, '')) || '\' || coalesce(a.visit_name, '') || '\' || coalesce(a.data_value, '') || '\', '(\\){2,}', '\') 
					else regexp_replace(topNode || replace(coalesce(a.category_path, ''), 'DATALABEL',coalesce(a.data_label, '')) || '\' || coalesce(a.data_value, '') || '\' || coalesce(a.visit_name, '') || '\', '(\\){2,}', '\')
				end
			ELSE case
			when a.category_path like '%\VISITNFST' -- TR: support visit first
				then REGEXP_REPLACE(TOPNODE || replace(coalesce(a.category_path, ''),'\VISITNFST', '') || '\'  || coalesce(a.data_label, '') || '\' || coalesce(a.visit_name, '') || '\' || coalesce(a.data_value, '') || '\', '(\\){2,}', '\')
				else REGEXP_REPLACE(TOPNODE || coalesce(a.category_path, '') || '\'  || coalesce(a.DATA_LABEL, '') || '\' || coalesce(a.DATA_VALUE, '') || '\' || coalesce(a.VISIT_NAME, '') || '\', '(\\){2,}', '\')
			end
	end
	--	else is numeric data_type and default_node
	else case when a.category_path like '%DATALABEL%' and a.category_path like '%VISITNAME%'
		      then regexp_replace(topNode || replace(replace(replace(coalesce(a.category_path, ''),'DATALABEL',coalesce(a.data_label, '')),'VISITNAME',coalesce(a.visit_name, '')), '\VISITNFST', '') || '\','(\\){2,}', '\')
			  when a.CATEGORY_PATH like '%DATALABEL%'
			  then regexp_replace(topNode || replace(replace(coalesce(a.category_path, ''),'DATALABEL',coalesce(a.data_label, '')), '\VISITNFST', '') || '\' || coalesce(a.visit_name, '') || '\', '(\\){2,}', '\')
			  else REGEXP_REPLACE(topNode || replace(coalesce(a.category_path, ''), '\VISITNFST', '') || 
                   '\'  || coalesce(a.data_label, '') || '\' || coalesce(a.visit_name, '') || '\',
                   '(\\){2,}', '\')
			  end
	end as leaf_node,
    a.category_cd,
    a.visit_name,
	a.data_label,
	case when a.data_type = 'T' then a.data_value else null end as data_value
    ,a.data_type
	from  tm_wz.wrk_clinical_data a;
	get diagnostics rowCt := ROW_COUNT; 
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes for trial',rowCt,stepCt,'Done') into rtnCd;

	--	set node_name
	
	begin
	update tm_wz.wt_trial_nodes
	set node_name=tm_cz.parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT; 
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated node name for leaf nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert subjects into patient_dimension if needed
	
	execute ('truncate table tm_wz.wt_subject_info');

	begin
	insert into tm_wz.wt_subject_info
	(usubjid,
     age_in_years_num,
     sex_cd,
     race_cd
    )
	select a.usubjid,
	      coalesce(max(case when upper(a.data_label) = 'AGE'
					   then case when tm_cz.is_numeric(a.data_value) = 1 then 0 else a.data_value::integer end
		               when upper(a.data_label) like '%(AGE)' 
					   then case when tm_cz.is_numeric(a.data_value) = 1 then 0 else a.data_value::integer end
					   else null end),0) as age,
		  coalesce(max(case when upper(a.data_label) = 'SEX' then a.data_value
		           when upper(a.data_label) like '%(SEX)' then a.data_value
				   when upper(a.data_label) = 'GENDER' then a.data_value
				   else null end),'Unknown') as sex,
		  max(case when upper(a.data_label) = 'RACE' then a.data_value
		           when upper(a.data_label) like '%(RACE)' then a.data_value
				   else null end) as race
	from tm_wz.wrk_clinical_data a
	group by a.usubjid;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert subject information into temp table',rowCt,stepCt,'Done') into rtnCd;

	--	Delete dropped subjects from patient_dimension if they do not exist in de_subject_sample_mapping
	
	begin
	delete from i2b2demodata.patient_dimension
	where sourcesystem_cd in
		 (select distinct pd.sourcesystem_cd from i2b2demodata.patient_dimension pd
		  where pd.sourcesystem_cd like TrialId || ':%'
		  except 
		  select distinct cd.usubjid from tm_wz.wrk_clinical_data cd)
	  and patient_num not in
		  (select distinct sm.patient_id from deapp.de_subject_sample_mapping sm);
	get diagnostics rowCt := ROW_COUNT;		 
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete dropped subjects from patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	update patients with changed information
	begin
	with nsi as (select t.usubjid, t.sex_cd, t.age_in_years_num, t.race_cd from tm_wz.wt_subject_info t) 
	update i2b2demodata.patient_dimension
	set sex_cd=nsi.sex_cd
	   ,age_in_years_num=nsi.age_in_years_num
	   ,race_cd=nsi.race_cd
	   from nsi
	where sourcesystem_cd = nsi.usubjid;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update subjects with changed demographics in patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	insert new subjects into patient_dimension
	
	begin
	insert into i2b2demodata.patient_dimension
    (patient_num,
     sex_cd,
     age_in_years_num,
     race_cd,
     update_date,
     download_date,
     import_date,
     sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num'),
		   t.sex_cd,
		   t.age_in_years_num,
		   t.race_cd,
		   current_timestamp,
		   current_timestamp,
		   current_timestamp,
		   t.usubjid
    from tm_wz.wt_subject_info t
	where t.usubjid in 
		 (select distinct cd.usubjid from tm_wz.wt_subject_info cd
		  except
		  select distinct pd.sourcesystem_cd from i2b2demodata.patient_dimension pd
		  where pd.sourcesystem_cd like TrialId || ':%');
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert new subjects into patient_dimension',rowCt,stepCt,'Done') into rtnCd;
		
	--	delete leaf nodes that will not be reused, if any
	
	 FOR r_delUnusedLeaf in delUnusedLeaf Loop

    --	deletes unused leaf nodes for a trial one at a time

		select tm_cz.i2b2_delete_1_node(r_delUnusedLeaf.c_fullname) into rtnCd;
		stepCt := stepCt + 1;	
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Deleted unused leaf node: ' || r_delUnusedLeaf.c_fullname,1,stepCt,'Done') into rtnCd;

	END LOOP;	
	
	--	bulk insert leaf nodes
	begin
	with ncd as (select t.leaf_node, t.node_name from tm_wz.wt_trial_nodes t)
	update i2b2demodata.concept_dimension
	set name_char=ncd.node_name
	from ncd
	where concept_path = ncd.leaf_node;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update name_char in concept_dimension for changed names',rowCt,stepCt,'Done') into rtnCd;
	
	begin
	insert into i2b2demodata.concept_dimension
    (concept_cd
	,concept_path
	,name_char
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	)
    select nextval('i2b2demodata.concept_id')
	     ,x.leaf_node
		 ,x.node_name
		 ,current_timestamp
		 ,current_timestamp
		 ,current_timestamp
		 ,TrialId
	from (select distinct c.leaf_node
				,c.node_name::text as node_name
		  from tm_wz.wt_trial_nodes c
		  where not exists
			(select 1 from i2b2demodata.concept_dimension x
			where c.leaf_node = x.concept_path)
		 ) x;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted new leaf nodes into I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCd;
	
	--	update i2b2 with name, data_type and xml for leaf nodes
	begin
	with ncd as (select t.leaf_node, t.node_name, t.data_type from tm_wz.wt_trial_nodes t)
	update i2b2metadata.i2b2
	set c_name=ncd.node_name
	   ,c_columndatatype=ncd.data_type
	   ,c_metadataxml=case when ncd.data_type = 'T'
					  then null
					  else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
					  end
	from ncd
	where c_fullname = ncd.leaf_node;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated name and data type in i2b2 if changed',rowCt,stepCt,'Done') into rtnCd;
			   
	begin
	insert into i2b2metadata.i2b2
    (c_hlevel
	,c_fullname
	,c_name
	,c_visualattributes
	,c_synonym_cd
	,c_facttablecolumn
	,c_tablename
	,c_columnname
	,c_dimcode
	,c_tooltip
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,c_basecode
	,c_operator
	,c_columndatatype
	,c_comment
	,m_applied_path
	,c_metadataxml
	)
    select (length(c.concept_path) - coalesce(length(replace(c.concept_path, '\','')),0)) / length('\') - 2 + root_level
		  ,c.concept_path
		  ,c.name_char
		  ,'LA'
		  ,'N'
		  ,'CONCEPT_CD'
		  ,'CONCEPT_DIMENSION'
		  ,'CONCEPT_PATH'
		  ,c.concept_path
		  ,c.concept_path
		  ,current_timestamp
		  ,current_timestamp
		  ,current_timestamp
		  ,c.sourcesystem_cd
		  ,c.concept_cd
		  ,'LIKE'	--'T'
		  , 'T' --t.data_type
		  ,'trial:' || TrialID 
		  ,'@'
		  ,case when t.data_type = 'T' then null
		   else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
		   end
    from i2b2demodata.concept_dimension c
		,tm_wz.wt_trial_nodes t
    where c.concept_path = t.leaf_node
	  and not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where c.concept_path = x.c_fullname);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted leaf nodes into I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

	--	delete from observation_fact all concept_cds for trial that are clinical data, exclude concept_cds from biomarker data
	
	begin
	delete from i2b2demodata.observation_fact f
	where f.modifier_cd = TrialId
	  and f.concept_cd not in
		 (select distinct concept_code as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and concept_code is not null
		  union
		  select distinct platform_cd as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and platform_cd is not null
		  union
		  select distinct sample_type_cd as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and sample_type_cd is not null
		  union
		  select distinct tissue_type_cd as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and tissue_type_cd is not null
		  union
		  select distinct timepoint_cd as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and timepoint_cd is not null
		  union
		  select distinct concept_cd as concept_cd from deapp.de_subject_snp_dataset
		  where trial_name = TrialId
		    and concept_cd is not null);
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete clinical data for study from observation_fact',rowCt,stepCt,'Done') into rtnCd;	  
	
    --Insert into observation_fact
	
	begin
	insert into i2b2demodata.observation_fact
	(encounter_num,
     patient_num,
     concept_cd,
     start_date,
     modifier_cd,
     valtype_cd,
     tval_char,
     nval_num,
     sourcesystem_cd,
     import_date,
     valueflag_cd,
     provider_id,
     location_cd,
     instance_num
	)
	select distinct c.patient_num,
		   c.patient_num,
		   i.c_basecode,
		   current_timestamp,
		   a.study_id,
		   a.data_type,
		   case when a.data_type = 'T' then a.data_value
				else 'E'  --Stands for Equals for numeric types
				end,
		   case when a.data_type = 'N' then a.data_value::numeric
				else null --Null for text types
				end,
		   a.study_id, 
		   current_timestamp, 
		   '@',
		   '@',
		   '@',
                   0
	from tm_wz.wrk_clinical_data a
		,i2b2demodata.patient_dimension c
		,tm_wz.wt_trial_nodes t
		,i2b2metadata.i2b2 i
	where a.usubjid = c.sourcesystem_cd
	  and coalesce(a.category_cd,'@') = coalesce(t.category_cd,'@')
	  and coalesce(a.data_label,'**NULL**') = coalesce(t.data_label,'**NULL**')
	  and coalesce(a.visit_name,'**NULL**') = coalesce(t.visit_name,'**NULL**')
	  and case when a.data_type = 'T' then a.data_value else '**NULL**' end = coalesce(t.data_value,'**NULL**')
	  and t.leaf_node = i.c_fullname
	  and not exists		-- don't insert if lower level node exists
		 (select 1 from tm_wz.wt_trial_nodes x
		  where x.leaf_node like t.leaf_node || '%_' escape '`')
	  and a.data_value is not null;
	get diagnostics rowCt := ROW_COUNT; 
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--	update c_visualattributes for all nodes in study, done to pick up node that changed c_columndatatype
	
	begin
	with upd as (select p.c_fullname, count(*) as nbr_children 
				 from i2b2metadata.i2b2 p
					 ,i2b2metadata.i2b2 c
				 where p.c_fullname like topNode || '%' escape '`'
				   and c.c_fullname like p.c_fullname || '%' escape '`'
				 group by p.c_fullname)
	update i2b2metadata.i2b2 b
	set c_visualattributes=case when upd.nbr_children = 1 
								then 'L' || substr(b.c_visualattributes,2,2)
								else 'F' || substr(b.c_visualattributes,2,1) ||
									case when upd.c_fullname = topNode and highlight_study = 'Y'
										 then 'J' else substr(b.c_visualattributes,3,1) end
								end
		,c_columndatatype=case when upd.nbr_children > 1 then 'T' else b.c_columndatatype end
	from upd
	where b.c_fullname = upd.c_fullname
	  and b.c_fullname in
		 (select x.c_fullname from i2b2 x
		  where x.c_fullname like topNode || '%' escape '`');
  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set c_visualattributes in i2b2',rowCt,stepCt,'Done') into rtnCd;

	-- final procs
  
	select tm_cz.i2b2_fill_in_tree(TrialId, topNode, jobID) into rtnCd;
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
		
	begin
	update i2b2metadata.i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	get diagnostics rowCt := ROW_COUNT;	  
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper-level nodes',rowCt,stepCt,'Done') into rtnCd;

	select tm_cz.i2b2_create_concept_counts(topNode, jobID) into rtnCd;
	
	--	delete each node that is hidden after create concept counts
	
	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		select tm_cz.i2b2_delete_1_node(r_delNodes.c_fullname) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;

	END LOOP;  	

	select tm_cz.i2b2_create_security_for_trial(TrialId, secureStudy, jobID) into rtnCd;
	select tm_cz.i2b2_load_security_data(jobID) into rtnCd;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_clinical_data',0,stepCt,'Done') into rtnCd;
	
	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
/*	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
*/
END;

$$;


ALTER FUNCTION tm_cz.i2b2_load_clinical_data(trial_id character varying, top_node character varying, secure_study character varying, highlight_study character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_load_eqtl_top50(numeric, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_eqtl_top50(i_bio_assay_analysis_id numeric, currentjobid numeric DEFAULT 0) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	newJobFlag integer;
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID numeric(18,0);
	stepCt numeric(18,0);
	rowCt		numeric(18,0);
	tExists		integer;
	v_sqlerrm		varchar(1000);
	rtnCd		integer;
	errorNumber		character varying;
	errorMessage	character varying;
	
begin

	stepCt := 0;
	rowCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_EQTL_TOP50';
	
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobId;
	END IF;
	
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Start ' || procedureName,0,stepCt,'Done') into rtnCd;
	
	begin
	delete from biomart.bio_asy_analysis_eqtl_top50
	where bio_assay_analysis_id = i_bio_assay_analysis_id;
	get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete analysis from bio_asy_analysis_eqtl_top50',rowCt,stepCt,'Done') into rtnCd;
	
	begin
	insert into biomart.bio_asy_analysis_eqtl_top50
	(bio_assay_analysis_id
	,analysis
	,chrom
	,pos
	,rsgene
	,rsid
	,pvalue
	,logpvalue
	,extdata
	,rnum
	)
	select a.*
	from (select eqtl.bio_assay_analysis_id
				,baa.analysis_name as analysis
				,info.chrom as chrom
				,info.pos as pos
				,info.gene_name as rsgene
				,eqtl.rs_id as rsid
				,eqtl.p_value as pvalue
				,eqtl.log_p_value as logpvalue
				,eqtl.ext_data as extdata
				,row_number () over (order by eqtl.p_value asc, eqtl.rs_id asc) as rnum
		  from biomart.bio_assay_analysis_eqtl eqtl 
		  inner join biomart.bio_assay_analysis baa 
				on  baa.bio_assay_analysis_id = eqtl.bio_assay_analysis_id
		  inner join deapp.de_rc_snp_info info 
				on  eqtl.rs_id = info.rs_id 
				and hg_version='19'
		  where eqtl.bio_assay_analysis_id = i_bio_assay_analysis_id) a
	where a.rnum <= 500;
	get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert into bio_asy_analysis_eqtl_top50',rowCt,stepCt,'Done') into rtnCd;
	
      ---Cleanup OVERALL JOB if this proc is being run standalone
	if newjobflag = 1
	then
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	end if;
	
	return 0;

END;
$$;


ALTER FUNCTION tm_cz.i2b2_load_eqtl_top50(i_bio_assay_analysis_id numeric, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_load_from_stage(character varying, character varying, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_from_stage(character varying, character varying, bigint) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER
    AS $_$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--	Alias for parameters
	
	trial_id  alias for $1;
	data_type alias for $2;
	currentJobID alias for $3;
	rtnCd integer;
	TrialId 		varchar(200);
	msgText			varchar(2000);
	dataType		varchar(50);

	tText			varchar(2000);
	tExists 		integer;
	source_table	varchar(50);
	release_table	varchar(50);
	tableOwner		varchar(50);
	tableName		varchar(50);
	vSNP 			integer;
	topNode			varchar(1000);
	rootNode		varchar(1000);
	tPath			varchar(1000);
	pExists			integer;
	pCount			integer;
	rowCt			bigint;
	bslash			char(1);

	--Audit variables
	newJobFlag integer;
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID numeric(18,0);
	stepCt numeric(18,0);
	v_sqlerrm		varchar(1000);
  
	r_stage_table	record;
	r_stage_columns record;
	
BEGIN

	TrialID := upper(trial_id);
	dataType := upper(data_type);
	
	stepCt := 0;
	pCount := 0;
	bslash := '\\';
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_FROM_STAGE';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		jobId := tm_cz.czx_start_audit (procedureName, databaseName);
	END IF;
  
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done')into rtnCd;
	
	stepCt := stepCt + 1;
	msgText := 'Extracting trial: ' || TrialId;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName, msgText,0,stepCt,'Done');

	if TrialId is null then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'TrialID missing',0,stepCt,'Done')into rtnCd;
		return 16;
	end if;
	
	for r_stage_table in
		select upper(table_owner) as table_owner
			  ,upper(table_name) as table_name
			  ,upper(study_specific) as study_specific
			  ,where_clause
			  ,upper(stage_table_name) as stage_table_name
		from tm_cz.migrate_tables
		where instr(dataType,data_type) > 0
	loop	
		pCount := pCount + 1;
		--	setup variables
		
		source_table := r_stage_table.table_owner || '.' || r_stage_table.table_name;
		release_table := 'tm_stage.' || r_stage_table.stage_table_name;
		tableName := r_stage_table.table_name;
		tableOwner := r_stage_table.table_owner;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Processing ' || source_table,0,stepCt,'Done')into rtnCd;

		if r_stage_table.study_specific = 'N' then	
			--	truncate target table
			tText := 'truncate table ' || source_table;
			execute immediate tText;
			stepCt := stepCt + 1;		
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Truncated '|| source_table,0,stepCt,'Done')into rtnCd;
			--	insert from staged source into target
			tText := 'insert into ' || source_table || ' select st.* from ' || release_table || ' st ';
			execute immediate tText;
			rowCt := ROW_COUNT;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted all data into ' || source_table,rowCt,stepCt,'Done')into rtnCd;		
		else
			tText := 'delete from ' || source_table || ' st ' || replace(r_stage_table.where_clause,'TrialId','''' || TrialId || '''');
			execute immediate tText;
			rowCt := ROW_COUNT;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Deleted study from ' || source_table,ROW_COUNT,stepCt,'Done')into rtnCd;
			tText := 'insert into ' || source_table || ' select ';
			
			--	get list of columns in order
		
			for r_stage_columns in
				select attname as column_name
				from _v_relation_column 
				where name=upper(tablename)
				order by attnum asc
			loop
				--	insert by column for study_specific 
				tText := tText || ' st.' || r_stage_columns.column_name || ',';
			end loop;
			
			tText := trim(trailing ',' from tText) || ' from ' || release_table || ' st ' || ' where st.release_study = ' || '''' || TrialId || '''';
			execute immediate tText;
			rowCt := ROW_COUNT;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted study into ' || source_table,rowCt,stepCt,'Done')into rtnCd;
		end if;		
		
	end loop;
	
	if pCount = 0 then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'No staged data for study',0,stepCt,'Done')into rtnCd;
		return 16;
	end if;	

	--	if CLINICAL data, add root node if needed and fill in tree for any top nodes
	
	if instr(dataType,'CLINICAL') > 0 then
	
		--	get topNode for study
	
		select min(c_fullname) into topNode
		from i2b2metadata.i2b2
		where sourcesystem_cd = TrialId;
		
		if topNode is null then
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Unable to get topNode for study',0,stepCt,'Done')into rtnCd;
			return 16;
		end if;
		
		-- Get rootNode from topNode
  
		rootNode := replace(substr(topNode,1,instr(topNode,bslash,2)),bslash,'');
	
		select count(*) into pExists
		from i2b2metadata.table_access
		where c_name = rootNode;
	
		select count(*) into pCount
		from i2b2metadata.i2b2
		where c_name = rootNode;
	
		if pExists = 0 or pCount = 0 then
			select tm_cz.i2b2_add_root_node(rootNode, jobId)into rtnCd;
		end if;
		
		--	Add any upper level nodes as needed, trim off study name because it's already in i2b2
	
		tPath := substr(topNode, 1,instr(topNode,bslash,-2,1));
		pCount := length(tPath) - length(replace(tPath,bslash,''));

		if pCount > 2 then
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Adding upper-level nodes',0,stepCt,'Done')into rtnCd;
			select i2b2_fill_in_tree(null, tPath, jobId)into rtnCd;
		end if;

		select tm_cz.i2b2_load_security_data(jobId)into rtnCd;
	end if;

	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End '||procedureName,0,stepCt,'Done')into rtnCd;

       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    select tm_cz.czx_end_audit (jobID, 'SUCCESS')into rtnCd;
  END IF;
  
  return 0;

  EXCEPTION
  WHEN OTHERS THEN
	v_sqlerrm := substr(SQLERRM,1,1000);
	raise notice 'error: %', v_sqlerrm;
    --Handle errors.
    select tm_cz.czx_error_handler (jobID, procedureName,v_sqlerrm)into rtnCd;
    --End Proc
    select tm_cz.czx_end_audit (jobID, 'FAIL')into rtnCd;
	return 16;
END;

$_$;


ALTER FUNCTION tm_cz.i2b2_load_from_stage(character varying, character varying, bigint) OWNER TO tm_cz;

--
-- Name: i2b2_load_gwas_top50(numeric, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_gwas_top50(i_bio_assay_analysis_id numeric, currentjobid numeric DEFAULT 0) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, biomart, biomart_stage, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
	--Audit variables
	newJobFlag integer;
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID bigint;
	stepCt integer;
	rowCt		integer;
	tExists		integer;
	v_sqlerrm		varchar(1000);
	rtnCd		integer;
	errorNumber		character varying;
	errorMessage	character varying;
	
begin

	stepCt := 0;
	rowCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_GWAS_TOP50';
	
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobId;
	END IF;
	
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Start ' || procedureName,0,stepCt,'Done') into rtnCd;
	
	begin
	delete from biomart.bio_asy_analysis_gwas_top50
	where bio_assay_analysis_id = i_bio_assay_analysis_id;
	get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete analysis from bio_asy_analysis_gwas_top50',rowCt,stepCt,'Done') into rtnCd;
		
	begin
	insert into biomart.bio_asy_analysis_gwas_top50
	(bio_assay_analysis_id
	,analysis
	,chrom
	,pos
	,rsgene
	,rsid
	,pvalue
	,logpvalue
	,extdata
	,rnum
	)
	select a.*
	from (select gwas.bio_assay_analysis_id
				,baa.analysis_name as analysis
				,info.chrom as chrom
				,info.pos as pos
				,info.gene_name as rsgene
				,gwas.rs_id as rsid
				,gwas.p_value as pvalue
				,gwas.log_p_value as logpvalue
				,gwas.ext_data as extdata
				,row_number () over (order by gwas.p_value asc, gwas.rs_id asc) as rnum
		  from biomart.bio_assay_analysis_gwas gwas 
		  inner join biomart.bio_assay_analysis baa 
				on  baa.bio_assay_analysis_id = gwas.bio_assay_analysis_id
		  inner join deapp.de_rc_snp_info info 
				on  gwas.rs_id = info.rs_id 
				and hg_version='19'
		  where gwas.bio_assay_analysis_id = i_bio_assay_analysis_id) a
	where a.rnum <= 500;
	get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert into bio_asy_analysis_gwas_top50',rowCt,stepCt,'Done') into rtnCd;
	
      ---Cleanup OVERALL JOB if this proc is being run standalone
	if newjobflag = 1
	then
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	end if;
	
	return 0;

END;
$$;


ALTER FUNCTION tm_cz.i2b2_load_gwas_top50(i_bio_assay_analysis_id numeric, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_load_metabolomics_annot(numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_metabolomics_annot(currentjobid numeric DEFAULT NULL::numeric) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, pg_temp, deapp, tm_lz, tm_wz, biomart
    AS $$
/*************************************************************************
*This stored procedure is for ETL to load METABOLOMICS ANNOTATION
* Date:12/29/2013
******************************************************************/
DECLARE
	--Audit variables
	newJobFlag numeric(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID numeric(18,0); 
	stepCt numeric(18,0); 
	idREF	varchar(100);
	rowCt integer;
	gplId VARCHAR(100);

BEGIN
  	stepCt := 0; 

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_METABOLOMICS_ANNOTATION';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;
	
    stepCt := stepCt + 1;
    perform cz_write_audit(jobId,databaseName,procedureName,'Starting I2B2_LOAD_METABOLOMICS_ANNOTTATION',0,stepCt,'Done');

    --    get  id_ref  from external table
    
	select distinct gpl_id into gplId from tm_lz.lt_metabolomic_annotation;
      
  --    delete any existing data from de_metabolite_super_pathways
    
	begin
    delete from deapp.de_metabolite_super_pathways
    where gpl_id = gplId;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
        
    perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_metabolite_super_pathways',rowCt,stepCt,'Done');

	--    delete any existing data from de_metabolite_sub_pathways
	begin
	delete from de_metabolite_sub_pathways where gpl_id = gplId;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

    perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_metabolite_sub_pathways',rowCt,stepCt,'Done');
        
	--    delete any existing data from de_metabolite_sub_pway_metab
	begin
	delete from deapp.de_metabolite_sub_pway_metab where not exists (select id from de_metabolite_sub_pathways where de_metabolite_sub_pathways.id = de_metabolite_sub_pway_metab.sub_pathway_id) ;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	
    perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_metabolite_sub_pway_metab',rowCt,stepCt,'Done');

    --    delete any existing data from deapp.de_metabolite_annotation
	begin
        delete from deapp.de_metabolite_annotation
        where gpl_id = gplId;
       exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

    perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_metabolite_annotation',rowCt,stepCt,'Done');

    
	begin
    insert into  deapp.de_metabolite_annotation
        (
        id
        ,gpl_id
        ,biochemical_name
        ,biomarker_id
        ,hmdb_id
        )
    select
        nextval('deapp.metabolomics_annot_id')
        ,d.gpl_id
    ,trim(d.biochemical_name)
    ,b.primary_external_id
    ,d.hmdb_id
    from lt_metabolomic_annotation d
    left outer join bio_marker b on b.bio_marker_name = d.biochemical_name
    --,peptide_deapp p
    where d.gpl_id = gplId;
    exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;  
    
    perform cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_metabolite_annotation',rowCt,stepCt,'Done');
        
	begin
     insert into deapp.de_metabolite_super_pathways
        (
        id
        ,gpl_id
        ,super_pathway_name
        )
    select
        nextval('deapp.metabolite_sup_pth_id')
        ,d.gpl_id
    ,d.super_pathway
    from (select distinct gpl_id,super_pathway from lt_metabolomic_annotation ) d
    where d.gpl_id = gplId;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
     
    perform cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_metabolite_super_pathways',rowCt,stepCt,'Done');
                           
		begin
        insert into  deapp.de_metabolite_sub_pathways
        (
        id
        ,gpl_id
        ,sub_pathway_name
        ,super_pathway_id
        )
        select
        nextval('deapp.metabolite_sub_pth_id')
        ,d.gpl_id
    ,trim(d.sub_pathway)
        ,sp.id
    from (select unnest(regexp_split_to_array(sub_pathway, ';')) AS sub_pathway ,gpl_id,super_pathway
        FROM tm_lz.lt_metabolomic_annotation) as d
    ,deapp.de_metabolite_super_pathways sp
    where
        trim(d.super_pathway) = trim(sp.super_pathway_name)
        and d.gpl_id = gplId
        and sp.gpl_id = gplId;     
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;		
    
    perform cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_metabolite_sub_pathways',rowCt,stepCt,'Done');
                                                             
    begin
        insert into  deapp.de_metabolite_sub_pway_metab
        (
          metabolite_id
          ,sub_pathway_id
        )
	   select d.id, sp.id from deapp.de_metabolite_annotation d, deapp.de_metabolite_sub_pathways sp,
	(select unnest(regexp_split_to_array(sub_pathway, ';')) AS sub_pathway ,biochemical_name, gpl_id
			FROM tm_lz.lt_metabolomic_annotation) as lma
	where trim(lma.biochemical_name) = trim(d.biochemical_name)
	and trim(lma.sub_pathway) = trim (sp.sub_pathway_name)
	and d.gpl_id =gplId
			and lma.gpl_id=gplId;
		exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
            
    perform cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_metabolite_sub_pway_metab',rowCt,stepCt,'Done');
        
    --    update biomarker_id if null
    
	begin
        update deapp.de_metabolite_annotation t
    set biomarker_id=(select min(b.bio_marker_name) as biomarker_id
                 from biomart.mirna_bio_marker b
                 where t.biomarker_id::text = b.primary_external_id
                   and upper(b.bio_marker_type) = 'metabolomic')
    where t.gpl_id = gplId
      and t.biomarker_id is null
      and t.biochemical_name is not null
      and exists
         (select 1 from biomart.mirna_bio_marker x
          where t.biomarker_id::text = x.primary_external_id
            and upper(x.bio_marker_type) = 'metabolomic');
    exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	get diagnostics rowCt := ROW_COUNT;
	
    perform cz_write_audit(jobId,databaseName,procedureName,'Updated missing uniprotid in de_protien_annotation',rowCt,stepCt,'Done');
    
    --    insert probesets into biomart.bio_assay_feature_group
    begin
    insert into biomart.mirna_bio_assay_feature_group
    (feature_group_name
    ,feature_group_type)
    select distinct t.biochemical_name, 'METABOLOMIC' --ask
    from tm_lz.lt_metabolomic_annotation t        
    where not exists
         (select 1 from biomart.mirna_bio_assay_feature_group x
          where t.gpl_id = x.feature_group_name);
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
            
    perform cz_write_audit(jobId,databaseName,procedureName,'Insert peptides into biomart.mirna_bio_assay_feature_group',rowCt,stepCt,'Done');
          
    --    insert probesets into biomart.mirna_bio_assay_data_annotation
    
	begin
    insert into biomart.mirna_bio_assay_data_annot
    (bio_assay_feature_group_id
    ,bio_marker_id)
    select distinct fg.bio_assay_feature_group_id
          ,coalesce(bgs.bio_marker_id,bgi.bio_marker_id)
    from lt_metabolomic_annotation t
        inner join biomart.mirna_bio_assay_feature_group fg on t.biochemical_name = fg.feature_group_name
        left outer join biomart.mirna_bio_marker bgs on t.biochemical_name = bgs.bio_marker_name
        left outer join biomart.mirna_bio_marker bgi on t.hmdb_id::text= bgi.primary_external_id
    where (t.hmdb_id is not null)
      and coalesce(bgs.bio_marker_id,bgi.bio_marker_id,-1) > 0
      and not exists
         (select 1 from biomart.mirna_bio_assay_data_annot x
          where fg.bio_assay_feature_group_id = x.bio_assay_feature_group_id
            and coalesce(bgs.bio_marker_id,bgi.bio_marker_id,-1) = x.bio_marker_id);
            exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
    perform cz_write_audit(jobId,databaseName,procedureName,'Link feature_group to bio_marker in biomart.mirna_bio_assay_data_annotation',rowCt,stepCt,'Done');
            
        -- Inserts subpathways into search_keyword,
-- subpathways into search_keyword_term,
-- superpathways into search_keyword,
-- superpathways into search_keyword_term
			begin
          INSERT INTO searchapp.search_keyword (
            keyword,
            bio_data_id,
            unique_id,
            data_category,
            display_data_category)
          SELECT
            CONCAT(CONCAT(subp.sub_pathway_name, '_'), subp.gpl_id),
            subp.id,
            CONCAT('METABOLITE_SUBPATHWAY:', subp.id),
            'METABOLITE_SUBPATHWAY',
            'Metabolite subpathway'
          FROM
            deapp.de_metabolite_sub_pathways subp
            where subp.gpl_id = gplId;
exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
    perform cz_write_audit(jobId,databaseName,procedureName,'Insert subpathways into search_keyword',rowCt,stepCt,'Done');
    
		begin
            INSERT INTO searchapp.search_keyword_term (
              keyword_term,
              search_keyword_id,
              rank,
              term_length)
            SELECT
              upper_keyword,
              search_keyword_id,
              1,
              LENGTH(upper_keyword)
            FROM (
              SELECT
                UPPER(skw.keyword) AS upper_keyword,
                skw.search_keyword_id AS search_keyword_id
              FROM
                searchapp.search_keyword skw
              WHERE
                data_category = 'METABOLITE_SUBPATHWAY'
              AND
                bio_data_id IN (
                  SELECT
                    subp.id
                  FROM
                    deapp.de_metabolite_sub_pathways subp
                    where subp.gpl_id = gplId
                )
            ) as s;

            stepCt := stepCt + 1;
            perform cz_write_audit(jobId,databaseName,procedureName,'Insert subpathways into search_keyword_term',rowCt,stepCt,'Done');
            
            INSERT INTO searchapp.search_keyword (
              keyword,
              bio_data_id,
              unique_id,
              data_category,
              display_data_category)
            SELECT
              CONCAT(CONCAT(supp.super_pathway_name, '_'), supp.gpl_id),
              supp.id,
              CONCAT('METABOLITE_SUPERPATHWAY:', supp.id),
              'METABOLITE_SUPERPATHWAY',
              'Metabolite superpathway'
            FROM
              deapp.de_metabolite_super_pathways supp
              where supp.gpl_id = gplId;
			  exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

            perform cz_write_audit(jobId,databaseName,procedureName,'Insert superpathways into search_keyword',rowCt,stepCt,'Done');
			
			begin
            INSERT INTO searchapp.search_keyword_term (
              keyword_term,
              search_keyword_id,
              rank,
              term_length)
            SELECT
              upper_keyword,
              search_keyword_id,
              1,
              LENGTH(upper_keyword)
            FROM (
              SELECT
                UPPER(skw.keyword) AS upper_keyword,
                skw.search_keyword_id AS search_keyword_id
              FROM
                searchapp.search_keyword skw
              WHERE
                data_category = 'METABOLITE_SUPERPATHWAY'
              AND
                bio_data_id IN (
                  SELECT
                    supp.id
                  FROM
                    deapp.de_metabolite_super_pathways supp
                    where supp.gpl_id = gplId
                )
            ) as s;
			exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

        stepCt := stepCt + 1;
        perform cz_write_audit(jobId,databaseName,procedureName,'Insert superpathways into search_keyword_term',rowCt,stepCt,'Done');
                       
	begin
    INSERT INTO biomart.bio_marker (
          bio_marker_name,
          bio_marker_description,
          primary_external_id,
          bio_marker_type)
        SELECT
          CONCAT('PRIVATE:', annotation.id),
          CONCAT('PRIVATE:', annotation.id),
          CONCAT('PRIVATE:', annotation.id),
          'METABOLITE'
        FROM
          deapp.de_metabolite_annotation annotation
        WHERE
          annotation.hmdb_id IS NULL;
         exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT; 
        perform cz_write_audit(jobId,databaseName,procedureName,'Insert into biomart.bio_marker',rowCt,stepCt,'Done');
                 
		begin
        UPDATE deapp.de_metabolite_annotation annotation
        SET  hmdb_id = CONCAT('PRIVATE:', annotation.id)
        WHERE  annotation.hmdb_id IS NULL;
		exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
                 
        perform cz_write_audit(jobId,databaseName,procedureName,'Update deapp.de_metabolite_annotation',rowCt,stepCt,'Done');                 
        
        stepCt := stepCt + 1;
    perform cz_write_audit(jobId,databaseName,procedureName,'End I2B2_LOAD_METABOLOMICS_ANNOT',0,stepCt,'Done');
        
       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
   perform cz_end_audit (jobID, 'SUCCESS');
  END IF;

  return 1;

END;
$$;


ALTER FUNCTION tm_cz.i2b2_load_metabolomics_annot(currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_load_mirna_annot_deapp(numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_mirna_annot_deapp(currentjobid numeric DEFAULT NULL::numeric) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
*This stored procedure is for ETL to load QPCR MIRNA ANNOTATION 
* Date:10/29/2013
******************************************************************/
DECLARE
	--Audit variables
	newJobFlag numeric(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID numeric(18,0); 
	stepCt numeric(18,0); 
	idREF	varchar(100);
	rowCt integer;

BEGIN

	stepCt := 0; 

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_MIRNA_ANNOT_DEAPP';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_MIRNA_annot_deapp',0,stepCt,'Done');

	begin
	delete from mirna_annotation_deapp
	where id_ref in ( select distinct id_ref from tm_lz.lt_qpcr_mirna_annotation)
  and gpl_id in ( select distinct gpl_id from tm_lz.lt_qpcr_mirna_annotation);
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from mirna_annotation_deapp',rowCt,stepCt,'Done');

        begin
        delete from deapp.de_qpcr_mirna_annotation
	where id_ref in (select distinct id_ref from tm_lz.lt_qpcr_mirna_annotation)
  and gpl_id in(select gpl_id from tm_lz.lt_qpcr_mirna_annotation);
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_qpcr_mirna_annotation',rowCt,stepCt,'Done');

	begin
	insert into mirna_probeset_deapp
	(probeset
	,organism
	,platform)
	select distinct id_ref
		  ,coalesce(organism,'Homo sapiens')
	      ,gpl_id
	from tm_lz.lt_qpcr_mirna_annotation t
	where not exists
		 (select 1 from mirna_probeset_deapp x
		  where 
                         t.id_ref = x.probeset
                         and t.gpl_id = x.platform
			--and coalesce(t.organism,'Homo sapiens') = coalesce(x.organism,'Homo sapiens')
                        )
	;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
        
      
	--where id_ref is not null 
	--   or mirna_symbol is not null;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert new probesets into mirna_probeset_deapp',rowCt,stepCt,'Done');
		
                --	update organism for existing probesets in mirna_probeset_deapp

	begin
	update mirna_probeset_deapp p
	set organism=(select distinct t.organism from tm_lz.lt_qpcr_mirna_annotation t
				  where p.probeset = t.id_ref
				    --and p.probeset = t.probe_id
                                    )
	where exists
		 (select 1 from tm_lz.lt_qpcr_mirna_annotation x
		  where p.platform = x.gpl_id
		    and p.probeset = x.id_ref);
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update organism in mirna_probeset_deapp',rowCt,stepCt,'Done');
			 
                
                
	--	insert data into mirna_annotation_deapp
	begin
	insert into mirna_annotation_deapp
	(id_ref
	,probe_id
	,mirna_symbol
	,mirna_id
	,probeset_id
	,organism
  ,gpl_id)
	select distinct d.id_ref
	,null
	,null
	,d.mirna_id
	,p.probeset_id
	,coalesce(d.organism,'Homo sapiens')
  ,d.gpl_id
	from tm_lz.lt_qpcr_mirna_annotation d
	,mirna_probeset_deapp p
	where d.id_ref = p.probeset
    and p.platform = d.gpl_id
	  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens')
	  --and (d.id_ref is not null or d.mirna_symbol is not null)
	  ;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into REFERENCE mirna_annotation_deapp',rowCt,stepCt,'Done');
		
	--	insert data into deapp.de_qpcr_mirna_annotation

	begin
	insert into 
        deapp.de_qpcr_mirna_annotation
	(id_ref
	,probe_id
	,mirna_symbol
	,mirna_id
	,probeset_id
	,organism
  ,gpl_id)
	select distinct d.id_ref
	,null
	,null --d.mirna_symbol
	,lower(d.mirna_id) as mirna_id
	,p.probeset_id
	,coalesce(d.organism,'Homo sapiens')
  ,d.gpl_id
	from tm_lz.lt_qpcr_mirna_annotation d
	,mirna_probeset_deapp p
	where d.id_ref = p.probeset
	  and p.platform = d.gpl_id
	  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens');	  
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_qpcr_mirna_annotation',rowCt,stepCt,'Done');
	
	insert into biomart.mirna_bio_assay_feature_group
	(feature_group_name
	,feature_group_type)
	select distinct t.id_ref, 'PROBESET'
	from tm_lz.lt_qpcr_mirna_annotation t
	where not exists
		 (select 1 from biomart.mirna_bio_assay_feature_group x
		  where t.id_ref = x.feature_group_name);
			
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert probesets into biomart.mirna_bio_assay_feature_group',rowCt,stepCt,'Done');
		  
	--	insert probesets into biomart.mirna_bio_assay_data_annotation
	begin
	insert into biomart.mirna_bio_assay_data_annot
	(bio_assay_feature_group_id
	,bio_marker_id)
	select distinct fg.bio_assay_feature_group_id
		  ,bgi.bio_marker_id
	from tm_lz.lt_qpcr_mirna_annotation t left outer join biomart.bio_marker bgi on bio_marker_type = 'MIRNA' and t.mirna_id::varchar = bgi.primary_external_id
		,biomart.mirna_bio_assay_feature_group fg
	where (
               t.mirna_id is not null)
	  and t.id_ref = fg.feature_group_name
	  and upper(coalesce(t.organism,'Homo sapiens')) = upper(bgi.organism)
	  and coalesce(bgi.bio_marker_id,-1) > 0
	  and not exists
		 (select 1 from biomart.mirna_bio_assay_data_annot x
		  where fg.bio_assay_feature_group_id = x.bio_assay_feature_group_id
		    and coalesce(bgi.bio_marker_id,-1) = x.bio_marker_id);
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT; 
	perform cz_write_audit(jobId,databaseName,procedureName,'Link feature_group to bio_marker in biomart.mirna_bio_assay_data_annotation',rowCt,stepCt,'Done');
			
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_MIRNA_annot_deapp',0,stepCt,'Done');
	
       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    perform cz_end_audit (jobID, 'SUCCESS'); 
  END IF;

  return 1;
  EXCEPTION 
  WHEN OTHERS THEN
    --Handle errors.
    perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
    --End Proc
    perform cz_end_audit (jobID, 'FAIL');

    return -16;
END;
$$;


ALTER FUNCTION tm_cz.i2b2_load_mirna_annot_deapp(currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_load_omicsoft_annot(bigint, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_omicsoft_annot(analysis_id bigint, i_job_id bigint DEFAULT NULL::bigint, OUT rtn_code bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research , LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
  
    --Audit variables
	newJobFlag 	integer;
	databaseName 	varchar(100);
	procedureName varchar(100);
	jobID 		bigint;
	stepCt 		bigint;

	v_probe_id		    varchar(200);
  v_gene_symbol 		varchar(1000);
  v_gene_id          bigint;
  v_organism         varchar(200);
  
  v_row_count     integer;
	
	no_new_annotations	exception;
	
	
BEGIN	
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := i_job_id;
  rtn_code := 0;
  v_row_count := 0;


	PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		czx_start_audit (procedureName, databaseName, jobID);
	END IF;
    	
	stepCt := 1;	
	czx_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_omicsoft_annot',0,stepCt,'Done');

  -- load any missing probe_ids into bio_assay_feature_group
  insert into BIOMART.bio_assay_feature_group(
    feature_group_name
  , feature_group_type)
    PERFORM distinct
    probe_id
  , 'PROBESET'
    from TM_LZ.lt_src_omicsoft_annot lz
    where probe_id not in (select feature_group_name from BIOMART.bio_assay_feature_group);
    
    v_row_count := SQL%ROWCOUNT;
 
  czx_write_audit(jobId,databaseName,procedureName,'Loaded bio_assay_featurwe_group with ' || v_row_count || ' records' ,0,stepCt,'Done');
	stepCt := stepCt + 1;
  
  if v_row_count = 0 then
		raise no_new_annotations;
	end if;
  
  -- need to get platform from analysis
  insert into BIOMART.bio_assay_data_annotation(
   bio_assay_feature_group_id
  , bio_marker_id
  , data_table)
    PERFORM distinct
      bafg.bio_assay_feature_group_id
    , bm.bio_marker_id -- analysis
    , 'BAAD'
    from biomart.bio_assay_feature_group bafg
    join TM_LZ.lt_src_omicsoft_annot lz on lz.probe_id = bafg.feature_group_name
    join biomart.bio_marker bm on bm.bio_marker_name = lz.gene_symbol and upper(bm.organism) = upper(lz.organism)
    where not exists (select 1 from biomart.bio_assay_data_annotation 
                      where bio_assay_feature_group_id = bafg.bio_assay_feature_group_id
                      and bio_marker_id = bm.bio_marker_id);
    
  v_row_count := SQL%ROWCOUNT;
  
  czx_write_audit(jobId,databaseName,procedureName,'Loaded bio_assay_data_annotation with ' || v_row_count || ' records' ,0,stepCt,'Done');
	stepCt := stepCt + 1;
	
	czx_write_audit(jobId,databaseName,procedureName,'End i2b2_load_omicsoft_annot',0,stepCt,'Done');
	stepCt := stepCt + 1;
	
	czx_end_audit(jobId, 'Success');
	
	exception
	when no_new_annotations then
		czx_write_audit(jobId, databaseName, procedureName, 'No new feature groups to load - terminating normally',0,stepCt,'Done');
		czx_end_audit(jobId, 'Success');
	when others then
    --Handle errors.
		czx_error_handler (jobID, procedureName);
    --End Proc
		czx_end_audit (jobID, 'FAIL');
    rtn_code := 16;
	
END;
 
$_$;


ALTER FUNCTION tm_cz.i2b2_load_omicsoft_annot(analysis_id bigint, i_job_id bigint, OUT rtn_code bigint) OWNER TO tm_cz;

--
-- Name: i2b2_load_proteomics_annot(numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_proteomics_annot(currentjobid numeric DEFAULT NULL::numeric) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
*This stored procedure is for ETL to load proteomics ANNOTATION 
* Date:10/29/2013
******************************************************************/
Declare
	--Audit variables
	newJobFlag NUMERIC(1);
	databaseName character varying(100);
	procedureName character varying(100);
	jobID numeric(18,0); 
	stepCt numeric(18,0); 
	gplId	character varying(100);
	rtnCd integer;
	errorNumber character varying;
	errorMessage character varying;
	rowCt integer;

BEGIN

	stepCt := 0; 

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_PROTEOMICS_ANNOT';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting I2B2_LOAD_PROTEOMICS_ANNOTTATION',0,stepCt,'Done') into rtnCd;

	--	get  id_ref  from external table
	
      select distinct gpl_id into gplId from lt_protein_annotation ;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_protein_annotation',rowCt,stepCt,'Done') into rtnCd;
        --	delete any existing data from deapp.de_protien_annotation
        begin
		delete from deapp.de_protein_annotation
		where gpl_id =gplId;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_protien_annotation',rowCt,stepCt,'Done') into rtnCd;
	begin
	insert into  deapp.de_protein_annotation
	(gpl_id
	,peptide 
	,uniprot_id
	,biomarker_id
	,organism)
	select distinct d.gpl_id
	,trim(d.peptide)
	,d.uniprot_id
	,p.bio_marker_id
	,coalesce(d.organism,'Homo sapiens')
	from lt_protein_annotation d
	,biomart.bio_marker p
	where d.gpl_id = gplId
        and p.primary_external_id = d.uniprot_id 
	--  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens')
	 -- and (d.gpl_id is not null or d.gene_symbol is not null)
	  ;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated missing uniprot_id in de_protien_annotation',rowCt,stepCt,'Done') into rtnCd;

	begin
        update DEAPP.DE_PROTEIN_ANNOTATION set uniprot_name = (select bio_marker_name
        from BIOMART.BIO_MARKER
        WHERE biomart.bio_marker.primary_external_id = deapp.de_protein_annotation.uniprot_id)
        where gpl_id = gplId;
        exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;  
        
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Update uniprot_name in DEAPP de_protein_annotation',rowCt,stepCt,'Done') into rtnCd;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_proteomics_annottation',0,stepCt,'Done') into rtnCd;
	
       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    select cz_end_audit (jobID, 'SUCCESS') into rtnCd; 
  END IF; 

  return rtnCd;
  
  EXCEPTION 
  WHEN OTHERS THEN
    errorNumber := SQLSTATE;
    errorMessage := SQLERRM;
    select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
    select cz_end_audit (jobID, 'FAIL') into rtnCd;

  return rtnCd;
END;
$$;


ALTER FUNCTION tm_cz.i2b2_load_proteomics_annot(currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_load_rbm_annotation(bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_rbm_annotation(currentjobid bigint DEFAULT NULL::bigint) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE

/*************************************************************************
* This is for RBM Annotation ETL for Sanofi
* Date:12/05/2013
******************************************************************/

	--Audit variables
	newJobFlag numeric(1);
	databaseName character varying(100);
	procedureName character varying(100);
	jobID bigint;
	stepCt bigint;
	gplId	character varying(100);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	rowCt			numeric(18,0);
	
BEGIN

	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	
	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_RBM_ANNOTATION';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName, jobID) into jobId;
	END IF;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_rbm_annotation',0,stepCt,'Done') into rtnCd;

	--	get GPL id from external table
	
	select distinct gpl_id into gplId from TM_LZ.LT_SRC_RBM_ANNOTATION;
	
	
	--	delete any existing data from antigen_deapp
	
	begin
	delete from antigen_deapp
	where platform = gplId;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;	

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from REFERENCE antigen_deapp',rowCt,stepCt,'Done') into rtnCd;

		
	--	delete any existing data from annotation_deapp
	begin
	delete from annotation_deapp
	where gpl_id = gplId;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;	

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from annotation_deapp',rowCt,stepCt,'Done') into rtnCd;

	--	delete any existing data from deapp.de_mrna_annotation
	begin
	delete from deapp.DE_RBM_ANNOTATION
	where gpl_id = gplId;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert any new probesets into probeset_deapp
	begin
	insert into antigen_deapp 
	(antigen_name
	,platform)
	select distinct antigen_name
	      ,gpl_id
	from TM_LZ.LT_SRC_RBM_ANNOTATION t
	where not exists
		 (select 1 from antigen_deapp x
		  where t.gpl_id = x.platform
		    and t.antigen_name = x.antigen_name
		);
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert new probesets into antigen_deapp',rowCt,stepCt,'Done') into rtnCd;
		
	--	insert data into annotation_deapp
	begin
	insert into annotation_deapp
	(gpl_id
	,probe_id
	,gene_symbol
	,gene_id
	,probeset_id
	,organism)
	select distinct d.gpl_id
	,d.uniprotid
	,d.gene_symbol
	,d.gene_id
	,p.antigen_id
	,'Homo sapiens'
	from TM_LZ.LT_SRC_RBM_ANNOTATION d
	,antigen_deapp p
	where d.antigen_name = p.antigen_name
	  and d.gpl_id = p.platform
	  and ((d.gene_id IS NOT NULL AND d.gene_id::text <> '') or (d.gene_symbol IS NOT NULL AND d.gene_symbol::text <> '')) ;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into REFERENCE annotation_deapp',rowCt,stepCt,'Done') into rtnCd;
		
	--	insert data into deapp.de_rbm_annotation
	begin
	insert into DEAPP.DE_RBM_ANNOTATION
	(gpl_id
        ,id
	,antigen_name
        ,uniprot_id
	,gene_symbol
	,gene_id
	)
	select  distinct d.gpl_id
        ,antigen_id
	,d.antigen_name
        ,d.uniprotid
	,d.gene_symbol
	,CASE WHEN d.gene_id = null THEN null ELSE d.gene_id::numeric END as gene_id
	from TM_LZ.LT_SRC_RBM_ANNOTATION d
	,antigen_deapp p --check
	where d.antigen_name = p.antigen_name
	  and d.gpl_id = p.platform;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
        
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_rbm_annotation',rowCt,stepCt,'Done') into rtnCd;
		
	--	update gene_id if null
	begin
	update DEAPP.DE_RBM_ANNOTATION t
	set gene_id=(select min(b.primary_external_id)::numeric as gene_id
				 from biomart.bio_marker b
				 where t.gene_symbol = b.bio_marker_name
				  -- and upper(b.organism) = upper(t.organism)
				   and upper(b.bio_marker_type) = 'RBM')
	where t.gpl_id = gplId
	  and coalesce(t.gene_id::text, '') = ''
	  and (t.gene_symbol IS NOT NULL AND t.gene_symbol::text <> '')
	  and exists
		 (select 1 from biomart.bio_marker x
		  where t.gene_symbol = x.bio_marker_name
			--and upper(x.organism) = upper(t.organism)
			and upper(x.bio_marker_type) = 'RBM');
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
			
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated missing gene_id in de_rbm_annotation',rowCt,stepCt,'Done') into rtnCd;
	
	--	update gene_symbol if null
	begin
	update DEAPP.DE_RBM_ANNOTATION t 
	set gene_symbol=(select min(b.bio_marker_name) as gene_symbol
				 from biomart.bio_marker b
				 where t.gene_id::varchar = b.primary_external_id
				 --  and upper(b.organism) = upper(t.organism)
				   and upper(b.bio_marker_type) = 'RBM')
	where t.gpl_id = gplId
	  and coalesce(t.gene_symbol::text, '') = ''
	  and (t.gene_id IS NOT NULL AND t.gene_id::text <> '')
	  and exists
		 (select 1 from biomart.bio_marker x
		  where t.gene_id::varchar = x.primary_external_id
			--and upper(x.organism) = upper(t.organism)
			and upper(x.bio_marker_type) = 'RBM');
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
			
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated missing gene_id in de_rbm_annotation',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert probesets into biomart.bio_assay_feature_group
	begin
	insert into biomart.bio_assay_feature_group
	(feature_group_name
	,feature_group_type)
	select distinct t.uniprotid, 'PROTEIN'
	from tm_lz.LT_SRC_RBM_ANNOTATION t
	where not exists
		 (select 1 from biomart.bio_assay_feature_group x
		  where t.uniprotid = x.feature_group_name)
		and (t.uniprotid IS NOT NULL AND t.uniprotid::text <> '');
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
			
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert probesets into biomart.bio_assay_feature_group',rowCt,stepCt,'Done') into rtnCd;
		  
	--	insert probesets into biomart.bio_assay_data_annotation
	begin
	insert into biomart.bio_assay_data_annotation
	(bio_assay_feature_group_id
	,bio_marker_id)
	select distinct fg.bio_assay_feature_group_id
		  ,coalesce(bgs.bio_marker_id,bgi.bio_marker_id)
	from TM_LZ.LT_SRC_RBM_ANNOTATION t
	INNER JOIN biomart.bio_assay_feature_group fg on t.uniprotid = fg.feature_group_name
	LEFT OUTER JOIN biomart.bio_marker bgs on t.gene_symbol = bgs.bio_marker_name
	LEFT OUTER JOIN biomart.bio_marker bgi on t.gene_id::varchar = bgi.primary_external_id
	where ((t.gene_symbol IS NOT NULL AND t.gene_symbol::text <> '') or (t.gene_id IS NOT NULL AND t.gene_id::text <> ''))
	  and coalesce(bgs.bio_marker_id,bgi.bio_marker_id,-1) > 0
	  and not exists 
		 (select 1 from biomart.bio_assay_data_annotation x
		  where fg.bio_assay_feature_group_id = x.bio_assay_feature_group_id
		    and coalesce(bgs.bio_marker_id,bgi.bio_marker_id,-1) = x.bio_marker_id);
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
			
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Link feature_group to bio_marker in biomart.bio_assay_data_annotation',rowCt,stepCt,'Done') into rtnCd;
			
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_rbm_annotation',0,stepCt,'Done') into rtnCd;
	
       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
  END IF;

  return 1;
  
END;
 
$$;


ALTER FUNCTION tm_cz.i2b2_load_rbm_annotation(currentjobid bigint) OWNER TO tm_cz;

--
-- Name: i2b2_load_rbm_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_rbm_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_code character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT NULL::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE

/*************************************************************************

* This store procedure is for ETL  to load  RBM data for Sanofi
* Date: 12/05/2013

******************************************************************/
--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint	

  TrialID		varchar(100);
  RootNode		varchar(2000);
  root_level	integer;
  topNode		varchar(2000);
  topLevel		integer;
  tPath			varchar(2000);
  study_name	varchar(100);
  sourceCd		varchar(50);
  secureStudy	varchar(1);

  dataType		varchar(10);
  sqlText		varchar(1000);
  tText			varchar(1000);
  gplTitle		varchar(1000);
  pExists		bigint;
  partTbl   	bigint;
  partExists 	bigint;
  sampleCt		bigint;
  idxExists 	bigint;
  logBase		bigint;
  pCount		integer;
  sCount		integer;
  tablespaceName	varchar(200);
  v_bio_experiment_id	bigint;
  partitioniD	numeric(18,0);
  partitionName	varchar(100);
  partitionIndx	varchar(100);
  
    --Audit variables
  newJobFlag integer;
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  rowCt			numeric(18,0);
  errorNumber		character varying;
  errorMessage	character varying;
  rtnCd			integer;

	addNodes CURSOR FOR
	SELECT distinct t.leaf_node
          ,t.node_name
	from  tm_wz.WT_RBM_NODES t
	where not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where t.leaf_node = x.c_fullname);

 
--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  delNodes CURSOR FOR
  SELECT distinct c_fullname 
  from  i2b2metadata.i2b2
  where c_fullname like topNode || '%'
    and substring(c_visualattributes from 2 for 1) = 'H';


	uploadI2b2 CURSOR FOR
    select category_cd,display_value,display_label,display_unit from
    tm_lz.lt_src_rbm_display_mapping;



BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\','g');
	select length(topNode)-length(replace(topNode,'\','')) into topLevel ;
	
	if coalesce(data_type::text, '') = '' then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;
	
	logBase := log_base;
	sourceCd := upper(coalesce(source_code,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_RBM_DATA';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select tm_cz.cz_start_audit (procedureName, databaseName, jobID) into jobId;
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_rbm_data',0,stepCt,'Done') into rtnCd;
	
	--	Get count of records in LT_SRC_RBM_SUBJ_SAMP_MAP
	
	select count(*) into sCount
	from TM_LZ.LT_SRC_RBM_SUBJ_SAMP_MAP;
	
	--	check if all subject_sample map records have a platform, If not, abort run
       /* if sCount > 0 then
		select tm_cz.cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
	end if;
	*/
	select count(*) into pCount
	from TM_LZ.LT_SRC_RBM_SUBJ_SAMP_MAP
	where coalesce(platform::text, '') = '';
	
	if pCount > 0 then
		select tm_cz.cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
	end if;
  
  	--	check if platform exists in de_rbm_annotation .  If not, abort run.
	
	select count(*) into pCount
	from TM_LZ.LT_SRC_RBM_ANNOTATION --change
	where gpl_id in (select distinct m.platform from TM_LZ.LT_SRC_RBM_SUBJ_SAMP_MAP m);
	
	select count(*) into pCount
	from DEAPP.DE_gpl_info
	where platform in (select distinct m.platform from TM_LZ.LT_SRC_RBM_SUBJ_SAMP_MAP m);
	
	if PCOUNT = 0 then
		select tm_cz.cz_write_audit(jobId,databasename,procedurename,'Platform not found in de_rbm_annotation',1,stepCt,'ERROR') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 163;
	end if;
		
	--	check if all subject_sample map records have a tissue_type, If not, abort run
	
	select count(*) into pCount
	from TM_LZ.LT_SRC_RBM_SUBJ_SAMP_MAP
	where coalesce(tissue_type::text, '') = '';
	
	if pCount > 0 then
		select tm_cz.cz_write_audit(jobId,databasename,procedurename,'Tissue Type data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select CZ_END_AUDIT (JOBID,'FAIL') into rtnCd;
		return 162;  
	end if;
	
	--	check if there are multiple platforms, if yes, then platform must be supplied in LT_SRC_RBM_DATA

	select count(*) into pCount
	from (select sample_cd
		  from TM_LZ.LT_SRC_RBM_SUBJ_SAMP_MAP
		  group by sample_cd
		  having count(distinct platform) > 1) as x;
	
	if pCount > 0 then
		select tm_cz.cz_write_audit(jobId,databasename,procedurename,'Multiple platforms for sample_cd in TM_LZ.LT_SRC_RBM_SUBJ_SAMP_MAP',1,stepCt,'ERROR') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 164;
	end if;
		
	-- Get root_node from topNode
  
	select tm_cz.parse_nth_value(topNode, 2, '\') into RootNode ;
	
	select count(*) into pExists
	from i2b2metadata.table_access
	where c_name = rootNode;
	
	if pExists = 0 then
		perform tm_cz.i2b2_add_root_node(rootNode, jobId);
	end if;
	
	select c_hlevel into root_level
	from i2b2metadata.i2b2
	where c_name = RootNode;
	
	-- Get study name from topNode
  
	select tm_cz.parse_nth_value(topNode, topLevel, '\') into study_name ;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount ;

	if pCount > 2 then
		perform tm_cz.i2b2_fill_in_tree(null, tPath, jobId);
	end if;

	--	uppercase study_id in lt_src_rbm_subj_samp_map in case curator forgot
	begin
	update TM_LZ.LT_SRC_RBM_SUBJ_SAMP_MAP
	set trial_name=upper(trial_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in LT_SRC_RBM_SUBJ_SAMP_MAP',rowCt,stepCt,'Done') into rtnCd;

	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd
	begin
	insert into i2b2demodata.patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from TM_LZ.LT_SRC_RBM_SUBJ_SAMP_MAP s
		     ,DEAPP.DE_gpl_info g
		 where (s.subject_id IS NOT NULL AND s.subject_id::text <> '')
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = 'RBM'
		   and not exists
			  (select 1 from i2b2demodata.patient_dimension x
			   where x.sourcesystem_cd = 
				  regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) as x;
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	pCount := rowCt;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',pCount,stepCt,'Done') into rtnCd;
	
	perform tm_cz.i2b2_create_security_for_trial(TrialId, secureStudy, jobID);

	--	Delete existing observation_fact data, will be repopulated
	begin
	delete from i2b2demodata.observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from deapp.DE_SUBJECT_SAMPLE_MAPPING x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = 'RBM');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;
	
	select count(*) into partExists
	from deapp.de_subject_sample_mapping sm
	where sm.trial_name = TrialId
	and coalesce(sm.source_cd,'STD') = sourceCd
	and sm.platform = 'RBM'
	and sm.partition_id is not null;
	
	if partExists = 0 then
		select nextval('deapp.seq_rbm_partition_id') into partitionId;
	else
		select distinct partition_id into partitionId
		from deapp.de_subject_sample_mapping sm
		where sm.trial_name = TrialId
		and coalesce(sm.source_cd,'STD') = sourceCd
		and sm.platform = 'RBM';
	end if;

	partitionName := 'deapp.de_subject_rbm_data_' || partitionId::text;
	partitionIndx := 'de_subject_rbm_data_' || partitionId::text;

	--	Cleanup any existing data in de_subject_sample_mapping.  
	begin
	delete from deapp.DE_SUBJECT_SAMPLE_MAPPING 
	where trial_name = TrialID 
	  and coalesce(source_cd,'STD') = sourceCd
	  and platform = 'RBM'; --Making sure only rbm data is deleted
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

--	truncate tmp node table

	EXECUTE('truncate table tm_wz.WT_RBM_NODES');
	
--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
--	from wt_subject_rbm_data

	EXECUTE('truncate table tm_wz.WT_RBM_NODE_VALUES');
	begin
	insert into tm_wz.WT_RBM_NODE_VALUES
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from TM_LZ.LT_SRC_RBM_SUBJ_SAMP_MAP a
	    ,DEAPP.DE_gpl_info g 
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = 'RBM'
	  and g.title = (select min(x.title) from DEAPP.DE_gpl_info x where coalesce(a.platform,'GPL570') = x.platform)
	  ;
	  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
      
	--  and decode(dataType,'R',sign(a.intensity_value),1) = 1;	--	take all values when dataType T, only >0 for dataType R
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP wt_rbm_node_values',rowCt,stepCt,'Done') into rtnCd;
	
	begin
	insert into tm_wz.WT_RBM_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
        ,attribute_2
	,node_type
	)
			select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g')
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  tm_wz.WT_RBM_NODE_VALUES;
		   	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_rbm_nodes',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert for platform node so platform concept can be populated
	
	begin
	insert into tm_wz.WT_RBM_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
        ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  tm_wz.WT_RBM_NODE_VALUES;
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		   
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in wt_rbm_nodes',rowCt,stepCt,'Done') into rtnCd;

	
	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd

	begin
	insert into tm_wz.WT_RBM_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  tm_wz.WT_RBM_NODE_VALUES
	where category_cd like '%ATTR1%'
	  and (attribute_1 IS NOT NULL AND attribute_1::text <> '');
	  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		   
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in WT_RBM_NODES',rowCt,stepCt,'Done') into rtnCd;

	
	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd
	begin
	insert into tm_wz.WT_RBM_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
		select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
		substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  tm_wz.WT_RBM_NODE_VALUES
	where category_cd like '%ATTR2%'
	  and (attribute_2 IS NOT NULL AND attribute_2::text <> '');
	  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		   
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_RBM_NODES',rowCt,stepCt,'Done') into rtnCd;

	
	--	insert for tissue_type node so sample_type_cd can be populated
	begin
	insert into tm_wz.WT_RBM_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  tm_wz.WT_RBM_NODE_VALUES
	where category_cd like '%TISSUETYPE%';
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		   
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_qpcr_rbm_nodes',rowCt,stepCt,'Done') into rtnCd;

	begin
	update tm_wz.WT_RBM_NODES
	set node_name=tm_cz.parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_rbm_nodes',rowCt,stepCt,'Done') into rtnCd;

		
--	add leaf nodes for RBM data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)
		begin
		perform tm_cz.i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId);
			get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;
		
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;
		
		perform tm_cz.i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID);

	END LOOP;  
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
	begin
	update i2b2metadata.i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end; 
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done') into rtnCd;

		
--	update concept_cd for nodes, this is done to make the next insert easier
	begin
	update tm_wz.WT_RBM_NODES t
	set concept_cd=(select c.concept_cd from i2b2demodata.concept_dimension c
	                where c.concept_path = t.leaf_node 
				   )
    where exists
         (select 1 from i2b2demodata.concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and coalesce(t.concept_cd::text, '') = '';
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update WT_RBM_NODES with newly created concept_cds',rowCt,stepCt,'Done') into rtnCd;

	 

  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_rbm_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in wt_rbm_nodes
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in wt_rbm_nodes
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in wt_rbm_nodes
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in wt_rbm_nodes
  --PLATFORM        = RBM - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in wt_rbm_nodes
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_rbm_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd
  
  --ASSAY_ID        = generated by trigger
	begin
	insert into deapp.DE_SUBJECT_SAMPLE_MAPPING
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
	,partition_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
		  ,partitionId
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,'RBM' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+RBM+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from TM_LZ.LT_SRC_rbm_subj_samp_map a		
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join i2b2demodata.patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = b.sourcesystem_cd
		inner join tm_wz.WT_RBM_NODES ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'@') = coalesce(ln.attribute_1,'@')
			and coalesce(a.attribute_2,'@') = coalesce(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join tm_wz.WT_RBM_NODES pn
			on a.platform = pn.platform
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(pn.tissue_type,'@')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(pn.attribute_1,'@')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'	  
		left outer join tm_wz.WT_RBM_NODES ttp
			on a.tissue_type = ttp.tissue_type
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = coalesce(ttp.platform,'@')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(ttp.attribute_1,'@')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'		  
		left outer join tm_wz.WT_RBM_NODES a1
			on a.attribute_1 = a1.attribute_1
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a1.platform,'@')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a1.tissue_type,'@')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'		  
		left outer join tm_wz.WT_RBM_NODES a2
			on a.attribute_2 = a1.attribute_2
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a2.platform,'@')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a2.tissue_type,'@')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'			  
		left outer join i2b2demodata.patient_dimension sid
			 on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  (ln.concept_cd IS NOT NULL AND ln.concept_cd::text <> '')) as t;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

--	Insert records for patients and samples into observation_fact
	begin
	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,INSTANCE_NUM
    )
    select distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,1
    from  deapp.DE_SUBJECT_SAMPLE_MAPPING m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCD
      and m.platform = 'RBM';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	  
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

    
    
	--	Insert sample facts 
	begin
	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    select distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  deapp.DE_SUBJECT_SAMPLE_MAPPING m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCd
      and m.platform = 'RBM'
	 and m.patient_id != m.sample_id;
	  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

    
    
	--Update I2b2 for correct data type
	begin
	update i2b2metadata.i2b2 t
	set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
	where t.c_basecode in (select distinct x.concept_cd from tm_wz.WT_RBM_NODES x);
  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	    stepCt := stepCt + 1;
    select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',rowCt,stepCt,'Done') into rtnCd;
    
     ---INSERT sample_dimension
	 begin
      INSERT INTO I2B2DEMODATA.SAMPLE_DIMENSION(SAMPLE_CD)
         SELECT DISTINCT SAMPLE_CD FROM
           DEAPP.DE_SUBJECT_SAMPLE_MAPPING WHERE SAMPLE_CD NOT IN (SELECT SAMPLE_CD FROM I2B2DEMODATA.SAMPLE_DIMENSION) ;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
       stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'insert distinct sample_cd in sample_dimension from de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

		---- update c_metedataxml in i2b2
	begin	
		   for ul in uploadI2b2
			loop
		 update i2b2metadata.i2b2 n
		SET n.c_columndatatype = 'T',
		  --Static XML String
			n.c_metadataxml =  ('<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>N</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue>
					<HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue>
					<LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue>
					<EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion>
					<UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits>
					<ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor>
					</ConvertingUnits></UnitValues><Analysis><Enums /><Counts />
					<New /></Analysis>'||(select xmlelement(name "SeriesMeta",xmlforest(m.display_value as "Value",m.display_unit as "Unit",m.display_label as "DisplayName")) as hi
		  from tm_lz.lt_src_rbm_display_mapping m where m.category_cd=ul.category_cd)||
					'</ValueMetadata>') where n.c_fullname=(select leaf_node from tm_wz.WT_RBM_NODES where category_cd=ul.category_cd  and leaf_node=n.c_fullname);
					
					end loop;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',rowCt,stepCt,'Done')into rtnCd;

	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	begin
	update i2b2metadata.i2b2 a
    set c_visualattributes = 'LAH'
	where a.c_basecode in (select distinct x.concept_code from deapp.DE_SUBJECT_SAMPLE_MAPPING x
						   where x.trial_name = TrialId
						     and x.platform = 'RBM'
							 and (x.concept_code IS NOT NULL AND x.concept_code::text <> ''));
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;  
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;
  
begin
    update i2b2metadata.i2b2 a
	set c_visualattributes='FAS'
        where a.c_fullname = substr(topNode,1,instr(topNode,'\',1,3));
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
        
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for study nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done');
    
  
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for rbm data
  
    perform tm_cz.i2b2_create_concept_counts(topNode ,jobID );
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done') into rtnCd;
	
	--	delete each node that is hidden

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time
	begin
		perform tm_cz.i2b2_delete_1_node(r_delNodes.c_fullname);
			get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;

	END LOOP;  	


  --Reload Security: Inserts one record for every I2B2 record into the security table

    perform tm_cz.i2b2_load_security_data(jobId);
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done') into rtnCd;

--	tag data with probeset_id from reference.probeset_deapp
  
	EXECUTE ('truncate table tm_wz.WT_SUBJECT_RBM_PROBESET');
	
	--	note: assay_id represents a unique subject/site/sample
	begin
	insert into tm_wz.WT_SUBJECT_RBM_PROBESET  --mod
    (probeset
--    ,expr_id
    ,intensity_value
    --  ,num_calls
    --  ,pvalue
        ,assay_id
        ,patient_id
        ,sample_id
    ,subject_id
    ,trial_name
        ,timepoint
        ,sample_type
        ,platform
        ,tissue_type    
    )
    select md.analyte
          ,avg(md.avalue)
                  ,sd.assay_id
                  ,sd.patient_id
          ,md.sample_id
                  ,sd.subject_id
                  ,TrialId
                  ,sd.timepoint
                  ,sd.sample_type
                  ,sd.gpl_id   --UAT_142 25/feb/14 changes
                  ,sd.tissue_type
    from deapp.de_subject_sample_mapping sd
        ,tm_lz.LT_SRC_RBM_DATA md
    where sd.sample_cd = md.sample_id
     and sd.platform = 'RBM'
      and sd.trial_name =TrialId
      and sd.source_cd = sourceCd
     -- and sd.gpl_id = gs.id_ref   --check
    --and trim(substr(md.analyte,1,instr(md.analyte,'(')-1)) =trim(gs.antigen_name)
    and (CASE WHEN dataType = 'R' THEN sign(md.avalue) ELSE 1 END) <> -1  --UAT 154 changes done on 19/03/2014
    and sd.subject_id in (select subject_id from tm_lz.LT_SRC_RBM_SUBJ_SAMP_MAP)
    group by md.analyte
          ,sd.patient_id,sd.assay_id
                  ,md.sample_id
                  ,sd.subject_id
                  ,sd.timepoint
                  ,sd.sample_type
                  ,sd.gpl_id
                  ,sd.tissue_type;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_rbm_probeset',rowCt,stepCt,'Done') into rtnCd;
	
--mod

	--	Calculate ZScores and insert data into de_subject_rbm_data.  The 'L' parameter indicates that the gene expression data will be selected from
	--	wt_subject_rbm_probeset as part of a Load.  

		if dataType = 'R' or dataType = 'L' then
			perform tm_cz.i2b2_rbm_zscore_calc_new(TrialID, partitionName, partitionindx,partitioniD,'L',jobId,dataType,logBase,sourceCD);
			stepCt := stepCt + 1;
			select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',0,stepCt,'Done') into rtnCd;
		end if;

    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_LOAD_RBM_DATA',0,stepCt,'Done') into rtnCd;

	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 0 ; 
END;
 
$$;


ALTER FUNCTION tm_cz.i2b2_load_rbm_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base numeric, secure_study character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_load_sample_categories(bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_sample_categories(currentjobid bigint DEFAULT NULL::bigint) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE



	--Audit variables
	newJobFlag integer(1);
	databaseName varchar(100);
	procedureName varchar(100);
	jobID bigint;
	stepCt bigint;

	--	JEA@20110916	New
	--	JEA@20120209	Remove insert of sample to patient_dimension

	--
	-- Copyright ? 2011 Recombinant Data Corp.
	--


BEGIN
    
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
  
	--	delete any data for study in sample_categories_extrnl from lz_src_sample_categories
	
	delete from lz_src_sample_categories
	where trial_cd in (select distinct trial_cd from lt_src_sample_categories);
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted existing study data in lz_src_sample_categories',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

/*	
	--	create records in patient_dimension for samples if they do not exist
	--	format of sourcesystem_cd:  trial:S:[site:]subject_cd:sample_cd
	--	if no sample_cd specified, then the patient_num of the trial:[site]:subject_cd should have already been created
	
	insert into patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select seq_patient_num.nextval,
		   null as sex_cd,
		   0 as age_in_years_num,
		   null as race_cd,
		   sysdate,
		   sysdate,
		   sysdate,
		   regexp_replace(s.trial_cd || ':S:' || s.site_cd || ':' || s.subject_cd || ':' || s.sample_cd,
						  '(::){1,}', ':')
	from (select distinct trial_cd
	             ,site_cd
				 ,subject_cd
				 ,sample_cd
		  from sample_categories_extrnl s
		  where s.sample_cd is not null
			and not exists
				(select 1 from patient_dimension x
				 where x.sourcesystem_cd = 
					   regexp_replace(s.trial_cd || ':S:' || s.site_cd || ':' || s.subject_cd || ':' || s.sample_cd,
					 '(::){1,}', ':'))
		  ) s;
			
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Added new sample_cds for study in I2B2DEMODATA patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
	commit;
*/

	--	Load data into lz_src_sample_categories table, joins to make sure study/trial exists and there's an entry in the patient_dimension
	
	insert into lz_src_sample_categories
	(trial_cd
	,site_cd
	,subject_cd
	,sample_cd
	,category_cd
	,category_value
	)
	PERFORM distinct s.trial_cd
		  ,s.site_cd
		  ,s.subject_cd
		  ,s.sample_cd
		  ,replace(s.category_cd,'"',null)
		  ,replace(s.category_value,'"',null)
	from lt_src_sample_categories s
	where replace(s.category_cd,'"',null) is not null
	  and replace(s.category_value,'"',null) is not null
	  and s.trial_cd in (select distinct x.sourcesystem_cd from i2b2 x)
	;
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted sample data in lz_src_sample_categories',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	if newjobflag = 1
	then
		cz_end_audit (jobID, 'SUCCESS');
	end if;

	exception
	when others then
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		
		--End Proc
		cz_end_audit (jobID, 'FAIL');
	
END;
 
$_$;


ALTER FUNCTION tm_cz.i2b2_load_sample_categories(currentjobid bigint) OWNER TO tm_cz;

--
-- Name: i2b2_load_security_data(numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_security_data(currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;

BEGIN

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_SECURITY';
	
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobId;
	END IF;

	Execute  ('truncate table I2B2METADATA.i2b2_secure');

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Truncate I2B2METADATA i2b2_secure',0,stepCt,'Done') into rtnCd;

	insert into I2B2METADATA.i2b2_secure
	(C_HLEVEL,
     C_FULLNAME,
     C_NAME,
     C_SYNONYM_CD,
     C_VISUALATTRIBUTES,
     C_TOTALNUM,
     C_BASECODE,
     C_METADATAXML,
     C_FACTTABLECOLUMN,
     C_TABLENAME,
     C_COLUMNNAME,
     C_COLUMNDATATYPE,
     C_OPERATOR,
     C_DIMCODE,
     C_COMMENT,
     C_TOOLTIP,
     UPDATE_DATE,
     DOWNLOAD_DATE,
     IMPORT_DATE,
     SOURCESYSTEM_CD,
     VALUETYPE_CD,
	 secure_obj_token)
  select
    b.C_HLEVEL,
    b.C_FULLNAME,
    b.C_NAME,
    b.C_SYNONYM_CD,
    b.C_VISUALATTRIBUTES,
    b.C_TOTALNUM,
    b.C_BASECODE,
    b.C_METADATAXML,
    b.C_FACTTABLECOLUMN,
    b.C_TABLENAME,
    b.C_COLUMNNAME,
    b.C_COLUMNDATATYPE,
    b.C_OPERATOR,
    b.C_DIMCODE,
    b.C_COMMENT,
    b.C_TOOLTIP,
    b.UPDATE_DATE,
    b.DOWNLOAD_DATE,
    b.IMPORT_DATE,
    b.SOURCESYSTEM_CD,
    b.VALUETYPE_CD,
	coalesce(f.tval_char,'EXP:PUBLIC')
    from I2B2METADATA.I2B2 b
	left outer join (select distinct modifier_cd, tval_char from i2b2demodata.observation_fact where concept_cd = 'SECURITY') f
		 on b.sourcesystem_cd = f.modifier_cd;
	get diagnostics rowCt := ROW_COUNT;
    stepCt := stepCt + 1;
    select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert security data into I2B2METADATA i2b2_secure',rowCt,stepCt,'Done') into rtnCd;

    ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_load_security_data(currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_load_security_data(character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_security_data(sourcesystemcd character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;

BEGIN
	--Set Audit Parameters
	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_SECURITY';

	select case when coalesce(currentjobid, -1) < 1 then tm_cz.cz_start_audit(procedureName, databaseName) else currentjobid end into jobId;

	delete from I2B2METADATA.i2b2_secure where sourcesystem_cd = sourcesystemCd;

  get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	perform tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Clean-up I2B2METADATA i2b2_secure',rowCt,stepCt,'Done');

	insert into I2B2METADATA.i2b2_secure
	(C_HLEVEL,
     C_FULLNAME,
     C_NAME,
     C_SYNONYM_CD,
     C_VISUALATTRIBUTES,
     C_TOTALNUM,
     C_BASECODE,
     C_METADATAXML,
     C_FACTTABLECOLUMN,
     C_TABLENAME,
     C_COLUMNNAME,
     C_COLUMNDATATYPE,
     C_OPERATOR,
     C_DIMCODE,
     C_COMMENT,
     C_TOOLTIP,
     UPDATE_DATE,
     DOWNLOAD_DATE,
     IMPORT_DATE,
     SOURCESYSTEM_CD,
     VALUETYPE_CD,
	 secure_obj_token)
  select
    b.C_HLEVEL,
    b.C_FULLNAME,
    b.C_NAME,
    b.C_SYNONYM_CD,
    b.C_VISUALATTRIBUTES,
    b.C_TOTALNUM,
    b.C_BASECODE,
    b.C_METADATAXML,
    b.C_FACTTABLECOLUMN,
    b.C_TABLENAME,
    b.C_COLUMNNAME,
    b.C_COLUMNDATATYPE,
    b.C_OPERATOR,
    b.C_DIMCODE,
    b.C_COMMENT,
    b.C_TOOLTIP,
    b.UPDATE_DATE,
    b.DOWNLOAD_DATE,
    b.IMPORT_DATE,
    b.SOURCESYSTEM_CD,
    b.VALUETYPE_CD,
	coalesce(f.tval_char,'EXP:PUBLIC')
    from I2B2METADATA.I2B2 b
	left outer join (select distinct modifier_cd, tval_char from i2b2demodata.observation_fact where concept_cd = 'SECURITY') f
		 on b.sourcesystem_cd = f.modifier_cd
	where b.sourcesystem_cd = sourcesystemCd;

	get diagnostics rowCt := ROW_COUNT;
  stepCt := stepCt + 1;
  perform tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert security data into I2B2METADATA i2b2_secure',rowCt,stepCt,'Done');

    ---Cleanup OVERALL JOB if this proc is being run standalone
	perform tm_cz.cz_end_audit (jobID, 'SUCCESS') where coalesce(currentJobId, -1) <> jobId;

	return 1;

	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);
		--End Proc
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_load_security_data(sourcesystemcd character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_load_study_metadata(numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_load_study_metadata(currentjobid numeric DEFAULT (-1)) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
declare
  
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	
	dcount 				int;
	lcount 				int;
	upload_date			timestamp;
	tmp_compound		varchar(200);
	tmp_disease			varchar(200);
	tmp_organism		varchar(200);
	tmp_pubmed			varchar(2000);
	pubmed_id			varchar(200);
	pubmed_title		varchar(2000);
	
	study_compound_rec	record;
	study_disease_rec	record;
	study_taxonomy_rec  record;
	study_pubmed_rec 	record;

BEGIN

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	databaseName := 'tm_cz';
	procedureName := 'i2b2_load_study_metadata';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done') into rtnCd;

	select clock_timestamp() into upload_date;
 
	--	Update existing bio_experiment data
	
	begin
	with upd as (select m.study_id
				,m.title
				,m.description
				,m.design
				,case when tm_cz.is_date(m.start_date,'YYYYMMDD') = 1 then null
					  else to_date(m.start_date,'YYYYMMDD') end as start_date
				,case when tm_cz.is_date(m.completion_date,'YYYYMMDD') = 1 then null
					  else to_date(m.completion_date,'YYYYMMDD') end as completion_date
				,coalesce(m.primary_investigator,m.study_owner) as primary_investigator
				,m.overall_design
				,m.institution
				,m.country
				from tm_lz.lt_src_study_metadata m
				where m.study_id is not null)
	update biomart.bio_experiment b
	set title=upd.title
	    ,description=upd.description
		,design=upd.design
		,start_date=upd.start_date
		,completion_date=upd.completion_date
		,primary_investigator=upd.primary_investigator
		,overall_design=upd.overall_design
		,institution=upd.institution
		,country=upd.country 
	from upd
	where b.accession = upd.study_id
	  and b.etl_id = 'METADATA:' || upd.study_id;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Updated trial data in BIOMART bio_experiment',rowCt,stepCt,'Done') into rtnCd;

/*	
	--	Update existing bio_clinical_trial data only for true Clinical Trials or JnJ Experimental Medicine Studies

	update biomart.bio_clinical_trial b
	set (study_owner
	    ,study_phase
		,blinding_procedure
		,studytype
		,duration_of_study_weeks
		,number_of_patients
		,number_of_sites
		,route_of_administration
		,dosing_regimen
		,group_assignment
		,type_of_control
		,completion_date
		,primary_end_points
		,secondary_end_points
		,inclusion_criteria
		,exclusion_criteria
		,subjects
		,gender_restriction_mfb
		,min_age
		,max_age
		,secondary_ids
		,development_partner
		,main_findings
		,geo_platform
		--,platform_name
		,search_area
        ) =
		(select m.study_owner
			   ,m.study_phase
			   ,m.blinding_procedure
			   ,m.studytype
			   ,decode(is_number(m.duration_of_study_weeks),1,null,to_number(m.duration_of_study_weeks))
			   ,decode(is_number(m.number_of_patients),1,null,to_number(m.number_of_patients))
			   ,decode(is_number(m.number_of_sites),1,null,to_number(m.number_of_sites))
			   ,m.route_of_administration
			   ,m.dosing_regimen
			   ,m.group_assignment
			   ,m.type_of_control
			   ,decode(is_date(m.completion_date,'YYYYMMDD'),1,null,to_date(m.completion_date,'YYYYMMDD'))
			   ,m.primary_end_points
			   ,m.secondary_end_points
			   ,m.inclusion_criteria
			   ,m.exclusion_criteria
			   ,m.subjects
			   ,m.gender_restriction_mfb
			   ,decode(is_number(m.min_age),1,null,to_number(m.min_age))
			   ,decode(is_number(m.max_age),1,null,to_number(m.max_age))
			   ,m.secondary_ids
			   ,m.development_partner
			   ,m.main_findings
			   ,m.geo_platform
			   --,m.platform_name
			   ,m.search_area
		 from lt_src_study_metadata m
		 where m.study_id is not null
		   and b.trial_number = m.study_id
		)
	where exists
	     (select 1 from lt_src_study_metadata x
		  where b.trial_number = x.study_id
		    and x.study_id is not null
		 )
	;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Updated study data in BIOMART bio_clinical_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
*/
	
	--	Add new trial data to bio_experiment
	
	begin
	insert into biomart.bio_experiment
	(bio_experiment_type
	,title
	,description
	,design
	,start_date
	,completion_date
	,primary_investigator
	,contact_field
	,etl_id
	,status
	,overall_design
	,accession
	,country
	,institution)
	select 'Experiment'
	      ,m.title
		  ,m.description
		  ,m.design
		  ,case when tm_cz.is_date(m.start_date,'YYYYMMDD') = 1 then null
				else to_date(m.start_date,'YYYYMMDD') end as start_date
		  ,case when tm_cz.is_date(m.completion_date,'YYYYMMDD') = 1 then null
				else to_date(m.completion_date,'YYYYMMDD') end as completion_date
		  ,coalesce(m.primary_investigator,m.study_owner) as primary_investigator
		  ,m.contact_field
		  ,'METADATA:' || m.study_id
		  ,m.study_id
		  ,m.overall_design
		  ,m.study_id
		  ,m.country
		  ,m.institution
	from tm_lz.lt_src_study_metadata m
	where m.study_id is not null
	  and not exists
	      (select 1 from biomart.bio_experiment x
		   where m.study_id = x.accession
		     and m.study_id is not null);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study to BIOMART bio_experiment',rowCt,stepCt,'Done') into rtnCd;

/*		
	--	Add new trial data to bio_clinical_trial
	
	insert into biomart.bio_clinical_trial
	(trial_number
	,study_owner
	,study_phase
	,blinding_procedure
	,studytype
	,duration_of_study_weeks
	,number_of_patients
	,number_of_sites
	,route_of_administration
	,dosing_regimen
	,group_assignment
	,type_of_control
	,completion_date
	,primary_end_points
	,secondary_end_points
	,inclusion_criteria
	,exclusion_criteria
	,subjects
	,gender_restriction_mfb
	,min_age
	,max_age
	,secondary_ids
	,bio_experiment_id
	,development_partner
	,main_findings
	,geo_platform
	--,platform_name
	,search_area
	)
	select m.study_id
          ,m.study_owner
          ,m.study_phase
          ,m.blinding_procedure
          ,m.studytype
		  ,decode(is_number(m.duration_of_study_weeks),1,null,to_number(m.duration_of_study_weeks))
		  ,decode(is_number(m.number_of_patients),1,null,to_number(m.number_of_patients))
		  ,decode(is_number(m.number_of_sites),1,null,to_number(m.number_of_sites))
          ,m.route_of_administration
          ,m.dosing_regimen
          ,m.group_assignment
          ,m.type_of_control
          ,decode(is_date(m.completion_date,'YYYYMMDD'),1,null,to_date(m.completion_date,'YYYYMMDD'))
          ,m.primary_end_points
          ,m.secondary_end_points
          ,m.inclusion_criteria
          ,m.exclusion_criteria
          ,m.subjects
          ,m.gender_restriction_mfb
		  ,decode(is_number(m.min_age),1,null,to_number(m.min_age))
		  ,decode(is_number(m.max_age),1,null,to_number(m.max_age))
          ,m.secondary_ids
          ,b.bio_experiment_id
		  ,m.development_partner
		  ,m.main_findings
		  ,m.geo_platform
		  --,m.platform_name
		  ,m.search_area
	from lt_src_study_metadata m
	    ,biomart.bio_experiment b
	where m.study_id is not null
	  and m.study_id = b.accession
	  and not exists
	      (select 1 from biomart.bio_clinical_trial x
		   where m.study_id = x.trial_number);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data in BIOMART bio_clinical_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
*/
	
	--	Insert new trial into bio_data_uid
	
	begin
	insert into biomart.bio_data_uid
	(bio_data_id
	,unique_id
	,bio_data_type
	)
	select distinct b.bio_experiment_id
	      ,'EXP:' || m.study_id
		  ,'EXP'
	from biomart.bio_experiment b
		,tm_lz.lt_src_study_metadata m
	where m.study_id is not null
	  and m.study_id = b.accession
	  and not exists
	      (select 1 from biomart.bio_data_uid x
		   where x.unique_id = 'EXP:' || m.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Added study to bio_data_uid',rowCt,stepCt,'Done') into rtnCd;

	--	delete existing compound data for study, compound list may change
	
	begin
	delete from biomart.bio_data_compound dc
	where dc.bio_data_id in 
		 (select x.bio_experiment_id
		  from biomart.bio_experiment x
			  ,tm_lz.lt_src_study_metadata y
		  where x.accession = y.study_id
		    and x.etl_id = 'METADATA:' || y.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete existing study data from bio_compound',rowCt,stepCt,'Done') into rtnCd;

	--	add study compound data
	
	for study_compound_rec in
		select distinct study_id
			  ,compound
		from tm_lz.lt_src_study_metadata
		where compound is not null
	loop
		select length(study_compound_rec.compound)-length(replace(study_compound_rec.compound,';',''))+1 into dcount;
		while dcount > 0
		Loop	
			select tm_cz.parse_nth_value(study_compound_rec.compound,dcount,';') into tmp_compound;
			   
			--	add new compound
			begin
			insert into biomart.bio_compound
			(generic_name)
			select tmp_compound
			where not exists
				 (select 1 from biomart.bio_compound x
				  where upper(x.generic_name) = upper(tmp_compound))
			  and tmp_compound is not null;
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study compound to bio_compound',rowCt,stepCt,'Done') into rtnCd;
					
			--	Insert new trial data into bio_data_compound
			begin
			insert into biomart.bio_data_compound
			(bio_data_id
			,bio_compound_id
			,etl_source
			)
			select b.bio_experiment_id
				  ,c.bio_compound_id
				  ,'METADATA:' || study_compound_rec.study_id
			from biomart.bio_experiment b
				,biomart.bio_compound c
			where upper(tmp_compound) = upper(c.generic_name) 
			  and tmp_compound is not null
			  and b.accession = study_compound_rec.study_id
			  and not exists
					 (select 1 from biomart.bio_data_compound x
						  where b.bio_experiment_id = x.bio_data_id
							and c.bio_compound_id = x.bio_compound_id);
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study compound to bio_data_compound',rowCt,stepCt,'Done') into rtnCd;			
			dcount := dcount - 1;
		end loop;
	end loop;

	--	delete existing disease data for studies
	
	begin
	delete from biomart.bio_data_disease dc
	where dc.bio_data_id in 
		 (select x.bio_experiment_id
		  from biomart.bio_experiment x
			  ,tm_lz.lt_src_study_metadata y
		  where x.accession = y.study_id
		    and x.etl_id = 'METADATA:' || y.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete existing study data from bio_data_disease',rowCt,stepCt,'Done') into rtnCd;

	--	add study disease data
	
	for study_disease_rec in
		select distinct study_id, disease
		from tm_lz.lt_src_study_metadata
		where disease is not null
	loop
		select length(study_disease_rec.disease)-length(replace(study_disease_rec.disease,';',''))+1 into dcount;
		while dcount > 0
		Loop	
			select tm_cz.parse_nth_value(study_disease_rec.disease,dcount,';') into tmp_disease;
			   
			--	add new disease
			begin
			insert into biomart.bio_disease
			(disease
			,prefered_name)
			select tmp_disease
				  ,tmp_disease
			where not exists
				 (select 1 from biomart.bio_disease x
				  where upper(x.disease) = upper(tmp_disease))
			  and tmp_disease is not null;
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study disease to bio_disease',rowCt,stepCt,'Done') into rtnCd;
			
			--	Insert new trial data into bio_data_disease
			begin
			insert into biomart.bio_data_disease
			(bio_data_id
			,bio_disease_id
			,etl_source
			)
			select b.bio_experiment_id
				  ,c.bio_disease_id
				  ,'METADATA:' || study_disease_rec.study_id
			from biomart.bio_experiment b
				,biomart.bio_disease c
			where upper(tmp_disease) = upper(c.disease) 
			  and tmp_disease is not null
			  and b.accession = study_disease_rec.study_id
			  and not exists
					 (select 1 from biomart.bio_data_disease x
					  where b.bio_experiment_id = x.bio_data_id
						and c.bio_disease_id = x.bio_disease_id);
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study disease to bio_data_disease',rowCt,stepCt,'Done') into rtnCd;
			dcount := dcount - 1;
		end loop;
	end loop;

	--	delete existing taxonomy data for studies
	
	begin
	delete from biomart.bio_data_taxonomy dc
	where dc.bio_data_id in 
		 (select x.bio_experiment_id
		  from biomart.bio_experiment x
			  ,tm_lz.lt_src_study_metadata y
		  where x.accession = y.study_id
		    and x.etl_id = 'METADATA:' || y.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete existing study data from bio_data_taxonomy',rowCt,stepCt,'Done') into rtnCd;

	--	add study organism to taxonomy
	
	for study_taxonomy_rec in
		select distinct study_id, organism
		from tm_lz.lt_src_study_metadata
		where organism is not null
	loop
		select length(study_taxonomy_rec.organism)-length(replace(study_taxonomy_rec.organism,';',''))+1 into dcount;
		while dcount > 0
		Loop	
			select tm_cz.parse_nth_value(study_taxonomy_rec.organism,dcount,';') into tmp_organism;
			   
			--	add new organism
			begin
			insert into biomart.bio_taxonomy
			(taxon_name
			,taxon_label)
			select tmp_organism
				  ,tmp_organism
			where not exists
				 (select 1 from biomart.bio_taxonomy x
				  where upper(x.taxon_name) = upper(tmp_organism))
			  and tmp_organism is not null;
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study organism to bio_taxonomy',rowCt,stepCt,'Done') into rtnCd;
							
			--	Insert new trial data into bio_data_taxonomy
			begin
			insert into biomart.bio_data_taxonomy
			(bio_data_id
			,bio_taxonomy_id
			,etl_source
			)
			select b.bio_experiment_id
				  ,c.bio_taxonomy_id
				  ,'METADATA:' || study_disease_rec.study_id
			from biomart.bio_experiment b
				,biomart.bio_taxonomy c
			where upper(tmp_organism) = upper(c.taxon_name) 
			  and tmp_organism is not null
			  and b.accession = study_disease_rec.study_id
			  and not exists
					 (select 1 from biomart.bio_data_taxonomy x
					  where b.bio_experiment_id = x.bio_data_id
						and c.bio_taxonomy_id = x.bio_taxonomy_id);
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study organism to bio_data_taxonomy',rowCt,stepCt,'Done') into rtnCd;

			dcount := dcount - 1;
		end loop;
	end loop;
	
	--	add ncbi/GEO linking
	
	--	check if ncbi exists in bio_content_repository, if not, add
	
	select count(*) into dcount
	from biomart.bio_content_repository
	where repository_type = 'NCBI'
	  and location_type = 'URL';
	
	if dcount = 0 then
		begin
		insert into biomart.bio_content_repository
		(location
		,active_y_n
		,repository_type
		,location_type) 
		values ('http://www.ncbi.nlm.nih.gov/','Y','NCBI','URL');
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		get diagnostics rowCt := ROW_COUNT;	
		end;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert link to NCBI into bio_content_repository',rowCt,stepCt,'Done') into rtnCd;
	end if;

	--	insert GSE studies into bio_content
	
	begin
	insert into biomart.bio_content
	(repository_id
	,location
	,file_type
	,etl_id_c
	)
	select bcr.bio_content_repo_id
		  ,'geo/query/acc.cgi?acc=' || m.study_id
		  ,'Experiment Web Link'
		  ,'METADATA:' || m.study_id
	from tm_lz.lt_src_study_metadata m
		,biomart.bio_content_repository bcr
	where m.study_id like 'GSE%'
	  and bcr.repository_type = 'NCBI'
	  and bcr.location_type = 'URL'
	  and not exists
		 (select 1 from biomart.bio_content x
		  where x.etl_id_c like '%' || m.study_id || '%'
		    and x.file_type = 'Experiment Web Link'
			and x.location = 'geo/query/acc.cgi?acc=' || m.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add GEO study to bio_cotent',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert GSE studies into bio_content_reference
	
	begin
	insert into biomart.bio_content_reference
	(bio_content_id
	,bio_data_id
	,content_reference_type
	,etl_id_c
	)
	select bc.bio_file_content_id
		  ,be.bio_experiment_id
		  ,'Experiment Web Link'
		  ,'METADATA:' || m.study_id
	from tm_lz.lt_src_study_metadata m
		,biomart.bio_experiment be
		,biomart.bio_content bc
	where m.study_id like 'GSE%'
	  and m.study_id = be.accession
	  and bc.file_type = 'Experiment Web Link'
	  and bc.etl_id_c = 'METADATA:' || m.study_id
	  and bc.location = 'geo/query/acc.cgi?acc=' || m.study_id
	  and not exists
		 (select 1 from biomart.bio_content_reference x
		  where bc.bio_file_content_id = x.bio_content_id
		    and be.bio_experiment_id = x.bio_data_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Added GEO study to bio_content_reference',rowCt,stepCt,'Done') into rtnCd;

	--	add PUBMED linking
	
	--	delete existing pubmed data for studies
	
	begin
	delete from biomart.bio_content_reference dc
	where dc.bio_content_id in 
		 (select x.bio_file_content_id
		  from biomart.bio_content x
			  ,tm_lz.lt_src_study_metadata y
		  where x.file_type = 'Publication Web Link'
		    and x.etl_id_c = 'METADATA:' || y.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete existing study pubmed from bio_content_reference',rowCt,stepCt,'Done') into rtnCd;
		
	begin
	delete from biomart.bio_content dc
	where dc.bio_file_content_id in 
		 (select x.bio_file_content_id
		  from biomart.bio_content x
			  ,tm_lz.lt_src_study_metadata y
		  where x.file_type = 'Publication Web Link'
		    and x.etl_id_c = 'METADATA:' || y.study_id);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete existing study pubmed from bio_content',rowCt,stepCt,'Done') into rtnCd;

	--	add study pubmed ids'
	
	select count(*) into dcount
	from biomart.bio_content_repository
	where repository_type = 'PubMed';	
	
	if dcount = 0 then
		begin
		insert into biomart.bio_content_repository
		(location
		,active_y_n
		,repository_type
		,location_type) 
		values ('http://www.ncbi.nlm.nih.gov/pubmed/','Y','PubMed','URL');
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		get diagnostics rowCt := ROW_COUNT;	
		end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add pubmed url to bio_content_repository',rowCt,stepCt,'Done') into rtnCd;
	end if;
	
	for study_pubmed_rec in
		select distinct study_id, pubmed_ids
		from tm_lz.lt_src_study_metadata
		where pubmed_ids is not null
	loop
		select length(study_pubmed_rec.pubmed_ids)-length(replace(study_pubmed_rec.pubmed_ids,'|',''))+1 into dcount;
		while dcount > 0
		Loop	
			-- multiple pubmed id can be separated by |, pubmed id and title are separated by :
			
			select tm_cz.parse_nth_value(study_pubmed_rec.pubmed_ids,dcount,'|') into tmp_pubmed;			
			select tm_cz.instr(tmp_pubmed,'@') into lcount;
			
			if lcount = 0 then
				pubmed_id := tmp_pubmed;
				pubmed_title := null;
			else
				pubmed_id := substr(tmp_pubmed,1,instr(tmp_pubmed,'@')-1);	
				pubmed_title := substr(tmp_pubmed,instr(tmp_pubmed,'@')+1);
			end if;
			
			begin
			insert into biomart.bio_content
			(repository_id
			,location
			,title
			,file_type
			,etl_id_c
			)
			select bcr.bio_content_repo_id
				  ,pubmed_id
				  ,pubmed_title
				  ,'Publication Web Link'
				  ,'METADATA:' || study_pubmed_rec.study_id
			from biomart.bio_content_repository bcr
			where bcr.repository_type = 'PubMed'
			  and not exists
					 (select 1 from biomart.bio_content x
					  where x.etl_id_c like '%' || study_pubmed_rec.study_id || '%'
					    and x.file_type = 'Publication Web Link'
						and x.location = pubmed_id);
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study pubmed to bio_content',rowCt,stepCt,'Done') into rtnCd;
		
			begin
			insert into biomart.bio_content_reference
			(bio_content_id
			,bio_data_id
			,content_reference_type
			,etl_id_c
			)
			select bc.bio_file_content_id
				  ,be.bio_experiment_id
				  ,'Publication Web Link'
				  ,'METADATA:' || study_pubmed_rec.study_id
			from biomart.bio_experiment be
				,biomart.bio_content bc
			where be.accession = study_pubmed_rec.study_id
			  and bc.file_type = 'Publication Web Link'
			  and bc.etl_id_c = 'METADATA:' || study_pubmed_rec.study_id
			  and bc.location = pubmed_id
			  and not exists
				 (select 1 from biomart.bio_content_reference x
				  where bc.bio_file_content_id = x.bio_content_id
					and be.bio_experiment_id = x.bio_data_id);	
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			get diagnostics rowCt := ROW_COUNT;	
			end;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study pubmed to bio_content_reference',rowCt,stepCt,'Done') into rtnCd;
			dcount := dcount - 1;
		end loop;
	end loop;
	
		--	Create i2b2_tags

	begin
	delete from i2b2metadata.i2b2_tags
	where upper(tag_type) = 'Trial';
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete study from i2b2_tags',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into i2b2metadata.i2b2_tags
	(tag_id, path, tag, tag_type, tags_idx)
	select nextval('i2b2metadata.sq_i2b2_tag_id')
		  ,min(b.c_fullname) as path
		  ,be.accession as tag
		  ,'Trial' as tag_type
		  ,0 as tags_idx
	from biomart.bio_experiment be
		,i2b2metadata.i2b2 b
	where be.accession = b.sourcesystem_cd
	group by be.accession;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Add study to i2b2_tags',rowCt,stepCt,'Done') into rtnCd;

/*					 
	--	Insert trial data tags - COMPOUND
	
	delete from i2b2_tags t
	where upper(t.tag_type) = 'COMPOUND';

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete existing Compound tags in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	insert into i2b2_tags
	(path, tag, tag_type, tags_idx)
	select distinct min(o.c_fullname) as path
		  ,decode(x.rec_num,1,c.generic_name,c.brand_name) as tag
		  ,'Compound' as tag_type
		  ,1 as tags_idx
	from bio_experiment be
		,bio_data_compound bc
		,bio_compound c
		,i2b2 o
		,(select rownum as rec_num from table_access where rownum < 3) x
	where be.bio_experiment_id = bc.bio_data_id
       and bc.bio_compound_id = c.bio_compound_id
       and be.accession = o.sourcesystem_cd
       and decode(x.rec_num,1,c.generic_name,c.brand_name) is not null
	group by decode(x.rec_num,1,c.generic_name,c.brand_name);

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert Compound tags in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
					 
	--	Insert trial data tags - DISEASE
	
	delete from i2b2_tags t
	where upper(t.tag_type) = 'DISEASE';

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete existing DISEASE tags in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
		
	insert into i2b2_tags
	(path, tag, tag_type, tags_idx)
	select distinct min(o.c_fullname) as path
		   ,c.prefered_name
		   ,'Disease' as tag_type
		   ,1 as tags_idx
	from bio_experiment be
		,bio_data_disease bc
		,bio_disease c
		,i2b2 o
      --,(select rownum as rec_num from table_access where rownum < 3) x
	where be.bio_experiment_id = bc.bio_data_id
      and bc.bio_disease_id = c.bio_disease_id
      and be.accession = o.sourcesystem_cd
    --and decode(x.rec_num,1,c.generic_name,c.brand_name) is not null
	group by c.prefered_name;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert Disease tags in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
*/
	
    ---Cleanup OVERALL JOB if this proc is being run standalone

	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.czx_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;
	
END;

$$;


ALTER FUNCTION tm_cz.i2b2_load_study_metadata(currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_metabolomics_zscore_calc(character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying DEFAULT 'L'::character varying, currentjobid numeric DEFAULT (-1), data_type character varying DEFAULT 'R'::character varying, log_base numeric DEFAULT 2) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
This Stored Procedure is used in ETL load METABOLOMICS data
Date:1/3/2014
******************************************************************/

  TrialID varchar(100);
  sourceCD	varchar(50);
  sqlText varchar(2000);
  runType varchar(10);
  dataType varchar(10);
  stgTrial varchar(100);
  idxExists numeric;
  pExists	numeric;
  nbrRecs numeric;
  logBase numeric;
   
  --Audit variables
  newJobFlag integer(1);
  databaseName varchar(100);
  procedureName varchar(100);
  jobID numeric;
  stepCt numeric;
  
  --  exceptions
  invalid_runType exception;
  trial_mismatch exception;
  trial_missing exception;
  

BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	  RAISE NOTICE 'DK0';
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
   
  stepCt := 0;
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done');
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting'
,SQL%ROWCOUNT,stepCt,'Done');
		raise invalid_runType;
	end if;
  
--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_METABOLOMICS_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from WT_SUBJECT_MBOLOMICS_PROBESET;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in WT_SUBJECT_MBOLOMICS_PROBESET - procedure exiting'
,SQL%ROWCOUNT,stepCt,'Done');
			--raise trial_mismatch;
		end if;
	end if;

/*	remove Reload processing
--	For Reload, make sure that the TrialId passed as parameter has data in de_subject_METABOLOMICS_data
--	If not, raise exception

	if runType = 'R' then
		select count(*) into idxExists
		from DE_SUBJECT_METABOLOMICS_DATA
  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
   
  stepCt := 0;
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done');
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting',SQL%ROWCOUNT,stepCt,'Done');
		raise invalid_runType;
	end if;
  
		where trial_name = TrialId;
		
		if idxExists = 0 then
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'No data for TrialId in DE_SUBJECT_METABOLOMICS_DATA - procedure exiting',SQL%ROWCOUNT,stepCt,'Done');
			raise trial_missing;
		end if;
	end if;
*/
   
--	truncate tmp tables

	EXECUTE('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_LOGS');
	EXECUTE('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_CALCS');
	EXECUTE('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_MED');

	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'WT_SUBJECT_METABOLOMICS_LOGS'
	  and index_name = 'WT_SUBJECT_MBOLOMICS_LOGS_I1'
	  and owner = 'TM_WZ';

	if idxExists = 1 then
		EXECUTE('drop index tm_wz.WT_SUBJECT_MBOLOMICS_LOGS_I1');		
	end if;
	
	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'WT_SUBJECT_METABOLOMICS_CALCS'
	  and index_name = 'WT_SUBJECT_METABOLOMICS_CALCS_I1'
	  and owner = 'TM_WZ';

	if idxExists = 1 then
		EXECUTE('drop index tm_wz.WT_SUBJECT_METABOLOMICS_CALCS_I1');
	end if;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value


	if dataType = 'L' then

		insert into WT_SUBJECT_METABOLOMICS_LOGS 
			(probeset
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
			,subject_id
			)
			PERFORM probeset
				  ,intensity_value  
				  ,assay_id 
				  ,intensity_value
				  ,patient_id
			--	  ,sample_cd
				  ,subject_id
			from WT_SUBJECT_MBOLOMICS_PROBESET
			where trial_name = TrialId;
           
		--end if;
	else	

                	insert into WT_SUBJECT_METABOLOMICS_LOGS 
			(probeset
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
			,subject_id
			)
			PERFORM probeset
				  ,intensity_value 
				  ,assay_id 
				  ,log(2,intensity_value)
				  ,patient_id
		--		  ,sample_cd
				  ,subject_id
			from WT_SUBJECT_MBOLOMICS_PROBESET
			where trial_name = TrialId;
--		end if;

	end if;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_mirna_logs',SQL%ROWCOUNT,stepCt,'Done');

	commit;

	EXECUTE('create index tm_wz.WT_SUBJECT_MBOLOMICS_LOGS_I1 on tm_wz.WT_SUBJECT_METABOLOMICS_LOGS (trial_name, probeset) nologging  tablespace "INDX"');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_MBOLOMICS_LOGS_I1',0,stepCt,'Done');
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe

	insert into WT_SUBJECT_METABOLOMICS_CALCS
	(trial_name
	,probeset
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
	PERFORM d.trial_name 
		  ,d.probeset
		  ,avg(log_intensity)
		  ,median(log_intensity)
		  ,stddev(log_intensity)
	from WT_SUBJECT_METABOLOMICS_LOGS d 
	group by d.trial_name 
			,d.probeset;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ WT_SUBJECT_METABOLOMICS_CALCS',SQL%ROWCOUNT,stepCt,'Done');

	commit;

	--execute immediate('create index tm_wz.wt_subject_METABOLOMICS_calcs_i1 on tm_wz.WT_SUBJECT_METABOLOMICS_CALCS (trial_name, probeset_id) nologging tablespace "INDX"');
	--stepCt := stepCt + 1;
	--cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_METABOLOMICS_CALCS',0,stepCt,'Done');
		
-- calculate zscore

	
        insert into WT_SUBJECT_METABOLOMICS_MED parallel 
	(probeset
	,intensity_value
	,log_intensity
	,assay_id
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,patient_id
--	,sample_cd
	,subject_id
	)
	PERFORM d.probeset
		  ,d.intensity_value 
		  ,d.log_intensity 
		  ,d.assay_id  
		  ,c.mean_intensity 
		  ,c.stddev_intensity 
		  ,c.median_intensity 
		  ,(CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END)
		  ,d.patient_id
	--	  ,d.sample_cd
		  ,d.subject_id
    from WT_SUBJECT_METABOLOMICS_LOGS d 
		,WT_SUBJECT_METABOLOMICS_CALCS c 
    where trim(d.probeset) = c.probeset;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ WT_SUBJECT_METABOLOMICS_MED',SQL%ROWCOUNT,stepCt,'Done');

    commit;

/*
	select count(*) into n
	select count(*) into nbrRecs
	from WT_SUBJECT_METABOLOMICS_MED;
	
	if nbrRecs > 10000000 then
		i2b2_mrna_index_maint('DROP',,jobId);
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on DEAPP de_subject_METABOLOMICS_data',0,stepCt,'Done');
	else
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Less than 10M records, index drop bypassed',0,stepCt,'Done');
	end if;
*/
	


/*
	insert into DE_SUBJECT_METABOLOMICS_DATA
	(
        trial_source
        ,trial_name
	,metabolite_annotation_id
	--,component
	--,gene_symbol
	--,gene_id
	,assay_id
	,subject_id
	,raw_intensity 
        ,log_intensity
	,zscore
	,patient_id
		)
                select m.trial_name || ':' || mpp.source_cd,
                  TrialID
                ,d.Id
		  ,m.assay_id
                  ,m.subject_id 
                  ,m.intensity_value
                  ,log(2,m.intensity_value)
			  ,case when m.intensity_value < -2.5
			        then -2.5
					when m.intensity_value > 2.5
					then 2.5
					else m.intensity_value
			   end as zscore
                           ,m.patient_id
                from WT_SUBJECT_MBOLOMICS_PROBESET  m,
                (select distinct mp.source_cd From "TM_LZ"."LT_SRC_METABOLOMIC_MAP" mp where rownum = 1 and mp.trial_name =TrialID) mpp
                ,DEAPP.DE_METABOLITE_ANNOTATION d
		where m.trial_name = TrialID
                and d.biochemical_name = m.probeset;
        */
        insert into DE_SUBJECT_METABOLOMICS_DATA
	(
        trial_source
	,trial_name
	,metabolite_annotation_id
	--,component
	--,gene_symbol
	--,gene_id
	,assay_id
	,subject_id
	,raw_intensity 
        ,log_intensity
	,zscore
	,patient_id
	)
	PERFORM 
                  TrialId || ':' || mpp.source_cd,
                  TrialId
                 ,d.id
                 --,m.probeset_id 
                 --,d.hmdb_id
                 --,d.biomarker_id
                 ,m.assay_id
                 ,m.subject_id
	    --  ,decode(dataType,'R',m.intensity_value,'L',power(logBase, m.log_intensity),null)
                  ,m.intensity_value
		  ,round(m.log_intensity,4)
                  ,round(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE round(m.zscore,5) END,5)		  
                   ,m.patient_id
	from WT_SUBJECT_METABOLOMICS_MED m,
        (select distinct mp.source_cd,mp.platform From "TM_LZ"."LT_SRC_METABOLOMIC_MAP" mp LIMIT 1 OFFSET 1 and mp.trial_name =TrialID) mpp                
       , DE_METABOLITE_ANNOTATION d
        where trim(d.biochemical_name) = trim(m.probeset)
        and d.gpl_id = mpp.platform;
        
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial in DEAPP DE_SUBJECT_METABOLOMICS_DATA',SQL%ROWCOUNT,stepCt,'Done');

  	commit;

--	add indexes, if indexes were not dropped, procedure will not try and recreate
/*
	i2b2_mrna_index_maint('ADD',,jobId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Add indexes on DEAPP de_subject_METABOLOMICS_data',0,stepCt,'Done');
*/
	
--	cleanup tmp_ files

	--execute immediate('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_LOGS');
	--execute immediate('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_CALCS');
	--execute immediate('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_MED');

   	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION

  WHEN invalid_runType or trial_mismatch or trial_missing then
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
  
    cz_end_audit (jobID, 'FAIL');
  when OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);


    cz_end_audit (jobID, 'FAIL');
	
END;
 
$_$;


ALTER FUNCTION tm_cz.i2b2_metabolomics_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) OWNER TO tm_cz;

--
-- Name: i2b2_metabolomics_zscore_calc(character varying, character varying, character varying, numeric, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, source_cd character varying, run_type character varying DEFAULT 'L'::character varying, currentjobid numeric DEFAULT (-1), data_type character varying DEFAULT 'R'::character varying, log_base numeric DEFAULT 2) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*************************************************************************
This Stored Procedure is used in ETL load METABOLOMICS data
Date:1/3/2014
******************************************************************/

  TrialID varchar(100);
  sourceCD	varchar(50);
  sqlText varchar(2000);
  runType varchar(10);
  dataType varchar(10);
  stgTrial varchar(100);
  idxExists numeric;
  pExists	numeric;
  nbrRecs numeric;
  logBase numeric;
  partitionName varchar(200);
  partitionindx varchar(200);

   
  --Audit variables
  newJobFlag integer;
  databaseName varchar(100);
  procedureName varchar(100);
  jobID numeric;
  stepCt numeric;
  rowCt			bigint;
  rtnCd			integer;
  errorNumber		character varying;
  errorMessage	character varying;

BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	  RAISE NOTICE 'DK0';
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;
  
  partitionindx := partition_indx;
  partitionName := partition_name;

  databaseName := 'TM_CZ';
  procedureName := 'i2b2_metabolomics_zscore_calc';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName, jobID) into jobId;
  END IF;
   
  stepCt := 0;
  
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done');
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		perform cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting'
,0,stepCt,'Done');
		select cz_error_handler(jobid,procedurename, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return;
	end if;
  
--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_METABOLOMICS_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from WT_SUBJECT_MBOLOMICS_PROBESET;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			perform cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in WT_SUBJECT_MBOLOMICS_PROBESET - procedure exiting'
,0,stepCt,'Done');
select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			select cz_end_audit (jobId,'FAIL') into rtnCd;
			return;
		end if;
	end if;

--	remove Reload processing
--	For Reload, make sure that the TrialId passed as parameter has data in de_subject_METABOLOMICS_data
--	If not, raise exception

	if runType = 'R' then
		select count(*) into idxExists
		from DE_SUBJECT_METABOLOMICS_DATA		
		where trial_name = TrialId;
		
		if idxExists = 0 then
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'No data for TrialId in de_subject_rbm_data - procedure exiting'
,0,stepCt,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return;
		end if;
	end if;

	EXECUTE('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_LOGS');
	EXECUTE('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_CALCS');
	EXECUTE('truncate table tm_wz.WT_SUBJECT_METABOLOMICS_MED');

	EXECUTE('drop index if exists tm_wz.WT_SUBJECT_MBOLOMICS_LOGS_I1');		
	EXECUTE('drop index if exists tm_wz.WT_SUBJECT_METABOLOMICS_CALCS_I1');

	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value
	begin
	if dataType = 'L' then
		insert into WT_SUBJECT_METABOLOMICS_LOGS 
			(probeset
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
			,subject_id
			)
			select probeset
				  ,intensity_value  
				  ,assay_id 
				  ,intensity_value
				  ,patient_id
				  ,subject_id
			from WT_SUBJECT_MBOLOMICS_PROBESET
			where trial_name = TrialId;
	else	
			insert into WT_SUBJECT_METABOLOMICS_LOGS 
			(probeset
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
			,subject_id
			)
			select probeset
				  ,intensity_value 
				  ,assay_id 
				  ,CASE WHEN intensity_value <= 0 THEN log(2,(intensity_value + 0.001)) ELSE log(2,intensity_value) END
				  ,patient_id
				  ,subject_id
			from WT_SUBJECT_MBOLOMICS_PROBESET
			where trial_name = TrialId;
	end if;
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;

	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_mirna_logs',rowCt,stepCt,'Done');

	EXECUTE('create index WT_SUBJECT_MBOLOMICS_LOGS_I1 on tm_wz.WT_SUBJECT_METABOLOMICS_LOGS (trial_name, probeset) tablespace "indx"');
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_MBOLOMICS_LOGS_I1',0,stepCt,'Done');
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe
	begin
	insert into WT_SUBJECT_METABOLOMICS_CALCS
	(trial_name
	,probeset
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
	select d.trial_name 
		  ,d.probeset
		  ,avg(log_intensity)
		  ,median(log_intensity)
		  ,coalesce(stddev(log_intensity),0)
	from WT_SUBJECT_METABOLOMICS_LOGS d 
	group by d.trial_name 
			,d.probeset;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ WT_SUBJECT_METABOLOMICS_CALCS',rowCt,stepCt,'Done');

-- calculate zscore
	begin
        insert into WT_SUBJECT_METABOLOMICS_MED 
	(probeset
	,intensity_value
	,log_intensity
	,assay_id
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,patient_id
	,subject_id
	)
	select d.probeset
		  ,d.intensity_value 
		  ,d.log_intensity 
		  ,d.assay_id  
		  ,c.mean_intensity 
		  ,c.stddev_intensity 
		  ,c.median_intensity 
		  ,(CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END)
		  ,d.patient_id
		  ,d.subject_id
    from WT_SUBJECT_METABOLOMICS_LOGS d 
		,WT_SUBJECT_METABOLOMICS_CALCS c 
    where trim(d.probeset) = c.probeset;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ WT_SUBJECT_METABOLOMICS_MED',rowCt,stepCt,'Done');
	
    begin
	sqlText := 'insert into ' || partitionName || 
	'(partition_id, trial_source ,trial_name ,metabolite_annotation_id ' ||
	',assay_id ,subject_id ,raw_intensity ,log_intensity ,zscore ,patient_id) ' ||
	'select ' || partitioniD::text || ', ''' || TrialId || '''' ||
		  ',''' || TrialId || ''',d.id ,m.assay_id ,m.subject_id ' ||
           ',m.intensity_value ,round(m.log_intensity,4) ' ||
            ',round(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE round(m.zscore,5) END,5) ' ||  
            ',m.patient_id ' ||
			'from WT_SUBJECT_METABOLOMICS_MED m, ' ||
        '(select distinct mp.source_cd,mp.platform From TM_LZ.LT_SRC_METABOLOMIC_MAP mp where mp.trial_name = ''' || TrialId || ''') as mpp ' ||
		', DE_METABOLITE_ANNOTATION d ' ||
        'where trim(d.biochemical_name) = trim(m.probeset) ' ||
        'and d.gpl_id = mpp.platform ';
        raise notice 'sqlText= %', sqlText;
	execute sqlText;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial in DEAPP DE_SUBJECT_METABOLOMICS_DATA',rowCt,stepCt,'Done');

	sqlText := ' create index ' || partitionIndx || '_idx1 on ' || partitionName || ' using btree (partition_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx2 on ' || partitionName || ' using btree (assay_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx3 on ' || partitionName || ' using btree (metabolite_annotation_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx4 on ' || partitionName || ' using btree (assay_id, metabolite_annotation_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
        
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    perform cz_end_audit (jobID, 'SUCCESS');
  END IF;

END;
 
$$;


ALTER FUNCTION tm_cz.i2b2_metabolomics_zscore_calc(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) OWNER TO tm_cz;

--
-- Name: i2b2_mirna_zscore_calc(character varying, character varying, numeric, character varying, numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_mirna_zscore_calc(trial_id character varying, run_type character varying DEFAULT 'L'::character varying, currentjobid numeric DEFAULT NULL::numeric, data_type character varying DEFAULT 'R'::character varying, log_base numeric DEFAULT 2, source_cd character varying DEFAULT NULL::character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
/*************************************************************************
This Stored Procedure is used in ETL load MIRNA data
Date:12/9/2013
******************************************************************/
Declare
  TrialID character varying(50);
  sourceCD	character varying(50);
  sqlText character varying(2000);
  runType character varying(10);
  dataType character varying(10);
  stgTrial character varying(50);
  idxExists numeric;
  pExists	numeric;
  nbrRecs numeric;
  logBase numeric;
   
  --Audit variables
  newJobFlag numeric(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID numeric(18,0);
  stepCt numeric(18,0);
  rtnCd integer;
  rowCt integer;
  
BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  databaseName := 'TM_CZ';
  procedureName := 'I2B2_MIRNA_ZSCORE_CALC';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName) into jobID;
  END IF;
   
  stepCt := 0;
  
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done') into rtnCd;
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting',rowCt,stepCt,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName) into rtnCd;  
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return 150;
	end if;
  
--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_mirna_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from WT_SUBJECT_MIRNA_PROBESET;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			get diagnostics rowCt := ROW_COUNT;
			select cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in WT_SUBJECT_MIRNA_PROBESET - procedure exiting',rowCt,stepCt,'Done') into rtnCd;
			select cz_error_handler(jobID, procedureName) into rtnCd;
			select cz_end_audit (jobID, 'FAIL') into rtnCd;
			return 161;
		end if;
	end if;
   
--	truncate tmp tables
	begin
		execute ('truncate table tm_wz.WT_SUBJECT_MIRNA_LOGS');
		execute ('truncate table tm_wz.WT_SUBJECT_MIRNA_CALCS');
		execute ('truncate table tm_wz.WT_SUBJECT_MIRNA_MED');
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	--drop index if exists tm_wz.WT_SUBJECT_MIRNA_LOGS_I1;		
	--drop index if exists tm_wz.WT_SUBJECT_MIRNA_CALCS_I1;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done') into rtnCd;
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value


	if dataType = 'L' then
		begin
		insert into WT_SUBJECT_MIRNA_LOGS 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
			)
			select probeset_id
				  ,intensity_value ----UAT 154 changes done on 19/03/2014
				  ,assay_id 
				  ,round((case when intensity_value<=0 then 0
                                  when intensity_value>0 then log(2,intensity_value)
                                  else 0 end),5)
				  ,patient_id
			from WT_SUBJECT_MIRNA_PROBESET
			where trial_name = TrialId;
		exception
		when others then
			perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
			perform tm_cz.cz_end_audit (jobID, 'FAIL');
			return -16;
		end;
	else	
		begin
                	insert into WT_SUBJECT_MIRNA_LOGS 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
			)
			select probeset_id
				  ,intensity_value  ----UAT 154 changes done on 19/03/2014
				  ,assay_id 
				  ,-(intensity_value)  ----UAT 154 changes done on 19/03/2014
				  ,patient_id
			from WT_SUBJECT_MIRNA_PROBESET
			where trial_name = TrialId;
		exception
		when others then
			perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
			perform tm_cz.cz_end_audit (jobID, 'FAIL');
			return -16;
		end;
	end if;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_mirna_logs',rowCt,stepCt,'Done') into rtnCd;

	
    
	--execute ('create index WT_SUBJECT_MIRNA_LOGS_I1 on tm_wz.WT_SUBJECT_MIRNA_LOGS (trial_name, probeset_id)');
	stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_MIRNA_LOGS_I1',0,stepCt,'Done') into rtnCd;
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe

	begin
	insert into WT_SUBJECT_MIRNA_CALCS
	(trial_name
	,probeset_id
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
	select d.trial_name 
		  ,d.probeset_id
		  ,avg(log_intensity)
		  ,median(log_intensity)
		  ,stddev(log_intensity)
	from WT_SUBJECT_MIRNA_LOGS d 
	group by d.trial_name 
			,d.probeset_id;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ WT_SUBJECT_MIRNA_CALCS',rowCt,stepCt,'Done') into rtnCd;

	

	--execute ('create index tm_wz.wt_subject_mirna_calcs_i1 on tm_wz.WT_SUBJECT_MIRNA_CALCS (trial_name, probeset_id) nologging tablespace "INDX"');
	--stepCt := stepCt + 1;
	--cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_MIRNA_CALCS',0,stepCt,'Done');
		
-- calculate zscore

	begin
	insert into WT_SUBJECT_MIRNA_MED 
	(probeset_id
	,intensity_value
	,log_intensity
	,assay_id
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,patient_id
--	,sample_cd
--	,subject_id
	)
	select d.probeset_id
		  ,d.intensity_value 
		  ,d.log_intensity 
		  ,d.assay_id  
		  ,c.mean_intensity 
		  ,c.stddev_intensity 
		  ,c.median_intensity 
		  ,(CASE WHEN stddev_intensity=0 THEN 0 ELSE (d.log_intensity - c.median_intensity ) / c.stddev_intensity END)
		  ,d.patient_id
	--	  ,d.sample_cd
	--	  ,d.subject_id
    from WT_SUBJECT_MIRNA_LOGS d 
		,WT_SUBJECT_MIRNA_CALCS c 
    where d.probeset_id = c.probeset_id;
    	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ WT_SUBJECT_MIRNA_MED',rowCt,stepCt,'Done') into rtnCd;

	--select count(*) into pExists from de_subject_mirna_data where trial_name=TrialId;
	
	begin
	insert into de_subject_mirna_data
	(trial_source
	,trial_name
	,assay_id
	,probeset_id
	,raw_intensity 
	,log_intensity
	,zscore
	,patient_id
	--,sample_id
	--,subject_id
	)
	select (TrialId || ':' || sourceCD)
		  ,TrialId
	      ,m.assay_id
	      ,m.probeset_id 
		  ,case when dataType = 'R' then m.intensity_value
				when dataType = 'L' 
				then m.intensity_value
				else null
				end as raw_intensity
	    --  ,decode(dataType,'R',m.intensity_value,'L',power(logBase, m.log_intensity),null)
		  ,case when dataType = 'R' then -(m.intensity_value)
				when dataType = 'L' 
				then m.log_intensity
				else null
				end
	      ,(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE round(m.zscore,5) END)
              --,m.zscore
		  ,m.patient_id
	--	  ,m.sample_id
	--	  ,m.subject_id
	from wt_subject_MIRNA_med m;
        exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial in DEAPP DE_SUBJECT_MIRNA_DATA',rowCt,stepCt,'Done') into rtnCd;

	/*
	if pExists > 0 then
		perform tm_cz.I2B2_MIRNA_INC_SUB_ZSCORE(TrialId,dataType);
		stepCt := stepCt + 1;
		perform cz_write_audit(jobId,databaseName,procedureName,'update zscore in de_subject_MIRNA_data ',0,stepCt,'Done');
	end if;
	*/
	---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    perform cz_end_audit (jobID, 'SUCCESS');
  END IF;
  return 0;	
END;
$$;


ALTER FUNCTION tm_cz.i2b2_mirna_zscore_calc(trial_id character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric, source_cd character varying) OWNER TO tm_cz;

--
-- Name: i2b2_move_analysis_to_prod(numeric, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_move_analysis_to_prod(i_etl_id numeric, i_job_id numeric DEFAULT 0) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, biomart, biomart_stage, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
	
    --Audit variables
    newJobFlag     integer;
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         bigint;
    stepCt         integer;
	rowCt		integer;
	v_sqlerrm		varchar(1000);
	rtnCd			integer;
	errorNumber		character varying;
	errorMessage	character varying;
	
 
    v_etl_id					bigint;
    v_bio_assay_analysis_id		bigint;
    v_data_type					varchar(50);
    v_sqlText					varchar(2000);
    v_exists					integer;
    v_GWAS_staged				integer;
    v_EQTL_staged				integer;	
	v_max_ext_flds				integer;
    
	stage_rec					record;
 
BEGIN    
    jobId := i_job_id;
	
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_MOVE_ANALYSIS_TO_PROD';
	
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.czx_start_audit (procedureName, databaseName) into jobId;
	END IF;
        
    stepCt := 1;    
    select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done') into rtnCd;
	
	--	delete existing data for staged analyses from bio_asy_analysis_gwas
	
	begin
	delete from biomart.bio_assay_analysis_gwas g
	where g.bio_assay_analysis_id in
		  (select x.bio_assay_analysis_id
		   from tm_lz.lz_src_analysis_metadata t
			   ,biomart.bio_assay_analysis x
		  where t.status = 'STAGED'
			and t.data_type in ('GWAS','Metabolic GWAS')
			and t.study_id = x.etl_id
			and t.etl_id = x.etl_id_source
			and case when i_etl_id = -1 then 1
					 when t.etl_id = i_etl_id then 1
                     else 0 end = 1);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select * from tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete exising data for staged analyses from BIOMART.BIO_ASSAY_ANALYSIS_GWAS',rowCt,stepCt,'Done') into rtnCd;
	raise notice 'here';
	--	delete existing data for staged analyses from bio_asy_analysis_eqtl
	
	begin
	delete from biomart.bio_assay_analysis_eqtl g
	where g.bio_assay_analysis_id in
	     (select x.bio_assay_analysis_id
		  from tm_lz.lz_src_analysis_metadata t
			  ,biomart.bio_assay_analysis x
		  where t.status = 'STAGED'
			and t.data_type = 'EQTL'
			and t.study_id = x.etl_id
			and t.etl_id = x.etl_id_source
			and case when i_etl_id = -1 then 1
                     when t.etl_id = i_etl_id then 1
                     else 0 end = 1);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete exising data for staged analyses from BIOMART.BIO_ASSAY_ANALYSIS_EQTL',rowCt,stepCt,'Done') into rtnCd;
			
    --    load staged analysis to array
	
	v_GWAS_staged := 0;
    v_EQTL_staged := 0;
    
	for stage_rec in
		select baa.bio_assay_analysis_id
			  ,lz.etl_id
			  ,lz.study_id
			  ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
			  ,lz.data_type as orig_data_type
			  ,lz.analysis_name
		from tm_lz.lz_src_analysis_metadata lz
			,biomart.bio_assay_analysis baa
		where lz.status = 'STAGED'
		  and lz.study_id = baa.etl_id
		  and lz.etl_id = baa.etl_id_source
		  and case when i_etl_id = -1 then 1
				   when lz.etl_id = i_etl_id then 1
				   else 0 end = 1
	loop   
	
	    select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done') into rtnCd;
					   
		v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
		v_data_type := stage_rec.data_type;
		v_etl_id := stage_rec.etl_id;
		
		--	get max nbr fields in ext_data for original data type
			
		select max(field_idx) into v_max_ext_flds
		from biomart.bio_asy_analysis_data_idx
		where ext_type = stage_rec.orig_data_type;
					   
        if stage_rec.data_type = 'GWAS' then
            v_GWAS_staged := 1;

			--	move GWAS data from biomart_stage to biomart
			
			begin
			insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,cast(p_value_char as double precision)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
						then ext_data || repeat(';',v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))))
						else ext_data
				   end
                  ,log(cast(p_value_char as double precision))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
			get diagnostics rowCt := ROW_COUNT;
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			end;
            stepCt := stepCt + 1;
            select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert data for analysis from BIOMART_STAGE.BIO_ASSAY_ANALYSIS_' || v_data_type,rowCt,stepCt,'Done') into rtnCd;
			
			--	update data_count in bio_assay_analysis
			
			begin
		    update biomart.bio_assay_analysis baa
			set data_count=rowCt
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
			get diagnostics rowCt := ROW_COUNT;
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			end;
            stepCt := stepCt +1;
            select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Update data_count in bio_assay_analysis',rowCt,stepCt,'Done') into rtnCd;
			
			v_sqlText := 'delete from biomart_stage.bio_assay_analysis_' || v_data_type || 
						 ' where bio_assay_analysis_id = ' || v_bio_assay_analysis_id;
			execute v_sqlText;
			get diagnostics rowCt := ROW_COUNT;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data for analysis from BIOMART_STAGE.BIO_ASSAY_ANALYSIS_' || v_data_type,rowCt,stepCt,'Done') into rtnCd;       
           
			--	load top 500 rows to bio_asy_analysis_gwas_top50
			
			-- select * from tm_cz.i2b2_load_gwas_top50(v_bio_assay_analysis_id,jobId) into rtnCd;
			
        end if;
        
        if stage_rec.data_type = 'EQTL' then
            v_EQTL_staged := 1;
			
			--	move EQTL data from biomart_stage to biomart

			begin
			insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,cast(p_value_char as double precision)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
						then ext_data || repeat(';',v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))))
						else ext_data
				   end
                  ,log(cast(p_value_char as double precision))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
			get diagnostics rowCt := ROW_COUNT;
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			end;
            stepCt := stepCt + 1;
            select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Insert data for analysis from BIOMART_STAGE.BIO_ASSAY_ANALYSIS_' || v_data_type,rowCt,stepCt,'Done') into rtnCd;
        
			--	update data_count in bio_assay_analysis
			
			begin
		    update biomart.bio_assay_analysis baa
			set data_count=rowCt
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
			get diagnostics rowCt := ROW_COUNT;
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				--Handle errors.
				select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
				--End Proc
				select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
				return -16;
			end;
            stepCt := stepCt +1;
            select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Update data_count in bio_assay_analysis',rowCt,stepCt,'Done') into rtnCd;
           			
			v_sqlText := 'delete from biomart_stage.bio_assay_analysis_' || v_data_type || 
						 ' where bio_assay_analysis_id = ' || v_bio_assay_analysis_id;
			execute  v_sqlText;
			get diagnostics rowCt := ROW_COUNT;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Delete data for analysis from BIOMART_STAGE.BIO_ASSAY_ANALYSIS_' || v_data_type,rowCt,stepCt,'Done') into rtnCd;       

			--	load top 500 rows to bio_asy_analysis_eqtl_top50
			
			select * from tm_ca.i2b2_load_eqtl_top50(v_bio_assay_analysis_id,jobId) into rtnCd;
			
		end if;    
		
		--	update status in lz_src_analysis_metadata
		
		begin
        update tm_lz.lz_src_analysis_metadata
        set status='PRODUCTION'
        where etl_id = v_etl_id;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.czx_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.czx_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
        stepCt := stepCt + 1;
        select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',rowCt,stepCt,'Done') into rtnCd;               
        
	end loop;
      
	--	check if no data loaded from biomart_stage, if none, terminate normally
	
	if v_GWAS_staged = 0 and v_EQTL_staged = 0 then
	    stepCt := stepCt + 1;
        select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'No staged data - run terminating normally',0,stepCt,'Done') into rtnCd;
		return 0;
	end if;
    
	--	check if any data left in stage tables after move, usually indicates missing bio_assay_analysis record
	
	if i_etl_id = -1 then
		select count(*) into v_exists
		from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
			  union
			  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl) x;
		if v_exists > 0 then
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'**WARNING ** Data remains in staging tables',0,stepCt,'Done') into rtnCd;
		end if;
	end if;
    
    select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End i2b2_move_analysis_to_prod',0,stepCt,'Done') into rtnCd;
    stepCt := stepCt + 1;
    
    select tm_cz.czx_end_audit(jobId, 'Success') into rtnCd;
	return 0;
    
    
END;
$$;


ALTER FUNCTION tm_cz.i2b2_move_analysis_to_prod(i_etl_id numeric, i_job_id numeric) OWNER TO tm_cz;

--
-- Name: i2b2_move_node(character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_move_node(old_path character varying, new_path character varying, topnode character varying, currentjobid numeric DEFAULT (-1)) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

  root_node		varchar(2000);
  root_level	integer;
 
  --Audit variables
  newJobFlag integer(1);
  databaseName varchar(100);
  procedureName varchar(100);
  jobID numeric;
  stepCt integer;
  

BEGIN
  
	stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
	procedureName := $$PLSQL_UNIT;
  
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
	cz_start_audit (procedureName, databaseName, jobID);
	END IF;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_move_node',0,stepCt,'Done');  
	
	PERFORM parse_nth_value(topNode, 2, '\') into root_node ;
	
	select c_hlevel into root_level
	from table_access
	where c_name = root_node;
	
	if old_path != ''  or old_path != '%' or new_path != ''  or new_path != '%'
	then 
      --CONCEPT DIMENSION
		update concept_dimension
		set CONCEPT_PATH = replace(concept_path, old_path, new_path)
		where concept_path like old_path || '%';
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Update concept_dimension with new path',SQL%ROWCOUNT,stepCt,'Done'); 
		COMMIT;
    
		--I2B2
		update i2b2
		set c_fullname = replace(c_fullname, old_path, new_path)
		where c_fullname like old_path || '%';
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Update i2b2 with new path',SQL%ROWCOUNT,stepCt,'Done'); 
		COMMIT;
  
		--update level data
		UPDATE I2B2
		set c_hlevel = (length(c_fullname) - coalesce(length(replace(c_fullname, '\')),0)) / length('\') - 2 + root_level
		where c_fullname like new_path || '%';
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Update i2b2 with new level',SQL%ROWCOUNT,stepCt,'Done'); 
		COMMIT;
		
		--Update tooltip and dimcode
		update i2b2
		set c_dimcode = c_fullname,
		c_tooltip = c_fullname
		where c_fullname like new_path || '%';
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Update i2b2 with new dimcode and tooltip',SQL%ROWCOUNT,stepCt,'Done'); 
		COMMIT;

		--if topNode != '' then
		--	i2b2_create_concept_counts(topNode,jobId);
		--end if;
	end if;
	
	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;

	EXCEPTION
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		--End Proc
		cz_end_audit (jobID, 'FAIL');
		
END;
 
$_$;


ALTER FUNCTION tm_cz.i2b2_move_node(old_path character varying, new_path character varying, topnode character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_move_study(character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_move_study(old_path character varying, new_path character varying, currentjobid numeric) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, i2b2metadata, i2b2demodata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

  root_node		varchar(2000);
  root_level	integer;
  rtnCd			integer;
  
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
  
BEGIN
    
	stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_ADD_NODE';
	
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobId;
	END IF;
  
	select tm_cz.parse_nth_value(path, 2, '\') into root_node;
	
	select c_hlevel into root_level
	from i2b2metadata.table_access
	where c_name = root_node;
  
	if old_path != ''  or old_path != '%' or new_path != ''  or new_path != '%'
	then 
	
      --CONCEPT DIMENSION
		update concept_dimension
		set CONCEPT_PATH = replace(concept_path, old_path, new_path)
		where concept_path like old_path || '%';
		get diagnostics rowCt := ROW_COUNT;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update concept_dimension with new path',rowCt,stepCt,'Done') into rtnCd;




    
		--I2B2
		update i2b2
		set c_fullname = replace(c_fullname, old_path, new_path)
			,c_dimcode = replace(c_fullname, old_path, new_path)
			,c_tooltip = replace(c_fullname, old_path, new_path)
			,c_hlevel =  (length(replace(c_fullname, old_path, new_path)) - nvl(length(replace(replace(c_fullname, old_path, new_path), '\')),0)) / length('\') - 2 + root_level
		where c_fullname like old_path || '%';
		get diagnostics rowCt := ROW_COUNT;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update i2b2 with new path',rowCt,stepCt,'Done') into rtnCd;



		
		--	concept_counts
		
		update concept_counts
		set concept_path = replace(concept_path, old_path, new_path)
		   ,parent_concept_path = replace(parent_concept_path, old_path, new_path)
		where concept_path like old_path || '%';
		
		--	fill in any upper levels
		
		select i2b2_fill_in_tree(null, new_path, jobID);
	END IF;



		
      ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCD;
	END IF;

	return 1;
	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

  
END;

$$;


ALTER FUNCTION tm_cz.i2b2_move_study(old_path character varying, new_path character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_mrna_index_maint(text, text, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_mrna_index_maint(run_type text DEFAULT 'DROP'::text, tablespace_name text DEFAULT 'INDX'::text, currentjobid bigint DEFAULT NULL::bigint) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

  runType	varchar(100);
  idxExists	bigint;
  pExists	bigint;
  localVar	varchar(20);
  bitmapVar	varchar(20);
  bitmapCompress	varchar(20);
  tableSpace	varchar(50);
   
  --Audit variables
  newJobFlag integer(1);
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  

BEGIN

	runType := upper(run_type);
	tableSpace := upper(tablespace_name);
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  
	--	Determine if de_subject_microarray_data is partitioned, if yes, set localVar to local
  	select count(*)
	into pExists
	from all_tables
	where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
	  and partitioned = 'YES';
	  
	if pExists = 0 then
		localVar := null;
		bitmapVar := null;
		bitmapCompress := 'compress';
	else 
		localVar := 'local';
		bitmapVar := 'bitmap';
		bitmapCompress := null;
	end if;
   
	if runType = 'DROP' then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Start de_subject_microarray_data index drop',0,stepCt,'Done');
		--	drop the indexes
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX1'
		  and owner = 'DEAPP';
		
		if idxExists = 1 then
			EXECUTE('drop index deapp.de_microarray_data_idx1');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Drop de_microarray_data_idx1',0,stepCt,'Done');
		end if;
		
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX2'
		  and owner = 'DEAPP';
		
		if idxExists = 1 then
			EXECUTE('drop index deapp.de_microarray_data_idx2');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Drop de_microarray_data_idx2',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX3'
		  and owner = 'DEAPP';
		
		if idxExists = 1 then
			EXECUTE('drop index deapp.de_microarray_data_idx3');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Drop de_microarray_data_idx3',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX4'
		  and owner = 'DEAPP';
		
		if idxExists = 1 then
			EXECUTE('drop index deapp.de_microarray_data_idx4');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Drop de_microarray_data_idx4',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX5'
		  and owner = 'DEAPP';
		
		if idxExists = 1 then
			EXECUTE('drop index deapp.de_microarray_data_idx5');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Drop de_microarray_data_idx5',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX10'
		  and owner = 'DEAPP';
		
		if idxExists = 1 then
			EXECUTE('drop index deapp.de_microarray_data_idx10');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Drop de_microarray_data_idx10',0,stepCt,'Done');
		end if;
						
	else
		--	add indexes
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Start de_subject_microarray_data index create',0,stepCt,'Done');
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX1'
		  and owner = 'DEAPP';
		  
		if idxExists = 0 then
			EXECUTE('create index deapp.de_microarray_data_idx1 on deapp.de_subject_microarray_data(trial_name, assay_id, probeset_id) ' || localVar || ' nologging compress tablespace "' || tableSpace || '"'); 
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Create de_microarray_data_idx1',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX2'
		  and owner = 'DEAPP';
		  
		if idxExists = 0 then		
			EXECUTE('create index deapp.de_microarray_data_idx2 on deapp.de_subject_microarray_data(assay_id, probeset_id) ' || localVar || ' nologging compress tablespace "' || tableSpace || '"');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Create de_microarray_data_idx2',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX3'
		  and owner = 'DEAPP';
		  
		if idxExists = 0 then		
			EXECUTE('create ' || bitmapVar || ' index deapp.de_microarray_data_idx3 on deapp.de_subject_microarray_data(assay_id) ' || localVar || ' nologging ' || bitmapCompress || ' tablespace "' || tableSpace || '"');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Create de_microarray_data_idx3',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX4'
		  and owner = 'DEAPP';
		  
		if idxExists = 0 then
			EXECUTE('create ' || bitmapVar || ' index deapp.de_microarray_data_idx4 on deapp.de_subject_microarray_data(probeset_id) ' || localVar || ' nologging ' || bitmapCompress || ' tablespace "' || tableSpace || '"');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Create de_microarray_data_idx4',0,stepCt,'Done');
		end if;

		if pExists = 0 then
			--	only create this index if the table is not partitioned.  This is the column that the table would be partitioned on
			
			select count(*) 
			into idxExists
			from all_indexes
			where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
			  and index_name = 'DE_MICROARRAY_DATA_IDX5'
			  and owner = 'DEAPP';
			  
			if idxExists = 0 then
				EXECUTE('create index deapp.de_microarray_data_idx5 on deapp.de_subject_microarray_data(trial_source) ' || localVar || ' nologging ' || bitmapCompress || ' tablespace "' || tableSpace || '"');
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Create de_microarray_data_idx5',0,stepCt,'Done');
			end if;
		end if;

/*		not used
	
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX10'
		  and owner = 'DEAPP';
		  
		if idxExists = 0 then
			execute immediate('create index deapp.de_microarray_data_idx10 on deapp.de_subject_microarray_data(assay_id, subject_id, probeset_id, zscore) ' || localVar || ' nologging compress tablespace "' || tableSpace || '"');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Create de_microarray_data_idx10',0,stepCt,'Done');
		end if;
*/
							
	end if;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End FUNCTION'||procedureName,SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	
    ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;

	EXCEPTION
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		
		--End Proc
		cz_end_audit (jobID, 'FAIL');
end;
 
 

 
$_$;


ALTER FUNCTION tm_cz.i2b2_mrna_index_maint(run_type text, tablespace_name text, currentjobid bigint) OWNER TO tm_cz;

--
-- Name: i2b2_mrna_zscore_calc(character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_mrna_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying DEFAULT 'L'::character varying, currentjobid numeric DEFAULT (-1), data_type character varying DEFAULT 'R'::character varying, log_base numeric DEFAULT 2) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

  TrialID varchar(50);
  sourceCD	varchar(50);
  sqlText varchar(2000);
  runType varchar(10);
  dataType varchar(10);
  stgTrial varchar(50);
  idxExists integer;
  pExists	integer;
  nbrRecs integer;
  logBase integer;
   
  --Audit variables
  newJobFlag integer(1);
  databaseName varchar(100);
  procedureName varchar(100);
  jobID numeric;
  stepCt integer;
  
  --  exceptions
  invalid_runType exception;
  trial_mismatch exception;
  trial_missing exception;
  

BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done');
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting'
,SQL%ROWCOUNT,stepCt,'Done');
		raise invalid_runType;
	end if;
  
--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_mrna_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from wt_subject_mrna_probeset;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in wt_subject_mrna_probeset - procedure exiting'
,SQL%ROWCOUNT,stepCt,'Done');
			raise trial_mismatch;
		end if;
	end if;
   
/*	remove Reload processing
--	For Reload, make sure that the TrialId passed as parameter has data in de_subject_microarray_data
--	If not, raise exception

	if runType = 'R' then
		select count(*) into idxExists
		from de_subject_microarray_data
		where trial_name = TrialId;
		
		if idxExists = 0 then
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'No data for TrialId in de_subject_microarray_data - procedure exiting',SQL%ROWCOUNT,stepCt,'Done');
			raise trial_missing;
		end if;
	end if;
*/
   
--	truncate tmp tables

	EXECUTE('truncate table tm_wz.wt_subject_microarray_logs');
	EXECUTE('truncate table tm_wz.wt_subject_microarray_calcs');
	EXECUTE('truncate table tm_wz.wt_subject_microarray_med');
	
	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'WT_SUBJECT_MICROARRAY_LOGS'
	  and index_name = 'WT_SUBJECT_MRNA_LOGS_I1'
	  and owner = 'TM_WZ';
		
	if idxExists = 1 then
		EXECUTE('drop index tm_wz.wt_subject_mrna_logs_i1');		
	end if;
	
	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'WT_SUBJECT_MICROARRAY_CALCS'
	  and index_name = 'WT_SUBJECT_MRNA_CALCS_I1'
	  and owner = 'TM_WZ';
		
	if idxExists = 1 then
		EXECUTE('drop index tm_wz.wt_subject_mrna_calcs_i1');
	end if;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value


	if dataType = 'L' then
/*	Remove Reload processing
		if runType = 'R' then
			insert into wt_subject_microarray_logs 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
			,sample_id
			,subject_id
			)
			select probeset_id
				  ,raw_intensity 
				  ,assay_id
				  ,log_intensity
				  ,patient_id
				  ,sample_id
				  ,subject_id
			from de_subject_microarray_data 
			where trial_name =  TrialID;
		else
*/
			insert into wt_subject_microarray_logs 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
		--	,subject_id
			)
			PERFORM probeset_id
				  ,intensity_value  
				  ,assay_id 
				  ,intensity_value
				  ,patient_id
			--	  ,sample_cd
			--	  ,subject_id
			from wt_subject_mrna_probeset
			where trial_name = TrialId;
		--end if;
	else
	/*	remove Reload processing
		if runType = 'R' then
			insert into wt_subject_microarray_logs 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
			,sample_id
			,subject_id
			)
			select probeset_id
				  ,raw_intensity 
				  ,assay_id  
				  ,log(2,raw_intensity)
				  ,patient_id
				  ,sample_id
				  ,subject_id
			from de_subject_microarray_data 
			where trial_name =  TrialID;
		else
*/
			insert into wt_subject_microarray_logs 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
		--	,subject_id
			)
			PERFORM probeset_id
				  ,intensity_value 
				  ,assay_id 
				  ,log(2,intensity_value)
				  ,patient_id
		--		  ,sample_cd
		--		  ,subject_id
			from wt_subject_mrna_probeset
			where trial_name = TrialId;
--		end if;
	end if;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_microarray_logs',SQL%ROWCOUNT,stepCt,'Done');

	commit;
    
	EXECUTE('create index tm_wz.wt_subject_mrna_logs_i1 on tm_wz.wt_subject_microarray_logs (trial_name, probeset_id) nologging  tablespace "INDX"');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_microarray_logs',0,stepCt,'Done');
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe

	insert into wt_subject_microarray_calcs
	(trial_name
	,probeset_id
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
	PERFORM d.trial_name 
		  ,d.probeset_id
		  ,avg(log_intensity)
		  ,median(log_intensity)
		  ,stddev(log_intensity)
	from wt_subject_microarray_logs d 
	group by d.trial_name 
			,d.probeset_id;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ wt_subject_microarray_calcs',SQL%ROWCOUNT,stepCt,'Done');

	commit;

	EXECUTE('create index tm_wz.wt_subject_mrna_calcs_i1 on tm_wz.wt_subject_microarray_calcs (trial_name, probeset_id) nologging tablespace "INDX"');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_microarray_calcs',0,stepCt,'Done');
		
-- calculate zscore

	insert into wt_subject_microarray_med parallel 
	(probeset_id
	,intensity_value
	,log_intensity
	,assay_id
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,patient_id
--	,sample_cd
--	,subject_id
	)
	PERFORM d.probeset_id
		  ,d.intensity_value 
		  ,d.log_intensity 
		  ,d.assay_id  
		  ,c.mean_intensity 
		  ,c.stddev_intensity 
		  ,c.median_intensity 
		  ,CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END
		  ,d.patient_id
	--	  ,d.sample_cd
	--	  ,d.subject_id
    from wt_subject_microarray_logs d 
		,wt_subject_microarray_calcs c 
    where d.probeset_id = c.probeset_id;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ wt_subject_microarray_med',SQL%ROWCOUNT,stepCt,'Done');

    commit;
  
/*
	select count(*) into nbrRecs
	from wt_subject_microarray_med;
	
	if nbrRecs > 10000000 then
		i2b2_mrna_index_maint('DROP',,jobId);
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on DEAPP de_subject_microarray_data',0,stepCt,'Done');
	else
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Less than 10M records, index drop bypassed',0,stepCt,'Done');
	end if;
*/
	


	insert into de_subject_microarray_data
	(trial_source
	,trial_name
	,assay_id
	,probeset_id
	,raw_intensity 
	,log_intensity
	,zscore
	,patient_id
	--,sample_id
	--,subject_id
	)
	PERFORM TrialId || ':' || sourceCD
		  ,TrialId
	      ,m.assay_id
	      ,m.probeset_id 
		  ,round(case when dataType = 'R' then m.intensity_value
				when dataType = 'L' 
				then case when logBase = -1 then null else power(logBase, m.log_intensity) end
				else null
				end,4) as raw_intensity
	    --  ,decode(dataType,'R',m.intensity_value,'L',power(logBase, m.log_intensity),null)
		  ,round(m.log_intensity,4)
	      ,round(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE round(m.zscore,5) END,5)
		  ,m.patient_id
	--	  ,m.sample_id
	--	  ,m.subject_id
	from wt_subject_microarray_med m;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial in DEAPP de_subject_microarray_data',SQL%ROWCOUNT,stepCt,'Done');

  	commit;

--	add indexes, if indexes were not dropped, procedure will not try and recreate
/*
	i2b2_mrna_index_maint('ADD',,jobId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Add indexes on DEAPP de_subject_microarray_data',0,stepCt,'Done');
*/
	
--	cleanup tmp_ files

	EXECUTE('truncate table tm_wz.wt_subject_microarray_logs');
	EXECUTE('truncate table tm_wz.wt_subject_microarray_calcs');
	EXECUTE('truncate table tm_wz.wt_subject_microarray_med');

   	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION

  WHEN invalid_runType or trial_mismatch or trial_missing then
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
  when OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;


/*	--	Recreate tmp tables used for calculation of mRNA Zscore if necessary

create table wt_subject_microarray_logs parallel nologging compress as 
select probeset_id 
	  ,raw_intensity 
	  ,pvalue 
	  ,refseq 
	  ,assay_id 
	  ,patient_id 
	  ,subject_id 
	  ,trial_name 
	  ,timepoint  
      ,raw_intensity as log_intensity 
       from de_subject_microarray_data
	   where 1=2;
	   
create index tmp_microarray_logs_i1 on wt_subject_microarray_logs (trial_name, probeset_id);

create table wt_subject_microarray_calcs parallel nologging compress as
select d.trial_name 
	  ,d.probeset_id
	  ,log_intensity as mean_intensity
	  ,log_intensity as median_intensity 
	  ,log_intensity as stddev_intensity 
from wt_subject_microarray_logs d 
where 1=2;

create index tmp_microarray_calcs_i1 on wt_subject_microarray_calcs (trial_name, probeset_id);	

create table wt_subject_microarray_med parallel nologging compress as  
select d.probeset_id
	  ,d.raw_intensity  
	  ,d.log_intensity  
	  ,d.assay_id  
	  ,d.patient_id  
	  ,d.subject_id  
	  ,d.trial_name  
	  ,d.timepoint  
	  ,d.pvalue  
	  ,d.refseq 
	  ,c.mean_intensity  
	  ,c.stddev_intensity  
	  ,c.median_intensity  
	  ,d.log_intensity as zscore 
from wt_subject_microarray_logs d 
	 ,wt_subject_microarray_calcs c
where 1=2;
            
create table wt_subject_microarray_mcapped parallel nologging compress as 
select d.probeset_id 
	  ,d.patient_id 
	  ,d.trial_name 
	  ,d.timepoint 
	  ,d.pvalue 
	  ,d.refseq 
	  ,d.subject_id 
	  ,d.raw_intensity 
	  ,d.log_intensity 
	  ,d.assay_id 
	  ,d.mean_intensity 
	  ,d.stddev_intensity 
	  ,d.median_intensity 
	  ,d.zscore 
 from wt_subject_microarray_med d
 where 1=2;
		   
*/

 
 
$_$;


ALTER FUNCTION tm_cz.i2b2_mrna_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) OWNER TO tm_cz;

--
-- Name: i2b2_process_acgh_data(character varying, character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_process_acgh_data(trial_id character varying, top_node character varying, source_cd character varying DEFAULT 'STD'::character varying, secure_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, deapp, i2b2demodata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;

	TrialID			varchar(100);
	RootNode		varchar(2000);
	root_level		integer;
	topNode			varchar(2000);
	topLevel		integer;
	tPath			varchar(2000);
	study_name		varchar(100);
	sourceCd		varchar(50);
	secureStudy		varchar(1);

	dataType		varchar(10);
	sqlText			varchar(1000);
	tText			varchar(1000);
	gplTitle		varchar(1000);
	pExists			numeric;
	partTbl   		numeric;
	partExists 		numeric;
	sampleCt		numeric;
	idxExists 		numeric;
	logBase			numeric;
	pCount			integer;
	sCount			integer;
	tablespaceName	varchar(200);
	partitioniD		numeric(18,0);
	partitionName	varchar(100);
	partitionIndx	varchar(100);

	--	cursor to add leaf nodes, cursor is used here because there are few nodes to be added

	addNodes CURSOR is
	select distinct t.leaf_node
          ,t.node_name
	from  tm_wz.wt_mrna_nodes t
	where not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where t.leaf_node = x.c_fullname);

	--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

	delNodes CURSOR is
	select distinct c_fullname
	from  i2b2metadata.i2b2
	where c_fullname like topNode || '%' escape '`'
      and substr(c_visualattributes,2,1) = 'H';

BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	databaseName := 'TM_CZ';
	procedureName := 'i2b2_process_acgh_data';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_acgh_data',0,stepCt,'Done') into rtnCd;

	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;

	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\','g');
	select length(topNode)-length(replace(topNode,'\','')) into topLevel;

	sourceCd := upper(coalesce(source_cd,'STD'));

	--	Get count of records in tm_lz.lt_src_mrna_subj_samp_map

	select count(*) into sCount
	from tm_lz.lt_src_mrna_subj_samp_map;

	--	check if all subject_sample map records have a subject_id, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map t
	where subject_id is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'subject_id missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a sample_cd, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map t
	where sample_cd is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'sample_cd missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a platform, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map t
	where platform is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Platform missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

  	--	check if platform exists in probeset_deapp .  If not, abort run.

	select count(*) into pCount
	from deapp.de_chromosomal_region
	where gpl_id in (select distinct m.platform from tm_lz.lt_src_mrna_subj_samp_map m);

	if pCount = 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'No Chromosomal platforms in deapp.de_chromosomal_region',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if entry in deapp.de_gpl_info for every Chromosomal platform, if not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map sm
	where not exists
		 (select 1 from deapp.de_gpl_info gi
		  where sm.platform = gi.platform
		    and gi.marker_type = 'Chromosomal'
			and gi.title is not null);

	if pCount > 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'deapp.de_gpl_info entry missing for one or more platforms',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a tissue_type, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map
	where tissue_type is null;

	if pCount > 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Tissue_Type is null for subjects',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if there are multiple platforms for a single sample   if yes, then different source_cd must be used to load the samples.

	select count(*) into pCount
	from (select sample_cd
		  from tm_lz.lt_src_mrna_subj_samp_map
		  group by sample_cd
		  having count(distinct platform) > 1) x;

	if pCount > 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Multiple platforms for single sample',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	-- Get root_node from topNode

	select tm_cz.parse_nth_value(topNode, 2, '\') into RootNode;

	select count(*) into pExists
	from i2b2metadata.i2b2
	where c_name = rootNode;

	if pExists = 0 then
		select tm_cz.i2b2_add_root_node(rootNode, jobId) into rtnCd;
	end if;

	select c_hlevel into root_level
	from i2b2metadata.i2b2
	where c_name = RootNode;

	-- Get study name from topNode

	select tm_cz.parse_nth_value(topNode, topLevel, '\') into study_name;

	--	Add any upper level nodes as needed

	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount;

	if pCount > 2 then
		select tm_cz.i2b2_fill_in_tree('', tPath, jobId) into rtnCd;
	end if;

	--	uppercase study_id in tm_lz.lt_src_mrna_subj_samp_map in case curator forgot

	begin
	update tm_lz.lt_src_mrna_subj_samp_map
	set trial_name=upper(trial_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in tm_lz.lt_src_mrna_subj_samp_map',rowCt,stepCt,'Done') into rtnCd;

	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd

	begin
	insert into i2b2demodata.patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,current_timestamp
		  ,current_timestamp
		  ,current_timestamp
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from tm_lz.lt_src_mrna_subj_samp_map s
		     ,deapp.de_gpl_info g
		 where s.subject_id is not null
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = 'CHROMOSOMAL'
		   and not exists
			  (select 1 from i2b2demodata.patient_dimension x
			   where x.sourcesystem_cd =
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) x;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	add security for trial if new subjects added to patient_dimension

	if pCount > 0 then
		select tm_cz.i2b2_create_security_for_trial(TrialId, secureStudy, jobID) into rtnCd;
	end if;

	--	Delete existing observation_fact data, will be repopulated

	begin
	delete from i2b2demodata.observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from deapp.de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		--    and x.platform = 'MRNA_AFFYMETRIX');
		    and x.platform = 'ACGH');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--	check if trial/source_cd already loaded, if yes, get existing partition_id else get new one
	
	select count(*) into partExists
	from deapp.de_subject_sample_mapping sm
	where sm.trial_name = TrialId
	  and coalesce(sm.source_cd,'STD') = sourceCd
	  -- and sm.platform = 'MRNA_AFFYMETRIX'
	  and sm.platform = 'ACGH'
	  and sm.partition_id is not null;

	if partExists = 0 then
		select nextval('deapp.seq_mrna_partition_id') into partitionId;
	else
		select distinct partition_id into partitionId
		from deapp.de_subject_sample_mapping sm
		where sm.trial_name = TrialId
		  and coalesce(sm.source_cd,'STD') = sourceCd
		--  and sm.platform = 'MRNA_AFFYMETRIX';
		  and sm.platform = 'ACGH';
	end if;

	partitionName := 'deapp.de_subject_acgh_data_' || partitionId::text;
	partitionIndx := 'de_subject_acgh_data_' || partitionId::text;

	--	truncate tmp node table

	execute ('truncate table tm_wz.wt_mrna_nodes');

	--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
	--	from wt_subject_mrna_data

	execute ('truncate table tm_wz.wt_mrna_node_values');

	begin
	insert into tm_wz.wt_mrna_node_values
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from tm_lz.lt_src_mrna_subj_samp_map a
	    ,deapp.de_gpl_info g
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = 'CHROMOSOMAL';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP tm_wz.wt_mrna_node_values',rowCt,stepCt,'Done') into rtnCd;

	--	inserts that create the ontology for the leaf nodes

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g')
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  tm_wz.wt_mrna_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for platform node so platform concept can be populated

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'PLATFORM'
	from  tm_wz.wt_mrna_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else '' end as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'ATTR1'
	from  tm_wz.wt_mrna_node_values
	where category_cd like '%ATTR1%'
	  and attribute_1 is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else '' end as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  tm_wz.wt_mrna_node_values
	where category_cd like '%ATTR2%'
	  and attribute_2 is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for tissue_type node so sample_type_cd can be populated

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else '' end as platform
		  ,tissue_type as tissue_type
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'TISSUETYPE'
	from  tm_wz.wt_mrna_node_values
	where category_cd like '%TISSUETYPE%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	set node_name

	begin
	update tm_wz.wt_mrna_nodes
	set node_name=tm_cz.parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	add leaf nodes for mRNA data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)

		select tm_cz.i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;

		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,tText,1,stepCt,'Done') into rtnCd;

		select tm_cz.i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID) into rtnCd;

	END LOOP;

	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes

	begin
	update i2b2metadata.i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done') into rtnCd;

	--	update concept_cd for nodes, this is done to make the next insert easier

	begin
	update tm_wz.wt_mrna_nodes t
	set concept_cd=(select c.concept_cd from i2b2demodata.concept_dimension c
	                where c.concept_path = t.leaf_node
				   )
    where exists
         (select 1 from i2b2demodata.concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and t.concept_cd is null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update tm_wz.wt_mrna_nodes with newly created concept_cds',rowCt,stepCt,'Done') into rtnCd;

	--	delete any site/subject/samples that are not in lt_src_mrna_data for the trial on a reload

	if partExists > 0 then
	begin
	delete from deapp.de_subject_sample_mapping sm
	where sm.trial_name = trial_id
	  and sm.source_cd = sourceCd
	  and sm.platform = 'ACGH'
	 and not exists
		 (select 1 from tm_lz.lt_src_mrna_subj_samp_map x
		  where coalesce(sm.site_id,'@') = coalesce(x.site_id,'@')
		    and sm.subject_id = x.subject_id
			and sm.sample_cd = x.sample_cd
			and sm.source_cd = coalesce(x.source_cd,'STD'));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
		end;
	end if;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete dropped site/subject/sample from de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

	--Update or insert DE_SUBJECT_SAMPLE_MAPPING from wt_subject_mrna_data

	--PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
	--SITE_ID         = site_id
	--SUBJECT_ID      = subject_id
	--SUBJECT_TYPE    = NULL
	--CONCEPT_CODE    = from LEAF records in tm_wz.wt_mrna_nodes
	--SAMPLE_TYPE    	= TISSUE_TYPE
	--SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in tm_wz.wt_mrna_nodes
	--TRIAL_NAME      = TRIAL_NAME
	--TIMEPOINT		= attribute_2
	--TIMEPOINT_CD	= concept_cd from ATTR2 records in tm_wz.wt_mrna_nodes
	--TISSUE_TYPE     = attribute_1
	--TISSUE_TYPE_CD  = concept_cd from ATTR1 records in tm_wz.wt_mrna_nodes
	--PLATFORM        = MRNA_AFFYMETRIX - this is required by ui code
	--PLATFORM_CD     = concept_cd from PLATFORM records in tm_wz.wt_mrna_nodes
	--DATA_UID		= concatenation of concept_cd-patient_num
	--GPL_ID			= platform from wt_subject_mrna_data
	--CATEGORY_CD		= category_cd that generated ontology
	--SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
	--SAMPLE_CD		= sample_cd
	--SOURCE_CD		= sourceCd
	--PARTITION_ID	= partitionId

	--ASSAY_ID        = generated by trigger

	begin
	with upd as (select a.site_id, a.subject_id, a.sample_cd,
					ln.concept_cd as concept_code, ttp.concept_cd as sample_type_cd, a2.concept_cd as timepoint_cd, a1.concept_cd as tissue_type_cd, a.category_cd,
				    pd.patient_num as patient_id, ln.concept_cd || '-' || pd.patient_num::text as data_uid,
					ln.tissue_type as sample_type, ln.attribute_1 as tissue_type, ln.attribute_2 as timepoint, a.platform as gpl_id
				 from tm_lz.lt_src_mrna_subj_samp_map a
				 inner join i2b2demodata.patient_dimension pd
					on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = pd.sourcesystem_cd
				 inner join tm_wz.wt_mrna_nodes ln
					on 	a.platform = ln.platform
					and a.tissue_type = ln.tissue_type
					and coalesce(a.attribute_1,'') = coalesce(ln.attribute_1,'')
					and coalesce(a.attribute_2,'') = coalesce(ln.attribute_2,'')
					and ln.node_type = 'LEAF'
				 inner join tm_wz.wt_mrna_nodes pn
					on  a.platform = pn.platform
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(pn.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(pn.attribute_1,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(pn.attribute_2,'')
					and pn.node_type = 'PLATFORM'
				 left outer join tm_wz.wt_mrna_nodes ttp
					on  a.tissue_type = ttp.tissue_type
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '' end = coalesce(ttp.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(ttp.attribute_1,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(ttp.attribute_2,'')
					and ttp.node_type = 'TISSUETYPE'
				 left outer join tm_wz.wt_mrna_nodes a1
					on  a.attribute_1 = a1.attribute_1
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a1.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a1.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(a1.attribute_2,'')
					and a1.node_type = 'ATTR1'
				 left outer join tm_wz.wt_mrna_nodes a2
					on  a.attribute_2 = a1.attribute_2
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a2.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a2.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(a2.attribute_1,'')
					and a2.node_type = 'ATTR2')
		update deapp.de_subject_sample_mapping pd
		set concept_code=upd.concept_code
			,sample_type_cd=upd.sample_type_cd
			,timepoint_cd=upd.timepoint_cd
			,tissue_type_cd=upd.tissue_type_cd
			,category_cd=upd.category_cd
			,patient_id=upd.patient_id
			,data_uid=upd.data_uid
			,sample_type=upd.sample_type
			,tissue_type=upd.tissue_type
			,timepoint=upd.timepoint
			,omic_patient_id=upd.patient_id
			,partition_id=partitionId
		from upd
		where pd.trial_name = TrialID
		  and pd.source_cd = sourceCD
		  and coalesce(pd.site_id,'') = coalesce(upd.site_id,'')
		  and pd.subject_id = upd.subject_id
		  and pd.sample_cd = upd.sample_cd;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update existing data in de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
	pcount := rowCt;	--	set counter to check that all subject_sample mapping records were added/updated
	--	insert any site/subject/samples that are not in de_subject_sample_mapping

	begin
	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
	,partition_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
		  ,partitionId
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			--  ,'MRNA_AFFYMETRIX' as platform
			  ,'ACGH' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+Gene_Expression+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from tm_lz.lt_src_mrna_subj_samp_map a
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join i2b2demodata.patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = b.sourcesystem_cd
		inner join tm_wz.wt_mrna_nodes ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'') = coalesce(ln.attribute_1,'')
			and coalesce(a.attribute_2,'') = coalesce(ln.attribute_2,'')
			and ln.node_type = 'LEAF'
		inner join tm_wz.wt_mrna_nodes pn
			on a.platform = pn.platform
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(pn.tissue_type,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(pn.attribute_1,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(pn.attribute_2,'')
			and pn.node_type = 'PLATFORM'
		left outer join tm_wz.wt_mrna_nodes ttp
			on a.tissue_type = ttp.tissue_type
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '' end = coalesce(ttp.platform,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(ttp.attribute_1,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(ttp.attribute_2,'')
			and ttp.node_type = 'TISSUETYPE'
		left outer join tm_wz.wt_mrna_nodes a1
			on a.attribute_1 = a1.attribute_1
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a1.platform,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a1.tissue_type,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(a1.attribute_2,'')
			and a1.node_type = 'ATTR1'
		left outer join tm_wz.wt_mrna_nodes a2
			on a.attribute_2 = a1.attribute_2
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a2.platform,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a2.tissue_type,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(a2.attribute_1,'')
			and a2.node_type = 'ATTR2'
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  ln.concept_cd is not null
		  and not exists
			  (select 1 from deapp.de_subject_sample_mapping x
			   where a.trial_name = x.trial_name
			     and coalesce(a.source_cd,'STD') = x.source_cd
				-- and x.platform = 'MRNA_AFFYMETRIX'
				 and x.platform = 'ACGH'
				 and coalesce(a.site_id,'') = coalesce(x.site_id,'')
				 and a.subject_id = x.subject_id
				 and a.sample_cd = x.sample_cd
				 )) t;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
	pCount := pCount + rowCt;
	
	--	check if all records from lt_src_mrna_subj_samp_map were added/updated
	
	if scount <> pCount then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Not all records in lt_src_mrna_subj_samp_map inserted/updated in de_subject_sample_mapping',0,stepCt,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;	
	--	Insert records for subjects into observation_fact

	begin
	insert into i2b2demodata.observation_fact
    (encounter_num
        ,patient_num
	,concept_cd
	,start_date
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
	,instance_num
    )
    select distinct m.patient_id
                  ,m.patient_id
		  ,m.concept_code
		  ,current_timestamp
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,current_timestamp
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
		  , 0
    from  deapp.de_subject_sample_mapping m
    where m.trial_name = TrialID
	  and m.source_cd = sourceCD
    --  and m.platform = 'MRNA_AFFYMETRIX';
      and m.platform = 'ACGH';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--Update I2b2 for correct c_columndatatype, c_visualattributes, c_metadataxml

	begin
	with upd as (select x.concept_cd, min(case when x.node_type = 'LEAF' then 0 else 1 end) as node_type from tm_wz.wt_mrna_nodes x group by x.concept_cd)
	update i2b2metadata.i2b2 t
	set c_columndatatype = 'T'
	   ,c_metadataxml = null
	   ,c_visualattributes=case when upd.node_type = 0 then 'LAH' else 'FA' end  
	from upd
	where t.c_basecode = upd.concept_cd;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Initialize visualattributes and xml in i2b2',rowCt,stepCt,'Done') into rtnCd;

  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for mRNA data

    select tm_cz.i2b2_create_concept_counts(topNode ,jobID ) into rtnCd;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done') into rtnCd;

	--	delete each node that is hidden

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		select tm_cz.i2b2_delete_1_node(r_delNodes.c_fullname) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;

		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done') into rtnCd;

	END LOOP;

	--Reload Security: Inserts one record for every I2B2 record into the security table

    select tm_cz.i2b2_load_security_data(jobId) into rtnCd;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done') into rtnCd;

	--	tag data with probeset_id from reference.probeset_deapp

	execute ('truncate table tm_wz.wt_subject_acgh_region');

	--	note: assay_id represents a unique subject/site/sample

	begin
	insert into tm_wz.wt_subject_acgh_region
	(region_id
	,chip
	,segmented
	,flag
	,probloss
	,probnorm
	,probgain
	,probamp
	,patient_id
	,trial_name
	,assay_id
	)
	select gs.region_id
		  ,cast(md.chip as double precision)
		  ,cast(md.segmented as double precision)
		  ,cast(md.flag as smallint)
		  ,cast(md.probloss as double precision)
		  ,cast(md.probnorm as double precision)
		  ,cast(md.probgain as double precision)
		  ,cast(md.probamp as double precision)
		  ,sd.patient_id
		  ,TrialId
		  ,sd.assay_id
	from deapp.de_subject_sample_mapping sd
		,tm_lz.lt_src_acgh_data md
		,deapp.de_chromosomal_region gs
	where sd.sample_cd = md.expr_id
	  and sd.platform = 'ACGH'
	  and sd.trial_name = TrialId
	  and sd.source_cd = sourceCd
	  and sd.gpl_id = gs.gpl_id
	  and md.region_name = gs.region_name
	group by gs.region_id, md.chip, md.segmented, md.flag, md.probloss, md.probnorm, md.probgain, md.probamp
		  ,sd.patient_id,sd.assay_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_acgh_region',rowCt,stepCt,'Done') into rtnCd;

	if rowCt = 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Unable to match probesets to platform in probeset_deapp',0,rowCt,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;
	
	--	add partition if it doesn't exist, drop indexes and truncate if it does (reload)

	select count(*) into pExists
	from information_schema.tables
	where table_name = partitionindx;
	
	if pExists = 0 then
		sqlText := 'create table ' || partitionName || ' ( constraint mrna_' || partitionId::text || '_check check ( partition_id = ' || partitionId::text ||
				--	')) inherits (deapp.de_subject_microarray_data)';
					')) inherits (deapp.de_subject_acgh_data)';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create partition ' || partitionName,1,stepCt,'Done') into rtnCd;
	else
		sqlText := 'drop index if exists ' || partitionIndx || '_idx1';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		sqlText := 'drop index if exists ' || partitionIndx || '_idx2';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		sqlText := 'drop index if exists ' || partitionIndx || '_idx3';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		sqlText := 'drop index if exists ' || partitionIndx || '_idx4';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on ' || partitionName,1,stepCt,'Done') into rtnCd;
		sqlText := 'truncate table ' || partitionName;
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Truncate ' || partitionName,1,stepCt,'Done') into rtnCd;
	end if;

	--	insert into de_subject_microarray_data when dataType is T (transformed)

	sqlText := 'insert into ' || partitionName || ' (partition_id, region_id, assay_id, patient_id, trial_name, chip, segmented, flag, probloss, probnorm, probgain, probamp) ' ||
			   'select ' || partitionId::text || ', region_id, assay_id, patient_id, trial_name, chip, segmented, flag, probloss, probnorm, probgain, probamp ' ||
			   'from tm_wz.wt_subject_acgh_region';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted data into ' || partitionName,rowCt,stepCt,'Done') into rtnCd;

	--	create indexes on partition

	sqlText := ' create index ' || partitionIndx || '_idx1 on ' || partitionName || ' using btree (region_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx2 on ' || partitionName || ' using btree (assay_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx3 on ' || partitionName || ' using btree (region_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx4 on ' || partitionName || ' using btree (assay_id, region_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
    ---Cleanup OVERALL JOB if this proc is being run standalone

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_acgh_data',0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_process_acgh_data(trial_id character varying, top_node character varying, source_cd character varying, secure_study character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_process_metabolomic_data(character varying, character varying, character varying, character varying, bigint, character varying, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_process_metabolomic_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_code character varying DEFAULT 'STD'::character varying, log_base bigint DEFAULT 2, secure_study character varying DEFAULT 'N'::character varying, currentjobid bigint DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$

/*************************************************************************

* This store procedure is for ETL for Sanofi to load  metabolomics data
* Date: 1/2/2014

******************************************************************
--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint
*************************************/

Declare
  TrialID		varchar(100);
  RootNode		varchar(2000);
  root_level	integer;
  topNode		varchar(2000);
  topLevel		integer;
  tPath			varchar(2000);
  study_name	varchar(100);
  sourceCd		varchar(50);
  secureStudy	varchar(1);

  dataType		varchar(10);
  sqlText		varchar(1000);
  tText			varchar(1000);
  gplTitle		varchar(1000);
  pExists		bigint;
  partTbl   	bigint;
  partExists 	bigint;
  sampleCt		bigint;
  idxExists 	bigint;
  logBase		bigint;
  pCount		integer;
  sCount		integer;
  tablespaceName	varchar(200);
  v_bio_experiment_id	bigint;
  rtn_code		integer;
  partitioniD	numeric(18,0);
  partitionName	varchar(100);
  partitionIndx	varchar(100);
  
    --Audit variables
  newJobFlag integer;
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  rowCt			numeric(18,0);
  errorNumber		character varying;
  errorMessage	character varying;
  rtnCd			integer;
  
	addNodes CURSOR FOR
	SELECT distinct t.leaf_node
          ,t.node_name
	from  WT_METABOLOMIC_NODES t
	where not exists
		 (select 1 from i2b2 x
		  where t.leaf_node = x.c_fullname);

 
--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  delNodes CURSOR FOR
  SELECT distinct c_fullname 
  from  i2b2
  where c_fullname like topNode || '%'
    and substring(c_visualattributes from 2 for 1) = 'H';
    --and c_visualattributes like '_H_';


     uploadI2b2 cursor for
    select category_cd,display_value,display_label,display_unit from
    tm_lz.lt_src_METABOLOMICS_display_mapping;
    



BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\');	
	select length(topNode)-length(replace(topNode,'\','')) into topLevel ;
	
	if coalesce(data_type::text, '') = '' then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;
	
	logBase := log_base;
	sourceCd := upper(coalesce(source_code,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

    databaseName := 'TM_CZ';
	procedureName := 'I2B2_PROCESS_METABOLOMIC_DATA';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName, jobID) into jobId;
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_metabolomics_data',0,stepCt,'Done');
	
	--	Get count of records in LT_SRC_METABOLOMIC_MAP
	
	select count(*) into sCount
	from LT_SRC_METABOLOMIC_MAP;
	
	--	check if all subject_sample map records have a platform, If not, abort run
	select count(*) into pCount
	from LT_SRC_METABOLOMIC_MAP
	where coalesce(platform::text, '') = '';
	
	if pCount > 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename);
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
	end if;
  
  	--	check if platform exists in de_qpcr_mirna_annotation .  If not, abort run.
	
	select count(*) into pCount
	from LT_METABOLOMIC_ANNOTATION
	where gpl_id in (select distinct m.platform from LT_SRC_METABOLOMIC_MAP m);
	
	select count(*) into pCount
	from DE_gpl_info
	where platform in (select distinct m.platform from LT_SRC_METABOLOMIC_MAP m);
	
	if PCOUNT = 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Platform not found in de_qpcr_metabolomics_annotation',1,stepCt,'ERROR');
		perform CZ_ERROR_HANDLER(JOBID,PROCEDURENAME);
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		RETURN 163;
	end if;
		
	--	check if all subject_sample map records have a tissue_type, If not, abort run
	
	select count(*) into pCount
	from LT_SRC_METABOLOMIC_MAP
	where coalesce(tissue_type::text, '') = '';
	
	if pCount > 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Tissue Type data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename);
		select CZ_END_AUDIT (JOBID,'FAIL') into rtnCd;
		return 162;
	end if;
	
	--	check if there are multiple platforms, if yes, then platform must be supplied in LT_SRC_METABOLOMIC_MAP
	
	select count(*) into pCount
	from (select sample_cd
		  from LT_SRC_METABOLOMIC_MAP
		  group by sample_cd
		  having count(distinct platform) > 1)as s;
	
	if pCount > 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Multiple platforms for sample_cd in LT_SRC_METABOLOMIC_MAP',1,stepCt,'ERROR');
		perform CZ_ERROR_HANDLER(JOBID,PROCEDURENAME);
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		RETURN 164;
	end if;
		
	-- Get root_node from topNode
  
	select parse_nth_value(topNode, 2, '\') into RootNode ;
	
	select count(*) into pExists
	from table_access
	where c_name = rootNode;
	
	if pExists = 0 then
		perform i2b2_add_root_node(rootNode, jobId);
	end if;
	
	select c_hlevel into root_level
	from i2b2
	where c_name = RootNode;
	
	-- Get study name from topNode
  
	select parse_nth_value(topNode, topLevel, '\') into study_name ;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,null),'(\\){2,}', '\');
	select length(tPath) - length(replace(tPath,'\',null)) into pCount ;

	if pCount > 2 then
		perform i2b2_fill_in_tree(null, tPath, jobId);
	end if;

	--	uppercase study_id in LT_SRC_METABOLOMIC_MAP in case curator forgot
	begin
	update LT_SRC_METABOLOMIC_MAP
	set trial_name=upper(trial_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in LT_SRC_METABOLOMIC_MAP',rowCt,stepCt,'Done');
	
	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd
	begin
	insert into patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from LT_SRC_METABOLOMIC_MAP s
		     ,de_gpl_info g
		 where (s.subject_id IS NOT NULL AND s.subject_id::text <> '')
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = 'METABOLOMICS'
		   and not exists
			  (select 1 from patient_dimension x
			   where x.sourcesystem_cd = 
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) as x;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',rowCt,stepCt,'Done');
	
	perform i2b2_create_security_for_trial(TrialId, secureStudy, jobID);

	--	Delete existing observation_fact data, will be repopulated
	begin
	delete from observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = 'METABOLOMICS');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done');

	select count(*) into partExists
	from deapp.de_subject_sample_mapping sm
	where sm.trial_name = TrialId
	and coalesce(sm.source_cd,'STD') = sourceCd
	and sm.platform = 'METABOLOMICS'
	and sm.partition_id is not null;
	
	if partExists = 0 then
		select nextval('deapp.seq_metabolomics_partition_id') into partitionId;
	else
		select distinct partition_id into partitionId
		from deapp.de_subject_sample_mapping sm
		where sm.trial_name = TrialId
		and coalesce(sm.source_cd,'STD') = sourceCd
		and sm.platform = 'METABOLOMICS';
	end if;

	partitionName := 'deapp.de_subject_metabolomics_data_' || partitionId::text;
	partitionIndx := 'de_subject_metabolomics_data_' || partitionId::text;

	--	Cleanup any existing data in de_subject_sample_mapping.  
	begin
	delete from DE_SUBJECT_SAMPLE_MAPPING 
	where trial_name = TrialID 
	  and coalesce(source_cd,'STD') = sourceCd
	  and platform = 'METABOLOMICS'; --Making sure only metabolomic data is deleted
	  get diagnostics rowCt := ROW_COUNT;
	  exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		  
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done');

--	truncate tmp node table

	EXECUTE('truncate table tm_wz.WT_METABOLOMIC_NODES');
	
--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
--	from wt_subject_mirna_data

	EXECUTE('truncate table tm_wz.WT_METABOLOMIC_NODE_VALUES');
	begin
	insert into WT_METABOLOMIC_NODE_VALUES
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from LT_SRC_METABOLOMIC_MAP a
	    ,de_gpl_info g 
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = 'METABOLOMICS'
	  and g.title = (select min(x.title) from de_gpl_info x where coalesce(a.platform,'GPL570') = x.platform)
	  ;
	  get diagnostics rowCt := ROW_COUNT;
      exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP WT_METABOLOMIC_NODE_VALUES',rowCt,stepCt,'Done');
	
	begin
	insert into WT_METABOLOMIC_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g')
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  WT_METABOLOMIC_NODE_VALUES;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		   
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_metabolomics_nodes',rowCt,stepCt,'Done');
	
	--	insert for platform node so platform concept can be populated
	begin
	insert into WT_METABOLOMIC_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  WT_METABOLOMIC_NODE_VALUES;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in WT_METABOLOMIC_NODES',rowCt,stepCt,'Done');

	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd
	begin
	insert into WT_METABOLOMIC_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  WT_METABOLOMIC_NODE_VALUES
	where category_cd like '%ATTR1%'
	  and (attribute_1 IS NOT NULL AND attribute_1::text <> '');
	  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in WT_METABOLOMIC_NODES',rowCt,stepCt,'Done');
	
	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd
	begin
	insert into WT_METABOLOMIC_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
		substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  WT_METABOLOMIC_NODE_VALUES
	where category_cd like '%ATTR2%'
	  and (attribute_2 IS NOT NULL AND attribute_2::text <> '');
	  get diagnostics rowCt := ROW_COUNT;
	  exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		   
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_METABOLOMIC_NODES',rowCt,stepCt,'Done');
	
	--	insert for tissue_type node so sample_type_cd can be populated
	begin
	insert into WT_METABOLOMIC_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  WT_METABOLOMIC_NODE_VALUES
	where category_cd like '%TISSUETYPE%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_METABOLOMIC_NODES',rowCt,stepCt,'Done');
	
	begin
	update WT_METABOLOMIC_NODES
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_metabolomics_nodes',rowCt,stepCt,'Done');
		
--	add leaf nodes for metabolomics data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)
		begin
		perform i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId);
		get diagnostics rowCt := ROW_COUNT;
		exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;
		
		perform cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done');
		
		perform i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID);

	END LOOP;  
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
	begin
	update i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	  get diagnostics rowCt := ROW_COUNT;
	  exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	  	
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done');
		
--	update concept_cd for nodes, this is done to make the next insert easier
	begin
	update WT_METABOLOMIC_NODES t
	set concept_cd=(select c.concept_cd from concept_dimension c
	                where c.concept_path = t.leaf_node
				   )
    where exists
         (select 1 from concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and coalesce(t.concept_cd::text, '') = '';
	  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update WT_METABOLOMIC_NODES with newly created concept_cds',rowCt,stepCt,'Done'); 
	
  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_metabolomics_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in WT_METABOLOMIC_NODES
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in WT_METABOLOMIC_NODES
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in WT_METABOLOMIC_NODES
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in WT_METABOLOMIC_NODES
  --PLATFORM        = metabolomics - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in WT_METABOLOMIC_NODES
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_metabolomics_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd
  
  --ASSAY_ID        = generated by trigger
	begin
	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
	,partition_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
		  ,partitionId
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,'METABOLOMICS' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+metabolomics+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from LT_SRC_METABOLOMIC_MAP a		
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = b.sourcesystem_cd
		inner join WT_METABOLOMIC_NODES ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'@') = coalesce(ln.attribute_1,'@')
			and coalesce(a.attribute_2,'@') = coalesce(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join WT_METABOLOMIC_NODES pn
			on a.platform = pn.platform
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(pn.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(pn.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'	  
		left outer join WT_METABOLOMIC_NODES ttp
			on a.tissue_type = ttp.tissue_type
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = coalesce(ttp.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(ttp.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'		  
		left outer join WT_METABOLOMIC_NODES a1
			on a.attribute_1 = a1.attribute_1
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a1.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a1.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'		  
		left outer join WT_METABOLOMIC_NODES a2
			on a.attribute_2 = a1.attribute_2
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a2.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a2.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'			  
		left outer join patient_dimension sid
			on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  (ln.concept_cd IS NOT NULL AND ln.concept_cd::text <> '')) t;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done');

--	Insert records for patients and samples into observation_fact
	begin
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,INSTANCE_NUM
    )
    select distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,1
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCD
      and m.platform = 'METABOLOMICS';
	  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	  
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done');

	--	Insert sample facts 
	begin
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    select distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCd
      and m.platform = 'METABOLOMICS'
	 and m.patient_id != m.sample_id;
	 get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	  
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done');

	--Update I2b2 for correct data type
	begin
	update i2b2 t
	set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
	where t.c_basecode in (select distinct x.concept_cd from WT_METABOLOMIC_NODES x);
  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',rowCt,stepCt,'Done');
	


 ---INSERT sample_dimension
	begin
      INSERT INTO I2B2DEMODATA.SAMPLE_DIMENSION(SAMPLE_CD) 
         SELECT DISTINCT SAMPLE_CD FROM 
	   DEAPP.DE_SUBJECT_SAMPLE_MAPPING WHERE SAMPLE_CD NOT IN (SELECT SAMPLE_CD FROM I2B2DEMODATA.SAMPLE_DIMENSION) ;
	   get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'insert distinct sample_cd in sample_dimension from de_subject_sample_mapping',rowCt,stepCt,'Done');

    ---- update c_metedataxml in i2b2
	begin
       for ul in uploadI2b2
        loop
	 update i2b2 n
	SET n.c_columndatatype = 'N',
      --Static XML String
		c_metadataxml =  ('<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue>
                <HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue>
                <LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue>
                <EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion>
                <UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits>
                <ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor>
                </ConvertingUnits></UnitValues><Analysis><Enums /><Counts />
                <New /></Analysis>'||(select xmlelement(name "SeriesMeta",xmlforest(m.display_value as "Value",m.display_unit as "Unit",m.display_label as "DisplayName")) as hi 
      from tm_lz.lt_src_display_mapping m where m.category_cd=ul.category_cd)||
                '</ValueMetadata>') where n.c_fullname=ul.category_cd;
                
                end loop;
		 get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end; 
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',rowCt,stepCt,'Done');
	    
	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	begin
	update i2b2 a
    set c_visualattributes = 'LAH'
	where a.c_basecode in (select distinct x.concept_code from de_subject_sample_mapping x
						   where x.trial_name = TrialId
						     and x.platform = 'METABOLOMICS'
							 and (x.concept_code IS NOT NULL AND x.concept_code::text <> ''));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done');
  
  begin
    update i2b2metadata.i2b2 a
	set c_visualattributes='FAS'
        where a.c_fullname = substr(topNode,1,instr(topNode,'\',1,3));
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
        
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for study nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done');
    
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for metabolomic data
  
    perform i2b2_create_concept_counts(topNode ,jobID );
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done');
	
	--	delete each node that is hidden

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		perform i2b2_delete_1_node(r_delNodes.c_fullname);
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		
		perform cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done');

	END LOOP;  	


  --Reload Security: Inserts one record for every I2B2 record into the security table
	begin
    perform i2b2_load_security_data(jobId);
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done');

--	tag data with probeset_id from reference.probeset_deapp
  
	EXECUTE ('truncate table tm_wz.WT_SUBJECT_MBOLOMICS_PROBESET');
	
	--	note: assay_id represents a unique subject/site/sample
	begin
	insert into WT_SUBJECT_MBOLOMICS_PROBESET  --mod
	(probeset
	,intensity_value
	,patient_id
	,subject_id
	,trial_name
	,assay_id
	)
	select md.biochemical
		  ,avg(md.intensity_value)
                  ,sd.patient_id
                  ,sd.subject_id
		  ,TrialId
		  ,sd.assay_id
	from deapp.de_subject_sample_mapping sd
		,LT_SRC_METABOLOMIC_DATA md   
	where sd.sample_cd = md.expr_id
	  and sd.platform = 'METABOLOMICS'
	  and sd.trial_name =TrialId
	  and sd.source_cd = sourceCd
	 and (CASE WHEN dataType = 'R' THEN sign(md.intensity_value) ELSE 1 END) = 1 
		group by md.biochemical, subject_id
		,sd.patient_id, sd.assay_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_mbolomics_probeset',rowCt,stepCt,'Done') into rtnCd;

	select count(*) into pExists
	from information_schema.tables
	where table_name = partitionindx;

	if pExists = 0 then
	sqlText := 'create table ' || partitionName || ' ( constraint metabolomics_' || partitionId::text || '_check check ( partition_id = ' || partitionId::text ||
	')) inherits (deapp.de_subject_metabolomics_data)';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create partition ' || partitionName,1,stepCt,'Done') into rtnCd;
	else
	sqlText := 'drop index if exists ' || partitionIndx || '_idx1';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx2';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx3';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx4';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on ' || partitionName,1,stepCt,'Done') into rtnCd;
	sqlText := 'truncate table ' || partitionName;
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Truncate ' || partitionName,1,stepCt,'Done') into rtnCd;
	end if;
	
	--	insert into de_subject_mirna_data when dataType is T (transformed)

	if dataType = 'T' then
        sqlText := 'insert into ' || partitionName || 
	'(partition_id,trial_source ,trial_name ,metabolite_annotation_id ' ||
	',assay_id ,subject_id ,raw_intensity ,log_intensity ,zscore ,patient_id ) ' ||
                'select ' || partitioniD::text || ', m.trial_name || '':'' || mpp.source_cd, ' ||
                  '''' || TrialId || '''' ||
                ',d.Id ,m.assay_id ,m.subject_id ,m.intensity_value ' ||
                  ' ,log(2,m.intensity_value) ' ||
			  ',case when m.intensity_value < -2.5 ' ||
			        'then -2.5 ' ||
					'when m.intensity_value > 2.5 ' ||
					'then 2.5 ' ||
					'else m.intensity_value ' ||
			   'end as zscore' ||
                           ',m.patient_id ' ||
                'from WT_SUBJECT_MBOLOMICS_PROBESET  m, ' ||
                '(select distinct mp.source_cd,mp.platform From TM_LZ.LT_SRC_METABOLOMIC_MAP mp and mp.trial_name = ''' || TrialID || ''') mpp ' ||
                ',DEAPP.DE_METABOLITE_ANNOTATION d ' ||
		'where m.trial_name = TrialID ' ||
                'and d.biochemical_name = m.probeset ' ||
                'and mpp.platform = d.gpl_id' ;
		
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
		perform cz_write_audit(jobId,databaseName,procedureName,'Insert transformed into DEAPP DE_SUBJECT_METABOLOMICS_DATA',rowCt,stepCt,'Done');

	else
		
	--	Calculate ZScores and insert data into de_subject_mirna_data.  The 'L' parameter indicates that the gene expression data will be selected from
	--	WT_SUBJECT_MBOLOMICS_PROBESET as part of a Load.  

		if dataType = 'R' or dataType = 'L' then
			perform I2B2_METABOLOMICS_ZSCORE_CALC(TrialID, partitionName, partitionindx,partitioniD,sourceCD,'L',jobId,dataType,logBase);
			stepCt := stepCt + 1;
			perform cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',0,stepCt,'Done');
		end if;
	
	end if;

    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_metabolomics_data',0,stepCt,'Done');

	IF newJobFlag = 1
	THEN
		perform cz_end_audit (jobID, 'SUCCESS');
	END IF;

	select 0 into rtn_code ;
	return 0;

END;
 
$$;


ALTER FUNCTION tm_cz.i2b2_process_metabolomic_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base bigint, secure_study character varying, currentjobid bigint) OWNER TO tm_cz;

--
-- Name: i2b2_process_mrna_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: postgres
--

CREATE FUNCTION i2b2_process_mrna_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_cd character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, deapp, i2b2demodata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;

	TrialID			varchar(100);
	RootNode		varchar(2000);
	root_level		integer;
	topNode			varchar(2000);
	topLevel		integer;
	tPath			varchar(2000);
	study_name		varchar(100);
	sourceCd		varchar(50);
	secureStudy		varchar(1);

	dataType		varchar(10);
	sqlText			varchar(1000);
	tText			varchar(1000);
	gplTitle		varchar(1000);
	pExists			numeric;
	partTbl   		numeric;
	partExists 		numeric;
	sampleCt		numeric;
	idxExists 		numeric;
	logBase			numeric;
	pCount			integer;
	sCount			integer;
	tablespaceName	varchar(200);
	partitioniD		numeric(18,0);
	partitionName	varchar(100);
	partitionIndx	varchar(100);

	--	cursor to add leaf nodes, cursor is used here because there are few nodes to be added

	addNodes CURSOR is
	select distinct t.leaf_node
          ,t.node_name
	from  tm_wz.wt_mrna_nodes t
	where not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where t.leaf_node = x.c_fullname);

	--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

	delNodes CURSOR is
	select distinct c_fullname
	from  i2b2metadata.i2b2
	where c_fullname like topNode || '%' escape '`'
      and substr(c_visualattributes,2,1) = 'H';

BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	databaseName := 'TM_CZ';
	procedureName := 'I2B2_PROCESS_MRNA_DATA';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_mrna_data',0,stepCt,'Done') into rtnCd;

	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;

	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\','g');
	select length(topNode)-length(replace(topNode,'\','')) into topLevel;

	if data_type is null then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;

	logBase := coalesce(log_base, 2);
	sourceCd := upper(coalesce(source_cd,'STD'));

	--	Get count of records in tm_lz.lt_src_mrna_subj_samp_map

	select count(*) into sCount
	from tm_lz.lt_src_mrna_subj_samp_map;

	--	check if all subject_sample map records have a subject_id, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map t
	where subject_id is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'subject_id missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a sample_cd, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map t
	where sample_cd is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'sample_cd missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a platform, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map t
	where platform is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Platform missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

  	--	check if platform exists in probeset_deapp .  If not, abort run.

	select count(*) into pCount
	from tm_cz.probeset_deapp
	where platform in (select distinct m.platform from tm_lz.lt_src_mrna_subj_samp_map m);

	if pCount = 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'No Gene Expression platforms in deapp.de_mrna_annotation',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if entry in deapp.de_gpl_info for every Gene Expression platform, if not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map sm
	where not exists
		 (select 1 from deapp.de_gpl_info gi
		  where sm.platform = gi.platform
		    and gi.marker_type = 'Gene Expression'
			and gi.title is not null);

	if pCount > 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'deapp.de_gpl_info entry missing for one or more platforms',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a tissue_type, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map
	where tissue_type is null;

	if pCount > 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Tissue_Type is null for subjects',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if there are multiple platforms for a single sample   if yes, then different source_cd must be used to load the samples.

	select count(*) into pCount
	from (select sample_cd
		  from tm_lz.lt_src_mrna_subj_samp_map
		  group by sample_cd
		  having count(distinct platform) > 1) x;

	if pCount > 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Multiple platforms for single sample',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	-- Get root_node from topNode

	select tm_cz.parse_nth_value(topNode, 2, '\') into RootNode;

	select count(*) into pExists
	from i2b2metadata.i2b2
	where c_name = rootNode;

	if pExists = 0 then
		select tm_cz.i2b2_add_root_node(rootNode, jobId) into rtnCd;
	end if;

	select c_hlevel into root_level
	from i2b2metadata.i2b2
	where c_name = RootNode;

	-- Get study name from topNode

	select tm_cz.parse_nth_value(topNode, topLevel, '\') into study_name;

	--	Add any upper level nodes as needed

	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount;

	if pCount > 2 then
		select tm_cz.i2b2_fill_in_tree('', tPath, jobId) into rtnCd;
	end if;

	--	uppercase study_id in tm_lz.lt_src_mrna_subj_samp_map in case curator forgot

	begin
	update tm_lz.lt_src_mrna_subj_samp_map
	set trial_name=upper(trial_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in tm_lz.lt_src_mrna_subj_samp_map',rowCt,stepCt,'Done') into rtnCd;

	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd

	begin
	insert into i2b2demodata.patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,current_timestamp
		  ,current_timestamp
		  ,current_timestamp
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from tm_lz.lt_src_mrna_subj_samp_map s
		     ,deapp.de_gpl_info g
		 where s.subject_id is not null
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = 'GENE EXPRESSION'
		   and not exists
			  (select 1 from i2b2demodata.patient_dimension x
			   where x.sourcesystem_cd =
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) x;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	add security for trial if new subjects added to patient_dimension

	if pCount > 0 then
		select tm_cz.i2b2_create_security_for_trial(TrialId, secureStudy, jobID) into rtnCd;
	end if;

	--	Delete existing observation_fact data, will be repopulated

	begin
	delete from i2b2demodata.observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from deapp.de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = 'MRNA_AFFYMETRIX');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--	check if trial/source_cd already loaded, if yes, get existing partition_id else get new one

	select count(*) into partExists
	from deapp.de_subject_sample_mapping sm
	where sm.trial_name = TrialId
	  and coalesce(sm.source_cd,'STD') = sourceCd
	  and sm.platform = 'MRNA_AFFYMETRIX'
	  and sm.partition_id is not null;

	if partExists = 0 then
		select nextval('deapp.seq_mrna_partition_id') into partitionId;
	else
		select distinct partition_id into partitionId
		from deapp.de_subject_sample_mapping sm
		where sm.trial_name = TrialId
		  and coalesce(sm.source_cd,'STD') = sourceCd
		  and sm.platform = 'MRNA_AFFYMETRIX';
	end if;

	partitionName := 'deapp.de_subject_microarray_data_' || partitionId::text;
	partitionIndx := 'de_subject_microarray_data_' || partitionId::text;

	--	truncate tmp node table

	execute ('truncate table tm_wz.wt_mrna_nodes');

	--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
	--	from wt_subject_mrna_data

	execute ('truncate table tm_wz.wt_mrna_node_values');

	begin
	insert into tm_wz.wt_mrna_node_values
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from tm_lz.lt_src_mrna_subj_samp_map a
	    ,deapp.de_gpl_info g
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = 'GENE EXPRESSION';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP tm_wz.wt_mrna_node_values',rowCt,stepCt,'Done') into rtnCd;

	--	inserts that create the ontology for the leaf nodes

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g')
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  tm_wz.wt_mrna_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for platform node so platform concept can be populated

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'PLATFORM'
	from  tm_wz.wt_mrna_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else '' end as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'ATTR1'
	from  tm_wz.wt_mrna_node_values
	where category_cd like '%ATTR1%'
	  and attribute_1 is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else '' end as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  tm_wz.wt_mrna_node_values
	where category_cd like '%ATTR2%'
	  and attribute_2 is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for tissue_type node so sample_type_cd can be populated

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else '' end as platform
		  ,tissue_type as tissue_type
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'TISSUETYPE'
	from  tm_wz.wt_mrna_node_values
	where category_cd like '%TISSUETYPE%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	set node_name

	begin
	update tm_wz.wt_mrna_nodes
	set node_name=tm_cz.parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	add leaf nodes for mRNA data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)

		select tm_cz.i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;

		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,tText,1,stepCt,'Done') into rtnCd;

		select tm_cz.i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID) into rtnCd;

	END LOOP;

	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes

	begin
	update i2b2metadata.i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done') into rtnCd;

	--	update concept_cd for nodes, this is done to make the next insert easier

	begin
	update tm_wz.wt_mrna_nodes t
	set concept_cd=(select c.concept_cd from i2b2demodata.concept_dimension c
	                where c.concept_path = t.leaf_node
				   )
    where exists
         (select 1 from i2b2demodata.concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and t.concept_cd is null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update tm_wz.wt_mrna_nodes with newly created concept_cds',rowCt,stepCt,'Done') into rtnCd;

	--	delete any site/subject/samples that are not in lt_src_mrna_data for the trial on a reload

	if partExists > 0 then
	begin
	delete from deapp.de_subject_sample_mapping sm
	where sm.trial_name = trial_id
	  and sm.source_cd = sourceCd
	  and sm.platform = 'MRNA_AFFYMETRIX'
	 and not exists
		 (select 1 from tm_lz.lt_src_mrna_subj_samp_map x
		  where coalesce(sm.site_id,'@') = coalesce(x.site_id,'@')
		    and sm.subject_id = x.subject_id
			and sm.sample_cd = x.sample_cd
			and sm.source_cd = coalesce(x.source_cd,'STD'));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
		end;
	end if;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete dropped site/subject/sample from de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

	--Update or insert DE_SUBJECT_SAMPLE_MAPPING from wt_subject_mrna_data

	--PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
	--SITE_ID         = site_id
	--SUBJECT_ID      = subject_id
	--SUBJECT_TYPE    = NULL
	--CONCEPT_CODE    = from LEAF records in tm_wz.wt_mrna_nodes
	--SAMPLE_TYPE    	= TISSUE_TYPE
	--SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in tm_wz.wt_mrna_nodes
	--TRIAL_NAME      = TRIAL_NAME
	--TIMEPOINT		= attribute_2
	--TIMEPOINT_CD	= concept_cd from ATTR2 records in tm_wz.wt_mrna_nodes
	--TISSUE_TYPE     = attribute_1
	--TISSUE_TYPE_CD  = concept_cd from ATTR1 records in tm_wz.wt_mrna_nodes
	--PLATFORM        = MRNA_AFFYMETRIX - this is required by ui code
	--PLATFORM_CD     = concept_cd from PLATFORM records in tm_wz.wt_mrna_nodes
	--DATA_UID		= concatenation of concept_cd-patient_num
	--GPL_ID			= platform from wt_subject_mrna_data
	--CATEGORY_CD		= category_cd that generated ontology
	--SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
	--SAMPLE_CD		= sample_cd
	--SOURCE_CD		= sourceCd
	--PARTITION_ID	= partitionId

	--ASSAY_ID        = generated by trigger

	begin
	with upd as (select a.site_id, a.subject_id, a.sample_cd,
					ln.concept_cd as concept_code, ttp.concept_cd as sample_type_cd, a2.concept_cd as timepoint_cd, a1.concept_cd as tissue_type_cd, a.category_cd,
				    pd.patient_num as patient_id, ln.concept_cd || '-' || pd.patient_num::text as data_uid,
					ln.tissue_type as sample_type, ln.attribute_1 as tissue_type, ln.attribute_2 as timepoint, a.platform as gpl_id
				 from tm_lz.lt_src_mrna_subj_samp_map a
				 inner join i2b2demodata.patient_dimension pd
					on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = pd.sourcesystem_cd
				 inner join tm_wz.wt_mrna_nodes ln
					on 	a.platform = ln.platform
					and a.tissue_type = ln.tissue_type
					and coalesce(a.attribute_1,'') = coalesce(ln.attribute_1,'')
					and coalesce(a.attribute_2,'') = coalesce(ln.attribute_2,'')
					and ln.node_type = 'LEAF'
				 inner join tm_wz.wt_mrna_nodes pn
					on  a.platform = pn.platform
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(pn.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(pn.attribute_1,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(pn.attribute_2,'')
					and pn.node_type = 'PLATFORM'
				 left outer join tm_wz.wt_mrna_nodes ttp
					on  a.tissue_type = ttp.tissue_type
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '' end = coalesce(ttp.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(ttp.attribute_1,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(ttp.attribute_2,'')
					and ttp.node_type = 'TISSUETYPE'
				 left outer join tm_wz.wt_mrna_nodes a1
					on  a.attribute_1 = a1.attribute_1
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a1.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a1.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(a1.attribute_2,'')
					and a1.node_type = 'ATTR1'
				 left outer join tm_wz.wt_mrna_nodes a2
					on  a.attribute_2 = a1.attribute_2
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a2.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a2.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(a2.attribute_1,'')
					and a2.node_type = 'ATTR2')
		update deapp.de_subject_sample_mapping pd
		set concept_code=upd.concept_code
			,sample_type_cd=upd.sample_type_cd
			,timepoint_cd=upd.timepoint_cd
			,tissue_type_cd=upd.tissue_type_cd
			,category_cd=upd.category_cd
			,patient_id=upd.patient_id
			,data_uid=upd.data_uid
			,sample_type=upd.sample_type
			,tissue_type=upd.tissue_type
			,timepoint=upd.timepoint
			,omic_patient_id=upd.patient_id
			,partition_id=partitionId
		from upd
		where pd.trial_name = TrialID
		  and pd.source_cd = sourceCD
		  and coalesce(pd.site_id,'') = coalesce(upd.site_id,'')
		  and pd.subject_id = upd.subject_id
		  and pd.sample_cd = upd.sample_cd;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update existing data in de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
	pcount := rowCt;	--	set counter to check that all subject_sample mapping records were added/updated
	--	insert any site/subject/samples that are not in de_subject_sample_mapping

	begin
	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
	,partition_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
		  ,partitionId
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,'MRNA_AFFYMETRIX' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+Gene_Expression+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from tm_lz.lt_src_mrna_subj_samp_map a
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join i2b2demodata.patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = b.sourcesystem_cd
		inner join tm_wz.wt_mrna_nodes ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'') = coalesce(ln.attribute_1,'')
			and coalesce(a.attribute_2,'') = coalesce(ln.attribute_2,'')
			and ln.node_type = 'LEAF'
		inner join tm_wz.wt_mrna_nodes pn
			on a.platform = pn.platform
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(pn.tissue_type,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(pn.attribute_1,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(pn.attribute_2,'')
			and pn.node_type = 'PLATFORM'
		left outer join tm_wz.wt_mrna_nodes ttp
			on a.tissue_type = ttp.tissue_type
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '' end = coalesce(ttp.platform,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(ttp.attribute_1,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(ttp.attribute_2,'')
			and ttp.node_type = 'TISSUETYPE'
		left outer join tm_wz.wt_mrna_nodes a1
			on a.attribute_1 = a1.attribute_1
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a1.platform,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a1.tissue_type,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(a1.attribute_2,'')
			and a1.node_type = 'ATTR1'
		left outer join tm_wz.wt_mrna_nodes a2
			on a.attribute_2 = a1.attribute_2
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a2.platform,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a2.tissue_type,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(a2.attribute_1,'')
			and a2.node_type = 'ATTR2'
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  ln.concept_cd is not null
		  and not exists
			  (select 1 from deapp.de_subject_sample_mapping x
			   where a.trial_name = x.trial_name
			     and coalesce(a.source_cd,'STD') = x.source_cd
				 and x.platform = 'MRNA_AFFYMETRIX'
				 and coalesce(a.site_id,'') = coalesce(x.site_id,'')
				 and a.subject_id = x.subject_id
				 and a.sample_cd = x.sample_cd
				 )) t;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
	pCount := pCount + rowCt;
	
	--	check if all records from lt_src_mrna_subj_samp_map were added/updated
	
	if scount <> pCount then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Not all records in lt_src_mrna_subj_samp_map inserted/updated in de_subject_sample_mapping',0,stepCt,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;	
	--	Insert records for subjects into observation_fact

	begin
	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    select distinct m.patient_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,current_timestamp
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  deapp.de_subject_sample_mapping m
    where m.trial_name = TrialID
	  and m.source_cd = sourceCD
      and m.platform = 'MRNA_AFFYMETRIX';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--Update I2b2 for correct c_columndatatype, c_visualattributes, c_metadataxml

	begin
	with upd as (select x.concept_cd, min(case when x.node_type = 'LEAF' then 0 else 1 end) as node_type from tm_wz.wt_mrna_nodes x group by x.concept_cd)
	update i2b2metadata.i2b2 t
	set c_columndatatype = 'T'
	   ,c_metadataxml = null
	   ,c_visualattributes=case when upd.node_type = 0 then 'LAH' else 'FA' end  
	from upd
	where t.c_basecode = upd.concept_cd;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type, visualattributes and xml in i2b2',rowCt,stepCt,'Done') into rtnCd;

  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for mRNA data

    select tm_cz.i2b2_create_concept_counts(topNode ,jobID ) into rtnCd;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done') into rtnCd;

	--	delete each node that is hidden

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		select tm_cz.i2b2_delete_1_node(r_delNodes.c_fullname) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;

		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done') into rtnCd;

	END LOOP;

	--Reload Security: Inserts one record for every I2B2 record into the security table

    select tm_cz.i2b2_load_security_data(jobId) into rtnCd;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done') into rtnCd;

	--	tag data with probeset_id from reference.probeset_deapp

	execute ('truncate table tm_wz.wt_subject_mrna_probeset');

	--	note: assay_id represents a unique subject/site/sample

	begin
	insert into tm_wz.wt_subject_mrna_probeset
	(probeset_id
	,intensity_value
	,assay_id
	,trial_name
	)
	select gs.probeset_id
		  ,avg(md.intensity_value::numeric(18,4))
		  ,sd.assay_id,TrialId
	from deapp.de_subject_sample_mapping sd
		,tm_lz.lt_src_mrna_data md
		,tm_cz.probeset_deapp gs
	where sd.sample_cd = md.expr_id
	  and sd.platform = 'MRNA_AFFYMETRIX'
	  and sd.trial_name = TrialId
	  and sd.source_cd = sourceCd
	  and sd.gpl_id = gs.platform
	  and md.probeset = gs.probeset
	  and case when dataType = 'R'
			   then case when md.intensity_value::numeric(18,4) > 0 then 1 else 0 end
			   else 1 end = 1         --	take only >0 for dataType R
	group by gs.probeset_id
		  ,sd.assay_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_mrna_probeset',rowCt,stepCt,'Done') into rtnCd;

	if rowCt = 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Unable to match probesets to platform in probeset_deapp',0,rowCt,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;
	
	--	add partition if it doesn't exist, drop indexes and truncate if it does (reload)

	select count(*) into pExists
	from information_schema.tables
	where table_name = partitionindx;
	
	if pExists = 0 then
		sqlText := 'create table ' || partitionName || ' ( constraint mrna_' || partitionId::text || '_check check ( partition_id = ' || partitionId::text ||
					')) inherits (deapp.de_subject_microarray_data)';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create partition ' || partitionName,1,stepCt,'Done') into rtnCd;
	else
		sqlText := 'drop index if exists ' || partitionIndx || '_idx1';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		sqlText := 'drop index if exists ' || partitionIndx || '_idx2';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		sqlText := 'drop index if exists ' || partitionIndx || '_idx3';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		sqlText := 'drop index if exists ' || partitionIndx || '_idx4';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on ' || partitionName,1,stepCt,'Done') into rtnCd;
		sqlText := 'truncate table ' || partitionName;
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Truncate ' || partitionName,1,stepCt,'Done') into rtnCd;
	end if;

	--	insert into de_subject_microarray_data when dataType is T (transformed)

	if dataType = 'T' or dataType = 'Z' then -- Z is for compatibility with TR ETL default settings
		sqlText := 'insert into ' || partitionName || ' (partition_id, trial_name, probeset_id, assay_id, log_intensity, zscore) ' ||
				   'select ' || partitionId::text || ', trial_name, probeset_id, assay_id, intensity_value, ' ||
				   'case when intensity_value < -2.5 then -2.5 when intensity_value > 2.5 then 2.5 else intensity_value end ' ||
				   'from tm_wz.wt_subject_mrna_probeset';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		get diagnostics rowCt := ROW_COUNT;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted data into ' || partitionName,rowCt,stepCt,'Done') into rtnCd;
	else
		--	calculate zscore and insert to partition

		execute ('drop index if exists tm_wz.wt_subject_mrna_logs_i1');
		execute ('drop index if exists tm_wz.wt_subject_mrna_calcs_i1');
		execute ('truncate table tm_wz.wt_subject_microarray_logs');
		execute ('truncate table tm_wz.wt_subject_microarray_calcs');
		execute ('truncate table tm_wz.wt_subject_microarray_med');
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Drop indexes and truncate zscore work tables',1,stepCt,'Done') into rtnCd;

		begin
		insert into tm_wz.wt_subject_microarray_logs
		(probeset_id
		,assay_id
		,raw_intensity
		,log_intensity
		,trial_name
		)
		select probeset_id
			  ,assay_id
			  ,case when dataType = 'R' then intensity_value else 
				    case when logBase = -1 then 0 else round(power(logBase,intensity_value),4) end
			   end
			  ,case when dataType = 'L' then intensity_value else log(logBase,intensity_value) end
			  ,trial_name
		from tm_wz.wt_subject_mrna_probeset;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_microarray_logs',rowCt,stepCt,'Done') into rtnCd;

		execute ('create index wt_subject_mrna_logs_i1 on tm_wz.wt_subject_microarray_logs (probeset_id) tablespace "indx"');
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_microarray_logs',0,stepCt,'Done') into rtnCd;

		--	calculate mean_intensity, median_intensity, and stddev_intensity per probeset

		begin
		insert into tm_wz.wt_subject_microarray_calcs
		(probeset_id
		,mean_intensity
		,median_intensity
		,stddev_intensity
		,trial_name
		)
		select d.probeset_id
			  ,avg(log_intensity)
			  ,median(log_intensity)
			  ,stddev(log_intensity)
			  ,TrialID
		from tm_wz.wt_subject_microarray_logs d
		group by d.probeset_id;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ wt_subject_microarray_calcs',rowCt,stepCt,'Done') into rtnCd;

		execute ('create index wt_subject_mrna_calcs_i1 on tm_wz.wt_subject_microarray_calcs (probeset_id) tablespace "indx"');
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_microarray_calcs',0,stepCt,'Done') into rtnCd;

		-- calculate zscore and insert into partition

		sqlText := 'insert into ' || partitionName || ' (partition_id, trial_name, probeset_id, assay_id, raw_intensity, log_intensity, zscore) ' ||
				   'select ' || partitionId::text || ', d.trial_name, d.probeset_id, d.assay_id, d.raw_intensity, d.log_intensity, ' ||
				   'case when c.stddev_intensity = 0 then 0 else ' ||
				   'case when (d.log_intensity - c.median_intensity ) / c.stddev_intensity < -2.5 then -2.5 ' ||
				   'when (d.log_intensity - c.median_intensity ) / c.stddev_intensity > 2.5 then 2.5 else ' ||
				   '(d.log_intensity - c.median_intensity ) / c.stddev_intensity end end ' ||
				   'from tm_wz.wt_subject_microarray_logs d ' ||
				   ',tm_wz.wt_subject_microarray_calcs c ' ||
				   'where d.probeset_id = c.probeset_id';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		get diagnostics rowCt := ROW_COUNT;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score and insert into ' || partitionName,rowCt,stepCt,'Done') into rtnCd;
	end if;

	--	create indexes on partition

	sqlText := ' create index ' || partitionIndx || '_idx1 on ' || partitionName || ' using btree (partition_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx2 on ' || partitionName || ' using btree (assay_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx3 on ' || partitionName || ' using btree (probeset_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx4 on ' || partitionName || ' using btree (assay_id, probeset_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
    ---Cleanup OVERALL JOB if this proc is being run standalone

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_mrna_data',0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_process_mrna_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_process_proteomics_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_process_proteomics_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_cd character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT NULL::character varying, currentjobid numeric DEFAULT NULL::numeric) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************

* This store procedure is for ETL for Sanofi to load  proteomics data
* Date: 9/12/2013

******************************************************************/
--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint	
Declare
  TrialID		character varying(100);
  RootNode		character varying(2000);
  root_level	integer;
  topNode		character varying(2000);
  topLevel		integer;
  tPath			character varying(2000);
  study_name	character varying(100);
  sourceCd		character varying(50);
  secureStudy	character varying(1);
  rtnCd			integer;
  dataType		character varying(10);
  sqlText		character varying(1000);
  tText			character varying(1000);
  gplTitle		character varying(1000);
  pExists		numeric;
  partTbl   	numeric;
  partExists 	numeric;
  sampleCt		numeric;
  idxExists 	numeric;
  logBase		numeric;
  pCount		integer;
  sCount		integer;
  tablespaceName	character varying(200);
  v_bio_experiment_id	numeric(18,0);
  errorNumber		character varying;
  errorMessage	character varying;
  
    --Audit variables
  newJobFlag numeric(1);
  databaseName character varying(100);
  procedureName character varying(100);
  jobID numeric(18,0);
  stepCt numeric(18,0);
  rowCt numeric(18,0);
  
	addNodes CURSOR is
	select distinct t.leaf_node
          ,t.node_name
	from  WT_PROTEOMICS_NODES t
	where not exists
		 (select 1 from i2b2 x
		  where t.leaf_node = x.c_fullname);

 
--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  delNodes CURSOR is
  select distinct c_fullname 
  from  i2b2
  where c_fullname like topNode || '%'
    and substr(c_visualattributes,2,1) = 'H';
    --and c_visualattributes like '_H_';

    uploadI2b2 cursor  is 
    select category_cd,display_value,display_label,display_unit from
    tm_lz.lt_src_protein_display_mapping;

BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\', 'g');	
	select length(topNode)-length(replace(topNode,'\','')) into topLevel;
	
	if data_type is null then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;
	
	logBase := log_base;
	sourceCd := upper(coalesce(source_cd,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  databaseName := 'TM_CZ';
  procedureName := 'I2B2_PROCESS_PROTEOMICS_DATA';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select tm_cz.cz_start_audit(procedureName, databaseName) into jobID;
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_proteomics_data',0,stepCt,'Done') into rtnCd;
	
	--	Get count of records in LT_SRC_PROTEOMICS_SUB_SAM_MAP
	
	select count(*) into sCount
	from LT_SRC_PROTEOMICS_SUB_SAM_MAP;

	select count(*) into pCount
	from LT_SRC_PROTEOMICS_SUB_SAM_MAP
	where platform is null;
	
	if pCount > 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select cz_error_handler(jobid,procedurename, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
	end if;
	
	select count(*) into pCount
	from LT_PROTEIN_ANNOTATION
	where gpl_id in (select distinct m.platform from LT_SRC_PROTEOMICS_SUB_SAM_MAP m);

	if pCount = 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databasename,procedurename,'Platform not found in LT_PROTEIN_ANNOTATION',1,stepCt,'ERROR') into rtnCd;
		select CZ_ERROR_HANDLER(JOBID,PROCEDURENAME, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 163;
	end if;
	
	select count(*) into pCount
	from DE_gpl_info
	where platform in (select distinct m.platform from LT_SRC_PROTEOMICS_SUB_SAM_MAP m);
	
	if pCount = 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databasename,procedurename,'Platform not found in DE_GPL_INFO',1,stepCt,'ERROR') into rtnCd;
		select CZ_ERROR_HANDLER(JOBID,PROCEDURENAME, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 16;
	end if;
		
	--	check if all subject_sample map records have a tissue_type, If not, abort run
	
	select count(*) into pCount
	from LT_SRC_PROTEOMICS_SUB_SAM_MAP
	where tissue_type is null;
	
	if pCount > 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databasename,procedurename,'Tissue Type data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select cz_error_handler(jobid,procedurename, '-1', 'Application raised error') into rtnCd;
		select CZ_END_AUDIT (JOBID,'FAIL') into rtnCd;
		return 162;
	end if;
	
	--	check if there are multiple platforms, if yes, then platform must be supplied in LT_SRC_PROTEOMICS_SUB_SAM_MAP
	
	select count(*) into pCount
	from (select sample_cd
		  from LT_SRC_PROTEOMICS_SUB_SAM_MAP
		  group by sample_cd
		  having count(distinct platform) > 1) as vtbl;
	
	if pCount > 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databasename,procedurename,'Multiple platforms for sample_cd in LT_SRC_PROTEOMICS_SUB_SAM_MAP',1,stepCt,'ERROR') into rtnCd;
		select CZ_ERROR_HANDLER(JOBID,PROCEDURENAME, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 164;
	end if;
		
	-- Get root_node from topNode
  
	select parse_nth_value(topNode, 2, '\') into RootNode;
	
	select count(*) into pExists
	from table_access
	where c_name = rootNode;
	
	if pExists = 0 then
		select i2b2_add_root_node(rootNode, jobId) into rtnCd;
	end if;
	
	select c_hlevel into root_level
	from i2b2
	where c_name = RootNode;
	
	-- Get study name from topNode
  
	select parse_nth_value(topNode, topLevel, '\') into study_name;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount;

	if pCount > 2 then
		select i2b2_fill_in_tree(null, tPath, jobId) into rtnCd;
	end if;

	--	uppercase study_id in LT_SRC_PROTEOMICS_SUB_SAM_MAP in case curator forgot
	begin
	update LT_SRC_PROTEOMICS_SUB_SAM_MAP
	set trial_name=upper(trial_name);
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in LT_SRC_PROTEOMICS_SUB_SAM_MAP',rowCt,stepCt,'Done') into rtnCd;	
	
	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd

	begin
	insert into patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,now()
		  ,now()
		  ,now()
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from LT_SRC_PROTEOMICS_SUB_SAM_MAP s
		     ,de_gpl_info g
		 where s.subject_id is not null
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = 'PROTEOMICS'
		   and not exists
			  (select 1 from patient_dimension x
			   where x.sourcesystem_cd = 
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) x;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',rowCt,stepCt,'Done') into rtnCd;	
	select i2b2_create_security_for_trial(TrialId, secureStudy, jobID) into rtnCd;

	--	Delete existing observation_fact data, will be repopulated

	begin
	delete from observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = 'PROTEIN');
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;

	begin
	delete from DE_SUBJECT_PROTEIN_DATA
	where trial_name = TrialId ;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete data from DE_SUBJECT_PROTEIN_DATA',rowCt,stepCt,'Done') into rtnCd;
		
	--	Cleanup any existing data in de_subject_sample_mapping.  

	begin
	delete from DE_SUBJECT_SAMPLE_MAPPING ssm
	where trial_name = TrialID 
	  and coalesce(ssm.source_cd,'STD') = sourceCd
	  and platform = 'PROTEIN'
	; --Making sure only miRNA data is deleted
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		  
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
	begin
	execute('truncate table tm_wz.WT_PROTEOMICS_NODES');
	execute('truncate table tm_wz.WT_PROTEOMICS_NODE_VALUES');
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	begin
	insert into WT_PROTEOMICS_NODE_VALUES
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
				   ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from LT_SRC_PROTEOMICS_SUB_SAM_MAP a
	    ,de_gpl_info g 
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = 'PROTEOMICS'
	  and g.title = (select min(x.title) from de_gpl_info x where coalesce(a.platform,'GPL570') = x.platform)
      -- and upper(g.organism) = 'HOMO SAPIENS'
	  ;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
      
	--  and decode(dataType,'R',sign(a.intensity_value),1) = 1;	--	take all values when dataType T, only >0 for dataType R
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP WT_PROTEOMICS_NODE_VALUES',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into WT_PROTEOMICS_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g') 
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  WT_PROTEOMICS_NODE_VALUES;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_proteomics_nodes',rowCt,stepCt,'Done') into rtnCd;
	--	insert for platform node so platform concept can be populated

	begin
	insert into WT_PROTEOMICS_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  WT_PROTEOMICS_NODE_VALUES;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in WT_PROTEOMICS_NODES',rowCt,stepCt,'Done') into rtnCd;
	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd

	begin
	insert into WT_PROTEOMICS_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  WT_PROTEOMICS_NODE_VALUES
	where category_cd like '%ATTR1%'
	  and attribute_1 is not null;
	  exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in WT_PROTEOMICS_NODES',rowCt,stepCt,'Done') into rtnCd;
	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd

	begin
	insert into WT_PROTEOMICS_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  WT_PROTEOMICS_NODE_VALUES
	where category_cd like '%ATTR2%'
	  and attribute_2 is not null;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_PROTEOMICS_NODES',rowCt,stepCt,'Done') into rtnCd;
	--	insert for tissue_type node so sample_type_cd can be populated

	begin
	insert into WT_PROTEOMICS_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  WT_PROTEOMICS_NODE_VALUES
	where category_cd like '%TISSUETYPE%';
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_PROTEOMICS_NODES',rowCt,stepCt,'Done') into rtnCd;
	begin
	update WT_PROTEOMICS_NODES
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_proteomics_nodes',rowCt,stepCt,'Done') into rtnCd;
--	add leaf nodes for proteomics data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)

		select i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId) into rtnCd;
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		if rtnCd > 1 then
			select cz_write_audit(jobId,databasename,procedurename,'Error while executing tm_cz.i2b2_add_node(' || TrialID || ',' || r_addNodes.leaf_node || ',' || r_addNodes.node_name || ',' || jobId || ')' ,1,stepCt,'ERROR') into rtnCd;
			select cz_end_audit (jobId,'FAIL') into rtnCd;
			return 168;
		end if;	
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;
		select cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;
		select i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID) into rtnCd;
		if rtnCd > 1 then
			select cz_write_audit(jobId,databasename,procedurename,'Error while executing tm_cz.i2b2_fill_in_tree(' || TrialID || ',' || r_addNodes.leaf_node || ',' || jobId || ')' ,1,stepCt,'ERROR') into rtnCd;
			select cz_end_audit (jobId,'FAIL') into rtnCd;
			return 170;
		end if;	
	END LOOP;  
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes

	begin
	update i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	  	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done') into rtnCd;
--	update concept_cd for nodes, this is done to make the next insert easier

	begin
	update WT_PROTEOMICS_NODES t
	set concept_cd=(select c.concept_cd from concept_dimension c
	                where c.concept_path = t.leaf_node limit 1
				   )
    where exists
         (select 1 from concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and t.concept_cd is null;
	  exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Update WT_PROTEOMICS_NODES with newly created concept_cds',rowCt,stepCt,'Done') into rtnCd;
  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_proteomics_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in wt_proteomics_nodes
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in wt_proteomics_nodes
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in wt_proteomics_nodes
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in wt_proteomics_nodes
  --PLATFORM        = PROTEOMICS - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in wt_proteomics_nodes
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_proteomics_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd
  
  --ASSAY_ID        = generated by trigger

	begin
	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,'PROTEIN' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+PROTEOMICS+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from lt_src_proteomics_sub_sam_map a		
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = b.sourcesystem_cd
		inner join WT_PROTEOMICS_NODES ln
			on a.platform = ln.platform
			and a.category_cd=ln.category_cd
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'@') = coalesce(ln.attribute_1,'@')
			and coalesce(a.attribute_2,'@') = coalesce(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join WT_PROTEOMICS_NODES pn
			on a.platform = pn.platform
			and  pn.category_cd=substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(pn.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(pn.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'	  
		left outer join WT_PROTEOMICS_NODES ttp
			on a.tissue_type = ttp.tissue_type
			and ttp.category_cd=substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = coalesce(ttp.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(ttp.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'		  
		left outer join WT_PROTEOMICS_NODES a1
			on a.attribute_1 = a1.attribute_1
			and a1.category_cd=substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a1.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a1.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'		  
		left outer join WT_PROTEOMICS_NODES a2
			on a.attribute_2 = a1.attribute_2
			and a2.category_cd=substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a2.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a2.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'			  
		left outer join patient_dimension sid
			on  regexp_replace(TrialId || ':S:' || coalesce(a.site_id,'') || ':' || a.subject_id || ':' || a.sample_cd,
							  '(::){1,}', ':', 'g') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  ln.concept_cd is not null) t;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
         ,sample_cd
        ,INSTANCE_NUM
        
    )
    select distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null::numeric	--	not numeric for qpcr_mirna
		  ,m.trial_name
		  ,now()
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                   ,m.sample_cd
                   ,1
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCD
      and m.platform = 'PROTEIN';
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;
	--	Insert sample facts 

	begin
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
         ,sample_cd
        ,INSTANCE_NUM
    )
    select distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null::numeric	--	not numeric for miRNA
		  ,m.trial_name
		  ,now()
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                   ,m.sample_cd
                  ,1
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCd
      and m.platform = 'PROTEIN'
	 and m.patient_id != m.sample_id;
    exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;
	--Update I2b2 for correct data type
	begin
	update i2b2 t
	set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
	where t.c_basecode in (select distinct x.concept_cd from WT_PROTEOMICS_NODES x);
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
  
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',rowCt,stepCt,'Done') into rtnCd;

	 ---INSERT sample_dimension
	begin
      INSERT INTO I2B2DEMODATA.SAMPLE_DIMENSION(SAMPLE_CD) 
         SELECT DISTINCT SAMPLE_CD FROM 
	   DEAPP.DE_SUBJECT_SAMPLE_MAPPING WHERE SAMPLE_CD NOT IN (SELECT SAMPLE_CD FROM I2B2DEMODATA.SAMPLE_DIMENSION) ;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'insert distinct sample_cd in sample_dimension from de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

    ---- update c_metedataxml in i2b2

       for ul in uploadI2b2
        loop
        begin
	 update i2b2 n
	SET n.c_columndatatype = 'T',
      --Static XML String
		n.c_metadataxml =  ('<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue>
                <HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue>
                <LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue>
                <EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion>
                <UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits>
                <ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor>
                </ConvertingUnits></UnitValues><Analysis><Enums /><Counts />
                <New /></Analysis>'||(select xmlelement(name "SeriesMeta",xmlforest(m.display_value as "Value",m.display_unit as "Unit",m.display_label as "DisplayName")) as hi 
      from tm_lz.lt_src_protein_display_mapping m where m.category_cd=ul.category_cd)||
                '</ValueMetadata>') where n.c_fullname=(select leaf_node from WT_PROTEOMICS_NODES where category_cd=ul.category_cd and leaf_node=n.c_fullname);
        exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
                end loop;
		  
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	begin
	update i2b2 a
        set c_visualattributes = 'LAH'
	where a.c_basecode in (select distinct x.concept_code from de_subject_sample_mapping x
						   where x.trial_name = TrialId
						     and x.platform = 'PROTEIN'
							 and x.concept_code is not null);
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	  
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;
  
        begin
	update i2b2 a
	set c_visualattributes='FAS'
        where a.c_fullname = substr(topNode,1,instr(topNode,'\',1,3));
        exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
        
        stepCt := stepCt + 1;
        get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for study nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;
  
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for miRNA data
  
    select i2b2_create_concept_counts(topNode ,jobID ) into rtnCd;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done') into rtnCd;
	
	--	delete each node that is hidden

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		select i2b2_delete_1_node(r_delNodes.c_fullname) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;

	END LOOP;  	


  --Reload Security: Inserts one record for every I2B2 record into the security table

    select i2b2_load_security_data(jobId) into rtnCd;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done') into rtnCd;

--	tag data with probeset_id from reference.probeset_deapp
	begin
	execute('truncate table tm_wz.WT_SUBJECT_PROTEOMICS_PROBESET');
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	--	note: assay_id represents a unique subject/site/sample

	begin
	insert into WT_SUBJECT_PROTEOMICS_PROBESET  --mod
	(probeset
--	,expr_id
	,intensity_value
	,patient_id
--	,sample_cd
	,subject_id
	,trial_name
	,assay_id
	)
	select    md.peptide
		  ,avg(md.intensity_value::numeric)
                  ,sd.patient_id
                  ,sd.subject_id
		  ,TrialId
		  ,sd.assay_id
	from deapp.de_subject_sample_mapping sd
		,LT_SRC_PROTEOMICS_DATA md   
              --  ,peptide_deapp p
	where sd.sample_cd = md.m_p_id
	  and sd.platform = 'PROTEIN'
	  and sd.trial_name =TrialId
	  and sd.source_cd = sourceCd
	 -- and sd.gpl_id = gs.id_ref
	--  and md.peptide =p.peptide-- gs.mirna_id
	 and CASE WHEN dataType = 'R' THEN sign(md.intensity_value::numeric) ELSE 1 END <> -1   --UAT 154 changes done on 19/03/2014
	 and sd.subject_id in (select subject_id from lt_src_proteomics_sub_sam_map) 
	group by md.peptide ,subject_id
		  ,sd.patient_id,sd.assay_id;

	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	get diagnostics rowCt := ROW_COUNT;
	pExists := rowCt;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP WT_SUBJECT_PROTEOMICS_PROBESET',rowCt,stepCt,'Done') into rtnCd;
		
	if pExists = 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databasename,procedurename,'Unable to match probesets to platform in probeset_deapp',1,stepCt,'ERROR') into rtnCd;
		select CZ_ERROR_HANDLER(JOBID,PROCEDURENAME, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 165;
	end if;

	--	insert into de_subject_mirna_data when dataType is T (transformed)

	if dataType = 'T' then

	begin
		insert into DE_SUBJECT_PROTEIN_DATA
		(trial_name
	,protein_annotation_id
	,component
	,gene_symbol
	,gene_id
	,assay_id
	,subject_id
	,intensity 
	,zscore
        ,log_intensity
	,patient_id
		)
		select TrialId 
                  ,d.id
		  ,m.probeset
                  ,d.uniprot_id
                  ,d.biomarker_id
		  ,m.assay_id
                  ,m.subject_id 
                   ,m.intensity_value as intensity ----UAT 154 changes done on 19/03/2014
			  ,case when m.intensity_value < -2.5
			        then -2.5
					when m.intensity_value > 2.5
					then 2.5
					else m.intensity_value
			   end as zscore
                           /*, case when m.intensity_value > 0 then round(log(2, m.intensity_value),6)
                            else 0 
                            end */
                            ,round(log(2, m.intensity_value + 0.001),6)  ----UAT 154 changes done on 19/03/2014
                            ,m.patient_id
		from WT_SUBJECT_PROTEOMICS_PROBESET  m
                ,DEAPP.DE_PROTEIN_ANNOTATION d
		where trial_name = TrialID
                 and d.peptide=m.probeset;
        exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,'Insert transformed into DEAPP DE_SUBJECT_PROTEIN_DATA',rowCt,stepCt,'Done') into rtnCd;
	else
		
	--	Calculate ZScores and insert data into de_subject_mirna_data.  The 'L' parameter indicates that the gene expression data will be selected from
	--	WT_SUBJECT_PROTEOMICS_PROBESET as part of a Load.  

		if dataType = 'R' or dataType = 'L' then
			select I2B2_PROTEOMICS_ZSCORE_CALC(TrialID,'L',jobId,dataType,logBase,sourceCD) into rtnCd;
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',0,stepCt,'Done') into rtnCd;
		end if;
	
	end if;

    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_proteomics_data',0,stepCt,'Done') into rtnCd;

	IF newJobFlag = 1
	THEN
		select cz_end_audit(jobID, 'SUCCESS') into rtnCd;
	END IF;

	return rtnCd;
END;
$$;


ALTER FUNCTION tm_cz.i2b2_process_proteomics_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_process_qpcr_mirna_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_cd character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT NULL::character varying, currentjobid numeric DEFAULT NULL::numeric, mirna_type character varying DEFAULT NULL::character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************

* This store procedure is for ETL for Sanofi to load  qpcr or seq miRNA data
* Date: 12/05/2013

******************************************************************/


--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint	
Declare
  TrialID		varchar(100);
  RootNode		varchar(2000);
  root_level	integer;
  topNode		varchar(2000);
  topLevel		integer;
  tPath			varchar(2000);
  study_name	varchar(100);
  sourceCd		varchar(50);
  secureStudy	varchar(1);

  dataType		varchar(10);
  sqlText		varchar(1000);
  tText			varchar(1000);
  gplTitle		varchar(1000);
  pExists		numeric;
  partTbl   	numeric;
  partExists 	numeric;
  sampleCt		numeric;
  idxExists 	numeric;
  logBase		numeric;
  pCount		integer;
  sCount		integer;
  tablespaceName	varchar(200);
  v_bio_experiment_id	numeric(18,0);
  mirnaType varchar(15);
 -- mirnaPlatform varchar(20);
  
    --Audit variables
  newJobFlag numeric(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID numeric(18,0);
  stepCt numeric(18,0);
  rowCt	integer;
  errorNumber		character varying;
  errorMessage	character varying;
    
	addNodes CURSOR is
	select distinct t.leaf_node
          ,t.node_name
	from  wt_qpcr_mirna_nodes t
	where not exists
		 (select 1 from i2b2 x
		  where t.leaf_node = x.c_fullname);

 
--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  delNodes CURSOR for
  select distinct c_fullname 
  from  i2b2
  where c_fullname like topNode || '%'
    and substr(c_visualattributes,2,1) = 'H';
    --and c_visualattributes like '_H_';

    uploadI2b2 cursor for 
    select category_cd,display_value,display_label,display_unit from
    tm_lz.lt_src_mirna_display_mapping;



BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	mirnaType:=upper(mirna_type);
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\', 'g');	
	select length(topNode)-length(replace(topNode,'\','')) into topLevel ;
	
	if data_type is null then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;

	logBase := log_base;
	sourceCd := upper(coalesce(source_cd,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  databaseName := 'TM_CZ';
  procedureName := 'I2B2_PROCESS_QPCR_MIRNA_DATA';
  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName) into jobID;
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_qpcr_mirna_data',0,stepCt,'Done');
	
	--	Get count of records in LT_SRC_MIRNA_SUBJ_SAMP_MAP
	
	select count(*) into sCount
	from LT_SRC_MIRNA_SUBJ_SAMP_MAP;
	
	--	check if all subject_sample map records have a platform, If not, abort run
	
	select count(*) into pCount
	from LT_SRC_MIRNA_SUBJ_SAMP_MAP
	where platform is null;
	
	if pCount > 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		perform cz_end_audit (jobId,'FAIL');
		return 161;
	end if;
  
  	--	check if platform exists in de_qpcr_mirna_annotation .  If not, abort run.
	
	select count(*) into pCount
	from deapp.de_qpcr_mirna_annotation
	where gpl_id in (select distinct m.platform from LT_SRC_MIRNA_SUBJ_SAMP_MAP m);
	
	if PCOUNT = 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Unmapped platform',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		perform cz_end_audit (jobId,'FAIL');
		return 162;
	end if;--mod
	
	select count(*) into pCount
	from DE_gpl_info
	where platform in (select distinct m.platform from LT_SRC_MIRNA_SUBJ_SAMP_MAP m);
	
	if PCOUNT = 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'No platoform in de_gpl_info',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		perform cz_end_audit (jobId,'FAIL');
		return 163;
	end if;
		
	--	check if all subject_sample map records have a tissue_type, If not, abort run
	
	select count(*) into pCount
	from LT_SRC_MIRNA_SUBJ_SAMP_MAP
	where tissue_type is null;
	
	if pCount > 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Missing tissue',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		perform cz_end_audit (jobId,'FAIL');
		return 164;
	end if;
	
	--	check if there are multiple platforms, if yes, then platform must be supplied in LT_SRC_QPCR_MIRNA_DATA
	
	select count(*) into pCount
	from (select sample_cd
		  from LT_SRC_MIRNA_SUBJ_SAMP_MAP
		  group by sample_cd
		  having count(distinct platform) > 1) t;
	
	if pCount > 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Multiple platforms',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		perform cz_end_audit (jobId,'FAIL');
		return 165;
	end if;
		
	-- Get root_node from topNode
  
	select parse_nth_value(topNode, 2, '\') into RootNode ;
	
	select count(*) into pExists
	from table_access
	where c_name = rootNode;
	
	if pExists = 0 then
		perform tm_cz.i2b2_add_root_node(rootNode, jobId);
	end if;
	
	select c_hlevel into root_level
	from i2b2
	where c_name = RootNode;
	
	-- Get study name from topNode
  
	select parse_nth_value(topNode, topLevel, '\') into study_name ;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount ;
	if pCount > 2 then
		perform i2b2_fill_in_tree(null, tPath, jobId);
	end if;

	--	uppercase study_id in lt_src_mirna_subj_samp_map in case curator forgot
	
	update LT_SRC_MIRNA_SUBJ_SAMP_MAP
	set trial_name=upper(trial_name);
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in LT_SRC_MIRNA_SUBJ_SAMP_MAP',rowCt,stepCt,'Done');	
	
	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd

	begin
	insert into patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,current_timestamp
		  ,current_timestamp
		  ,current_timestamp
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from LT_SRC_MIRNA_SUBJ_SAMP_MAP s
		     ,de_gpl_info g
		 where s.subject_id is not null
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = mirnaType
		   and not exists
			  (select 1 from patient_dimension x
			   where x.sourcesystem_cd = 
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) x;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
			
	get diagnostics rowCt := ROW_COUNT;
	pCount := rowCt;
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension.',pCount,stepCt,'Done');
	
	begin
		perform i2b2_create_security_for_trial(TrialId, secureStudy, jobID);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	--	Delete existing observation_fact data, will be repopulated

	begin
	delete from observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = mirna_type);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done');
	
        begin
	delete from de_subject_mirna_data
	where trial_source = TrialId || ':' || sourceCd;
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete data from de_subject_mirna_data',rowCt,stepCt,'Done');
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	begin
	delete from deapp.DE_SUBJECT_SAMPLE_MAPPING d 
	where trial_name = TrialID 
	  and coalesce(d.source_cd,'STD') = sourceCd
	  and platform = mirna_type;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	  
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done');

	begin
		execute('truncate table tm_wz.WT_QPCR_MIRNA_NODES');
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	begin
		execute('truncate table tm_wz.WT_QPCR_MIRNA_NODE_VALUES');
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	begin
	insert into WT_QPCR_MIRNA_NODE_VALUES
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from LT_SRC_MIRNA_SUBJ_SAMP_MAP a
	    ,de_gpl_info g 
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = mirnaType
	  and g.title = (select min(x.title) from de_gpl_info x where coalesce(a.platform,'GPL570') = x.platform)
      -- and upper(g.organism) = 'HOMO SAPIENS'
	  ;
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	--  and decode(dataType,'R',sign(a.intensity_value),1) = 1;	--	take all values when dataType T, only >0 for dataType R
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP wt_qpcr_mirna_node_values',rowCt,stepCt,'Done');
	
	begin
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g') 
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  WT_QPCR_MIRNA_NODE_VALUES;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_mirna_nodes',rowCt,stepCt,'Done');
	
	
	--	insert for platform node so platform concept can be populated
	begin
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
        ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  WT_QPCR_MIRNA_NODE_VALUES;
		   
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in wt_qpcr_mirna_nodes',rowCt,stepCt,'Done');
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd
	begin
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
        ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  WT_QPCR_MIRNA_NODE_VALUES
	where category_cd like '%ATTR1%'
        and attribute_1 is not null;
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in WT_QPCR_MIRNA_NODES',rowCt,stepCt,'Done');
	
	
	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd

	begin
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
        ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  WT_QPCR_MIRNA_NODE_VALUES
	where category_cd like '%ATTR2%'
	  and attribute_2 is not null;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_QPCR_MIRNA_NODES',rowCt,stepCt,'Done');
	
	
	--	insert for tissue_type node so sample_type_cd can be populated
	begin
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
        ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  WT_QPCR_MIRNA_NODE_VALUES
	where category_cd like '%TISSUETYPE%';
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	 
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_qpcr_mirna_nodes',rowCt,stepCt,'Done');
	
	begin			
	update WT_QPCR_MIRNA_NODES
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_mirna_nodes',rowCt,stepCt,'Done');
	
		
--	add leaf nodes for miRNA data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)
		begin
			perform i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId);
			stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
			tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;
		
			perform cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done');
		
			perform i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID);
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
			perform tm_cz.cz_end_audit (jobID, 'FAIL');
			return -16;
		end;

	END LOOP;  
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
	begin
	update i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done');

	begin
	update WT_QPCR_MIRNA_NODES t
	set concept_cd=(select c.concept_cd from concept_dimension c
	                where c.concept_path = t.leaf_node limit 1)
        where exists
         (select 1 from concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and t.concept_cd is null;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update WT_QPCR_MIRNA_NODES with newly created concept_cds',rowCt,stepCt,'Done');
	
	 
	
  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_mirna_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in wt_mirna_nodes
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in wt_mirna_nodes
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in wt_mirna_nodes
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in wt_mirna_nodes
  --PLATFORM        = MIRNA_AFFYMETRIX - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in wt_qpcr_mirna_nodes
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_mirna_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd
  
  --ASSAY_ID        = generated by trigger

	begin
	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,mirna_type as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::varchar as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+QPCR_MIRNA+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from lt_src_mirna_subj_samp_map a		
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = b.sourcesystem_cd
		inner join WT_QPCR_MIRNA_NODES ln
			on a.platform = ln.platform
			and a.category_cd=ln.category_cd
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'@') = coalesce(ln.attribute_1,'@')
			and coalesce(a.attribute_2,'@') = coalesce(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join WT_QPCR_MIRNA_NODES pn
			on a.platform = pn.platform
			and  pn.category_cd=substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(pn.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(pn.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'	  
		left outer join WT_QPCR_MIRNA_NODES ttp
			on a.tissue_type = ttp.tissue_type
			and ttp.category_cd=substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = coalesce(ttp.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(ttp.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'		  
		left outer join WT_QPCR_MIRNA_NODES a1
			on a.attribute_1 = a1.attribute_1
			and a1.category_cd=substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a1.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a1.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'		  
		left outer join WT_QPCR_MIRNA_NODES a2
			on a.attribute_2 = a1.attribute_2
			and a2.category_cd=substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a2.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a2.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'			  
		left outer join patient_dimension sid
			on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  ln.concept_cd is not null) t;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done');

--	Insert records for patients and samples into observation_fact
	begin
	insert into observation_fact
        (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,sample_cd
        ,INSTANCE_NUM
        )
        select distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null::numeric	--	not numeric for qpcr_mirna
		  ,m.trial_name
		  ,current_timestamp
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                   ,m.sample_cd
                  ,1
        from  de_subject_sample_mapping m
        where m.trial_name = TrialID 
        and m.source_cd = sourceCD
        and m.platform = mirna_type;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done');
    
	--	Insert sample facts 
	begin
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,sample_cd
        ,INSTANCE_NUM
    )
    select distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null::numeric--	not numeric for miRNA
		  ,m.trial_name
		  ,current_timestamp
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,m.sample_cd
                  ,1
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
    and m.source_cd = sourceCd
    and m.platform = mirna_type
    and m.patient_id != m.sample_id;
    exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	--Update I2b2 for correct data type
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done');
    
	begin
	update i2b2 t
	set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
	where t.c_basecode in (select distinct x.concept_cd from WT_QPCR_MIRNA_NODES x);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		
	 ---INSERT sample_dimension
      stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
      perform cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',rowCt,stepCt,'Done');
      
	  begin
      INSERT INTO I2B2DEMODATA.SAMPLE_DIMENSION(SAMPLE_CD) 
         SELECT DISTINCT SAMPLE_CD FROM 
           DEAPP.DE_SUBJECT_SAMPLE_MAPPING WHERE SAMPLE_CD NOT IN (SELECT SAMPLE_CD FROM I2B2DEMODATA.SAMPLE_DIMENSION) ;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'insert distinct sample_cd in sample_dimension from de_subject_sample_mapping',rowCt,stepCt,'Done');
	

    ---- update c_metedataxml in i2b2
 begin   
   for ul in uploadI2b2 loop
	 update i2b2 n
	SET c_columndatatype = 'T',
      --Static XML String
		c_metadataxml =  ('<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue>
                <HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue>
                <LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue>
                <EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion>
                <UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits>
                <ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor>
                </ConvertingUnits></UnitValues><Analysis><Enums /><Counts />
                <New /></Analysis>'||(select xmlelement(name "SeriesMeta",xmlforest(m.display_value as "Value",m.display_unit as "Unit",m.display_label as "DisplayName")) as hi 
      from tm_lz.lt_src_mirna_display_mapping m where m.category_cd=ul.category_cd)||
                '</ValueMetadata>') where n.c_fullname=(select leaf_node from WT_QPCR_MIRNA_NODES where category_cd=ul.category_cd and leaf_node=n.c_fullname);
     end loop;
      exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		  
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',rowCt,stepCt,'Done');

	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	begin
	update i2b2 a
        set c_visualattributes = 'LAH'
	where a.c_basecode in (select distinct x.concept_code from de_subject_sample_mapping x
						   where x.trial_name = TrialId
						     and x.platform = mirna_type
							 and x.concept_code is not null);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done');

	begin
    update i2b2 a
	set c_visualattributes='FAS'
        where a.c_fullname = substr(topNode,1,instr(topNode,'\',1,3));
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
        
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for study nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done');
    
	

  
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for miRNA data
  
        perform i2b2_create_concept_counts(topNode ,jobID );
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done');
	
	--	delete each node that is hidden
	begin
	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time
		
		perform i2b2_delete_1_node(r_delNodes.c_fullname);
		stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		get diagnostics rowCt := ROW_COUNT;
		perform cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done');

	END LOOP;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;  	


  --Reload Security: Inserts one record for every I2B2 record into the security table
	begin
		perform i2b2_load_security_data(jobId);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done');

--	tag data with probeset_id from reference.probeset_deapp

	begin
	execute ('truncate table tm_wz.WT_SUBJECT_MIRNA_PROBESET');
	
	--	note: assay_id represents a unique subject/site/sample

	
	insert into WT_SUBJECT_MIRNA_PROBESET  --mod
	(probeset_id
--	,expr_id
	,intensity_value
	,patient_id
--	,sample_cd
--	,subject_id
	,trial_name
	,assay_id
	)
	select    p.probeset_id 
		  ,avg(md.intensity_value::numeric)
                  ,sd.patient_id
		  ,TrialId
		  ,sd.assay_id
	from LT_SRC_QPCR_MIRNA_DATA md left outer join deapp.de_subject_sample_mapping sd on sd.sample_cd = md.expr_id
                ,mirna_probeset_deapp p
	where sd.platform = mirna_type
	  and sd.trial_name =TrialId
	  and sd.source_cd = sourceCd
	 -- and sd.gpl_id = gs.id_ref
	  and md.probeset =p.probeset-- gs.mirna_id
	  and CASE WHEN dataType ='R' THEN sign(md.intensity_value::numeric) ELSE 1 END <> -1  ---UAT 163 changes done,UAT 154 changes on 19/03/2014
	  and sd.subject_id in (select subject_id from lt_src_mirna_subj_samp_map) 
    and sd.gpl_id = p.platform
	group by  p.probeset_id 
        ,sd.patient_id,sd.assay_id;
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		  
	pExists := rowCt;
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_mirna_probeset',rowCt,stepCt,'Done');
	
			
	if pExists = 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'No probeset records',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		perform cz_end_audit (jobId,'FAIL');
		return 165;
	end if;

	--	insert into de_subject_mirna_data when dataType is T (transformed)
 
	if dataType = 'T' then
		begin
		insert into de_subject_mirna_data
		(trial_source
		,probeset_id
		,assay_id
		,patient_id
		--,sample_id
		--,subject_id
		,trial_name
		,zscore
		)
		select (TrialId || ':' || sourceCd)
			  ,probeset_id
			  ,assay_id
			  ,patient_id
			  --,sample_id
			  --,subject_id
			  ,trial_name
			  /*,case when intensity_value < -2.5
			        then -2.5
					when intensity_value > 2.5
					then 2.5
					else intensity_value
			   end as zscore */
                           ,intensity_value as zscore
		from WT_SUBJECT_MIRNA_PROBESET --mod
		where trial_name = TrialID    ;
		stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
		perform cz_write_audit(jobId,databaseName,procedureName,'Insert transformed into DEAPP de_subject_mirna_data',rowCt,stepCt,'Done');
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);
			perform tm_cz.cz_end_audit (jobID, 'FAIL');
			return -16;
		end;	
	else
		
	--	Calculate ZScores and insert data into de_subject_mirna_data.  The 'L' parameter indicates that the gene expression data will be selected from
	--	wt_subject_mirna_probeset as part of a Load.  

		if dataType = 'R' or dataType = 'L' then
			begin
			 if mirna_type='MIRNA_QPCR' then
			perform i2b2_mirna_zscore_calc(TrialID,'L',jobId,'R',logBase,sourceCD);----donot do log transform
                        else
                        perform i2b2_mirna_zscore_calc(TrialID,'L',jobId,'L',logBase,sourceCD);----do log transform
                        end if;
			stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
			perform cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',0,stepCt,'Done');
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				perform tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
				perform tm_cz.cz_end_audit (jobID, 'FAIL');
				return -16;
			end;
		end if;
	
	end if;

    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_QPCR_miRNA_DATA',0,stepCt,'Done');

	IF newJobFlag = 1
	THEN
		perform cz_end_audit (jobID, 'SUCCESS');
	END IF;
	
	return 0;
	
	EXCEPTION
	WHEN OTHERS THEN
		--Handle errors.
		perform cz_error_handler (jobID, procedureName, '-1', 'Application raised error');
		--End Proc
		perform cz_end_audit (jobID, 'FAIL');
		return 16;
END;
$$;


ALTER FUNCTION tm_cz.i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, mirna_type character varying) OWNER TO tm_cz;

--
-- Name: i2b2_process_rna_seq_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_code character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT NULL::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE

/*************************************************************************
* This stored procedure is for ETL to load RNA sequencing
* Date:10/23/2013
******************************************************************/
--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint	

  TrialID		varchar(100);
  RootNode		varchar(2000);
  root_level	integer;
  topNode		varchar(2000);
  topLevel		integer;
  tPath			varchar(2000);
  study_name	varchar(100);
  sourceCd		varchar(50);
  secureStudy	varchar(1);

  dataType		varchar(10);
  sqlText		varchar(1000);
  tText			varchar(1000);
  gplTitle		varchar(1000);
  pExists		bigint;
  partTbl   	bigint;
  partExists 	bigint;
  sampleCt		bigint;
  idxExists 	bigint;
  logBase		bigint;
  pCount		integer;
  sCount		integer;
  tablespaceName	varchar(200);
  v_bio_experiment_id	bigint;
   partitioniD	numeric(18,0);
  partitionName	varchar(100);
  partitionIndx	varchar(100);
  
    --Audit variables
  newJobFlag integer;
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  rowCt			numeric(18,0);
  errorNumber		character varying;
  errorMessage	character varying;
  rtnCd			integer;
 
	addNodes CURSOR FOR
	SELECT distinct t.leaf_node
          ,t.node_name
	from  tm_wz.wt_RNA_SEQ_nodes t
	where not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where t.leaf_node = x.c_fullname);

 
--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  delNodes CURSOR FOR
  SELECT distinct c_fullname 
  from  i2b2metadata.i2b2
  where c_fullname like topNode || '%'
    and substring(c_visualattributes from 2 for 1) = 'H';
    --and c_visualattributes like '_H_';

	uploadI2b2 CURSOR FOR
    select category_cd,display_value,display_label,display_unit from
    tm_lz.lt_src_rna_display_mapping;

BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\','g');
	select length(topNode)-length(replace(topNode,'\','')) into topLevel ;
	
	if coalesce(data_type::text, '') = '' then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;
	
	logBase := log_base;
	sourceCd := upper(coalesce(source_code,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

    databaseName := 'TM_CZ';
	procedureName := 'I2B2_PROCESS_RNA_SEQ_DATA';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName, jobID) into jobId;
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_RNA_SEQ_data',0,stepCt,'Done') into rtnCd;
	
	--	Get count of records in lt_src_RNA_SEQ_subj_samp_map
	
	select count(*) into sCount
	from tm_lz.lt_src_RNA_SEQ_subj_samp_map;
	
	--	check if all subject_sample map records have a platform, If not, abort run
	
	select count(*) into pCount
	from tm_lz.lt_src_RNA_SEQ_subj_samp_map
	where coalesce(platform::text, '') = '';
	
	if pCount > 0 then
		select cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
	end if;
  	
	--	check if all subject_sample map records have a tissue_type, If not, abort run
	
	select count(*) into pCount
	from tm_lz.lt_src_RNA_SEQ_subj_samp_map
	where coalesce(tissue_type::text, '') = '';
	
	if pCount > 0 then
		select cz_write_audit(jobId,databasename,procedurename,'Tissue Type data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select CZ_END_AUDIT (JOBID,'FAIL') into rtnCd;
		return 162;
	end if;
	
	--	check if there are multiple platforms, if yes, then platform must be supplied in lt_src_RNA_SEQ_data
	
	select count(*) into pCount
	from (select sample_cd
		  from tm_lz.lt_src_RNA_SEQ_subj_samp_map
		  group by sample_cd
		  having count(distinct platform) > 1) as x;
	
	if pCount > 0 then
		select cz_write_audit(jobId,databasename,procedurename,'Multiple platforms for sample_cd in lt_src_RNA_SEQ_subj_samp_map',1,stepCt,'ERROR') into rtnCd;
		select CZ_ERROR_HANDLER(JOBID,PROCEDURENAME) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 164;
	end if;
		
	-- Get root_node from topNode
  
	select parse_nth_value(topNode, 2, '\') into RootNode ;
	
	select count(*) into pExists
	from i2b2metadata.table_access
	where c_name = rootNode;
	
	if pExists = 0 then
		perform i2b2_add_root_node(rootNode, jobId);
	end if;
	
	select c_hlevel into root_level
	from i2b2metadata.i2b2
	where c_name = RootNode;
	
	-- Get study name from topNode
  
	select parse_nth_value(topNode, topLevel, '\') into study_name ;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount ;

	if pCount > 2 then
		perform i2b2_fill_in_tree(null, tPath, jobId);
	end if;

	--	uppercase study_id in lt_src_RNA_SEQ_subj_samp_map in case curator forgot
	begin
	update tm_lz.lt_src_RNA_SEQ_subj_samp_map
	set trial_name=upper(trial_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		-- select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	select count(*) into partExists
	from deapp.de_subject_sample_mapping sm
	where sm.trial_name = TrialId
	and coalesce(sm.source_cd,'STD') = sourceCd
	and sm.platform = 'RNA_AFFYMETRIX'
	and sm.partition_id is not null;
	
	if partExists = 0 then
		select nextval('deapp.seq_rna_partition_id') into partitionId;
	else
		select distinct partition_id into partitionId
		from deapp.de_subject_sample_mapping sm
		where sm.trial_name = TrialId
		and coalesce(sm.source_cd,'STD') = sourceCd
		and sm.platform = 'RNA_AFFYMETRIX';
	end if;

	partitionName := 'deapp.de_subject_rna_data_' || partitionId::text;
	partitionIndx := 'de_subject_rna_data_' || partitionId::text;	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in lt_src_RNA_SEQ_subj_samp_map',rowCt,stepCt,'Done') into rtnCd;	
	
	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd
	
	begin
	insert into i2b2demodata.patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialId || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from tm_lz.lt_src_RNA_SEQ_subj_samp_map s
		 where (s.subject_id IS NOT NULL AND s.subject_id::text <> '')
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and not exists
			  (select 1 from i2b2demodata.patient_dimension x
			   where x.sourcesystem_cd = 
				 regexp_replace(TrialID || ':' || coalesce(s.site_id, '') || ':' || s.subject_id,'(::){1,}', ':'))
		) as x;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',rowCt,stepCt,'Done') into rtnCd;
	
	perform i2b2_create_security_for_trial(TrialId, secureStudy, jobID);

	--	Delete existing observation_fact data, will be repopulated
	begin
	delete from i2b2demodata.observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from deapp.de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = 'RNA_AFFYMETRIX');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;
		
	--	Cleanup any existing data in de_subject_sample_mapping.  

	begin
	delete from deapp.DE_SUBJECT_SAMPLE_MAPPING 
	where trial_name = TrialID 
	  and coalesce(source_cd,'STD') = sourceCd
	  and platform = 'RNA_AFFYMETRIX'; --Making sure only RNA_sequencing data is deleted
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

--	truncate tmp node table

	EXECUTE('truncate table tm_wz.wt_RNA_SEQ_nodes');
	
--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
--	from wt_subject_RNA_sequencing_data

	EXECUTE('truncate table tm_wz.wt_RNA_SEQ_node_values');

	begin
	insert into tm_wz.wt_RNA_SEQ_node_values
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,''--g.title
    from tm_lz.lt_src_RNA_SEQ_subj_samp_map a
	where a.trial_name = TrialID
	  and a.source_cd = sourceCD;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP wt_RNA_SEQ_node_values',rowCt,stepCt,'Done') into rtnCd;
	
	begin
	insert into tm_wz.wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g')
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  tm_wz.wt_RNA_SEQ_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_RNA_SEQ_nodes',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert for platform node so platform concept can be populated
		begin
	insert into tm_wz.wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  tm_wz.wt_RNA_SEQ_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;		   
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in wt_RNA_SEQ_nodes',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd
	begin
	insert into tm_wz.wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  tm_wz.wt_RNA_SEQ_node_values
	where category_cd like '%ATTR1%'
	  and (attribute_1 IS NOT NULL AND attribute_1::text <> '');
		   get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in wt_RNA_SEQ_nodes',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd
	begin
	insert into tm_wz.wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
		substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  tm_wz.wt_RNA_SEQ_node_values
	where category_cd like '%ATTR2%'
	  and (attribute_2 IS NOT NULL AND attribute_2::text <> '');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_RNA_SEQ_nodes',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert for tissue_type node so sample_type_cd can be populated 
	begin
	insert into tm_wz.wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  tm_wz.wt_RNA_SEQ_node_values
	where category_cd like '%TISSUETYPE%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_RNA_SEQ_nodes',rowCt,stepCt,'Done') into rtnCd;
				
	begin
	update tm_wz.wt_RNA_SEQ_nodes
	set node_name=tm_cz.parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_RNA_SEQ_nodes',rowCt,stepCt,'Done') into rtnCd;
		
--	add leaf nodes for RNA_sequencing data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)
		begin
		perform i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId);
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;
		
		select cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;
		
		perform i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID);

	END LOOP;  
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
	begin
	update i2b2metadata.i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done') into rtnCd;
		
--	update concept_cd for nodes, this is done to make the next insert easier
	begin
	update tm_wz.wt_RNA_SEQ_nodes t
	set concept_cd=(select c.concept_cd from i2b2demodata.concept_dimension c
	                where c.concept_path = t.leaf_node
				   )
    where exists
         (select 1 from i2b2demodata.concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and coalesce(t.concept_cd::text, '') = '';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Update wt_RNA_SEQ_nodes with newly created concept_cds',rowCt,stepCt,'Done') into rtnCd;

  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_RNA_sequencing_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in wt_RNA_SEQ_nodes
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in wt_RNA_SEQ_nodes
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in wt_RNA_SEQ_nodes
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in wt_RNA_SEQ_nodes
  --PLATFORM        = RNA_sequencing_AFFYMETRIX - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in wt_RNA_SEQ_nodes
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_RNA_SEQ_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd
  
  --ASSAY_ID        = generated by trigger
	begin
	insert into deapp.de_subject_sample_mapping(
	partition_id
	,patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
    )
	select partitionId
		  ,t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,'RNA_AFFYMETRIX' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+RNA_SEQ+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from tm_lz.lt_src_RNA_SEQ_subj_samp_map a		
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join i2b2demodata.patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = b.sourcesystem_cd
		inner join tm_wz.wt_RNA_SEQ_nodes ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'@') = coalesce(ln.attribute_1,'@')
			and coalesce(a.attribute_2,'@') = coalesce(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join tm_wz.wt_RNA_SEQ_nodes pn
			on a.platform = pn.platform
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(pn.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(pn.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'	  
		left outer join tm_wz.wt_RNA_SEQ_nodes ttp
			on a.tissue_type = ttp.tissue_type
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = coalesce(ttp.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(ttp.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'		  
		left outer join tm_wz.wt_RNA_SEQ_nodes a1
			on a.attribute_1 = a1.attribute_1
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a1.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a1.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'		  
		left outer join tm_wz.wt_RNA_SEQ_nodes a2
			on a.attribute_2 = a1.attribute_2
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a2.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a2.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'			  
		left outer join i2b2demodata.patient_dimension sid
			on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  (ln.concept_cd IS NOT NULL AND ln.concept_cd::text <> '')) as t;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

--	Insert records for patients and samples into observation_fact
	begin
	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,INSTANCE_NUM
    )
    select distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,1
    from  deapp.de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCD
      and m.platform = 'RNA_AFFYMETRIX';
	  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;
  
	--	Insert sample facts 
	begin
	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,INSTANCE_NUM
    )
    select distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,1
    from  deapp.de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCd
      and m.platform = 'RNA_AFFYMETRIX'
	  and m.patient_id != m.sample_id;
	  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;
    
	--Update I2b2 for correct data type
    begin

     update i2b2metadata.i2b2 t
    set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
    where t.c_basecode in (select distinct x.concept_cd from tm_wz.wt_RNA_SEQ_nodes x);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
    select cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',rowCt,stepCt,'Done') into rtnCd;
    
 ---INSERT sample_dimension
	begin
      INSERT INTO I2B2DEMODATA.SAMPLE_DIMENSION(SAMPLE_CD)
         SELECT DISTINCT SAMPLE_CD FROM
           DEAPP.DE_SUBJECT_SAMPLE_MAPPING WHERE SAMPLE_CD NOT IN (SELECT SAMPLE_CD FROM I2B2DEMODATA.SAMPLE_DIMENSION) ;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
       stepCt := stepCt + 1;
    select cz_write_audit(jobId,databaseName,procedureName,'insert distinct sample_cd in sample_dimension from de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

    ---- update c_metedataxml in i2b2
    begin
       for ul in uploadI2b2
        loop
     update i2b2metadata.i2b2 n
    SET c_columndatatype = 'T',
      --Static XML String
        c_metadataxml =  ('<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue>
                <HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue>
                <LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue>
                <EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion>
                <UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits>
                <ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor>
                </ConvertingUnits></UnitValues><Analysis><Enums /><Counts />
                <New /></Analysis>'||(select xmlelement(name "SeriesMeta",xmlforest(m.display_value as "Value",m.display_unit as "Unit",m.display_label as "DisplayName")) as hi
      from tm_lz.lt_src_rna_display_mapping m where m.category_cd=ul.category_cd)||
                '</ValueMetadata>') where n.c_fullname=(select leaf_node from tm_wz.wt_RNA_SEQ_nodes where category_cd=ul.category_cd and leaf_node=n.c_fullname);
                
                end loop;
         get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
    select cz_write_audit(jobId,databaseName,procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

    --UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	begin
    update i2b2metadata.i2b2 a
    set c_visualattributes = 'LAH'
    where a.c_basecode in (select distinct x.concept_code from deapp.de_subject_sample_mapping x
                           where x.trial_name = TrialId
                             and x.platform = 'RNA_AFFYMETRIX'
                             and x.concept_code is not null);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
      
    stepCt := stepCt + 1; 
    select cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;
 
	begin
        update i2b2metadata.i2b2 a
    set c_visualattributes='FAS'
        where a.c_fullname = substr(topNode,1,instr(topNode,'\',1,3));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1; 
    select cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for study node in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;
	
	begin
   insert into probeset_deapp
   (
   probeset,
   platform 
   )select distinct s.probeset
               ,m.platform               
            from tm_lz.lt_src_rna_seq_data s,
                 tm_lz.lt_src_RNA_SEQ_subj_samp_map m  
                 where s.trial_name=m.trial_name  
                   and not exists
		 (select 1 from probeset_deapp x
		  where m.platform = x.platform
		    and s.probeset = x.probeset);
    get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert new probesets into probeset_deapp',rowCt,stepCt,'Done') into rtnCd;
        
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for RNA_sequencing data
	begin
    perform i2b2_create_concept_counts(topNode ,jobID );
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',rowCt,stepCt,'Done') into rtnCd;
	
	--	delete each node that is hidden
	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time
		begin
		perform i2b2_delete_1_node(r_delNodes.c_fullname);
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		
		select cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;

	END LOOP;  	

  --Reload Security: Inserts one record for every I2B2 record into the security table
	begin
    perform i2b2_load_security_data(jobId);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load security data',rowCt,stepCt,'Done') into rtnCd;

--	tag data with probeset_id from reference.probeset_deapp
  
	EXECUTE ('truncate table tm_wz.wt_subject_rna_probeset');
	
	--	note: assay_id represents a unique subject/site/sample
	begin
	insert into tm_wz.wt_subject_rna_probeset
	(probeset_id
--	,expr_id
	,intensity_value
	,patient_id
--	,sample_cd
--	,subject_id
	,trial_name
	,assay_id
	) select md.probeset
--		  ,sd.sample_cd
		 , avg(md.intensity_value) as intensity_value
		  ,sd.patient_id
--		  ,sd.sample_cd
--		  ,sd.subject_id
		 ,TrialId as trial_name
		  ,sd.assay_id
	from deapp.de_subject_sample_mapping sd
		,tm_lz.lt_src_RNA_SEQ_data md   
		,probeset_deapp gs
	where sd.sample_cd = md.expr_id
	  and sd.platform = 'RNA_AFFYMETRIX'
	  and sd.trial_name = TrialId
	  and sd.source_cd = sourceCd
	and md.probeset = gs.probeset
	  and (CASE WHEN dataType = 'R' THEN sign(md.intensity_value) ELSE 1 END) = 1  --	take only >0 for dataType R
	  and sd.subject_id in (select subject_id from tm_lz.lt_src_rna_seq_subj_samp_map)
	group by md.probeset
		  ,sd.patient_id
		  ,sd.assay_id;
get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	pExists := rowCt;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_rna_probeset',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert into de_subject_rna_data when dataType is T (transformed)

	if dataType = 'T' then
	begin
		insert into deapp.de_subject_rna_data
		(trial_source
		,probeset_id
		,assay_id
		,patient_id
		,trial_name
		,zscore
		)
		select TrialId || ':' || sourceCd
			  ,probeset_id
			  ,assay_id
			  ,patient_id
			  ,trial_name
			  ,case when intensity_value < -2.5
			        then -2.5
					when intensity_value > 2.5
					then 2.5
					else intensity_value
			   end as zscore
		from tm_wz.wt_subject_rna_probeset 
		where trial_name = TrialID;
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Insert transformed into DEAPP de_subject_rna_data',rowCt,stepCt,'Done') into rtnCd;
	
	else
		
	--	Calculate ZScores and insert data into de_subject_rna_data.  The 'L' parameter indicates that the RNA_sequencing  data will be selected from
	--	wt_subject_RNA_seq_probeset as part of a Load.  

		if dataType = 'R' or dataType = 'L' then
			begin
			perform I2B2_RNA_SEQ_ZSCORE_CALC(TrialID, partitionName, partitionindx,partitioniD,'L',jobId,dataType,logBase,sourceCD);
			get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',rowCt,stepCt,'Done') into rtnCd;
		end if;
	
	end if;
	
    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_RNA_SEQ_data',0,stepCt,'Done') into rtnCd;

	IF newJobFlag = 1
	THEN
		select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;
	
	return 0;
END;
 
$$;


ALTER FUNCTION tm_cz.i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base numeric, secure_study character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_process_rnaseq_data(character varying, character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_process_rnaseq_data(trial_id character varying, top_node character varying, source_cd character varying DEFAULT 'STD'::character varying, secure_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, deapp, i2b2demodata, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;

	TrialID			varchar(100);
	RootNode		varchar(2000);
	root_level		integer;
	topNode			varchar(2000);
	topLevel		integer;
	tPath			varchar(2000);
	study_name		varchar(100);
	sourceCd		varchar(50);
	secureStudy		varchar(1);

	dataType		varchar(10);
	sqlText			varchar(1000);
	tText			varchar(1000);
	gplTitle		varchar(1000);
	pExists			numeric;
	partTbl   		numeric;
	partExists 		numeric;
	sampleCt		numeric;
	idxExists 		numeric;
	logBase			numeric;
	pCount			integer;
	sCount			integer;
	tablespaceName	varchar(200);
	partitioniD		numeric(18,0);
	partitionName	varchar(100);
	partitionIndx	varchar(100);

	--	cursor to add leaf nodes, cursor is used here because there are few nodes to be added

	addNodes CURSOR is
	select distinct t.leaf_node
          ,t.node_name
	from  tm_wz.wt_mrna_nodes t
	where not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where t.leaf_node = x.c_fullname);

	--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

	delNodes CURSOR is
	select distinct c_fullname
	from  i2b2metadata.i2b2
	where c_fullname like topNode || '%' escape '`'
      and substr(c_visualattributes,2,1) = 'H';

BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	databaseName := 'TM_CZ';
	procedureName := 'i2b2_process_rnaseq_data';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select tm_cz.cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_rnaseq_data',0,stepCt,'Done') into rtnCd;

	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;

	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\','g');
	select length(topNode)-length(replace(topNode,'\','')) into topLevel;

	sourceCd := upper(coalesce(source_cd,'STD'));

	--	Get count of records in tm_lz.lt_src_mrna_subj_samp_map

	select count(*) into sCount
	from tm_lz.lt_src_mrna_subj_samp_map;

	--	check if all subject_sample map records have a subject_id, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map t
	where subject_id is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'subject_id missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a sample_cd, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map t
	where sample_cd is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'sample_cd missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a platform, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map t
	where platform is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Platform missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

  	--	check if platform exists in probeset_deapp .  If not, abort run.

	select count(*) into pCount
	from deapp.de_chromosomal_region
	where gpl_id in (select distinct m.platform from tm_lz.lt_src_mrna_subj_samp_map m);

	if pCount = 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'No Chromosomal platforms in deapp.de_chromosomal_region',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if entry in deapp.de_gpl_info for every Chromosomal platform, if not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map sm
	where not exists
		 (select 1 from deapp.de_gpl_info gi
		  where sm.platform = gi.platform
		    and gi.marker_type = 'Chromosomal'
			and gi.title is not null);

	if pCount > 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'deapp.de_gpl_info entry missing for one or more platforms',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a tissue_type, If not, abort run

	select count(*) into pCount
	from tm_lz.lt_src_mrna_subj_samp_map
	where tissue_type is null;

	if pCount > 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Tissue_Type is null for subjects',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if there are multiple platforms for a single sample   if yes, then different source_cd must be used to load the samples.

	select count(*) into pCount
	from (select sample_cd
		  from tm_lz.lt_src_mrna_subj_samp_map
		  group by sample_cd
		  having count(distinct platform) > 1) x;

	if pCount > 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Multiple platforms for single sample',0,pCount,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	-- Get root_node from topNode

	select tm_cz.parse_nth_value(topNode, 2, '\') into RootNode;

	select count(*) into pExists
	from i2b2metadata.i2b2
	where c_name = rootNode;

	if pExists = 0 then
		select tm_cz.i2b2_add_root_node(rootNode, jobId) into rtnCd;
	end if;

	select c_hlevel into root_level
	from i2b2metadata.i2b2
	where c_name = RootNode;

	-- Get study name from topNode

	select tm_cz.parse_nth_value(topNode, topLevel, '\') into study_name;

	--	Add any upper level nodes as needed

	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount;

	if pCount > 2 then
		select tm_cz.i2b2_fill_in_tree('', tPath, jobId) into rtnCd;
	end if;

	--	uppercase study_id in tm_lz.lt_src_mrna_subj_samp_map in case curator forgot

	begin
	update tm_lz.lt_src_mrna_subj_samp_map
	set trial_name=upper(trial_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in tm_lz.lt_src_mrna_subj_samp_map',rowCt,stepCt,'Done') into rtnCd;

	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd

	begin
	insert into i2b2demodata.patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,current_timestamp
		  ,current_timestamp
		  ,current_timestamp
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from tm_lz.lt_src_mrna_subj_samp_map s
		     ,deapp.de_gpl_info g
		 where s.subject_id is not null
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = 'CHROMOSOMAL'
		   and not exists
			  (select 1 from i2b2demodata.patient_dimension x
			   where x.sourcesystem_cd =
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) x;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	add security for trial if new subjects added to patient_dimension

	if pCount > 0 then
		select tm_cz.i2b2_create_security_for_trial(TrialId, secureStudy, jobID) into rtnCd;
	end if;

	--	Delete existing observation_fact data, will be repopulated

	begin
	delete from i2b2demodata.observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from deapp.de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		--    and x.platform = 'MRNA_AFFYMETRIX');
		    and x.platform = 'RNASEQ');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--	check if trial/source_cd already loaded, if yes, get existing partition_id else get new one

	select count(*) into partExists
	from deapp.de_subject_sample_mapping sm
	where sm.trial_name = TrialId
	  and coalesce(sm.source_cd,'STD') = sourceCd
	  -- and sm.platform = 'MRNA_AFFYMETRIX'
	  and sm.platform = 'RNASEQ'
	  and sm.partition_id is not null;

	if partExists = 0 then
		select nextval('deapp.seq_mrna_partition_id') into partitionId;
	else
		select distinct partition_id into partitionId
		from deapp.de_subject_sample_mapping sm
		where sm.trial_name = TrialId
		  and coalesce(sm.source_cd,'STD') = sourceCd
		--  and sm.platform = 'MRNA_AFFYMETRIX';
		  and sm.platform = 'RNASEQ';
	end if;

	partitionName := 'deapp.de_subject_rnaseq_data_' || partitionId::text;
	partitionIndx := 'de_subject_rnaseq_data_' || partitionId::text;

	--	truncate tmp node table

	execute ('truncate table tm_wz.wt_mrna_nodes');

	--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
	--	from wt_subject_mrna_data

	execute ('truncate table tm_wz.wt_mrna_node_values');

	begin
	insert into tm_wz.wt_mrna_node_values
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from tm_lz.lt_src_mrna_subj_samp_map a
	    ,deapp.de_gpl_info g
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = 'CHROMOSOMAL';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP tm_wz.wt_mrna_node_values',rowCt,stepCt,'Done') into rtnCd;

	--	inserts that create the ontology for the leaf nodes

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g')
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  tm_wz.wt_mrna_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for platform node so platform concept can be populated

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'PLATFORM'
	from  tm_wz.wt_mrna_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else '' end as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'ATTR1'
	from  tm_wz.wt_mrna_node_values
	where category_cd like '%ATTR1%'
	  and attribute_1 is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else '' end as platform
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  tm_wz.wt_mrna_node_values
	where category_cd like '%ATTR2%'
	  and attribute_2 is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for tissue_type node so sample_type_cd can be populated

	begin
	insert into tm_wz.wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10)
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else '' end as platform
		  ,tissue_type as tissue_type
		  ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
          ,case when tm_cz.instr(substr(category_cd,1,tm_cz.instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'TISSUETYPE'
	from  tm_wz.wt_mrna_node_values
	where category_cd like '%TISSUETYPE%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in tm_wz.wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	set node_name

	begin
	update tm_wz.wt_mrna_nodes
	set node_name=tm_cz.parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	add leaf nodes for mRNA data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)

		select tm_cz.i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;

		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,tText,1,stepCt,'Done') into rtnCd;

		select tm_cz.i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID) into rtnCd;

	END LOOP;

	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes

	begin
	update i2b2metadata.i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done') into rtnCd;

	--	update concept_cd for nodes, this is done to make the next insert easier

	begin
	update tm_wz.wt_mrna_nodes t
	set concept_cd=(select c.concept_cd from i2b2demodata.concept_dimension c
	                where c.concept_path = t.leaf_node
				   )
    where exists
         (select 1 from i2b2demodata.concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and t.concept_cd is null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update tm_wz.wt_mrna_nodes with newly created concept_cds',rowCt,stepCt,'Done') into rtnCd;

	--	delete any site/subject/samples that are not in lt_src_mrna_data for the trial on a reload

	if partExists > 0 then
	begin
	delete from deapp.de_subject_sample_mapping sm
	where sm.trial_name = trial_id
	  and sm.source_cd = sourceCd
	  and sm.platform = 'RNASEQ'
	 and not exists
		 (select 1 from tm_lz.lt_src_mrna_subj_samp_map x
		  where coalesce(sm.site_id,'@') = coalesce(x.site_id,'@')
		    and sm.subject_id = x.subject_id
			and sm.sample_cd = x.sample_cd
			and sm.source_cd = coalesce(x.source_cd,'STD'));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
		end;
	end if;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Delete dropped site/subject/sample from de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

	--Update or insert DE_SUBJECT_SAMPLE_MAPPING from wt_subject_mrna_data

	--PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
	--SITE_ID         = site_id
	--SUBJECT_ID      = subject_id
	--SUBJECT_TYPE    = NULL
	--CONCEPT_CODE    = from LEAF records in tm_wz.wt_mrna_nodes
	--SAMPLE_TYPE    	= TISSUE_TYPE
	--SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in tm_wz.wt_mrna_nodes
	--TRIAL_NAME      = TRIAL_NAME
	--TIMEPOINT		= attribute_2
	--TIMEPOINT_CD	= concept_cd from ATTR2 records in tm_wz.wt_mrna_nodes
	--TISSUE_TYPE     = attribute_1
	--TISSUE_TYPE_CD  = concept_cd from ATTR1 records in tm_wz.wt_mrna_nodes
	--PLATFORM        = MRNA_AFFYMETRIX - this is required by ui code
	--PLATFORM_CD     = concept_cd from PLATFORM records in tm_wz.wt_mrna_nodes
	--DATA_UID		= concatenation of concept_cd-patient_num
	--GPL_ID			= platform from wt_subject_mrna_data
	--CATEGORY_CD		= category_cd that generated ontology
	--SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
	--SAMPLE_CD		= sample_cd
	--SOURCE_CD		= sourceCd
	--PARTITION_ID	= partitionId

	--ASSAY_ID        = generated by trigger

	begin
	with upd as (select a.site_id, a.subject_id, a.sample_cd,
					ln.concept_cd as concept_code, ttp.concept_cd as sample_type_cd, a2.concept_cd as timepoint_cd, a1.concept_cd as tissue_type_cd, a.category_cd,
				    pd.patient_num as patient_id, ln.concept_cd || '-' || pd.patient_num::text as data_uid,
					ln.tissue_type as sample_type, ln.attribute_1 as tissue_type, ln.attribute_2 as timepoint, a.platform as gpl_id
				 from tm_lz.lt_src_mrna_subj_samp_map a
				 inner join i2b2demodata.patient_dimension pd
					on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = pd.sourcesystem_cd
				 inner join tm_wz.wt_mrna_nodes ln
					on 	a.platform = ln.platform
					and a.tissue_type = ln.tissue_type
					and coalesce(a.attribute_1,'') = coalesce(ln.attribute_1,'')
					and coalesce(a.attribute_2,'') = coalesce(ln.attribute_2,'')
					and ln.node_type = 'LEAF'
				 inner join tm_wz.wt_mrna_nodes pn
					on  a.platform = pn.platform
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(pn.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(pn.attribute_1,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(pn.attribute_2,'')
					and pn.node_type = 'PLATFORM'
				 left outer join tm_wz.wt_mrna_nodes ttp
					on  a.tissue_type = ttp.tissue_type
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '' end = coalesce(ttp.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(ttp.attribute_1,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(ttp.attribute_2,'')
					and ttp.node_type = 'TISSUETYPE'
				 left outer join tm_wz.wt_mrna_nodes a1
					on  a.attribute_1 = a1.attribute_1
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a1.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a1.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(a1.attribute_2,'')
					and a1.node_type = 'ATTR1'
				 left outer join tm_wz.wt_mrna_nodes a2
					on  a.attribute_2 = a1.attribute_2
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a2.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a2.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(a2.attribute_1,'')
					and a2.node_type = 'ATTR2')
		update deapp.de_subject_sample_mapping pd
		set concept_code=upd.concept_code
			,sample_type_cd=upd.sample_type_cd
			,timepoint_cd=upd.timepoint_cd
			,tissue_type_cd=upd.tissue_type_cd
			,category_cd=upd.category_cd
			,patient_id=upd.patient_id
			,data_uid=upd.data_uid
			,sample_type=upd.sample_type
			,tissue_type=upd.tissue_type
			,timepoint=upd.timepoint
			,omic_patient_id=upd.patient_id
			,partition_id=partitionId
		from upd
		where pd.trial_name = TrialID
		  and pd.source_cd = sourceCD
		  and coalesce(pd.site_id,'') = coalesce(upd.site_id,'')
		  and pd.subject_id = upd.subject_id
		  and pd.sample_cd = upd.sample_cd;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Update existing data in de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
	pcount := rowCt;	--	set counter to check that all subject_sample mapping records were added/updated
	--	insert any site/subject/samples that are not in de_subject_sample_mapping

	begin
	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
	,partition_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
		  ,partitionId
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			--  ,'MRNA_AFFYMETRIX' as platform
			  ,'RNASEQ' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+Gene_Expression+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from tm_lz.lt_src_mrna_subj_samp_map a
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join i2b2demodata.patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = b.sourcesystem_cd
		inner join tm_wz.wt_mrna_nodes ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'') = coalesce(ln.attribute_1,'')
			and coalesce(a.attribute_2,'') = coalesce(ln.attribute_2,'')
			and ln.node_type = 'LEAF'
		inner join tm_wz.wt_mrna_nodes pn
			on a.platform = pn.platform
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(pn.tissue_type,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(pn.attribute_1,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(pn.attribute_2,'')
			and pn.node_type = 'PLATFORM'
		left outer join tm_wz.wt_mrna_nodes ttp
			on a.tissue_type = ttp.tissue_type
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '' end = coalesce(ttp.platform,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(ttp.attribute_1,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(ttp.attribute_2,'')
			and ttp.node_type = 'TISSUETYPE'
		left outer join tm_wz.wt_mrna_nodes a1
			on a.attribute_1 = a1.attribute_1
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a1.platform,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a1.tissue_type,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(a1.attribute_2,'')
			and a1.node_type = 'ATTR1'
		left outer join tm_wz.wt_mrna_nodes a2
			on a.attribute_2 = a1.attribute_2
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a2.platform,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a2.tissue_type,'')
			and case when tm_cz.instr(substr(a.category_cd,1,tm_cz.instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(a2.attribute_1,'')
			and a2.node_type = 'ATTR2'
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  ln.concept_cd is not null
		  and not exists
			  (select 1 from deapp.de_subject_sample_mapping x
			   where a.trial_name = x.trial_name
			     and coalesce(a.source_cd,'STD') = x.source_cd
				-- and x.platform = 'MRNA_AFFYMETRIX'
				 and x.platform = 'RNASEQ'
				 and coalesce(a.site_id,'') = coalesce(x.site_id,'')
				 and a.subject_id = x.subject_id
				 and a.sample_cd = x.sample_cd
				 )) t;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
	pCount := pCount + rowCt;

	--	check if all records from lt_src_mrna_subj_samp_map were added/updated

	if scount <> pCount then
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Not all records in lt_src_mrna_subj_samp_map inserted/updated in de_subject_sample_mapping',0,stepCt,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;	
	--	Insert records for subjects into observation_fact

	begin
	insert into i2b2demodata.observation_fact
    (encounter_num
        ,patient_num
	,concept_cd
	,start_date
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
	,instance_num
    )
    select distinct m.patient_id
                  ,m.patient_id
		  ,m.concept_code
		  ,current_timestamp
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,current_timestamp
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
		  , 0
    from  deapp.de_subject_sample_mapping m
    where m.trial_name = TrialID
	  and m.source_cd = sourceCD
    --  and m.platform = 'MRNA_AFFYMETRIX';
      and m.platform = 'RNASEQ';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--Update I2b2 for correct c_columndatatype, c_visualattributes, c_metadataxml

	begin
	with upd as (select x.concept_cd, min(case when x.node_type = 'LEAF' then 0 else 1 end) as node_type from tm_wz.wt_mrna_nodes x group by x.concept_cd)
	update i2b2metadata.i2b2 t
	set c_columndatatype = 'T'
	   ,c_metadataxml = null
	   ,c_visualattributes=case when upd.node_type = 0 then 'LAH' else 'FA' end  
	from upd
	where t.c_basecode = upd.concept_cd;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Initialize visualattributes and xml in i2b2',rowCt,stepCt,'Done') into rtnCd;

  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for mRNA data

    select tm_cz.i2b2_create_concept_counts(topNode ,jobID ) into rtnCd;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done') into rtnCd;

	--	delete each node that is hidden

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		select tm_cz.i2b2_delete_1_node(r_delNodes.c_fullname) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;

		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done') into rtnCd;

	END LOOP;

	--Reload Security: Inserts one record for every I2B2 record into the security table

    select tm_cz.i2b2_load_security_data(jobId) into rtnCd;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done') into rtnCd;

	--	tag data with probeset_id from reference.probeset_deapp

	execute ('truncate table tm_wz.wt_subject_rnaseq_region');

	--	note: assay_id represents a unique subject/site/sample

	begin
	insert into tm_wz.wt_subject_rnaseq_region
	(region_id
	,readcount
	,patient_id
	,trial_name
	,assay_id
	)
	select gs.region_id
		  ,cast(md.readcount as bigint)
		  ,sd.patient_id
		  ,TrialId
		  ,sd.assay_id
	from deapp.de_subject_sample_mapping sd
		,tm_lz.lt_src_rnaseq_data md
		,deapp.de_chromosomal_region gs
	where sd.sample_cd = md.expr_id
	  and sd.platform = 'RNASEQ'
	  and sd.trial_name = TrialId
	  and sd.source_cd = sourceCd
	  and sd.gpl_id = gs.gpl_id
	  and md.region_name = gs.region_name
	group by gs.region_id, md.readcount
		  ,sd.patient_id,sd.assay_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_rnaseq_region',rowCt,stepCt,'Done') into rtnCd;

	if rowCt = 0 then
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Unable to match probesets to platform in probeset_deapp',0,rowCt,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	add partition if it doesn't exist, drop indexes and truncate if it does (reload)

	select count(*) into pExists
	from information_schema.tables
	where table_name = partitionindx;

	if pExists = 0 then
		sqlText := 'create table ' || partitionName || ' ( constraint mrna_' || partitionId::text || '_check check ( partition_id = ' || partitionId::text ||
				--	')) inherits (deapp.de_subject_microarray_data)';
					')) inherits (deapp.de_subject_rnaseq_data)';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create partition ' || partitionName,1,stepCt,'Done') into rtnCd;
	else
		sqlText := 'drop index if exists ' || partitionIndx || '_idx1';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		sqlText := 'drop index if exists ' || partitionIndx || '_idx2';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		sqlText := 'drop index if exists ' || partitionIndx || '_idx3';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		sqlText := 'drop index if exists ' || partitionIndx || '_idx4';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on ' || partitionName,1,stepCt,'Done') into rtnCd;
		sqlText := 'truncate table ' || partitionName;
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		stepCt := stepCt + 1;
		select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Truncate ' || partitionName,1,stepCt,'Done') into rtnCd;
	end if;

	--	insert into de_subject_rnaseq_data when dataType is T (transformed)

	sqlText := 'insert into ' || partitionName || ' (partition_id, region_id, assay_id, patient_id, trial_name, readcount) ' ||
			   'select ' || partitionId::text || ', region_id, assay_id, patient_id, trial_name, readcount ' ||
			   'from tm_wz.wt_subject_rnaseq_region';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted data into ' || partitionName,rowCt,stepCt,'Done') into rtnCd;

	--	create indexes on partition

	sqlText := ' create index ' || partitionIndx || '_idx1 on ' || partitionName || ' using btree (region_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx2 on ' || partitionName || ' using btree (assay_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx3 on ' || partitionName || ' using btree (region_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx4 on ' || partitionName || ' using btree (assay_id, region_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
    ---Cleanup OVERALL JOB if this proc is being run standalone

	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_rnaseq_data',0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select tm_cz.cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_cz.i2b2_process_rnaseq_data(trial_id character varying, top_node character varying, source_cd character varying, secure_study character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_proteomics_zscore_calc(character varying, character varying, numeric, character varying, numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_proteomics_zscore_calc(trial_id character varying, run_type character varying DEFAULT 'L'::character varying, currentjobid numeric DEFAULT NULL::numeric, data_type character varying DEFAULT 'R'::character varying, log_base numeric DEFAULT 2, source_cd character varying DEFAULT NULL::character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
This Stored Procedure is used in ETL load PROTEOMICS data
Date:12/9/2013
******************************************************************/
Declare
  TrialID character varying(50);
  sourceCD	character varying(50);
  sqlText character varying(2000);
  runType character varying(10);
  dataType character varying(10);
  stgTrial character varying(50);
  idxExists numeric;
  pExists	numeric;
  nbrRecs numeric;
  logBase numeric;
   
  --Audit variables
  newJobFlag numeric(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID numeric(18,0);
  stepCt numeric(18,0);
  rtnCd integer;
  rowCt integer;
  
BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  databaseName := 'TM_CZ';
  procedureName := 'I2B2_PROTEOMICS_ZSCORE_CALC';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName) into jobID;
  END IF;
   
  stepCt := 0;
  
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done') into rtnCd;
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting',rowCt,stepCt,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName) into rtnCd;  
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return 150;
	end if;
  
--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_proteomics_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from WT_SUBJECT_PROTEOMICS_PROBESET;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			get diagnostics rowCt := ROW_COUNT;
			select cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in WT_SUBJECT_PROTEOMICS_PROBESET - procedure exiting',rowCt,stepCt,'Done') into rtnCd;
			select cz_error_handler(jobID, procedureName) into rtnCd;
			select cz_end_audit (jobID, 'FAIL') into rtnCd;
			return 161;
		end if;
	end if;
   
--	truncate tmp tables
	begin
		execute ('truncate table tm_wz.WT_SUBJECT_PROTEOMICS_LOGS');
		execute ('truncate table tm_wz.WT_SUBJECT_PROTEOMICS_CALCS');
		execute ('truncate table tm_wz.WT_SUBJECT_PROTEOMICS_MED');
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	--drop index if exists tm_wz.WT_SUBJECT_PROTEOMICS_LOGS_I1;		
	--drop index if exists tm_wz.WT_SUBJECT_PROTEOMICS_CALCS_I1;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done') into rtnCd;
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value


	if dataType = 'L' then
		begin
		insert into WT_SUBJECT_PROTEOMICS_LOGS 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
			,subject_id
			)
			select probeset
				  ,intensity_value ----UAT 154 changes done on 19/03/2014
				  ,assay_id 
				  ,round(intensity_value,4)
				  ,patient_id
			--	  ,sample_cd
				  ,subject_id
			from WT_SUBJECT_PROTEOMICS_PROBESET
			where trial_name = TrialId;
		exception
		when others then
			perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
			perform tm_cz.cz_end_audit (jobID, 'FAIL');
			return -16;
		end;
	else	
		begin
                	insert into WT_SUBJECT_PROTEOMICS_LOGS 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
			,subject_id
			)
			select probeset
				  ,intensity_value  ----UAT 154 changes done on 19/03/2014
				  ,assay_id 
				  ,round(log(2,intensity_value  + 0.001),4)  ----UAT 154 changes done on 19/03/2014
				  ,patient_id
		--		  ,sample_cd
				  ,subject_id
			from WT_SUBJECT_PROTEOMICS_PROBESET
			where trial_name = TrialId;
		exception
		when others then
			perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
			perform tm_cz.cz_end_audit (jobID, 'FAIL');
			return -16;
		end;
	end if;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_mirna_logs',rowCt,stepCt,'Done') into rtnCd;

	
    
	--execute ('create index WT_SUBJECT_PROTEOMICS_LOGS_I1 on tm_wz.WT_SUBJECT_PROTEOMICS_LOGS (trial_name, probeset_id)');
	stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_PROTEOMICS_LOGS_I1',0,stepCt,'Done') into rtnCd;
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe

	begin
	insert into WT_SUBJECT_PROTEOMICS_CALCS
	(trial_name
	,probeset_id
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
	select d.trial_name 
		  ,d.probeset_id
		  ,avg(log_intensity)
		  ,median(log_intensity)
		  ,stddev(log_intensity)
	from WT_SUBJECT_PROTEOMICS_LOGS d 
	group by d.trial_name 
			,d.probeset_id;
	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ WT_SUBJECT_PROTEOMICS_CALCS',rowCt,stepCt,'Done') into rtnCd;

	

	--execute ('create index tm_wz.wt_subject_proteomics_calcs_i1 on tm_wz.WT_SUBJECT_PROTEOMICS_CALCS (trial_name, probeset_id) nologging tablespace "INDX"');
	--stepCt := stepCt + 1;
	--cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_PROTEOMICS_CALCS',0,stepCt,'Done');
		
-- calculate zscore

	begin
	insert into WT_SUBJECT_PROTEOMICS_MED 
	(probeset_id
	,intensity_value
	,log_intensity
	,assay_id
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,patient_id
--	,sample_cd
	,subject_id
	)
	select d.probeset_id
		  ,d.intensity_value 
		  ,d.log_intensity 
		  ,d.assay_id  
		  ,c.mean_intensity 
		  ,c.stddev_intensity 
		  ,c.median_intensity 
		  ,(CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END)
		  ,d.patient_id
	--	  ,d.sample_cd
		  ,d.subject_id
    from WT_SUBJECT_PROTEOMICS_LOGS d 
		,WT_SUBJECT_PROTEOMICS_CALCS c 
    where d.probeset_id = c.probeset_id;
    	exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ WT_SUBJECT_PROTEOMICS_MED',rowCt,stepCt,'Done') into rtnCd;

    
	begin
	insert into DE_SUBJECT_PROTEIN_DATA
	(
	 trial_name
	,protein_annotation_id
	,component
	,gene_symbol
	,gene_id
	,assay_id
	,subject_id
	,intensity 
	,zscore
        ,log_intensity
	,patient_id
	)
	select TrialId
                 ,d.id
                 ,m.probeset_id 
                 ,d.uniprot_id
                 ,d.biomarker_id
                 ,m.assay_id
                 ,m.subject_id
	    --  ,decode(dataType,'R',m.intensity_value,'L',power(logBase, m.log_intensity),null)
                ,m.intensity_value as intensity  ---UAT 154 changes done on 19/03/2014
                ,(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE round(m.zscore,5) END)	
                ,round(m.log_intensity,4) as log_intensity
                ,m.patient_id
	from WT_SUBJECT_PROTEOMICS_MED m
       , DEAPP.DE_PROTEIN_ANNOTATION d
        where d.peptide=m.probeset_id;
        exception
	when others then
		perform tm_cz.cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform tm_cz.cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial in DEAPP DE_SUBJECT_PROTEIN_DATA',rowCt,stepCt,'Done') into rtnCd;

   	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done') into rtnCd;
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
  END IF;
  return 1;	
END;
$$;


ALTER FUNCTION tm_cz.i2b2_proteomics_zscore_calc(trial_id character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric, source_cd character varying) OWNER TO tm_cz;

--
-- Name: i2b2_rbm_zscore_calc_new(character varying, character varying, bigint, character varying, bigint, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, run_type character varying DEFAULT 'L'::character varying, currentjobid bigint DEFAULT 0, data_type character varying DEFAULT 'R'::character varying, log_base bigint DEFAULT 2, source_cd character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
This Stored Procedure is used in ETL load RBM data
Date:12/04/2013
******************************************************************/

  TrialID varchar(50);
  sourceCD	varchar(50);
  sqlText varchar(2000);
  runType varchar(10);
  dataType varchar(10);
  stgTrial varchar(50);
  idxExists bigint;
  pExists	bigint;
  nbrRecs bigint;
  logBase bigint;
   
  --Audit variables
  newJobFlag integer(1);
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  
  --  exceptions
  invalid_runType exception;
  trial_mismatch exception;
  trial_missing exception;
  

BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
   
  stepCt := 0;
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done');
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting'
,SQL%ROWCOUNT,stepCt,'Done');
		raise invalid_runType;
	end if;
  
--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_mrna_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from WT_SUBJECT_RBM_PROBESET;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in WT_SUBJECT_RBM_PROBESET - procedure exiting'
,SQL%ROWCOUNT,stepCt,'Done');
			raise trial_mismatch;
		end if;
	end if;

	--remove Reload processing
--	For Reload, make sure that the TrialId passed as parameter has data in de_subject_rbm_data
--	If not, raise exception

	if runType = 'R' then 
		select count(*) into idxExists
		from de_subject_rbm_data
		where trial_name = TrialId;
		
		if idxExists = 0 then
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'No data for TrialId in de_subject_rbm_data - procedure exiting'
,SQL%ROWCOUNT,stepCt,'Done');
			raise trial_missing;
		end if;
	end if;

   
--	truncate tmp tables

	EXECUTE('truncate table tm_wz.wt_subject_rbm_logs');
	EXECUTE('truncate table tm_wz.wt_subject_rbm_calcs');
	EXECUTE('truncate table tm_wz.wt_subject_rbm_med');

	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'WT_SUBJECT_RBM_LOGS'
	  and index_name = 'WT_SUBJECT_RBM_LOGS_I1'
	  and owner = 'TM_WZ';
		
	if idxExists = 1 then
		EXECUTE('drop index tm_wz.wt_subject_rbm_logs_i1');		
	end if;
	
	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'WT_SUBJECT_RBM_CALCS'
	  and index_name = 'WT_SUBJECT_RBM_CALCS_I1'
	  and owner = 'TM_WZ';
		
	if idxExists = 1 then
		EXECUTE('drop index tm_wz.wt_subject_rbm_calcs_i1');
	end if;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value


	if dataType = 'L' then
		insert into wt_subject_rbm_logs 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
		--	,subject_id
			)
			PERFORM probeset
				  ,intensity_value  
				  ,assay_id 
				  ,intensity_value
				  ,patient_id
			--	  ,sample_cd
			--	  ,subject_id
			from wt_subject_rbm_probeset
			where trial_name = TrialId;
           
		--end if;
	else	
                	insert into wt_subject_rbm_logs 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
		--	,subject_id
			)
			PERFORM probeset
				  ,intensity_value 
				  ,assay_id 
				  ,log(2,intensity_value)
				  ,patient_id
		--		  ,sample_cd
		--		  ,subject_id
			from wt_subject_rbm_probeset
			where trial_name = TrialId;
--		end if;

	end if;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_rbm_logs',SQL%ROWCOUNT,stepCt,'Done');

	commit;
    
	EXECUTE('create index tm_wz.wt_subject_rbm_logs_i1 on tm_wz.wt_subject_rbm_logs (trial_name, probeset_id) nologging  tablespace "INDX"');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_rbm_logs',0,stepCt,'Done');
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe

	insert into wt_subject_rbm_calcs
	(trial_name
	,probeset_id
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
	PERFORM d.trial_name 
		  ,d.probeset_id
		  ,avg(log_intensity)
		  ,median(log_intensity)
		  ,stddev(log_intensity)
	from wt_subject_rbm_logs d 
	group by d.trial_name 
			,d.probeset_id;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ wt_subject_rbm_calcs',SQL%ROWCOUNT,stepCt,'Done');

	commit;

	EXECUTE('create index tm_wz.wt_subject_rbm_calcs_i1 on tm_wz.wt_subject_rbm_calcs (trial_name, probeset_id) nologging tablespace "INDX"');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_rbm_calcs',0,stepCt,'Done');
		
-- calculate zscore

	insert into wt_subject_rbm_med parallel 
	(probeset_id
	,intensity_value
	,log_intensity
	,assay_id
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,patient_id
--	,sample_cd
--	,subject_id
	)
	PERFORM d.probeset_id
		  ,d.intensity_value 
		  ,d.log_intensity 
		  ,d.assay_id  
		  ,c.mean_intensity 
		  ,c.stddev_intensity 
		  ,c.median_intensity 
		  ,(CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END)
		  ,d.patient_id
	--	  ,d.sample_cd
	--	  ,d.subject_id
    from wt_subject_rbm_logs d 
		,wt_subject_rbm_calcs c 
    where d.probeset_id = c.probeset_id;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ wt_subject_rbm_med',SQL%ROWCOUNT,stepCt,'Done');

    commit;

/*
	select count(*) into n
	select count(*) into nbrRecs
	from wt_subject_rbm_med;
	
	if nbrRecs > 10000000 then
		i2b2_mrna_index_maint('DROP',,jobId);
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on DEAPP de_subject_rbm_data',0,stepCt,'Done');
	else
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Less than 10M records, index drop bypassed',0,stepCt,'Done');
	end if;
*/
	


	insert into de_subject_rbm_data 
	(trial_name
        --,rbm_annotation_id
	,antigen_name
	,patient_id
        ,gene_symbol
        ,gene_id
        ,assay_id
        ,concept_cd
        ,value
        ,normalized_value
        ,unit    
	,zscore
	)
	PERFORM TrialId
               --,a.id ---rbm_annotation_id
              ,trim(substr(m.probeset_id,1,instr(m.probeset_id,'(')-1)) --m.probeset_id 
              ,m.patient_id
              ,a.gene_symbol  -- gene-symbol 
              ,a.gene_id  --gene_id
              ,m.assay_id
              ,d.concept_code --concept_cd
              ,m.intensity_value
              ,round(case when dataType = 'R' then m.intensity_value
				when dataType = 'L' 
				then case when logBase = -1 then null else power(logBase, m.log_intensity) end
				else null
				end,4) as normalized_value
	    --  ,decode(dataType,'R',m.intensity_value,'L',power(logBase, m.log_intensity),null)
              
              ,trim(substr(m.probeset_id ,instr(m.probeset_id ,'(',-1,1),length(m.probeset_id )))
              ,(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE m.zscore END)
          --	  ,m.sample_id
	--	  ,m.subject_id
	from wt_subject_rbm_med m
        ,wt_subject_rbm_probeset p
        ,DE_RBM_ANNOTATION a
        ,de_subject_sample_mapping d
        where 
        trim(substr(p.probeset,1,instr(p.probeset,'(')-1)) =trim(a.antigen_name) 
        --and 
      and   d.subject_id=p.subject_id
        and p.platform=a.gpl_id
        and m.assay_id=p.assay_id
        and d.platform=p.platform
        and d.patient_id=p.patient_id
        and d.concept_code in (select concept_cd from  i2b2demodata.concept_dimension where concept_cd=d.concept_code)
        and d.trial_name=TrialId
        
        and p.patient_id=m.patient_id
        and p.probeset=m.probeset_id;
        
        insert into DEAPP.DE_RBM_DATA_ANNOTATION_JOIN
select d.id, ann.id from deapp.de_subject_rbm_data d
inner join deapp.de_rbm_annotation ann on ann.antigen_name = d.antigen_name
inner join deapp.de_subject_sample_mapping ssm on ssm.assay_id = d.assay_id and ann.gpl_id = ssm.gpl_id
where not exists( select * from deapp.de_rbm_data_annotation_join j where j.data_id = d.id AND j.annotation_id = ann.id );

        /*
        select distinct TrialId
               ,a.id ---rbm_annotation_id
              ,trim(substr(m.probeset_id,1,instr(m.probeset_id,'(')-1)) --m.probeset_id 
              ,m.patient_id
              ,a.gene_symbol  -- gene-symbol 
              ,a.gene_id  --gene_id
              ,m.assay_id
              ,d.concept_code --concept_cd
              ,m.intensity_value
              ,round(case when dataType = 'R' then m.intensity_value
				when dataType = 'L' 
				then case when logBase = -1 then null else power(logBase, m.log_intensity) end
				else null
				end,4) as normalized_value
	    --  ,decode(dataType,'R',m.intensity_value,'L',power(logBase, m.log_intensity),null)
              
              ,trim(substr(m.probeset_id ,instr(m.probeset_id ,'('),length(m.probeset_id )))
              ,(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE m.zscore END)
          --	  ,m.sample_id
	--	  ,m.subject_id
         from wt_subject_rbm_med m, DE_RBM_ANNOTATION a,de_subject_sample_mapping d
         --(select distinct intensity_value from wt_subject_rbm_probeset p) x
        where a.antigen_name = trim(substr(m.probeset_id,1,instr(m.probeset_id,'(')-1)) and m.patient_id = d.patient_id  
        --and d.assay_id  = m.assay_id
        and d.trial_name = TrialId
        and d.source_cd = source_cd;
        --and d.gpl_id = a.gpl_id;
        --and x.intensity_value = m.intensity_value;
    */
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial in DEAPP de_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');

  	commit;

--	add indexes, if indexes were not dropped, procedure will not try and recreate
/*
	i2b2_mrna_index_maint('ADD',,jobId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Add indexes on DEAPP de_subject_rbm_data',0,stepCt,'Done');
*/
	
--	cleanup tmp_ files

	--execute immediate('truncate table tm_wz.wt_subject_rbm_logs');
	--execute immediate('truncate table tm_wz.wt_subject_rbm_calcs');
	--execute immediate('truncate table tm_wz.wt_subject_rbm_med');

   	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN 
    cz_end_audit (jobID, 'SUCCESS'); 
  END IF;

  EXCEPTION

  WHEN invalid_runType or trial_mismatch or trial_missing then
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
  
    cz_end_audit (jobID, 'FAIL');
  when OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);


    cz_end_audit (jobID, 'FAIL');
	
END;
 
$_$;


ALTER FUNCTION tm_cz.i2b2_rbm_zscore_calc_new(trial_id character varying, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) OWNER TO tm_cz;

--
-- Name: i2b2_rbm_zscore_calc_new(character varying, character varying, character varying, character varying, bigint, character varying, bigint, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, partition_name character varying, partition_indx character varying, run_type character varying DEFAULT 'L'::character varying, currentjobid bigint DEFAULT 0, data_type character varying DEFAULT 'R'::character varying, log_base bigint DEFAULT 2, source_cd character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*************************************************************************
This Stored Procedure is used in ETL load RBM data
Date:12/04/2013
******************************************************************/

  TrialID varchar(50);
  sourceCD	varchar(50);
  sqlText varchar(2000);
  runType varchar(10);
  dataType varchar(10);
  partitionName varchar(200);
  partitionindx varchar(200);
  stgTrial varchar(50);
  idxExists bigint;
  pExists	bigint;
  nbrRecs bigint;
  logBase bigint;
   
  --Audit variables
  newJobFlag integer;
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  rowCt			bigint;
  rtnCd			integer;  
  errorNumber		character varying;
  errorMessage	character varying;

BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	
	partitionindx := partition_indx;
	partitionName := partition_name;
	  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_RBM_DATA';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName, jobID) into rtnCd;
  END IF;
   
  stepCt := 0;
  
  	select count(*) into pExists
	from information_schema.tables
	where table_name = partitionindx;

	if pExists = 0 then
	sqlText := 'create table ' || partitionName || ' ( constraint rbm_' || partitionId::text || '_check check ( partition_id = ' || partitionId::text ||
	')) inherits (deapp.de_subject_rbm_data)';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create partition ' || partitionName,1,stepCt,'Done') into rtnCd;
	else
	sqlText := 'drop index if exists ' || partitionIndx || '_idx1';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx2';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx3';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx4';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on ' || partitionName,1,stepCt,'Done') into rtnCd;
	sqlText := 'truncate table ' || partitionName;
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Truncate ' || partitionName,1,stepCt,'Done') into rtnCd;
	end if;
  
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done') into rtnCd;
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting'
,0,stepCt,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return;
	end if;
  
--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_mrna_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from tm_wz.WT_SUBJECT_RBM_PROBESET;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in WT_SUBJECT_RBM_PROBESET - procedure exiting'
,0,stepCt,'Done') into rtnCd;
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			select cz_end_audit (jobId,'FAIL') into rtnCd;
			return;
		end if;
	end if;

	--remove Reload processing
--	For Reload, make sure that the TrialId passed as parameter has data in de_subject_rbm_data
--	If not, raise exception

	if runType = 'R' then 
		select count(*) into idxExists
		from deapp.de_subject_rbm_data
		where trial_name = TrialId;
		
		if idxExists = 0 then
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'No data for TrialId in de_subject_rbm_data - procedure exiting'
,0,stepCt,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return;
		end if;
	end if;

   
--	truncate tmp tables

	EXECUTE('truncate table tm_wz.wt_subject_rbm_logs');
	EXECUTE('truncate table tm_wz.wt_subject_rbm_calcs');
	EXECUTE('truncate table tm_wz.wt_subject_rbm_med');

	EXECUTE('drop index if exists tm_wz.wt_subject_rbm_logs_i1');		
		
	if idxExists = 1 then
		EXECUTE('drop index if exists tm_wz.wt_subject_rbm_calcs_i1');
	end if;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done') into rtnCd;
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value

	begin
		if dataType = 'L' then
			insert into tm_wz.wt_subject_rbm_logs 
				(probeset_id
				,intensity_value
				,assay_id
				,log_intensity
				,patient_id
				)
				select probeset
					  ,intensity_value  
					  ,assay_id 
					  ,intensity_value
					  ,patient_id
				from tm_wz.wt_subject_rbm_probeset
				where trial_name = TrialId;
			   
			--end if;
		else	
			insert into tm_wz.wt_subject_rbm_logs 
				(probeset_id
				,intensity_value
				,assay_id
				,log_intensity
				,patient_id
				)
				select probeset
					  ,intensity_value 
					  ,assay_id 
					  ,log(2,intensity_value)
					  ,patient_id
				from wt_subject_rbm_probeset
				where trial_name = TrialId;

		end if;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_rbm_logs',rowCt,stepCt,'Done') into rtnCd;
    
	EXECUTE('create index tm_wz.wt_subject_rbm_logs_i1 on tm_wz.wt_subject_rbm_logs (trial_name, probeset_id) nologging  tablespace "INDX"');
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_rbm_logs',0,stepCt,'Done') into rtnCd;
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe
	begin
		insert into tm_wz.wt_subject_rbm_calcs
		(trial_name
		,probeset_id
		,mean_intensity
		,median_intensity
		,stddev_intensity
		)
		select d.trial_name 
			  ,d.probeset_id
			  ,avg(log_intensity)
			  ,median(log_intensity)
			  ,stddev(log_intensity)
		from tm_wz.wt_subject_rbm_logs d 
		group by d.trial_name 
				,d.probeset_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ wt_subject_rbm_calcs',SQL%ROWCOUNT,stepCt,'Done') into rtnCd;


	EXECUTE('create index tm_wz.wt_subject_rbm_calcs_i1 on tm_wz.wt_subject_rbm_calcs (trial_name, probeset_id) nologging tablespace "INDX"');
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_rbm_calcs',0,stepCt,'Done') into rtnCd;
		
-- calculate zscore
	begin
		insert into tm_wz.wt_subject_rbm_med 
		(probeset_id
		,intensity_value
		,log_intensity
		,assay_id
		,mean_intensity
		,stddev_intensity
		,median_intensity
		,zscore
		,patient_id
		)
		select d.probeset_id
			  ,d.intensity_value 
			  ,d.log_intensity 
			  ,d.assay_id  
			  ,c.mean_intensity 
			  ,c.stddev_intensity 
			  ,c.median_intensity 
			  ,(CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END)
			  ,d.patient_id
		from tm_wz.wt_subject_rbm_logs d 
			,tm_wz.wt_subject_rbm_calcs c 
		where d.probeset_id = c.probeset_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ wt_subject_rbm_med',rowCt,stepCt,'Done') into rtnCd;

	
	-- insert into de_subject_rbm_data when dataType is T (transformed)

	execute ('drop index if exists tm_wz.wt_subject_mrna_logs_i1');
	execute ('drop index if exists tm_wz.wt_subject_mrna_calcs_i1');
	
	sqlText := 'insert into ' || partitionName || 
	'(trial_name, antigen_name, patient_id, gene_symbol, gene_id, assay_id ' ||
        ',concept_cd, value, normalized_value, unit, zscore) ' ||
	'select TrialId ' ||
              ',trim(substr(m.probeset_id,1,instr(m.probeset_id,''('')-1)) --m.probeset_id  ' ||
              ',m.patient_id ' ||
              ',a.gene_symbol  -- gene-symbol  ' ||
              ',a.gene_id  --gene_id ' ||
              ',m.assay_id ' ||
              ',d.concept_code --concept_cd ' ||
              ',m.intensity_value ' ||
              ',round(case when dataType = ''R'' then m.intensity_value ' ||
				'when dataType = ''L''  ' ||
				'then case when logBase = -1 then null else power(logBase, m.log_intensity) end ' ||
				'else null ' ||
				'end,4) as normalized_value ' ||
              ',trim(substr(m.probeset_id ,instr(m.probeset_id ,''('',-1,1),length(m.probeset_id ))) ' ||
              ',(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE m.zscore END) ' ||
	'from wt_subject_rbm_med m ' ||
        ',wt_subject_rbm_probeset p ' ||
        ',DE_RBM_ANNOTATION a ' ||
        ',de_subject_sample_mapping d ' ||
        'where  ' ||
        'trim(substr(p.probeset,1,instr(p.probeset,''('')-1)) =trim(a.antigen_name)  ' ||
      'and   d.subject_id=p.subject_id ' ||
        'and p.platform=a.gpl_id ' ||
        'and m.assay_id=p.assay_id ' ||
        'and d.platform=p.platform ' ||
        'and d.patient_id=p.patient_id ' ||
        'and d.concept_code in (select concept_cd from  i2b2demodata.concept_dimension where concept_cd=d.concept_code) ' ||
        'and d.trial_name=TrialId  ' ||
        'and p.patient_id=m.patient_id ' ||
        'and p.probeset=m.probeset_id ' ;
		
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted data into ' || partitionName,rowCt,stepCt,'Done') into rtnCd;

	insert into DEAPP.DE_RBM_DATA_ANNOTATION_JOIN
	select d.id, ann.id from deapp.de_subject_rbm_data d
	inner join deapp.de_rbm_annotation ann on ann.antigen_name = d.antigen_name
	inner join deapp.de_subject_sample_mapping ssm on ssm.assay_id = d.assay_id and ann.gpl_id = ssm.gpl_id
	where not exists( select * from deapp.de_rbm_data_annotation_join j where j.data_id = d.id AND j.annotation_id = ann.id );

        
	
	-- create indexes on partition

	sqlText := ' create index ' || partitionIndx || '_idx1 on ' || partitionName || ' using btree (partition_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx2 on ' || partitionName || ' using btree (assay_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx3 on ' || partitionName || ' using btree (probeset_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx4 on ' || partitionName || ' using btree (assay_id, probeset_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN 
    select cz_end_audit (jobID, 'SUCCESS') into rtnCd; 
  END IF;

END;
 
$$;


ALTER FUNCTION tm_cz.i2b2_rbm_zscore_calc_new(trial_id character varying, partition_name character varying, partition_indx character varying, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) OWNER TO tm_cz;

--
-- Name: i2b2_rbm_zscore_calc_new(character varying, character varying, character varying, numeric, character varying, bigint, character varying, bigint, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, run_type character varying DEFAULT 'L'::character varying, currentjobid bigint DEFAULT 0, data_type character varying DEFAULT 'R'::character varying, log_base bigint DEFAULT 2, source_cd character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*************************************************************************
This Stored Procedure is used in ETL load RBM data
Date:12/04/2013
******************************************************************/

  TrialID varchar(50);
  sourceCD	varchar(50);
  sqlText varchar(2000);
  runType varchar(10);
  dataType varchar(10);
  partitionName varchar(200);
  partitionindx varchar(200);
  stgTrial varchar(50);
  idxExists bigint;
  pExists	bigint;
  nbrRecs bigint;
  logBase bigint;
   
  --Audit variables
  newJobFlag integer;
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  rowCt			bigint;
  rtnCd			integer;  
  errorNumber		character varying;
  errorMessage	character varying;

BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	
	partitionindx := partition_indx;
	partitionName := partition_name;
	  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'i2b2_rbm_zscore_calc_new';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName, jobID) into rtnCd;
  END IF;
   
  stepCt := 0;
  
  	select count(*) into pExists
	from information_schema.tables
	where table_name = partitionindx;

	if pExists = 0 then
	sqlText := 'create table ' || partitionName || ' ( constraint rbm_' || partitionId::text || '_check check ( partition_id = ' || partitionId::text ||
	')) inherits (deapp.de_subject_rbm_data)';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create partition ' || partitionName,1,stepCt,'Done') into rtnCd;
	else
	sqlText := 'drop index if exists ' || partitionIndx || '_idx1';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx2';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx3';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx4';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on ' || partitionName,1,stepCt,'Done') into rtnCd;
	sqlText := 'truncate table ' || partitionName;
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Truncate ' || partitionName,1,stepCt,'Done') into rtnCd;
	end if;
  
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done') into rtnCd;
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting'
,0,stepCt,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return;
	end if;
  
--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_mrna_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from tm_wz.WT_SUBJECT_RBM_PROBESET;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in WT_SUBJECT_RBM_PROBESET - procedure exiting'
,0,stepCt,'Done') into rtnCd;
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			select cz_end_audit (jobId,'FAIL') into rtnCd;
			return;
		end if;
	end if;

	--remove Reload processing
--	For Reload, make sure that the TrialId passed as parameter has data in de_subject_rbm_data
--	If not, raise exception

	if runType = 'R' then 
		select count(*) into idxExists
		from deapp.de_subject_rbm_data
		where trial_name = TrialId;
		
		if idxExists = 0 then
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'No data for TrialId in de_subject_rbm_data - procedure exiting'
,0,stepCt,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return;
		end if;
	end if;

   
--	truncate tmp tables

	EXECUTE('truncate table tm_wz.wt_subject_rbm_logs');
	EXECUTE('truncate table tm_wz.wt_subject_rbm_calcs');
	EXECUTE('truncate table tm_wz.wt_subject_rbm_med');

	EXECUTE('drop index if exists tm_wz.wt_subject_rbm_logs_i1');		
		
	EXECUTE('drop index if exists tm_wz.wt_subject_rbm_calcs_i1');
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done') into rtnCd;
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value

	begin
		if dataType = 'L' then
			insert into tm_wz.wt_subject_rbm_logs 
				(probeset_id
				,intensity_value
				,assay_id
				,log_intensity
				,patient_id
				)
				select probeset
					  ,intensity_value  
					  ,assay_id 
					  ,intensity_value
					  ,patient_id
				from tm_wz.wt_subject_rbm_probeset
				where trial_name = TrialId;
			   
			--end if;
		else	
			insert into tm_wz.wt_subject_rbm_logs 
				(probeset_id
				,intensity_value
				,assay_id
				,log_intensity
				,patient_id
				)
				select probeset
					  ,intensity_value 
					  ,assay_id 
					  ,CASE WHEN intensity_value <= 0 THEN log(2,(intensity_value + 0.001)) ELSE log(2,intensity_value) END
					  ,patient_id
				from tm_wz.wt_subject_rbm_probeset
				where trial_name = TrialId;
		end if;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_rbm_logs',rowCt,stepCt,'Done') into rtnCd;
    
	EXECUTE('create index wt_subject_rbm_logs_i1 on tm_wz.wt_subject_rbm_logs (trial_name, probeset_id) tablespace "indx"');
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_rbm_logs',0,stepCt,'Done') into rtnCd;
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe
	begin
		insert into tm_wz.wt_subject_rbm_calcs
		(trial_name
		,probeset_id
		,mean_intensity
		,median_intensity
		,stddev_intensity
		)
		select d.trial_name 
			  ,d.probeset_id
			  ,avg(log_intensity)
			  ,median(log_intensity)
			  ,stddev(log_intensity)
		from tm_wz.wt_subject_rbm_logs d 
		group by d.trial_name 
				,d.probeset_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ wt_subject_rbm_calcs',rowCt,stepCt,'Done') into rtnCd;


	EXECUTE('create index wt_subject_rbm_calcs_i1 on tm_wz.wt_subject_rbm_calcs (trial_name, probeset_id) tablespace "indx"');
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_rbm_calcs',0,stepCt,'Done') into rtnCd;
		
-- calculate zscore
	begin
		insert into tm_wz.wt_subject_rbm_med 
		(probeset_id
		,intensity_value
		,log_intensity
		,assay_id
		,mean_intensity
		,stddev_intensity
		,median_intensity
		,zscore
		,patient_id
		)
		select d.probeset_id
			  ,d.intensity_value 
			  ,d.log_intensity 
			  ,d.assay_id  
			  ,c.mean_intensity 
			  ,c.stddev_intensity 
			  ,c.median_intensity 
			  ,(CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END)
			  ,d.patient_id
		from tm_wz.wt_subject_rbm_logs d 
			,tm_wz.wt_subject_rbm_calcs c 
		where d.probeset_id = c.probeset_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ wt_subject_rbm_med',rowCt,stepCt,'Done') into rtnCd;

	
	-- insert into de_subject_rbm_data when dataType is T (transformed)

	
	sqlText := 'insert into ' || partitionName || 
	'(partition_id, trial_name, antigen_name, patient_id, gene_symbol, gene_id, assay_id ' ||
        ',concept_cd, value, normalized_value, unit, zscore, id) ' ||
	'select ' || partitioniD::text || ', ''' || TrialId || '''' ||
              ',trim(substr(m.probeset_id,1,instr(m.probeset_id,''('')-1)) ' ||
              ',m.patient_id ' ||
              ',a.gene_symbol  ' ||
              ',a.gene_id::integer  ' ||
              ',m.assay_id ' ||
              ',d.concept_code ' ||
              ',m.intensity_value ' ||
              ',round(case when ''' || dataType || ''' = ''R'' then m.intensity_value::numeric ' ||
				'when ''' || dataType || ''' = ''L''  ' ||
				'then case when ''' || logBase || ''' = -1 then null else power( ''' || logBase || ''' , m.log_intensity)::numeric end ' ||
				'else null ' ||
				'end,4) as normalized_value ' ||
              ',trim(substr(m.probeset_id ,instr(m.probeset_id ,''('',-1,1),length(m.probeset_id ))) ' ||
              ',(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE m.zscore END) ' ||
			  ',nextval(''deapp.RBM_ANNOTATION_ID'') '||
	'from tm_wz.wt_subject_rbm_med m ' ||
        ',tm_wz.wt_subject_rbm_probeset p ' ||
        ',deapp.DE_RBM_ANNOTATION a ' ||
        ',deapp.de_subject_sample_mapping d ' ||
        'where  ' ||
        'trim(substr(p.probeset,1,instr(p.probeset,''('')-1)) =trim(a.antigen_name)  ' ||
      'and   d.subject_id=p.subject_id ' ||
        'and p.platform=a.gpl_id ' ||
        'and m.assay_id=p.assay_id ' ||
        'and d.gpl_id=p.platform ' ||
        'and d.patient_id=p.patient_id ' ||
        'and d.concept_code in (select concept_cd from  i2b2demodata.concept_dimension where concept_cd=d.concept_code) ' ||
        'and d.trial_name=''' || TrialId || '''' ||
        'and p.patient_id=m.patient_id ' ||
        'and p.probeset=m.probeset_id ' ;
		
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted data into ' || partitionName,rowCt,stepCt,'Done') into rtnCd;

	insert into DEAPP.DE_RBM_DATA_ANNOTATION_JOIN
	select d.id, ann.id from deapp.de_subject_rbm_data d
	inner join deapp.de_rbm_annotation ann on ann.antigen_name = d.antigen_name
	inner join deapp.de_subject_sample_mapping ssm on ssm.assay_id = d.assay_id and ann.gpl_id = ssm.gpl_id
	where not exists( select * from deapp.de_rbm_data_annotation_join j where j.data_id = d.id AND j.annotation_id = ann.id );
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN 
    select cz_end_audit (jobID, 'SUCCESS') into rtnCd; 
  END IF;

END;
 
$$;


ALTER FUNCTION tm_cz.i2b2_rbm_zscore_calc_new(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) OWNER TO tm_cz;

--
-- Name: i2b2_rename_node(character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_rename_node(trial_id character varying, old_node character varying, new_node character varying, currentjobid numeric DEFAULT (-1)) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
   
  --Audit variables
  newJobFlag integer(1);
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  

BEGIN
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;

  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_rename_node',0,stepCt,'Done'); 
	
  if old_node != ''  and old_node != '%' and new_node != ''  and new_node != '%'
  then

	--	Update concept_counts paths

	update concept_counts cc
      set CONCEPT_PATH = replace(cc.concept_path, '\' || old_node || '\', '\' || new_node || '\'),
	      parent_concept_path = replace(cc.parent_concept_path, '\' || old_node || '\', '\' || new_node || '\')
      where cc.concept_path in
		   (select cd.concept_path from concept_dimension cd
		    where cd.sourcesystem_cd = trial_id
              and cd.concept_path like '%' || old_node || '%');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update concept_counts with new path',SQL%ROWCOUNT,stepCt,'Done'); 

    COMMIT;
	
    --Update path in i2b2_tags
    update i2b2_tags t
      set path = replace(t.path, '\' || old_node || '\', '\' || new_node || '\')
      where t.path in
		   (select cd.concept_path from concept_dimension cd
		    where cd.sourcesystem_cd = trial_id
              and cd.concept_path like '%\' || old_node || '\%');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update i2b2_tags with new path',SQL%ROWCOUNT,stepCt,'Done'); 

    COMMIT;
	
    --Update specific name
    --update concept_dimension
    --  set name_char = new_node
    --  where name_char = old_node
    --    and sourcesystem_cd = trial_id;

    --Update all paths
    update concept_dimension
      set CONCEPT_PATH = replace(concept_path, '\' || old_node || '\', '\' || new_node || '\')
	     ,name_char=(CASE WHEN name_char=old_node THEN new_node ELSE name_char END)
      where
		sourcesystem_cd = trial_id
        and concept_path like '%\' || old_node || '\%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update concept_dimension with new path',SQL%ROWCOUNT,stepCt,'Done'); 

    COMMIT;



    --I2B2
    --Update specific name
    --update i2b2
    --  set c_name = new_node
    --  where c_name = old_node
    --    and c_fullname like '%' || trial_id || '%';

    --Update all paths, added updates to c_dimcode and c_tooltip instead of separate pass
    update i2b2
      set c_fullname = replace(c_fullname, '\' || old_node || '\', '\' || new_node || '\')
	  	 ,c_dimcode = replace(c_dimcode, '\' || old_node || '\', '\' || new_node || '\')
		 ,c_tooltip = replace(c_tooltip, '\' || old_node || '\', '\' || new_node || '\')
		 ,c_name = (CASE WHEN c_name=old_node THEN new_node ELSE c_name END)
      where sourcesystem_cd = trial_id
        and c_fullname like '%\' || old_node || '\%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update i2b2 with new path',SQL%ROWCOUNT,stepCt,'Done'); 

    COMMIT;

	--Update i2b2_secure to match i2b2
    --update i2b2_secure
    --  set c_fullname = replace(c_fullname, old_node, new_node)
	--  	 ,c_dimcode = replace(c_dimcode, old_node, new_node)
	--	 ,c_tooltip = replace(c_tooltip, old_node, new_node)
    --  where
    --    c_fullname like '%' || trial_id || '%';
    --COMMIT;
	
	i2b2_load_security_data(jobID);


  END IF;
END;
 
$_$;


ALTER FUNCTION tm_cz.i2b2_rename_node(trial_id character varying, old_node character varying, new_node character varying, currentjobid numeric) OWNER TO tm_cz;

--
-- Name: i2b2_rna_seq_annotation(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_rna_seq_annotation() RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE

	gpl_rtn bigint;
	newJobFlag numeric(1);
	databaseName character varying(100);
	procedureName character varying(100);
	jobID bigint;
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	rowCt			numeric(18,0);
	stepCt bigint;
BEGIN

	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := -1;
	
	databaseName := 'TM_CZ';
	procedureName := 'I2B2_RBA_SEQ_ANNOTATION';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName, jobID) into jobId;
	END IF;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_rna_seq_annotation',0,stepCt,'Done') into rtnCd;
	
 -- insert into "DEAPP"."DE_RNASEQ_ANNOTATION"
 
 select count(platform) into gpl_rtn from deapp.de_gpl_info where marker_type='RNASEQ' and (platform IS NOT NULL AND platform::text <> '');
 if gpl_rtn=0 then
		select cz_write_audit(jobId,databasename,procedurename,'Platform data missing from DEAPP.DE_GPL_INFO',1,stepCt,'ERROR') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
 end if;
 
 begin
 insert into deapp.DE_RNASEQ_ANNOTATION 
 (
   GPL_ID
  ,TRANSCRIPT_ID 
  ,GENE_SYMBOL
  ,GENE_ID
  ,ORGANISM
  ,PROBESET_ID
    )
    select g.platform
          ,a.transcript_id
          ,a.gene_symbol
          ,b.bio_marker_id
          ,a.organism
          ,pd.probeset_id
          from tm_lz.LT_RNASEQ_ANNOTATION a
               ,(select platform from deapp.de_gpl_info where marker_type='RNASEQ') as g
               ,biomart.bio_marker b
               ,probeset_deapp pd
                where b.bio_marker_name=a.gene_symbol
                and a.transcript_id =pd.probeset;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert new probesets into antigen_deapp',rowCt,stepCt,'Done') into rtnCd;
	
   return 0 ;
              
 
END;
 
$$;


ALTER FUNCTION tm_cz.i2b2_rna_seq_annotation() OWNER TO tm_cz;

--
-- Name: i2b2_rna_seq_annotation(bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_rna_seq_annotation(currentjobid bigint DEFAULT NULL::bigint) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE

	gpl_rtn bigint;
	newJobFlag numeric(1);
	databaseName character varying(100);
	procedureName character varying(100);
	jobID bigint;
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	rowCt			numeric(18,0);
	stepCt bigint;
BEGIN

	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	
	databaseName := 'TM_CZ';
	procedureName := 'I2B2_RNA_SEQ_ANNOTATION';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName, jobID) into jobId;
	END IF;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_rna_seq_annotation',0,stepCt,'Done') into rtnCd;
	
 -- insert into "DEAPP"."DE_RNASEQ_ANNOTATION"
 
 select count(platform) into gpl_rtn from deapp.de_gpl_info where marker_type='RNASEQ' and (platform IS NOT NULL AND platform::text <> '');
 if gpl_rtn=0 then
		select cz_write_audit(jobId,databasename,procedurename,'Platform data missing from DEAPP.DE_GPL_INFO',1,stepCt,'ERROR') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
 end if;
 
 begin
 insert into deapp.DE_RNASEQ_ANNOTATION
 (
 TRANSCRIPT_ID
   ,GPL_ID
    ,GENE_SYMBOL
  ,GENE_ID
  ,ORGANISM
    )
    select distinct (a.transcript_id)
      ,null
          ,a.gene_symbol
          ,null
          ,a.organism
          from tm_lz.LT_RNASEQ_ANNOTATION a
                where a.transcript_id not in (select distinct transcript_id from deapp.DE_RNASEQ_ANNOTATION);
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert data in DE_RNASEQ_ANNOTATION',0,stepCt,'Done') into rtnCd;
	
	begin
    update deapp.DE_RNASEQ_ANNOTATION a set GENE_ID=(select distinct primary_external_id from biomart.bio_marker b where
	b.bio_marker_name=a.gene_symbol limit 1)
    where a.GENE_ID is null;
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_rna_seq_annotation',0,stepCt,'Done') into rtnCd;
	
       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
  END IF;

  return 0;
 
END;
 
$$;


ALTER FUNCTION tm_cz.i2b2_rna_seq_annotation(currentjobid bigint) OWNER TO tm_cz;

--
-- Name: i2b2_rna_seq_zscore_calc(character varying, character varying, character varying, numeric, character varying, numeric, character varying, bigint, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_rna_seq_zscore_calc(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, run_type character varying DEFAULT 'L'::character varying, currentjobid numeric DEFAULT (-1), data_type character varying DEFAULT 'R'::character varying, log_base bigint DEFAULT 2, source_cd character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*************************************************************************
* This stored procedure is used to calculate z-scores for RNA sequencing data load
* Date:10/23/2013
******************************************************************/

  TrialID varchar(50);
  sourceCD	varchar(50);
  sqlText varchar(2000);
  runType varchar(10);
  dataType varchar(10);
  stgTrial varchar(50);
  idxExists bigint;
  pExists	bigint;
  nbrRecs bigint;
  logBase bigint;
  partitionName varchar(200);
  partitionindx varchar(200);
   
  --Audit variables
  newJobFlag integer;
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  rowCt			bigint;
  rtnCd			integer;  
  errorNumber		character varying;
  errorMessage	character varying;


BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;

	partitionindx := partition_indx;
	partitionName := partition_name;	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  	databaseName := 'TM_CZ';
	procedureName := 'i2b2_rna_seq_zscore_calc';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName, jobID) into rtnCd;
  END IF;
    	
  stepCt := 0;
  
    	select count(*) into pExists
	from information_schema.tables
	where table_name = partitionindx;

	if pExists = 0 then
	sqlText := 'create table ' || partitionName || ' ( constraint rnaseq_' || partitionId::text || '_check check ( partition_id = ' || partitionId::text ||
	')) inherits (deapp.de_subject_rna_data)';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Create partition ' || partitionName,1,stepCt,'Done') into rtnCd;
	else
	sqlText := 'drop index if exists ' || partitionIndx || '_idx1';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx2';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx3';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx4';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on ' || partitionName,1,stepCt,'Done') into rtnCd;
	sqlText := 'truncate table ' || partitionName;
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Truncate ' || partitionName,1,stepCt,'Done') into rtnCd;
	end if;
  
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done') into rtnCd;
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting'
,0,stepCt,'Done') into rtnCd;
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return;
	end if;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done') into rtnCd;
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting'
,0,stepCt,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName) into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end if;
  
	if runType = 'L' then
		select distinct trial_name into stgTrial
		from tm_wz.wt_subject_rna_probeset;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in wt_subject_rna_probeset - procedure exiting'
,0,stepCt,'Done') into rtnCd;
			select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			select cz_end_audit (jobId,'FAIL') into rtnCd;
			return;
		end if;
	end if;
   
--	truncate tmp tables

	EXECUTE('truncate table tm_wz.wt_subject_rna_logs');
	EXECUTE('truncate table tm_wz.wt_subject_rna_calcs');
	EXECUTE('truncate table tm_wz.wt_subject_rna_med');
	
	EXECUTE('drop index if exists tm_wz.WT_SUBJECT_RNA_LOGS_I1');		
	EXECUTE('drop index if exists tm_wz.WT_SUBJECT_RNA_CALCS_I1');

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done') into rtnCd;
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value
	begin
	if dataType = 'L' then
			insert into tm_wz.wt_subject_rna_logs 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
		--	,subject_id
			)
			select probeset_id
				  ,intensity_value  
				  ,assay_id 
				  ,intensity_value
				  ,patient_id
			from tm_wz.wt_subject_rna_probeset
			where trial_name = TrialId;
			
	else
			insert into tm_wz.wt_subject_rna_logs 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
			)
			select probeset_id
				  ,intensity_value 
				  ,assay_id 
				  ,CASE WHEN intensity_value <= 0 THEN log(2,(intensity_value + 0.001)) ELSE log(2,intensity_value) END
				  ,patient_id
			from tm_wz.wt_subject_rna_probeset
			where trial_name = TrialId;
	end if;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_rna_logs',rowCt,stepCt,'Done') into rtnCd;

	begin
	EXECUTE('create index WT_SUBJECT_RNA_LOGS_I1 on tm_wz.wt_subject_rna_logs (trial_name, probeset_id) tablespace "indx"');
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_RNA_LOGS_I1',0,stepCt,'Done') into rtnCd;
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe
	begin
	insert into tm_wz.wt_subject_rna_calcs
	(trial_name
	,probeset_id
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
	select d.trial_name 
		  ,d.probeset_id
		  ,avg(log_intensity)
		  ,median(log_intensity)
		  ,stddev(log_intensity)
	from tm_wz.wt_subject_rna_logs d 
	group by d.trial_name 
			,d.probeset_id;
			get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ wt_subject_rna_calcs',rowCt,stepCt,'Done') into rtnCd;
	
	begin
	EXECUTE('create index WT_SUBJECT_RNA_CALCS_I1 on tm_wz.wt_subject_rna_calcs (trial_name, probeset_id) tablespace "indx"');
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_RNA_CALCS_I1',0,stepCt,'Done') into rtnCd;
		
-- calculate zscore
	begin
	insert into tm_wz.wt_subject_rna_med 
	(probeset_id
	,intensity_value
	,log_intensity
	,assay_id
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,patient_id
	)
	select d.probeset_id
		  ,d.intensity_value 
		  ,d.log_intensity 
		  ,d.assay_id  
		  ,c.mean_intensity 
		  ,c.stddev_intensity 
		  ,c.median_intensity 
		  ,CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END
		  ,d.patient_id
    from tm_wz.wt_subject_rna_logs d 
		,tm_wz.wt_subject_rna_calcs c 
    where d.probeset_id = c.probeset_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ wt_subject_rna_med',rowCt,stepCt,'Done') into rtnCd;
  
	begin
	sqlText := 'insert into ' || partitionName || 
	'(partition_id, trial_source,trial_name,assay_id,probeset_id,raw_intensity ' ||
	',log_intensity,zscore,patient_id) '||
	'select ' || partitioniD::text || ', ''' || TrialId || '''' ||
		  ',''' || TrialId || ''',m.assay_id,m.probeset_id ' ||
		  ',round((case when ''' || dataType || '''= ''R'' then m.intensity_value::numeric '||
				'when ''' || dataType || '''= ''L'' ' ||
				'then case when ' || logBase || '= -1 then null else power(' || logBase || ', m.log_intensity)::numeric end ' ||
				'else null end),4) as raw_intensity ' ||
		  ',round(m.log_intensity::numeric,4) ' ||
	      ',round(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE round(m.zscore::numeric,5) END,5) ' ||
		  ',m.patient_id ' ||
	'from tm_wz.wt_subject_rna_med m';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select tm_cz.cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select tm_cz.cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select tm_cz.cz_write_audit(jobId,databaseName,procedureName,'Inserted data into ' || partitionName,rowCt,stepCt,'Done') into rtnCd;

	EXECUTE('truncate table tm_wz.wt_subject_rna_logs');
	EXECUTE('truncate table tm_wz.wt_subject_rna_calcs');
	EXECUTE('truncate table tm_wz.wt_subject_rna_med');

   	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done') into rtnCd;
	
		-- create indexes on partition

	sqlText := ' create index ' || partitionIndx || '_idx1 on ' || partitionName || ' using btree (partition_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx2 on ' || partitionName || ' using btree (assay_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx3 on ' || partitionName || ' using btree (probeset_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx4 on ' || partitionName || ' using btree (assay_id, probeset_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
  END IF;

	
END;
		   
 
$$;


ALTER FUNCTION tm_cz.i2b2_rna_seq_zscore_calc(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, run_type character varying, currentjobid numeric, data_type character varying, log_base bigint, source_cd character varying) OWNER TO tm_cz;

--
-- Name: i2b2_secure_study(text, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_secure_study(trial_id text, currentjobid bigint DEFAULT NULL::bigint) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research d, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	--Audit variables
	newJobFlag integer(1);
	databaseName varchar(100);
	procedureName varchar(100);
	jobID bigint;
	stepCt bigint;
	
	v_bio_experiment_id	bigint;
	pExists				integer;
	TrialId				varchar(100);


BEGIN

	TrialId := trial_id;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Start ' || procedureName,0,stepCt,'Done');
	
	--	create security records in observation_fact
	
	i2b2_create_security_for_trial(TrialId, 'Y', jobID);
	
	--	load i2b2_secure
	
	i2b2_load_security_data(jobID);
	
	--	check if entry exists for study in bio_experiment
	
	select count(*) into pExists
	from biomart.bio_experiment
	where accession = TrialId;
	
	if pExists = 0 then
		insert into biomart.bio_experiment
		(title, accession, etl_id)
		PERFORM 'Metadata not available'
			  ,TrialId
			  ,'METADATA:' || TrialId
		;
	    stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
		commit;
	end if;
	
	select bio_experiment_id into v_bio_experiment_id
	from biomart.bio_experiment
	where accession = TrialId;
	
	insert into searchapp.search_secure_object
	(bio_data_id
	,display_name
	,data_type
	,bio_data_unique_id
	)
	PERFORM v_bio_experiment_id
	      ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
		  ,'BIO_CLINICAL_TRIAL' as data_type
		  ,'EXP:' || TrialId as bio_data_unique_id
	from i2b2metadata.i2b2 md
	where md.sourcesystem_cd = TrialId
	  and md.c_hlevel = 
		 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
		  where x.sourcesystem_cd = TrialId)
	  and not exists
		 (select 1 from searchapp.search_secure_object so
		  where v_bio_experiment_id = so.bio_data_id);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
	commit;
		
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
    ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;

	EXCEPTION
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		
		--End Proc
		cz_end_audit (jobID, 'FAIL');
	
END;
 
$_$;


ALTER FUNCTION tm_cz.i2b2_secure_study(trial_id text, currentjobid bigint) OWNER TO tm_cz;

--
-- Name: i2b2_show_node(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_show_node(path character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN

  -------------------------------------------------------------
  -- Shows a tree node in I2b2
  -- KCR@20090519 - First Rev
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then

      --I2B2
    UPDATE i2b2
      SET c_visualattributes = 'FA'
    WHERE c_visualattributes LIKE 'F%'
      AND C_FULLNAME LIKE PATH || '%';

     UPDATE i2b2
      SET c_visualattributes = 'LA'
    WHERE c_visualattributes LIKE 'L%'
      AND C_FULLNAME LIKE PATH || '%';
    COMMIT;
  END IF;

END;
 
$$;


ALTER FUNCTION tm_cz.i2b2_show_node(path character varying) OWNER TO tm_cz;

--
-- Name: i2b2_table_bkp(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_table_bkp() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE


	tExists		integer;

BEGIN
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
  
	select count(*) into tExists
	from all_tables
	where owner = 'I2B2METADATA'
      and table_name = 'I2B2_BKP';
	
	if tExists > 0 then
		EXECUTE('drop table i2b2metadata.i2b2_bkp');
	end if;
	
	select count(*) into tExists
	from all_tables
	where owner = 'I2B2DEMODATA'
      and table_name = 'CONCEPT_COUNTS_BKP';
	
	if tExists > 0 then	
		EXECUTE('drop table i2b2demodata.concept_counts_bkp');
	end if;
  
	select count(*) into tExists
	from all_tables
	where owner = 'I2B2DEMODATA'
      and table_name = 'CONCEPT_DIMENSION_BKP';
	
	if tExists > 0 then
		EXECUTE('drop table i2b2demodata.concept_dimension_bkp');
	end if;
  
 	select count(*) into tExists
	from all_tables
	where owner = 'I2B2DEMODATA'
      and table_name = 'OBSERVATION_FACT_BKP';
	
	if tExists > 0 then
		EXECUTE('drop table i2b2demodata.observation_fact_bkp');
	end if;
  
 	select count(*) into tExists
	from all_tables
	where owner = 'I2B2DEMODATA'
      and table_name = 'PATIENT_DIMENSION_BKP';
	
	if tExists > 0 then
		EXECUTE('drop table i2b2demodata.patient_dimension_bkp');
	end if;

	--Backup tables
	EXECUTE 'CREATE TABLE I2B2METADATA.I2B2_BKP AS SELECT * FROM I2B2METADATA.I2B2';
	EXECUTE 'CREATE TABLE I2B2DEMODATA.CONCEPT_COUNTS_BKP AS SELECT * FROM I2B2DEMODATA.CONCEPT_COUNTS';
	EXECUTE 'CREATE TABLE I2B2DEMODATA.CONCEPT_DIMENSION_BKP AS SELECT * FROM I2B2DEMODATA.CONCEPT_DIMENSION';
	EXECUTE 'CREATE TABLE I2B2DEMODATA.OBSERVATION_FACT_BKP AS SELECT * FROM I2B2DEMODATA.OBSERVATION_FACT';
	EXECUTE 'CREATE TABLE I2B2DEMODATA.PATIENT_DIMENSION_BKP AS SELECT * FROM I2B2DEMODATA.PATIENT_DIMENSION';
END;


 
$$;


ALTER FUNCTION tm_cz.i2b2_table_bkp() OWNER TO tm_cz;

--
-- Name: i2b2_table_defrag(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_table_defrag() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN

  -------------------------------------------------------------
  -- Moves the I2B2 tables to reduce defragmentation
  -- KCR@20090527 - First Rev
  -- JEA@20090923 - Removed I2B2DEMODATA.IDX_OB_FACT_3, Oracle doesn't need to index every column like SQL Server (per Aaron A.)
  -------------------------------------------------------------
  EXECUTE 'ALTER TABLE I2B2METADATA.I2B2 MOVE';
  EXECUTE 'ALTER TABLE I2B2DEMODATA.CONCEPT_COUNTS MOVE';
  EXECUTE 'ALTER TABLE I2B2DEMODATA.CONCEPT_DIMENSION MOVE';
  EXECUTE 'ALTER TABLE I2B2DEMODATA.OBSERVATION_FACT MOVE';
  EXECUTE 'ALTER TABLE I2B2DEMODATA.PATIENT_DIMENSION MOVE';
  --Rebuild Indexes
  EXECUTE 'ALTER INDEX I2B2DEMODATA.OB_FACT_PK REBUILD';
  EXECUTE 'ALTER INDEX I2B2DEMODATA.IDX_OB_FACT_1 REBUILD';
  EXECUTE 'ALTER INDEX I2B2DEMODATA.IDX_OB_FACT_2 REBUILD';

  EXECUTE 'ALTER INDEX I2B2DEMODATA.IDX_CONCEPT_DIM_1 REBUILD';
  EXECUTE 'ALTER INDEX I2B2DEMODATA.IDX_CONCEPT_DIM_2 REBUILD';

  EXECUTE 'ALTER INDEX I2B2METADATA.IDX_I2B2_A REBUILD';
  EXECUTE 'ALTER INDEX I2B2METADATA.IDX_I2B2_B REBUILD';

  EXECUTE 'ALTER INDEX I2B2DEMODATA.CONCEPT_COUNTS_INDEX1 REBUILD';

END;






 
$$;


ALTER FUNCTION tm_cz.i2b2_table_defrag() OWNER TO tm_cz;

--
-- Name: i2b2_truncate_release_tables(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION i2b2_truncate_release_tables() RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

	--	Procedure to run one test in CZ_TEST

	--	JEA@20111019	New

	--	Define the abstract result set record

	TYPE r_type IS RECORD (
		rtn_text          varchar(2000)
	);

	--	Define the abstract result set table
	TYPE tr_type IS TABLE OF r_type;

	--	Define the result set

	rtn_array tr_type;

	--	Variables

	tText 			varchar(2000);

    --Audit variables
	newJobFlag integer(1);
	databaseName varchar(100);
	procedureName varchar(100);
	jobID bigint;
	stepCt bigint;

	
BEGIN

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := -1;

	PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;

	stepCt := 0;
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_truncate_release_tablese',0,stepCt,'Done');
	stepCt := stepCt + 1;

	tText := 'Select table_name from all_tables where owner = ' || '''' || 'TM_CZ' || '''' || 'and table_name like ' || '''' || '%_RELEASE' || '''';

	EXECUTE(tText) BULK COLLECT INTO rtn_array;

	for i in rtn_array.first .. rtn_array.last
	loop
		RAISE NOTICE '%', rtn_array(i).rtn_text;

		if (rtn_array(i)(.rtn_text IS NOT NULL AND .rtn_text::text <> '')) then
			tText := 'truncate table ' || rtn_array(i).rtn_text;

			EXECUTE(tText);
			tText := 'Truncated ' || rtn_array(i).rtn_text;

			cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');

		end if;

	end loop;

	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_truncate_release_tablese',0,stepCt,'Done');
	stepCt := stepCt + 1;

END;
 
$_$;


ALTER FUNCTION tm_cz.i2b2_truncate_release_tables() OWNER TO tm_cz;

--
-- Name: instr(character varying, character varying, integer, integer); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION instr(string character varying, string_to_search character varying, beg_index integer DEFAULT 1, occur_index integer DEFAULT 1) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index > 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;
    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos > 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    END IF;
END;
$$;


ALTER FUNCTION tm_cz.instr(string character varying, string_to_search character varying, beg_index integer, occur_index integer) OWNER TO tm_cz;

--
-- Name: is_date(character varying); Type: FUNCTION; Schema: tm_cz; Owner: weymouth
--

CREATE FUNCTION is_date(character varying) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$ 
declare 
        i numeric; 
begin 
        i := $1::date; 
        return 0; 
        EXCEPTION WHEN invalid_text_representation then 
                return 1; 
end; 
$_$;


ALTER FUNCTION tm_cz.is_date(character varying) OWNER TO weymouth;

--
-- Name: is_date(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION is_date(character varying, character varying) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
        i numeric;
begin
        i := $1::date;
        return 0;
        EXCEPTION WHEN invalid_text_representation then
                return 1;
end;
$_$;


ALTER FUNCTION tm_cz.is_date(character varying, character varying) OWNER TO tm_cz;

--
-- Name: is_number_v2(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION is_number_v2(p_string character varying) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE

        l_number numeric;
    
BEGIN
        l_number := p_string;
        return l_number;
   exception
       when others then
           return 1;
   end;

$$;


ALTER FUNCTION tm_cz.is_number_v2(p_string character varying) OWNER TO tm_cz;

--
-- Name: is_numeric(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION is_numeric(character varying) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$ 
declare 
        i numeric; 
begin 
        i := $1::numeric; 
        return 0; 
        EXCEPTION WHEN invalid_text_representation then 
                return 1; 
end; 
$_$;


ALTER FUNCTION tm_cz.is_numeric(character varying) OWNER TO tm_cz;

--
-- Name: isnumeric(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION isnumeric(p_string character varying) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE

      l_number numeric;
  
BEGIN
      l_number := p_string;
      return 1;
  exception
      when others then
          return 0;
  end;

$$;


ALTER FUNCTION tm_cz.isnumeric(p_string character varying) OWNER TO tm_cz;

--
-- Name: jnj_init_cap(text); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION jnj_init_cap(text_to_parse text) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

   start_pos 		bigint;
   end_pos   		bigint;
   string_length 	integer;
   string_tokens 	varchar(32676);
   counter 			integer;
   token_value 		varchar(1000);
   text_delimiter 	char(1);
   noInitCap 		boolean;
   
   --	create array to hold strings that will not be initcapped
   
	type excluded_aat is table of category_path_excluded_words%ROWTYPE index by integer;
	excludedText excluded_aat;
	exclCt integer;
   
   --	text to return
   initcap_text varchar(1000);
   

BEGIN
  -------------------------------------------------------------------------------
   -- Performs custom initcap for category paths where specific text strings are 
   -- excluded from the process.  Strings are delimited by a space.  The \ in
   -- the category path are converted to ' \ ' before parsing.
   
   -- JEA@20091001 - First rev. 
   -- Copyright ? 2009 Recombinant Data Corp.
   -------------------------------------------------------------------------------

	--	Load exclusion text
  
	select excluded_text
		bulk collect into excludedText
		from category_path_excluded_words;
  
	--	Add a delimiter to the end of the string so we dont lose last value and
	--	surround \ with spaces
	
	text_delimiter := ' ';
	string_tokens := replace(text_to_parse,'\',' \ ') || text_delimiter;
   
	--get length of string
	string_length := length(string_tokens);

	--set start and end for first token
	start_pos := 1;
	end_pos   := instr(string_tokens,text_delimiter,1,1);
	counter := 1;

	LOOP
		--	Get substring
		token_value := substr(string_tokens, start_pos, end_pos - start_pos);
	
		--	check if token_value is in excludedText, if yes, set indicator
	
		noInitCap := false;
		exclCt := excludedText.FIRST;

		while ((exclCt IS NOT NULL AND exclCt::text <> '') and not noInitCap)
		loop
			if token_value = excludedText(exclCt).excluded_text then
				noInitCap := true;
			end if;
			exclCt := excludedText.NEXT (exclCt);
		end loop;
	
		if noInitCap then
			initcap_text := initcap_text || token_value || ' ';
		else
			initcap_text := initcap_text || initcap(token_value) || ' ';
		end if;
    
		--Check to see if we are done
		IF end_pos = string_length  
		THEN
			initcap_text := replace(rtrim(initcap_text,' '),' \ ','\');
			EXIT;
		ELSE  
			-- Increment Start Pos and End Pos
			start_pos := end_pos + 1;
			--	increment counter
			counter := counter + 1;
			end_pos := instr(string_tokens, text_delimiter,1, counter);
      
		END IF;
  END LOOP;
  
  return initcap_text;
  
END JNJ_INIT_CAP;
 
$$;


ALTER FUNCTION tm_cz.jnj_init_cap(text_to_parse text) OWNER TO tm_cz;

--
-- Name: load_kegg_content_data(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION load_kegg_content_data() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN

begin

  delete from bio_content_reference
    where bio_content_id in
      (select bio_file_content_id
      from bio_content
      where repository_id in
        (select bio_content_repo_id
        from bio_content_repository
        where upper(repository_type)='KEGG')
      );
  --806
  delete from bio_content
    where repository_id =
      (select bio_content_repo_id
      from bio_content_repository
      where upper(repository_type)='KEGG');
  --806
  delete from bio_content_repository
    where upper(repository_type)='KEGG';
  --1
commit;
end;

begin
-- populate bio_content_repository
  insert into bio_content_repository(
    location
  , active_y_n
  , repository_type
  , location_type
  )
  values (
    'http://www.genome.jp/'
  , 'Y'
  , 'Kegg'
  , 'URL'
  );
commit;
end;

begin

  insert into bio_content(
  --  file_name
    repository_id
  , location
  --, title  , abstract
  , file_type
  --, etl_id
  )
  PERFORM distinct
    bcr.bio_content_repo_id
  , bcr.location||'dbget-bin/show_pathway?'|| bm.primary_external_id
  , 'Data'
  from
    bio_content_repository bcr
  , bio_marker bm
  where upper(bcr.repository_type)='KEGG'
  and upper(bm.primary_source_code)='KEGG';
  --806 rows inserted
commit;
end;

begin

  insert into bio_content_reference(
    bio_content_id
  , bio_data_id
  , content_reference_type
  )
  PERFORM distinct
    bc.bio_file_content_id
  , path.bio_marker_id
  , bcr.location_type
  from
    bio_content bc
  , bio_marker path
  , bio_content_repository bcr
  where bc.repository_id = bcr.bio_content_repo_id
  and path.primary_external_id=substring(bc.location from length(bc.location)-7)
  and path.primary_source_code='KEGG';
  --806
commit;
end;


end;
 
$$;


ALTER FUNCTION tm_cz.load_kegg_content_data() OWNER TO tm_cz;

--
-- Name: num_occurances(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION num_occurances(input_str character varying, search_str character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

  num integer;

BEGIN
  num := 0;
  while instr(input_str, search_str, 1, num + 1) > 0 loop
    num := num + 1;
  end loop;
  return num;
end;

$$;


ALTER FUNCTION tm_cz.num_occurances(input_str character varying, search_str character varying) OWNER TO tm_cz;

--
-- Name: number_parser(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION number_parser(numbers_to_parse character varying) RETURNS numeric[]
    LANGUAGE plpgsql
    AS $$
DECLARE

   start_pos bigint;
   end_pos   bigint;
   string_length integer;
   string_tokens varchar(32676);
   counter integer;
   token_value varchar(32676);

   list_values _numeric;


BEGIN
  -------------------------------------------------------------------------------
   -- Populates a temp_token table with parsed values for any comma separated list.
   -- Requires a type so that multiple records can exist for different uses.
   -- KCR@20090106 - First rev.
   -- Copyright c 2009 Recombinant Data Corp.
   -------------------------------------------------------------------------------

  --Add a delimiter to the end of the string so we dont lose last value
  string_tokens := numbers_to_parse || ',';

  --Initialize the collection
  list_values := NUMBER_TABLE() ;

  --get length of string
  string_length := length(string_tokens);

  --set start and end for first token
  start_pos := 1;
  end_pos   := instr(string_tokens,',',1,1);
  counter := 1;
  LOOP
    --Get substring
    token_value := to_number(substr(string_tokens, start_pos, end_pos - start_pos));

    --add values to collection
   list_values.EXTEND;
   list_values(list_Values.LAST):= token_value;

    --Check to see if we are done
    IF end_pos = string_length
    THEN
      EXIT;
    ELSE
      -- Increment Start Pos and End Pos
      start_pos := end_pos + 1;
      --increment counter
      counter := counter + 1;
      end_pos := instr(string_tokens, ',',1, counter);

    END IF;

  END LOOP;

  return list_values;
  --on an invalid value (Can't convert to number, just return the table of numbers.
  EXCEPTION WHEN OTHERS THEN
    return list_values;


END number_parser;
 
$$;


ALTER FUNCTION tm_cz.number_parser(numbers_to_parse character varying) OWNER TO tm_cz;

--
-- Name: nz_i2b2_copy_to_stage(character varying, character varying, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION nz_i2b2_copy_to_stage(character varying, character varying, bigint) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER
    AS $_$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
	--	Alias for parameters
	
	trial_id  alias for $1;
	data_type alias for $2;
	currentJobID alias for $3;
	rtnCd integer;
	TrialId 	varchar(200);
	msgText		varchar(2000);
	dataType	varchar(50);

	tText			varchar(2000);
	tExists 		integer;
	tCount			integer;
	source_table	varchar(50);
	release_table	varchar(50);
	vSNP 			integer;
	rowCt			bigint;
	v_sqlerrm		varchar(1000);

	--Audit variables
	newJobFlag integer;
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID numeric(18,0);
	stepCt numeric(18,0);
  
	r_stage_table	record;

	
BEGIN

	TrialID := upper(trial_id);
	dataType := upper(data_type);
	
	stepCt := 0;
	tCount := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_COPY_TO_STAGE';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		jobId := tm_cz.czx_start_audit (procedureName, databaseName);
	END IF;
  
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done')into rtnCd;
	
	stepCt := stepCt + 1;
	msgText := 'Extracting trial: ' || TrialId;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName, msgText,0,stepCt,'Done')into rtnCd;

	if TrialId = null then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'TrialID missing',0,stepCt,'Done')into rtnCd;
		Return 16;
	end if;
	
	for r_stage_table in
		select upper(table_owner) as table_owner
			  ,upper(table_name) as table_name
			  ,upper(study_specific) as study_specific
			  ,where_clause
			  ,upper(stage_table_name) as stage_table_name
		from tm_cz.migrate_tables
		where instr(dataType,data_type) > 0
	loop
		source_table := r_stage_table.table_owner || '.' || r_stage_table.table_name;
		release_table := 'tm_stage.' || r_stage_table.stage_table_name;
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Processing ' || source_table,0,stepCt,'Done')into rtnCd;
		tCount := tCount + 1;
		
		if r_stage_table.study_specific = 'Y' then
			tText := 'delete from ' || release_table || ' where release_study = ' || '''' || TrialId || '''';
			execute immediate tText;
			rowCt := ROW_COUNT;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Deleted study from ' || release_table,rowCt,stepCt,'Done')into rtnCd;
			
			tText := 'insert into ' || release_table || ' select st.*,' || '''' || TrialId || '''' || ' from ' || source_table || ' st ' || 
					 replace(r_stage_table.where_clause,'TrialId','''' || TrialId || '''');
			execute immediate tText ;
			rowCt := ROW_COUNT;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted study into ' || release_table,rowCt,stepCt,'Done')into rtnCd;
		else
			tText := 'truncate table ' || release_table;
			stepCt := stepCt + 1;		
			execute immediate tText;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Truncated '|| release_table,0,stepCt,'Done')into rtnCd;
			tText := 'insert into ' || release_table || ' select st.* from ' || source_table || ' st ';
			execute immediate(tText);
			rowCt := ROW_COUNT;
			stepCt := stepCt + 1;
			select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'Inserted all data into ' || release_table,rowCt,stepCt,'Done')into rtnCd;
		end if;
			
	end loop;
	
	if tCount = 0 then
		stepCt := stepCt + 1;
		select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'data_type invalid: '|| data_type,0,stepCt,'Done')into rtnCd;
		Return 16;
	end if;
	stepCt := stepCt + 1;
	select tm_cz.czx_write_audit(jobId,databaseName,procedureName,'End '||procedureName,0,stepCt,'Done')into rtnCd;

       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    select tm_cz.czx_end_audit (jobID, 'SUCCESS')into rtnCd;
  END IF;
  
  return 0;

  EXCEPTION
  WHEN OTHERS THEN
	v_sqlerrm := substr(SQLERRM,1,1000);
	raise notice 'error: %', v_sqlerrm;
    --Handle errors.
    select tm_cz.czx_error_handler (jobID, procedureName,v_sqlerrm)into rtnCd;
    --End Proc
    select tm_cz.czx_end_audit (jobID, 'FAIL')into rtnCd;
	return 16;
END;
$_$;


ALTER FUNCTION tm_cz.nz_i2b2_copy_to_stage(character varying, character varying, bigint) OWNER TO tm_cz;

--
-- Name: parse_nth_value(character varying, numeric, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION parse_nth_value(pvalue character varying, location numeric, delimiter character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
   v_posA integer;
   v_posB integer;
   iLoc	  integer;

begin
   iLoc := location;
   if location = 1 then
      v_posA := 1; -- Start at the beginning
   else
	  select tm_cz.instr(pValue,delimiter, 1, iLoc-1) into v_posA;
 --     v_posA := tm_cz.instr(pValue,delimiter, 1, location - 1); 
      if v_posA = 0 then
         return null; --No values left.
      end if;
      v_posA := v_posA + length(delimiter);
   end if;

   select tm_cz.instr (pValue, delimiter, 1, iLoc) into v_posB;
   --v_posB := tm_cz.instr (pValue, delimiter, 1, location);
   if v_posB = 0 then -- Use the end of the file
      return substr (pValue, v_posA);
   end if;
   
   return substr (pValue, v_posA, v_posB - v_posA);

end;
$$;


ALTER FUNCTION tm_cz.parse_nth_value(pvalue character varying, location numeric, delimiter character varying) OWNER TO tm_cz;

--
-- Name: rdc_init_cap(text); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION rdc_init_cap(text_to_parse text) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

   start_pos 		bigint;
   end_pos   		bigint;
   string_length 	integer;
   string_tokens 	varchar(32676);
   counter 			integer;
   token_value 		varchar(1000);
   text_delimiter 	char(1);
   noInitCap 		boolean;

   --	create array to hold strings that will not be initcapped

	type excluded_aat is table of category_path_excluded_words%ROWTYPE index by integer;
	excludedText excluded_aat;
	exclCt integer;

   --	text to return
   initcap_text varchar(1000);


BEGIN
  -------------------------------------------------------------------------------
   -- Performs custom initcap for category paths where specific text strings are
   -- excluded from the process.  Strings are delimited by a space.  The \ in
   -- the category path are converted to ' \ ' before parsing.

   -- JEA@20091001 - First rev.
   -- Copyright ? 2009 Recombinant Data Corp.
   -------------------------------------------------------------------------------

	--	Load exclusion text

	select excluded_text
		bulk collect into excludedText
		from category_path_excluded_words;

	--	Add a delimiter to the end of the string so we dont lose last value and
	--	surround \ with spaces

	text_delimiter := ' ';
	string_tokens := replace(text_to_parse,'\',' \ ') || text_delimiter;

	--get length of string
	string_length := length(string_tokens);

	--set start and end for first token
	start_pos := 1;
	end_pos   := instr(string_tokens,text_delimiter,1,1);
	counter := 1;

	LOOP
		--	Get substring
		token_value := substr(string_tokens, start_pos, end_pos - start_pos);

		--	check if token_value is in excludedText, if yes, set indicator

		noInitCap := false;
		exclCt := excludedText.FIRST;

		if (substring(token_value from 1 for 1) = '(' and substring(token_value from length(token_value) for 1) = ')' ) then
			noInitCap := true;
		else
		while ((exclCt IS NOT NULL AND exclCt::text <> '') and not noInitCap)
			loop
				if token_value = excludedText(exclCt).excluded_text then
					noInitCap := true;
				end if;
				exclCt := excludedText.NEXT (exclCt);
			end loop;
		end if;

		if noInitCap then
			initcap_text := initcap_text || token_value || ' ';
		else
			initcap_text := initcap_text || initcap(token_value) || ' ';
		end if;

		--Check to see if we are done
		IF end_pos = string_length
		THEN
			initcap_text := replace(rtrim(initcap_text,' '),' \ ','\');
			EXIT;
		ELSE
			-- Increment Start Pos and End Pos
			start_pos := end_pos + 1;
			--	increment counter
			counter := counter + 1;
			end_pos := instr(string_tokens, text_delimiter,1, counter);

		END IF;
  END LOOP;

  return initcap_text;

END RDC_INIT_CAP;
 
$$;


ALTER FUNCTION tm_cz.rdc_init_cap(text_to_parse text) OWNER TO tm_cz;

--
-- Name: rdc_reload_mrna_data(text, text, text, bigint, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION rdc_reload_mrna_data(trial_id text, data_type text DEFAULT 'R'::text, source_cd text DEFAULT 'STD'::text, log_base bigint DEFAULT 2, currentjobid bigint DEFAULT NULL::bigint) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE


	--	JEA@20111202	One-off to re-zscore gene expression data for a study

  TrialID		varchar(100);
  RootNode		varchar(2000);
  root_level	integer;
  topNode		varchar(2000);
  topLevel		integer;
  tPath			varchar(2000);
  study_name	varchar(100);
  sourceCd		varchar(50);

  dataType		varchar(10);
  sqlText		varchar(1000);
  tText			varchar(1000);
  gplTitle		varchar(1000);
  pExists		bigint;
  partTbl   	bigint;
  partExists 	bigint;
  sampleCt		bigint;
  idxExists 	bigint;
  logBase		bigint;
  pCount		integer;
  sCount		integer;
  tablespaceName	varchar(200);
  
    --Audit variables
  newJobFlag integer(1);
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  
  --unmapped_patients exception;
  missing_platform	exception;
  missing_tissue	EXCEPTION;
  unmapped_platform exception;
  


BEGIN
	TrialID := upper(trial_id);
--	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\');	
--	select length(topNode)-length(replace(topNode,'\','')) into topLevel from dual;
	
	if coalesce(data_type::text, '') = '' then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;
	
	logBase := log_base;
	sourceCd := upper(coalesce(source_cd,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_mrna_data',0,stepCt,'Done');
		
	--	truncate tmp tables

	EXECUTE('truncate table tm_wz.wt_subject_microarray_logs');
	EXECUTE('truncate table tm_wz.wt_subject_microarray_calcs');
	EXECUTE('truncate table tm_wz.wt_subject_microarray_med');
	
	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'WT_SUBJECT_MICROARRAY_LOGS'
	  and index_name = 'WT_SUBJECT_MRNA_LOGS_I1'
	  and owner = 'TM_WZ';
		
	if idxExists = 1 then
		EXECUTE('drop index tm_wz.wt_subject_mrna_logs_i1');		
	end if;
	
	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'WT_SUBJECT_MICROARRAY_CALCS'
	  and index_name = 'WT_SUBJECT_MRNA_CALCS_I1'
	  and owner = 'TM_WZ';
		
	if idxExists = 1 then
		EXECUTE('drop index tm_wz.wt_subject_mrna_calcs_i1');
	end if;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
	
	insert into wt_subject_microarray_logs 
	(probeset_id
	,intensity_value
	,assay_id
	,log_intensity
	,patient_id
	,sample_id
	,subject_id
	)
	PERFORM distinct gs.probeset_id
		  ,avg(md.intensity_value)
		  ,sd.assay_id
		  ,avg(md.intensity_value)
		  ,sd.patient_id
		  ,sd.sample_id
		  ,sd.subject_id
	from de_subject_sample_mapping sd
		,lz_src_mrna_data md   
		,de_mrna_annotation gs
	where sd.sample_cd = md.expr_id
	  and sd.platform = 'MRNA_AFFYMETRIX'
	  and sd.trial_name = TrialId
	  and md.trial_name = TrialId
	  and sd.gpl_id = gs.gpl_id
	  and md.probeset = gs.probe_id
	  group by gs.probeset_id
		  ,sd.assay_id
		  ,sd.patient_id
		  ,sd.sample_id
		  ,sd.subject_id;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_microarray_logs',SQL%ROWCOUNT,stepCt,'Done');

	commit;
    
	EXECUTE('create index tm_wz.wt_subject_mrna_logs_i1 on tm_wz.wt_subject_microarray_logs (trial_name, probeset_id) nologging  tablespace "INDX"');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_microarray_logs',0,stepCt,'Done');
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe

	insert into wt_subject_microarray_calcs
	(trial_name
	,probeset_id
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
	PERFORM d.trial_name 
		  ,d.probeset_id
		  ,avg(log_intensity)
		  ,median(log_intensity)
		  ,stddev(log_intensity)
	from wt_subject_microarray_logs d 
	group by d.trial_name 
			,d.probeset_id;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ wt_subject_microarray_calcs',SQL%ROWCOUNT,stepCt,'Done');

	commit;

	EXECUTE('create index tm_wz.wt_subject_mrna_calcs_i1 on tm_wz.wt_subject_microarray_calcs (trial_name, probeset_id) nologging tablespace "INDX"');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_microarray_calcs',0,stepCt,'Done');
		
-- calculate zscore

	insert into wt_subject_microarray_med parallel 
	(probeset_id
	,intensity_value
	,log_intensity
	,assay_id
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,patient_id
	,sample_id
	,subject_id)
	PERFORM d.probeset_id
		  ,d.intensity_value 
		  ,d.log_intensity 
		  ,d.assay_id  
		  ,c.mean_intensity 
		  ,c.stddev_intensity 
		  ,c.median_intensity 
		  ,CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END
		  ,d.patient_id
		  ,d.sample_id
		  ,d.subject_id
    from wt_subject_microarray_logs d 
		,wt_subject_microarray_calcs c 
    where d.probeset_id = c.probeset_id;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ wt_subject_microarray_med',SQL%ROWCOUNT,stepCt,'Done');

    commit;

	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
	  and index_name = 'MRNA_INDX1'
	  and owner = 'DEAPP';
		
	if idxExists = 0 then
		EXECUTE('create index deapp.mrna_idx1 on deapp.de_subject_microarray_data (trial_name) nologging tablespace "INDX"');
	end if;
	
	delete from de_subject_microarray_data
	where trial_name = TrialId;
	
	EXECUTE('drop index deapp.mrna_idx1');

	insert into de_subject_microarray_data
	(trial_name
	,assay_id
	,probeset_id
	,raw_intensity 
	,log_intensity
	,zscore
	,patient_id
	,sample_id
	,subject_id
	)
	PERFORM TrialId
	      ,m.assay_id
	      ,m.probeset_id 
		  ,case when dataType = 'R' then m.intensity_value
		        when dataType = 'L' then case when logBase = -1 then null else power(logBase, m.log_intensity) end
				else null end
		  ,m.log_intensity
	      ,round(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE round(m.zscore,5) END,5)
		  ,m.patient_id
		  ,m.sample_id
		  ,m.subject_id
	from wt_subject_microarray_med m;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial in DEAPP de_subject_microarray_data',SQL%ROWCOUNT,stepCt,'Done');

  	commit;
	
--	cleanup tmp_ files

	EXECUTE('truncate table tm_wz.wt_subject_microarray_logs');
	EXECUTE('truncate table tm_wz.wt_subject_microarray_calcs');
	EXECUTE('truncate table tm_wz.wt_subject_microarray_med');

   	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
	
    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_mrna_data',0,stepCt,'Done');

	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;
	
	--select 0 into rtn_code from dual;

	EXCEPTION
	--when unmapped_patients then
	--	cz_write_audit(jobId,databasename,procedurename,'No site_id/subject_id mapped to patient_dimension',1,stepCt,'ERROR');
	--	cz_error_handler(jobid,procedurename);
	--	cz_end_audit (jobId,'FAIL');
	when missing_platform then
		cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		cz_error_handler(jobid,procedurename);
		cz_end_audit (jobId,'FAIL');
		--select 16 into rtn_code from dual;
	when missing_tissue then
		cz_write_audit(jobId,databasename,procedurename,'Tissue Type data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		cz_error_handler(jobid,procedurename);
		CZ_END_AUDIT (JOBID,'FAIL');
		--select 16 into rtn_code from dual;
	when unmapped_platform then
		cz_write_audit(jobId,databasename,procedurename,'Platform not found in de_mrna_annotation',1,stepCt,'ERROR');
		CZ_ERROR_HANDLER(JOBID,PROCEDURENAME);
		cz_end_audit (jobId,'FAIL');
		--select 16 into rtn_code from dual;
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		--End Proc
		cz_end_audit (jobID, 'FAIL');
		--select 16 into rtn_code from dual;
END;
 
$_$;


ALTER FUNCTION tm_cz.rdc_reload_mrna_data(trial_id text, data_type text, source_cd text, log_base bigint, currentjobid bigint) OWNER TO tm_cz;

--
-- Name: rename_program(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION rename_program(oldprogramname character varying, newprogramname character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

oldTopNode		varchar(2000);
newTopNode		varchar(2000);
regex1		varchar(2000);
regex2		varchar(2000);

BEGIN

DBMS_OUTPUT.ENABLE (20000);
  oldTopNode := '\' || oldProgramName || '\' ;
  newTopNode := '\' || newProgramName || '\' ;
  regex1 := '\\' || oldProgramName || '\\' || '(.*)';
  regex2 := '\\' || newProgramName || '\\' || '\1';
  
  update i2b2metadata.i2b2 set c_fullname=REGEXP_REPLACE(c_fullname, regex1, regex2) where c_fullname like oldTopNode||'%';
  update i2b2metadata.i2b2 set c_dimcode=REGEXP_REPLACE(c_dimcode, regex1, regex2) where c_dimcode like oldTopNode||'%';
  update i2b2metadata.i2b2 set c_tooltip=REGEXP_REPLACE(c_tooltip, regex1, regex2)  where c_tooltip like oldTopNode||'%';
  update i2b2metadata.i2b2 set c_name=newProgramName where c_fullname=newTopNode;
  
  update i2b2metadata.i2b2_secure set c_fullname=REGEXP_REPLACE(c_fullname, regex1, regex2) where c_fullname like oldTopNode||'%';
  update i2b2metadata.i2b2_secure set c_dimcode=REGEXP_REPLACE(c_dimcode, regex1, regex2) where c_dimcode like oldTopNode||'%';
  update i2b2metadata.i2b2_secure set c_tooltip=REGEXP_REPLACE(c_tooltip, regex1, regex2) where c_tooltip like oldTopNode||'%';
  update i2b2metadata.i2b2_secure set c_name=newProgramName where c_fullname=newTopNode;
  
  update i2b2metadata.table_access set c_fullname=REGEXP_REPLACE(c_fullname, regex1, regex2) where c_fullname like oldTopNode||'%';
  update i2b2metadata.table_access set c_dimcode=REGEXP_REPLACE(c_dimcode, regex1, regex2) where c_dimcode like oldTopNode||'%';
  update i2b2metadata.table_access set c_tooltip=REGEXP_REPLACE(c_tooltip, regex1, regex2) where c_tooltip like oldTopNode||'%';
  update i2b2metadata.table_access set c_name=newProgramName where c_fullname=newTopNode;
  update i2b2metadata.table_access set c_table_cd=newProgramName where c_fullname=newTopNode;
 
  update I2B2DEMODATA.concept_counts set concept_path=REGEXP_REPLACE(concept_path, regex1, regex2) where concept_path like oldTopNode||'%';
  update I2B2DEMODATA.concept_counts set parent_concept_path=REGEXP_REPLACE(parent_concept_path, regex1, regex2)where parent_concept_path like oldTopNode||'%';
 
  update I2B2DEMODATA.concept_dimension set concept_path=REGEXP_REPLACE(concept_path, regex1, regex2) where concept_path like oldTopNode||'%';

 commit;
 
END;
 
$$;


ALTER FUNCTION tm_cz.rename_program(oldprogramname character varying, newprogramname character varying) OWNER TO tm_cz;

--
-- Name: rename_study(character varying, character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION rename_study(programname character varying, oldtitle character varying, newtitle character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

oldTopNode		varchar(2000);
newTopNode		varchar(2000);
regex1		varchar(2000);
regex2		varchar(2000);

BEGIN

DBMS_OUTPUT.ENABLE (20000);
  oldTopNode := '\' || programName || '\' || oldTitle|| '\';
  newTopNode := '\' || programName || '\' || newTitle|| '\';
  regex1 := '\\' || replace(replace(programName, '(', '\('), ')', '\)') || '\\' || replace(replace(oldTitle, '(', '\('), ')', '\)')|| '\\' || '(.*)';
  regex2 := '\\' || programName || '\\' || newTitle|| '\\' || '\1';
  
  update i2b2metadata.i2b2 set c_fullname=REGEXP_REPLACE(c_fullname, regex1, regex2);
  update i2b2metadata.i2b2 set c_dimcode=REGEXP_REPLACE(c_dimcode, regex1, regex2);
  update i2b2metadata.i2b2 set c_tooltip=REGEXP_REPLACE(c_tooltip, regex1, regex2);
  update i2b2metadata.i2b2 set c_name=newTitle where c_fullname=newTopNode;
  
  update i2b2metadata.i2b2_secure set c_fullname=REGEXP_REPLACE(c_fullname, regex1, regex2);
  update i2b2metadata.i2b2_secure set c_dimcode=REGEXP_REPLACE(c_dimcode, regex1, regex2);
  update i2b2metadata.i2b2_secure set c_tooltip=REGEXP_REPLACE(c_tooltip, regex1, regex2);
  update i2b2metadata.i2b2_secure set c_name=newTitle where c_fullname=newTopNode;
 
  update I2B2DEMODATA.concept_counts set concept_path=REGEXP_REPLACE(concept_path, regex1, regex2);
  update I2B2DEMODATA.concept_counts set parent_concept_path=REGEXP_REPLACE(parent_concept_path, regex1, regex2);
 
  update I2B2DEMODATA.concept_dimension set concept_path=REGEXP_REPLACE(concept_path, regex1, regex2);
  update I2B2DEMODATA.concept_dimension set name_char=newTitle where concept_path=newTopNode;
  
  commit;
 
END;
 
$$;


ALTER FUNCTION tm_cz.rename_study(programname character varying, oldtitle character varying, newtitle character varying) OWNER TO tm_cz;

--
-- Name: rwg_add_search_term(text, text, text, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION rwg_add_search_term(new_term text, category_name text, category_display text, currentjobid bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
	--Audit variables
	newJobFlag    smallint;
	databaseName  varchar(100);
	procedureName varchar(100);
	jobID         bigint;
	stepCt        bigint;
	rowCt         bigint;
	errorNumber   varchar;
	errorMessage  varchar;

	Parent_Id          integer;
	new_Term_Id        integer;
	keyword_id         integer;
	Lcount             integer;
	Ncount             integer;
	v_category_display varchar(200);


BEGIN
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	SELECT current_user INTO databaseName; --(sic)
	procedureName := 'RWG_ADD_SEARCH_TERM';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF (coalesce(jobID::text, '') = '' OR jobID < 1)
		THEN
		newJobFlag := 1; -- True
		SELECT cz_start_audit(procedureName, databaseName) INTO jobID;
	END IF;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Start FUNCTION', 0, stepCt, 'Done');
	stepCt := 1;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Term to add is ''' || new_term || ''', category is ''' ||
		category_name || '''', 0, stepCt, 'Done');

	/*
	1. Check if term exists in Search_Keyword_term
	2. Insert term into Searchapp.search_keyword
	3. Insert term into Searchapp.Search_Keyword_term
	 */
	/*
	-- check if the new term exists
	Select Count(*) 
	into Ncount
	From Searchapp.Search_Keyword
	where upper(Keyword) like upper(New_Term)
	and upper(Display_Data_Category) like upper(category_name);
	If(Ncount>0) Then
		RAISE Existing_Term;
	END IF;
    */

	IF coalesce(category_display::text, '') = '' THEN
		v_category_display := category_name;
	ELSE
		v_category_display := category_display;
	END IF;

	-- Insert taxonomy term into searchapp.search_keyword
	-- (searches Search_Keyword with the parent term to find the category to use)
	BEGIN
	INSERT INTO Searchapp.Search_Keyword(
		Data_Category,
		Keyword,
		Unique_Id,
		Source_Code,
		Display_Data_Category)
	SELECT
		category_name,
		New_Term,
		'RWG:'|| category_name || ':' || New_Term,
		'RWG_ADD_SEARCH_TERM',
		v_category_display
	WHERE
		NOT EXISTS
			(SELECT 1 FROM searchapp.search_keyword x
			WHERE upper(x.data_category) = upper(category_name)
				AND upper(x.keyword) = upper(New_Term));

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Term added to Searchapp.Search_Keyword', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	-- Get the ID of the new term in Search_Keyword
	BEGIN
	SELECT Search_Keyword_Id INTO Keyword_Id 
	FROM Searchapp.Search_Keyword
	WHERE Upper(Keyword) = Upper(New_Term)
		AND upper(data_category) = upper(category_name);

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'New search keyword ID stored in Keyword_Id', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	-- Insert the new term into Searchapp.Search_Keyword_Term 
	BEGIN
	INSERT INTO Searchapp.Search_Keyword_Term(
		Keyword_Term,
		Search_Keyword_Id,
		Rank,
		Term_Length)
	SELECT
		New_Term,
		Keyword_Id,
		1,
		Length(New_Term)
	WHERE
		NOT EXISTS (
			SELECT
				1
			FROM
				searchapp.search_keyword_term x
			WHERE
				UPPER(x.keyword_term) = UPPER(New_Term)
				AND x.search_keyword_id = Keyword_Id);

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Term added to Searchapp.Search_Keyword_Term', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

     ---Cleanup OVERALL JOB if this proc is being run standalone    
	IF newJobFlag = 1
		THEN
		PERFORM cz_end_audit (jobID, 'SUCCESS');
	END IF;

	RETURN 0;
EXCEPTION
	WHEN OTHERS THEN
	errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
END;

$$;


ALTER FUNCTION tm_cz.rwg_add_search_term(new_term text, category_name text, category_display text, currentjobid bigint) OWNER TO tm_cz;

--
-- Name: rwg_add_taxonomy_term(text, text, text, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION rwg_add_taxonomy_term(new_term_in text, parent_term_in text, category_term_in text, currentjobid bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
--Audit variables
	newJobFlag    smallint;
	databaseName  varchar(100);
	procedureName varchar(100);
	jobID         bigint;
	stepCt        bigint;
	rowCt         bigint;
	errorNumber   varchar;
	errorMessage  varchar;


	Parent_Id integer;
	New_Term_in_Id integer;
	keyword_id integer;
	Lcount integer;
	Ncount integer;
	--Existing_Term Exception;
BEGIN
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	SELECT current_user INTO databaseName; --(sic)
	procedureName := 'RWG_ADD_TAXONOMY_TERM';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF (coalesce(jobID::text, '') = '' OR jobID < 1)
		THEN
		newJobFlag := 1; -- True
		SELECT cz_start_audit(procedureName, databaseName) INTO jobID;
	END IF;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Start FUNCTION', 0, stepCt, 'Done');
	stepCt := 1;

	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Term: ' || New_Term_in, 0, stepCt, 'Done');
	stepCt := stepCt + 1;

	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Category: ' || category_term_in, 0, stepCt, 'Done');
	stepCt := stepCt + 1;

	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Parent: ' || parent_term_in, 0, stepCt, 'Done');
	stepCt := stepCt + 1;

	/*
	0. Check if term exists in Search_Keyword_term
	1. Insert term into Searchapp.search_keyword
	2. Insert term into Searchapp.Search_Keyword_term
	3. Find parent
	4. Insert new term into Searchapp.Search_Taxonomy
	5. Find id of new term
	6. Insert relationship into searchapp.search_taxonomy_rels
	 */
	-- Get the data category using the parent term
	/*
	Select distinct(data_category)
	into category_term_in
	From Searchapp.Search_Keyword Where Upper(Keyword)
	like upper(parent_term_in) or upper(display_data_category) like upper(parent_term_in);
	 */
	-- check if the new term exists (use the keyword AND the category, as the same
	-- term name may be used in more than 1 category
	SELECT
		COUNT ( * )
		INTO Ncount
	FROM
		Searchapp.Search_Keyword
	WHERE
		UPPER ( Keyword ) = UPPER ( New_Term_in )
		AND UPPER ( data_category ) LIKE UPPER ( category_term_in );
	--If(Ncount>0) Then
	-- RAISE Existing_Term;
	--END IF;
	-- Insert taxonomy term into searchapp.search_keyword
	IF Ncount = 0 THEN
		BEGIN
		INSERT INTO Searchapp.Search_Keyword (
			Data_Category,
			Keyword,
			Unique_Id,
			Source_Code,
			Display_Data_Category )
		SELECT
			DISTINCT data_category,
			New_Term_in,
			'RWG:' || data_category || ':' || New_Term_in,
			'RWG_ADD_TAXONOMY_TERM',
			Display_Data_Category
		FROM
			Searchapp.Search_Keyword
		WHERE
			UPPER ( display_data_category ) LIKE UPPER ( category_term_in );
		/*
		Insert Into Searchapp.Search_Keyword (Data_Category, Keyword, Unique_Id, Source_Code, Display_Data_Category)
		Select category_term_in, New_Term_in, 'RWG:'|| category_term_in || ':' || New_Term_in, 'RWG_ADD_TAXONOMY_TERM', category_term_in from dual;
		 */
		GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Term added to Searchapp.Search_Keyword', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;
	END IF;

	-- Get the ID of the new term in Search_Keyword
	BEGIN
	SELECT
		Search_Keyword_Id INTO Keyword_Id
	FROM
		Searchapp.Search_Keyword
	WHERE
		UPPER ( Keyword ) = UPPER ( New_Term_in )
		AND UPPER ( data_category ) LIKE UPPER ( category_term_in );
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'New search keyword ID stored in Keyword_Id', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	-- Insert the new term into Searchapp.Search_Keyword_Term
	BEGIN
	INSERT INTO Searchapp.Search_Keyword_Term (
		Keyword_Term,
		Search_Keyword_Id,
		RANK,
		Term_Length )
	SELECT
		New_Term_in,
		Keyword_Id,
		1,
		LENGTH ( New_Term_in )
	WHERE
		NOT EXISTS (
			SELECT
				1
			FROM
				searchapp.search_keyword_term x
			WHERE
				x.search_keyword_id = Keyword_Id );
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Term added to Searchapp.Search_Keyword_Term', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	-- Get the ID of the parent term
	SELECT
		DISTINCT Term_Id
	INTO Parent_Id
	FROM
		Searchapp.Search_Taxonomy
	WHERE
		UPPER ( Term_Name ) LIKE UPPER ( parent_term_in );

	IF COALESCE(Parent_Id,-1) > 0 THEN
		-- Insert the new term into the taxonomy
		BEGIN
		INSERT INTO Searchapp.Search_Taxonomy (
			term_name,
			source_cd,
			import_date,
			search_keyword_id )
		SELECT
			New_Term_in,
			parent_term_in || ':' || New_Term_in,
			LOCALTIMESTAMP,
			Keyword_Id
		WHERE
			NOT EXISTS (
				SELECT
					1
				FROM
					searchapp.search_taxonomy x
				WHERE
					x.search_keyword_id = Keyword_Id );
		GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Term added to Searchapp.Search_Taxonomy', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

		-- Get the ID of the new term
		SELECT
			DISTINCT Term_Id INTO New_Term_in_Id
		FROM
			Searchapp.Search_Taxonomy
		WHERE
			UPPER ( Term_Name ) LIKE UPPER ( New_Term_in );

		BEGIN
		INSERT INTO Searchapp.Search_Taxonomy_Rels (
			Child_Id,
			Parent_Id )
		SELECT
			New_Term_in_Id,
			Parent_Id
		WHERE
			NOT EXISTS (
				SELECT
					1
				FROM
					searchapp.search_taxonomy_rels x
				WHERE
					x.child_id = New_Term_in_Id
					AND x.parent_id = Parent_id );
		GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Term relationship added to Searchapp.Search_Taxonomy_Rels', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;
	END IF;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
		THEN
		PERFORM cz_end_audit (jobID, 'SUCCESS');
	END IF;
EXCEPTION
	WHEN OTHERS THEN
	errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
END;
$$;


ALTER FUNCTION tm_cz.rwg_add_taxonomy_term(new_term_in text, parent_term_in text, category_term_in text, currentjobid bigint) OWNER TO tm_cz;

--
-- Name: rwg_create_analysis_entry(text, text, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION rwg_create_analysis_entry(trialid text, delete_flag text DEFAULT NULL::text, currentjobid bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
	--Audit variables
	newJobFlag    smallint;
	databaseName  varchar(100);
	procedureName varchar(100);
	jobID         bigint;
	stepCt        bigint;
	rowCt         bigint;
	errorNumber   varchar;
	errorMessage  varchar;

	Cdelete CURSOR FOR 
		SELECT
			DISTINCT ( baa.bio_assay_analysis_id )
		FROM
			Biomart.bio_assay_analysis baa
		WHERE
			UPPER ( baa.etl_id ) LIKE ( UPPER ( trialID ) || ':%' );
	cDeleteRow record;

BEGIN
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	SELECT current_user INTO databaseName; --(sic)
	procedureName := 'RWG_CREATE_ANALYSIS_ENTRY';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF (coalesce(jobID::text, '') = '' OR jobID < 1)
		THEN
		newJobFlag := 1; -- True
		SELECT cz_start_audit(procedureName, databaseName) INTO jobID;
	END IF;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Start FUNCTION', 0, stepCt, 'Done');
	stepCt := 1;

	-- If this flag is set to 'D', all study data from biomart.bio_assay_analysis and biomart.bio_assay_analysis_data
	IF upper(delete_flag) = 'D' THEN
		PERFORM cz_write_audit(jobId,databaseName,procedureName,'Start Delete bio_assay_analysis_data Loop',0,stepCt,'Done');
		stepCt := stepCt + 1;	

		FOR Cdeleterow IN Cdelete LOOP
			BEGIN
			DELETE
			FROM
				biomart.bio_assay_analysis_data baad
			WHERE
				baad.bio_assay_analysis_id = cDeleteRow.bio_assay_analysis_id;
			GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete records for analysis:  ' || cDeleteRow.bio_assay_analysis_id, rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;
		END LOOP;

		BEGIN
		DELETE
		FROM
			Biomart.bio_assay_analysis baa
		WHERE UPPER ( baa.etl_id ) LIKE ( UPPER ( trialID ) || ':%' );
		GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing records from Biomart.bio_assay_analysis', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;
	END IF;

	BEGIN
	INSERT INTO Biomart.Bio_Assay_Analysis (
		ANALYSIS_NAME,
		Short_Description,
		Long_Description,
		Fold_Change_Cutoff,
		Pvalue_Cutoff,
		lsmean_cutoff,
		Analysis_Method_Cd,
		Bio_Assay_Data_Type,
		Etl_Id,
		Qa_Criteria,
		analysis_create_date,
		analysis_update_date )
	SELECT
		rwg.analysis_id,
		rwg.Short_Desc,
		rwg.Long_Desc,
		rwg.foldchange_cutoff,
		pvalue_cutoff,
		lsmean_cutoff,
		--fold_change, pvalue, lsmean cutoffs
		rwg.Analysis_Type,
		rwg.Data_Type,
		rwg.study_id || 'RWG',
		'(Abs(fold Change) > ' || rwg.foldchange_cutoff || ' OR coalesce(fold_change::text, '') = '')' || ' AND pvalue < ' || pvalue_cutoff || ' AND Max(LSMean) >' || lsmean_cutoff,
		now(),
		now()
	FROM
		tm_lz.rwg_analysis rwg
	WHERE
		UPPER ( rwg.study_id ) = UPPER ( trialID );
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert records into Biomart.Bio_Assay_Analysis', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	/* Update tm_lz.Rwg_Analysis with the newly created bio_assay_analysis_Id */
	BEGIN
	UPDATE tm_lz.Rwg_Analysis rwg
	SET
		rwg.bio_assay_analysis_id = (
			SELECT
				baa.bio_assay_analysis_id
			FROM
				Biomart.Bio_Assay_Analysis baa
			WHERE
				baa.analysis_name = rwg.analysis_id
				AND UPPER ( baa.etl_id ) LIKE UPPER ( trialID || ':%' )
				AND UPPER ( rwg.study_id ) LIKE UPPER ( trialID ) )
	WHERE
		UPPER ( rwg.study_id ) LIKE UPPER ( trialID );
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Update records in tm_lz.Rwg_Analysis with bio_assay_analysis_id ', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	PERFORM cz_write_audit(jobId,databaseName,procedureName,'FUNCTION Complete',0,stepCt,'Done');
	RETURN 0;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
		THEN
		PERFORM cz_end_audit (jobID, 'SUCCESS');
	END IF;
EXCEPTION
	WHEN OTHERS THEN
	errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
END;
$$;


ALTER FUNCTION tm_cz.rwg_create_analysis_entry(trialid text, delete_flag text, currentjobid bigint) OWNER TO tm_cz;

--
-- Name: rwg_import_from_ext(text, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION rwg_import_from_ext(trialid text, currentjobid bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
	newJobFlag    smallint;
	databaseName  varchar(100);
	procedureName varchar(100);
	jobID         bigint;
	stepCt        bigint;
	rowCt         bigint;
	errorNumber   varchar;
	errorMessage  varchar;
BEGIN
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	SELECT current_user INTO databaseName; --(sic)
	procedureName := 'RWG_IMPORT_FROM_EXT';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF (coalesce(jobID::text, '') = '' OR jobID < 1)
		THEN
		newJobFlag := 1; -- True
		SELECT cz_start_audit(procedureName, databaseName) INTO jobID;
	END IF;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Start FUNCTION', 0, stepCt, 'Done');
	stepCt := 1;

	delete from TM_LZ.Rwg_Analysis where upper(study_id) =upper(trialID);
	GET DIAGNOSTICS rowCt := ROW_COUNT;

	perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing records from TM_LZ.Rwg_Analysis',rowCt,stepCt,'Done');
	stepCt := stepCt + 1;

	delete from TM_LZ.Rwg_Cohorts where upper(study_id) =upper(trialID);
	GET DIAGNOSTICS rowCt := ROW_COUNT;

	perform cz_Write_Audit(Jobid,Databasename,Procedurename,'Delete existing records from TM_LZ.Rwg_Cohorts',rowCt,Stepct,'Done');
	stepCt := stepCt + 1;

	delete from TM_LZ.Rwg_Samples where upper(study_id) =upper(trialID);
	perform cz_Write_Audit(Jobid,Databasename,Procedurename,'Delete existing records from TM_LZ.Rwg_Samples',rowCt,Stepct,'Done');
	stepCt := stepCt + 1;

	-- not used??
	-- delete from TM_LZ.RWG_BAAD_ID where upper(study_id) =upper(trialID);
	--Cz_Write_Audit(Jobid,Databasename,Procedurename,'Delete existing records from TM_LZ.RWG_BAAD_ID',rowCt,Stepct,'Done');
	--stepCt := stepCt + 1;
	--Insert Analysis
	BEGIN
	INSERT INTO TM_LZ.Rwg_Analysis
	(
		Study_Id,
		Cohorts,
		ANALYSIS_ID,
		pvalue_cutoff,
		foldchange_cutoff ,
		lsmean_cutoff,
		Analysis_Type,
		Data_Type,
		Platform,
		Long_Desc,
		Short_Desc,
		import_date
	)
	SELECT
		Upper(Replace(  Study_Id,'"','')),
		REGEXP_REPLACE(upper(Replace(  Cohorts,'"','')), '\s*', '', 'g'),
		Replace(  ANALYSIS_ID ,'"',''),
		Replace( pvalue_cutoff ,'"','')::double precision,
		Replace(  foldchange_cutoff ,'"','')::double precision,
		Replace( lsmean_cutoff ,'"','')::double precision,
		Replace(  Analysis_Type,'"',''),
		Replace(  Data_Type,'"',''),
		Replace(   Platform,'"',''),
		Replace(  Long_Desc,'"',''),
		Replace(   short_desc,'"',''),
		now()
    FROM  TM_LZ.Rwg_Analysis_Ext
    WHERE upper(study_id) = upper(trialID);
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert records from TM_LZ.Rwg_Analysis_Ext to TM_LZ.Rwg_Analysis', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	--	update bio_assay_analysis_id for any existing analysis_id (20130111 JEA)
	BEGIN
	UPDATE tm_lz.rwg_analysis t
	SET
		bio_assay_analysis_id = (
			SELECT
				b.bio_assay_analysis_id
			FROM
				biomart.bio_assay_analysis b
			WHERE
				b.etl_id = trialID || ':RWG'
				AND b.analysis_name = t.analysis_id )
	WHERE
		t.study_id = trialID
		AND EXISTS (
			SELECT
				1
			FROM
				biomart.bio_assay_analysis x
			WHERE
				x.etl_id = trialID || ':RWG'
				AND t.analysis_id = x.analysis_name );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Update bio_assay_analysis_id on existing rwg_analysis records', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

    --Insert Cohorts
	BEGIN
	INSERT
	INTO TM_LZ.Rwg_Cohorts
	(
		Study_Id,
		Cohort_Id,
		Cohort_Title, Disease, Long_Desc,
		Organism, Pathology, Sample_Type, Short_Desc, Treatment,IMPORT_DATE
	)
	SELECT
	Upper(Replace(Study_Id,'"','')),
	trim(upper(Replace(Cohort_Id,'"',''))),
	Replace(Cohort_Title, '"',''),
	Replace(Disease, '"',''),
	Replace(Long_Desc, '"',''),
	Replace(Organism, '"',''),
	Replace(Pathology, '"',''),
	Replace(Sample_Type, '"',''),
	Replace(Short_Desc, '"',''),
	Replace(Treatment,'"',''),
	now()
	From  TM_LZ.Rwg_Cohorts_Ext
	where upper(study_id) = upper(trialID);

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert records from TM_LZ.Rwg_Cohorts_Ext to TM_LZ.Rwg_Cohorts', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	--Insert samples
	BEGIN
	INSERT
	INTO TM_LZ.Rwg_Samples(
		study_id, COHORTS, EXPR_ID, IMPORT_DATE
	)
	SELECT
		Upper(Replace(  Study_Id,'"','')),
		trim(upper(Replace(  Cohorts,'"',''))),
		Replace(  Expr_Id, '"',''),
		now()
	FROM  TM_LZ.Rwg_Samples_Ext
	WHERE upper(study_id) = upper(trialID);

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert records from TM_LZ.Rwg_Samples_Ext to TM_LZ.Rwg_Samples', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1 THEN
		PERFORM cz_end_audit(jobID, 'SUCCESS');
	END IF;

	RETURN 0;
EXCEPTION
	WHEN OTHERS THEN
	errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
END;

$$;


ALTER FUNCTION tm_cz.rwg_import_from_ext(trialid text, currentjobid bigint) OWNER TO tm_cz;

--
-- Name: rwg_load_analysis_data(text, bigint, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION rwg_load_analysis_data(trialid text, currentjobid bigint DEFAULT NULL::bigint, inplatformid bigint DEFAULT NULL::bigint, OUT rtn_code bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
--Audit variables
	newJobFlag    smallint;
	databaseName  varchar(100);
	procedureName varchar(100);
	jobID         bigint;
	stepCt        bigint;
	rowCt         bigint;
	errorNumber   varchar;
	errorMessage  varchar;

	vWZcount      integer;
	vLZcount      integer;
	vPlatformID   integer;
	vExpID        integer;

	cDelete       CURSOR FOR
		SELECT distinct bio_assay_analysis_id
			FROM tm_lz.Rwg_Analysis
			-- From BIOMART.bio_analysis_cohort_xref
			WHERE upper(study_id) = upper(trialID);

    cDeleteRow    record; --type of cDelete rows

BEGIN
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	SELECT current_user INTO databaseName; --(sic)
	procedureName := 'RWG_LOAD_ANALYSIS_DATA';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF (coalesce(jobID::text, '') = '' OR jobID < 1)
		THEN
		newJobFlag := 1; -- True
		SELECT cz_start_audit(procedureName, databaseName) INTO jobID;
	END IF;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Start FUNCTION', 0, stepCt, 'Done');
	stepCt := 1;

	FOR cDeleteRow IN cDelete
	LOOP
		BEGIN
		DELETE FROM BIOMART.bio_assay_analysis_data
		WHERE bio_assay_analysis_id = cDeleteRow.bio_assay_analysis_id;
		GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete records from BIOMART.bio_assay_analysis_data for analysis:  ' || cDeleteRow.bio_assay_analysis_id, rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

		BEGIN
		DELETE FROM tm_lz.rwg_analysis_data
		WHERE bio_assay_analysis_id = cDeleteRow.bio_assay_analysis_id;
		GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete records from BIOMART.bio_assay_analysis_data for analysis:  ' || cDeleteRow.bio_assay_analysis_id, rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;
	END LOOP;

	BEGIN
	TRUNCATE TABLE tm_wz.bio_assay_analysis_data_new;
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Truncate tm_wz.bio_assay_analysis_data_new', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	BEGIN
	TRUNCATE TABLE tm_wz.tmp_assay_analysis_metrics;
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Truncate tm_wz.tmp_assay_analysis_metrics', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- not used ???
	--delete from tm_lz.RWG_BAAD_ID where upper(study_id) =upper(trialID);
	--Cz_Write_Audit(Jobid,Databasename,Procedurename,'Delete existing records from tm_lz.RWG_BAAD_ID',rowCt,Stepct,'Done');
	--stepCt := stepCt + 1;
	IF (coalesce(inPlatformID::text, '') = '')
		THEN

		BEGIN
		SELECT max(bap.bio_assay_platform_id) INTO vPlatformID
		FROM DEAPP.de_subject_sample_mapping ssm, DEAPP.de_gpl_info gpl, BIOMART.bio_assay_platform bap
		WHERE upper(ssm.gpl_id) = upper(gpl.platform)
			AND upper(ssm.trial_name) = upper(trialID)
			AND ssm.platform = 'MRNA_AFFYMETRIX'
			AND upper(bap.platform_accession) LIKE '%'|| upper(gpl.platform) || '%';
		GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Get bio_assay_platform_ID: ' || vPlatformID, rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;
	ELSE
		vPlatformID := inPlatformID;
	END IF;

	BEGIN
	SELECT exp.bio_experiment_id INTO vExpID
	FROM BIOMART.bio_experiment exp
	WHERE upper(accession) = upper(trialID);
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Get bio_experiment_id: ' || vExpID, rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	BEGIN
	SELECT count(*) INTO vLZcount FROM TM_LZ.RWG_ANALYSIS_DATA_EXT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Count for TM_LZ.RWG_ANALYSIS_DATA_EXT = ' || vLZcount, 0, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	--	count number of data records with non-numeric data in preferred_pvalue or fold_change and log
	BEGIN
	SELECT COUNT (*)
	INTO vLZcount
	FROM tm_lz.rwg_analysis_data_ext
	WHERE
		is_numeric(preferred_pvalue) = 1
		OR is_numeric(fold_change) = 1;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Data records dropped for non-numeric preferred_pvalue or fold_change', vLZcount, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	--	insert data into rwg_analysis_data, skip records with non-numeric data in preferred_pvalue or fold_change
	--	change all other non-numeric data to null
	BEGIN
	INSERT INTO tm_lz.rwg_analysis_data (
		study_id,
		probeset,
		fold_change,
		pvalue,
		raw_pvalue,
		adjusted_pvalue,
		min_lsmean,
		max_lsmean,
		analysis_cd,
		bio_assay_analysis_id )
	SELECT
		rwg.study_id,
		ext.probeset,
		ext.fold_change::double precision,
		ext.preferred_pvalue::double precision,
		CASE
			WHEN is_numeric ( ext.raw_pvalue ) = 1 THEN NULL
			ELSE ext.raw_pvalue
		END::double precision
		,
		CASE
			WHEN is_numeric ( ext.adjusted_pvalue ) = 1 THEN NULL
			ELSE ext.adjusted_pvalue
		END::double precision
		,
		CASE
			WHEN is_numeric ( ext.lsmean_1 ) = 1 OR is_numeric ( ext.lsmean_1 ) = 1 THEN NULL
			WHEN ext.lsmean_1 > ext.lsmean_2 THEN ext.lsmean_2
			ELSE ext.lsmean_1
		END::double precision --min
		,
		CASE
			WHEN is_numeric ( ext.lsmean_1 ) = 1
			OR is_numeric ( ext.lsmean_1 ) = 1 THEN NULL
			WHEN ext.lsmean_1 > ext.lsmean_2 THEN ext.lsmean_1
			ELSE ext.lsmean_2
		END::double precision --max
		,
		ext.analysis_id,
		rwg.bio_assay_analysis_id
	FROM
		TM_LZ.RWG_ANALYSIS_DATA_EXT ext,
		tm_lz.rwg_analysis rwg
	WHERE
		TRIM ( UPPER ( ext.analysis_id ) ) = TRIM ( UPPER ( rwg.analysis_id ) )
		AND UPPER ( rwg.study_id ) = UPPER ( trialID )
		AND is_numeric ( ext.preferred_pvalue ) = 0
		AND is_numeric ( ext.fold_change ) = 0;
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert records into rwg_analysis_data', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	BEGIN
	SELECT COUNT(*) INTO vWZcount FROM tm_lz.rwg_analysis_data
	WHERE study_id = upper(trialID);
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Count for tm_lz.rwg_analysis_data = ' || vWZcount, 0, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;


	BEGIN
	INSERT INTO tm_wz.BIO_ASSAY_ANALYSIS_DATA_NEW (
		fold_change_ratio,
		raw_pvalue,
		adjusted_pvalue,
		bio_assay_analysis_id,
		feature_group_name,
		bio_experiment_id,
		bio_assay_platform_id,
		etl_id,
		preferred_pvalue,
		lsmean1,
		lsmean2,
		bio_assay_feature_group_id )
	SELECT
		rad.fold_change,
		rad.raw_pvalue,
		rad.adjusted_pvalue,
		rad.bio_assay_analysis_id,
		rad.probeset,
		vExpID,
		vPlatformID,
		rad.study_id || ':RWG',
		rad.pvalue,
		rad.min_lsmean,
		rad.max_lsmean,
		bafg.bio_assay_feature_group_id
	FROM
		tm_lz.rwg_analysis_data rad
		LEFT JOIN BIOMART.bio_assay_feature_group bafg ON ( rad.probeset = bafg.feature_group_name )
	WHERE
		rad.study_id = UPPER ( trialID ); -- 20121212 JEA
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert records into BIO_ASSAY_ANALYSIS_DATA_NEW', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	/*Calculate TEA Values */
	BEGIN
	INSERT INTO tm_wz.tmp_assay_analysis_metrics
	SELECT
		ad.bio_assay_analysis_id,
		COUNT ( * )
		data_ct,
		AVG ( ad.fold_change_ratio )
		fc_mean,
		Stddev ( Ad.Fold_Change_Ratio )
		Fc_Stddev
	FROM
		tm_wz.BIO_ASSAY_ANALYSIS_DATA_NEW ad
		JOIN biomart.bio_assay_analysis a ON ad.bio_assay_analysis_id = a.bio_assay_analysis_id
	WHERE ( ad.fold_change_ratio IS NOT NULL
		AND ad.fold_change_ratio::text <> '' )
		AND a.bio_assay_data_type <> 'RBM'
	GROUP BY
		ad.bio_assay_analysis_id
	ORDER BY
		data_ct;
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert records into tm_wz.tmp_assay_analysis_metrics ', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	BEGIN
	UPDATE tm_wz.BIO_ASSAY_ANALYSIS_DATA_NEW AS d
	SET
		tea_normalized_pvalue = TEA_NPV_PRECOMPUTE(d.fold_change_ratio, m.fc_mean, m.fc_stddev )
	FROM
		tm_wz.tmp_assay_analysis_metrics m
	WHERE d.bio_assay_analysis_id = m.bio_assay_analysis_id
		AND ( d.fold_change_ratio IS NOT NULL
			AND d.fold_change_ratio ::text <> '');
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Update TEA records in tm_lz.BIO_ASSAY_ANALYSIS_DATA_NEW', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	/* Final Insert */
	SET search_path = "$user", public, biomart;
	FOR cDeleterow IN cdElete LOOP
		BEGIN
		INSERT INTO biomart.bio_assay_analysis_data(
			FOLD_CHANGE_RATIO, RAW_PVALUE,ADJUSTED_PVALUE,BIO_ASSAY_ANALYSIS_ID,
			FEATURE_GROUP_NAME,BIO_EXPERIMENT_ID,BIO_ASSAY_PLATFORM_ID ,
			ETL_ID,PREFERRED_PVALUE,TEA_NORMALIZED_PVALUE,BIO_ASSAY_FEATURE_GROUP_ID,
			LSMEAN1,LSMEAN2 )
		SELECT
		FOLD_CHANGE_RATIO,RAW_PVALUE,ADJUSTED_PVALUE,BIO_ASSAY_ANALYSIS_ID,
		FEATURE_GROUP_NAME,BIO_EXPERIMENT_ID,BIO_ASSAY_PLATFORM_ID ,
		ETL_ID,PREFERRED_PVALUE,TEA_NORMALIZED_PVALUE,BIO_ASSAY_FEATURE_GROUP_ID,
		LSMEAN1,LSMEAN2
		FROM tm_wz.BIO_ASSAY_ANALYSIS_DATA_NEW
		WHERE bio_assay_analysis_id = cDeleteRow.bio_assay_analysis_id;

		GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert records into biomart.bio_assay_analysis_data for analysis:  ' || cDeleteRow.bio_assay_analysis_id, rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;
	END LOOP;

	PERFORM cz_write_audit(jobId,databaseName,procedureName,'FUNCTION Complete',0,stepCt,'Done');

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
		THEN
		PERFORM cz_end_audit (jobID, 'SUCCESS');
	END IF;
EXCEPTION
	WHEN OTHERS THEN
	errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
END;

$_$;


ALTER FUNCTION tm_cz.rwg_load_analysis_data(trialid text, currentjobid bigint, inplatformid bigint, OUT rtn_code bigint) OWNER TO tm_cz;

--
-- Name: rwg_load_analysis_metadata(text, text, text, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION rwg_load_analysis_metadata(trialid text, i_study_data_category text DEFAULT 'Study'::text, i_study_category_display text DEFAULT NULL::text, currentjobid bigint DEFAULT NULL::bigint, OUT rtn_code bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
  --Audit variables
	newJobFlag    smallint;
	databaseName  varchar(100);
	procedureName varchar(100);
	jobID         bigint;
	stepCt        bigint;
	rowCt         bigint;
	errorNumber   varchar;
	errorMessage  varchar;

	Dcount        integer;
	lcount        integer;
	analysisCount integer;
	resultCount   integer;
	innerRet      bigint;

BEGIN
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	SELECT current_user INTO databaseName; --(sic)
	procedureName := 'RWG_LOAD_ANALYSIS_METADATA';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF (coalesce(jobID::text, '') = '' OR jobID < 1)
		THEN
		newJobFlag := 1; -- True
		SELECT cz_start_audit(procedureName, databaseName) INTO jobID;
	END IF;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Start FUNCTION', 0, stepCt, 'Done');
	stepCt := 1;

	/*
	 * Before starting, ensure that the incoming analysis IDs match to the
	 * biomart.bio_assay_analysis name.
	 * If not, try to match using the short_desc. Update the analysis_name if
	 * this work; otherwise, quit
	 */
    /*
	 * NOTE: Due to a change in the curation/etl procedures, this step should no
	 * longer be needed.  The bio_assay_analysis_id is updated in
	 * TM_LZ.Rwg_Analysis at time of creation. A check is done, and if the IDs
	 * match, then this step is bypassed
	 */
  
  
	-- get the count of the incoming analysis data
	BEGIN
	SELECT count(*)
	INTO analysisCount 
	FROM TM_LZ.Rwg_Analysis
	WHERE study_id =  Upper(trialID);

	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Analysis count from TM_LZ.Rwg_Analysis =(see count)', analysisCount, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	--see how many of the analysees match by using the cohort analysis name
	BEGIN
	SELECT
		COUNT ( * )
		INTO resultCount
	FROM
		TM_LZ.Rwg_Analysis analysis,
		Biomart.Bio_Assay_Analysis Baa
	WHERE
		analysis.bio_assay_analysis_id = baa.bio_assay_analysis_id --bio_assay_analysis_id in 'TM_LZ.Rwg_Analysis analysis' should already exist
		AND UPPER ( analysis.study_id ) = UPPER ( trialID );

	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Join analysis.Cohorts to Baa.Analysis_Name, Analysis count =(see count)', resultCount, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	IF analysisCount != resultCount THEN  
	  RAISE 'Analysis count mismatch' USING ERRCODE = 'AA001';
	END IF;


	BEGIN
	DELETE FROM Biomart.Bio_Analysis_Cohort_Xref WHERE upper(study_id) = upper(trialID);

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing records from Biomart.Bio_Analysis_Cohort_Xref', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	BEGIN
	DELETE FROM Biomart.Bio_Analysis_Attribute_Lineage Baal
	WHERE Baal.Bio_Analysis_Attribute_Id IN
	(SELECT DISTINCT Baa.Bio_Analysis_Attribute_Id
	FROM Biomart.Bio_Analysis_Attribute baa WHERE upper(study_id) = upper(trialID));

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing records from Biomart.Bio_Analysis_Attribute_Lineage', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	BEGIN
	DELETE FROM Biomart.Bio_Analysis_Attribute  WHERE upper(study_id) = upper(trialID);

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing records from Biomart.Bio_Analysis_Attribute', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	/** Delete study from biomart.bio_assay_cohort table **/
	BEGIN
	DELETE FROM Biomart.Bio_Assay_Cohort WHERE upper(study_id) = upper(trialID);

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing records from Biomart.Bio_Assay_Cohort', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	/** Populate biomart.bio_assay_cohort table **/
	BEGIN
	INSERT INTO Biomart.Bio_Assay_Cohort (
		Study_Id,
		Cohort_Id,
		Disease,
		Sample_Type,
		Treatment,
		Organism,
		Pathology,
		Cohort_Title,
		Short_Desc,
		Long_Desc,
		Import_Date )
	SELECT
		Study_Id,
		Cohort_Id,
		Disease,
		Sample_Type,
		Treatment,
		Organism,
		Pathology,
		Cohort_Title,
		Short_Desc,
		Long_Desc,
		now()
	FROM
		TM_LZ.Rwg_Cohorts
	WHERE
		UPPER ( Study_Id ) = UPPER ( trialID );
	
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert into Biomart.Bio_Assay_Cohort', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	SELECT coalesce(Max(Length(Regexp_Replace(analysis.Cohorts,'[^;]','g'))),0)+1
	INTO dcount
	FROM TM_LZ.Rwg_Analysis analysis;

	FOR lcount IN 1 .. dcount
		LOOP

		BEGIN
		PERFORM cz_write_audit(jobId,databaseName,procedureName,'Starting Bio_Analysis_Cohort_Xref LOOP, pass: ',lcount,stepCt,'Done');
		INSERT INTO Biomart.Bio_Analysis_Cohort_Xref(
			Study_Id,
			Analysis_Cd,
			Cohort_Id,
			Bio_Assay_Analysis_Id
		)
		SELECT
			upper(analysis.Study_Id),
			analysis.Cohorts,
			trim(Parse_Nth_Value(analysis.Cohorts,lcount,';')) AS cohort,
			baa.bio_assay_analysis_id
		FROM TM_LZ.Rwg_Analysis analysis, Biomart.Bio_Assay_Analysis Baa
		WHERE analysis.bio_assay_analysis_id= Baa.bio_assay_analysis_id
			AND Upper(Baa.Etl_Id) LIKE '%' || Upper(Trialid) || '%'
			AND Upper(analysis.Study_Id) LIKE '%' || Upper(Trialid) || '%'
			AND Trim(Parse_Nth_Value(analysis.Cohorts,lcount,';')) IS NOT NULL;

		GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert COHORTS into  into Biomart.Bio_Analysis_Cohort_Xref', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;
	END LOOP;


	/*************************************/
	/** POPULATE Bio_Analysis_Attribute **/
	/*************************************/
	--	delete study from cz_rwg_invalid_terms 20121220 JEA
	BEGIN
	DELETE FROM cz_rwg_invalid_terms
	WHERE upper(study_id) = upper(trialID);

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing data from cz_rwg_invalid_terms', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	--	insert study as search_term term, sp will check if already exists
	SELECT rwg_add_search_term(upper(trialID),i_study_data_category,i_study_category_display,jobId) INTO innerRet;
	IF innerRet <> 0
		THEN
		errorNumber := '000000';
		errorMessage := 'RWG_ADD_SEARCH_TERM() failed. Arguments: ' ||
				upper(trialID) || ', ' || i_study_data_category ||
				', ' || i_study_category_display  || ', ' || jobId;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END IF;

	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert study as search_term', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;

	BEGIN
	-- sample_type: check for any records that do not have a match in the taxonomy
	INSERT INTO cz_rwg_Invalid_Terms(
		Study_Id,
		Category_Name,
		Term_Name)
	SELECT DISTINCT
		upper(Cohort.Study_Id),
		upper('sample_type'),
		cohort.sample_type
	FROM TM_LZ.Rwg_Cohorts Cohort
	WHERE upper(Cohort.Study_Id)=upper(trialID)
		AND NOT EXISTS 
			(SELECT Upper(Tax.Term_Name) FROM Searchapp.Search_Taxonomy Tax
			 WHERE Upper(Cohort.sample_type) = Upper(Tax.Term_Name));
	
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'sample_type: register invalid terms (with no match in the taxonomy)', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- sample_type: insert terms into attribute table
	BEGIN
	INSERT INTO Biomart.Bio_Analysis_Attribute(
		Study_Id,
		Bio_Assay_Analysis_Id,
		Term_Id,
		Source_Cd)
	SELECT DISTINCT
		upper(Cohort.Study_Id),
		Xref.Bio_Assay_Analysis_Id,
		Tax.Term_Id, Upper('sample_type:' || Cohort.sample_type) 
	FROM
		TM_LZ.Rwg_Cohorts Cohort,
		Biomart.Bio_Analysis_Cohort_Xref Xref,
		Searchapp.Search_Taxonomy Tax
	WHERE upper(Cohort.Cohort_Id) = upper(Xref.Cohort_Id)
		AND upper(Xref.Study_Id) = upper(Cohort.Study_Id)
		AND Upper(Cohort.Sample_Type) = Upper(Tax.Term_Name)
		AND Cohort.Study_Id =upper(trialID); 

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert SAMPLE_TYPE into Bio_Analysis_Attribute', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- disease: check for any records that do not have a match in the taxonomy
	BEGIN
	INSERT INTO Cz_Rwg_Invalid_Terms (
		Study_Id,
		Category_Name,
		Term_Name )
	SELECT DISTINCT
		UPPER ( Cohort.Study_Id ),
		'disease',
		cohort.disease
	FROM
		TM_LZ.Rwg_Cohorts Cohort
	WHERE
		UPPER ( Cohort.Study_Id )
		= UPPER ( trialID )
		AND NOT EXISTS (
			SELECT
				UPPER ( Tax.Term_Name )
			FROM
				Searchapp.Search_Taxonomy Tax
			WHERE
				UPPER ( Cohort.disease ) = UPPER ( Tax.Term_Name ) );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'disease: register invalid terms (with no match in the taxonomy)', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- disease: insert terms into attribute table
	BEGIN
	INSERT INTO Biomart.Bio_Analysis_Attribute (
		Study_Id,
		Bio_Assay_Analysis_Id,
		Term_Id,
		Source_Cd )
	SELECT DISTINCT
		UPPER ( Cohort.Study_Id ) ,
		Xref.Bio_Assay_Analysis_Id,
		Tax.Term_Id,
		UPPER ( 'disease:' || Cohort.disease )
	FROM
		TM_LZ.Rwg_Cohorts Cohort,
		Biomart.Bio_Analysis_Cohort_Xref Xref,
		Searchapp.Search_Taxonomy Tax
	WHERE
		UPPER ( Cohort.Cohort_Id ) = UPPER ( Xref.Cohort_Id )
		AND UPPER ( Xref.Study_Id ) = UPPER ( Cohort.Study_Id )
		AND UPPER ( Cohort.Disease ) = UPPER ( Tax.Term_Name )
		AND UPPER ( cohort.study_id ) = UPPER ( trialID ); 

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert disease into Bio_Analysis_Attribute', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- pathology: check for any records that do not have a match in the taxonomy
	BEGIN
	INSERT INTO Cz_Rwg_Invalid_Terms (
		Study_Id,
		Category_Name,
		Term_Name )
	SELECT DISTINCT
		UPPER ( Cohort.Study_Id ),
		'pathology',
		cohort.pathology
	FROM
		TM_LZ.Rwg_Cohorts Cohort
	WHERE
		UPPER ( Cohort.Study_Id ) = UPPER ( trialID )
		AND NOT EXISTS (
			SELECT
				UPPER ( Tax.Term_Name )
			FROM
				Searchapp.Search_Taxonomy Tax
			WHERE
				UPPER ( Cohort.pathology ) = UPPER ( Tax.Term_Name ) );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'pathology: register invalid terms (with no match in the taxonomy)', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- pathology: insert terms into attribute table
	BEGIN
	INSERT INTO Biomart.Bio_Analysis_Attribute (
		Study_Id,
		Bio_Assay_Analysis_Id,
		Term_Id,
		Source_Cd )
	SELECT DISTINCT
		UPPER ( Cohort.Study_Id ),
		Xref.Bio_Assay_Analysis_Id,
		Tax.Term_Id,
		UPPER ( 'pathology:' || Cohort.pathology )
	FROM
		TM_LZ.Rwg_Cohorts Cohort,
		Biomart.Bio_Analysis_Cohort_Xref Xref,
		Searchapp.Search_Taxonomy Tax
	WHERE
		UPPER ( Cohort.Cohort_Id ) = UPPER ( Xref.Cohort_Id )
		AND UPPER ( Xref.Study_Id ) = UPPER ( Cohort.Study_Id )
		AND UPPER ( Cohort.Pathology ) = UPPER ( Tax.Term_Name )
		AND UPPER ( cohort.study_id ) = UPPER ( trialID );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert pathology into Bio_Analysis_Attribute', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- LOOP FOR TREATMENT
	SELECT coalesce(Max(Length(Regexp_Replace(Cohort.Treatment,'[^;]', 'g'))),0)+1
	INTO Dcount
	FROM TM_LZ.Rwg_Cohorts Cohort
	WHERE upper(Cohort.Study_Id)=upper(trialID);
	FOR lcount IN 1 .. dcount
		LOOP	
		stepCt := stepCt + 1;
		PERFORM cz_write_audit(jobId,databaseName,procedureName,'Starting COHORT TREATMENT LOOP, pass: ',lcount,stepCt,'Done');

		-- treatment: check for any records that do not have a match in the taxonomy
		BEGIN
		INSERT INTO Cz_Rwg_Invalid_Terms (
			Study_Id,
			Category_Name,
			Term_Name )
		SELECT
			DISTINCT UPPER ( Cohort.Study_Id ) ,
			'treatment',
			TRIM ( Parse_Nth_Value ( cohort.treatment, lcount, ';' ) )
		FROM
			TM_LZ.Rwg_Cohorts Cohort
		WHERE
			UPPER ( Cohort.Study_Id ) = UPPER ( trialID )
			AND NOT EXISTS (
				SELECT
					UPPER ( Tax.Term_Name )
				FROM
					Searchapp.Search_Taxonomy Tax
				WHERE
					UPPER ( TRIM ( Parse_Nth_Value ( cohort.treatment, lcount, ';' ) ) )
					= UPPER ( Tax.Term_Name ) )
			AND TRIM ( Parse_Nth_Value ( cohort.treatment, lcount, ';' ) ) IS NOT NULL;

		-- treatment: insert terms into attribute table
		INSERT INTO biomart.bio_analysis_attribute (
			study_id,
			bio_assay_analysis_id,
			term_id,
			source_cd )
		SELECT DISTINCT
			UPPER ( cohort.study_id ) ,
			xref.bio_assay_analysis_id,
			tax.term_id,
			UPPER ( 'treatment:' || TRIM ( parse_nth_value ( cohort.treatment,
						lcount,
						';' ) ) )
		FROM
			tm_lz.rwg_cohorts cohort,
			biomart.bio_analysis_cohort_xref xref,
			searchapp.search_taxonomy tax
		WHERE
			UPPER ( cohort.cohort_id ) = UPPER ( xref.cohort_id )
			AND UPPER ( xref.study_id ) = UPPER ( cohort.study_id )
			AND UPPER ( TRIM ( parse_nth_value ( cohort.treatment, lcount, ';' ) ) )
				= UPPER ( tax.term_name )
			AND UPPER ( cohort.study_id ) = UPPER ( trialid );

		GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert treatment into Bio_Analysis_Attribute (LOOP)', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	END LOOP;

	stepCt := stepCt + 1;
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(Jobid,Databasename,Procedurename,'END TREATMENT LOOP',rowCt,stepCt,'Done');
	-- END TREATMENT LOOP

	-- organism: check for any records that do not have a match in the taxonomy
	BEGIN
	INSERT INTO Cz_Rwg_Invalid_Terms (
		Study_Id,
		Category_Name,
		Term_Name )
	SELECT DISTINCT
		UPPER ( Cohort.Study_Id ) ,
		'organism',
		Cohort.organism
	FROM
		TM_LZ.Rwg_Cohorts Cohort
	WHERE
		UPPER ( Cohort.Study_Id ) = UPPER ( trialID )
		AND NOT EXISTS (
			SELECT
				UPPER ( Tax.Term_Name )
			FROM
				Searchapp.Search_Taxonomy Tax
			WHERE
				UPPER ( Cohort.organism ) = UPPER ( Tax.Term_Name ) );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'organism: register invalid terms (with no match in the taxonomy)', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- organism: insert terms into attribute table
	BEGIN
	INSERT INTO Biomart.Bio_Analysis_Attribute (
		Study_Id,
		Bio_Assay_Analysis_Id,
		Term_Id,
		Source_Cd )
	SELECT DISTINCT
		UPPER ( Cohort.Study_Id ),
		Xref.Bio_Assay_Analysis_Id,
		Tax.Term_Id,
		UPPER ( 'organism:' || Cohort.Organism )
	FROM
		TM_LZ.Rwg_Cohorts Cohort,
		Biomart.Bio_Analysis_Cohort_Xref Xref,
		Searchapp.Search_Taxonomy Tax
	WHERE
		UPPER ( Cohort.Cohort_Id ) = UPPER ( Xref.Cohort_Id )
		AND UPPER ( Xref.Study_Id ) = UPPER ( Cohort.Study_Id )
		AND UPPER ( Cohort.Organism ) = UPPER ( Tax.Term_Name )
		AND UPPER ( cohort.study_id ) = UPPER ( trialID );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert organism into Bio_Analysis_Attribute', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- data_type: check for any records that do not have a match in the taxonomy
	BEGIN
	INSERT INTO Cz_Rwg_Invalid_Terms (
		Study_Id,
		Category_Name,
		Term_Name )
	SELECT DISTINCT
		UPPER ( analysis.Study_Id ),
		'data_type',
		analysis.data_type
	FROM
		TM_LZ.Rwg_Analysis analysis
	WHERE
		UPPER ( analysis.Study_Id ) = UPPER ( trialID )
		AND NOT EXISTS (
			SELECT
				UPPER ( Tax.Term_Name )
			FROM
				Searchapp.Search_Taxonomy Tax
			WHERE
				UPPER ( analysis.data_type ) = UPPER ( Tax.Term_Name ) );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'data_type: register invalid terms (with no match in the taxonomy)', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- data_type: insert terms into attribute table
	BEGIN
	INSERT INTO Biomart.Bio_Analysis_Attribute (
		Study_Id,
		Bio_Assay_Analysis_Id,
		Term_Id,
		Source_Cd )
	SELECT
		UPPER ( analysis.Study_Id ),
		Baa.Bio_Assay_Analysis_Id,
		Tax.Term_Id,
		UPPER ( 'data_type:' || analysis.Data_Type )
	FROM
		TM_LZ.Rwg_Analysis analysis,
		Searchapp.Search_Taxonomy Tax,
		Biomart.Bio_Assay_Analysis Baa
	WHERE
		UPPER ( analysis.Data_Type ) = UPPER ( Tax.Term_Name )
		AND analysis.bio_assay_analysis_id = Baa.bio_assay_analysis_id
		AND UPPER ( Baa.Etl_Id )
			LIKE '%' || UPPER ( analysis.Study_Id ) || '%'
		AND UPPER ( analysis.Study_Id ) = UPPER ( trialID );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert data_type into Bio_Analysis_Attribute', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- platform: check for any records that do not have a match in the taxonomy
	BEGIN
	INSERT INTO Cz_Rwg_Invalid_Terms (
		study_id,
		category_name,
		term_name )
	SELECT DISTINCT
		analysis.Study_Id,
		'platform',
		analysis.platform
	FROM
		TM_LZ.Rwg_Analysis analysis
	WHERE
		UPPER ( analysis.Study_Id ) = UPPER ( trialID )
		AND NOT EXISTS (
			SELECT
				UPPER ( Tax.Term_Name )
			FROM
				Searchapp.Search_Taxonomy Tax
			WHERE
				UPPER ( analysis.platform ) = UPPER ( Tax.Term_Name ) );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'platform: register invalid terms (with no match in the taxonomy)', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- platform: insert terms into attribute table
	BEGIN
	INSERT INTO Biomart.Bio_Analysis_Attribute (
		Study_Id,
		Bio_Assay_Analysis_Id,
		Term_Id,
		Source_Cd )
	SELECT
		UPPER ( analysis.Study_Id ),
		Baa.Bio_Assay_Analysis_Id,
		Tax.Term_Id,
		UPPER ( 'platform:' || analysis.Platform )
	FROM
		TM_LZ.Rwg_Analysis analysis,
		Searchapp.Search_Taxonomy Tax,
		Biomart.Bio_Assay_Analysis Baa
	WHERE
		UPPER ( analysis.Platform ) = UPPER ( Tax.Term_Name )
		AND analysis.bio_assay_analysis_id = Baa.bio_assay_analysis_id
		AND UPPER ( Baa.Etl_Id )
			LIKE '%' || UPPER ( analysis.Study_Id ) || '%'
		AND UPPER ( analysis.Study_Id ) = UPPER ( trialID );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert platform into Bio_Analysis_Attribute', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- LOOP FOR ANALYSIS TYPE
	SELECT coalesce(Max(Length(Regexp_Replace(analysis.Analysis_Type,'[^;]', 'g'))),0)+1
	INTO Dcount
	FROM TM_LZ.Rwg_Analysis analysis
	WHERE upper(analysis.Study_Id)=upper(trialID);

	FOR Lcount IN 1 .. Dcount
		LOOP	 
		stepCt := stepCt + 1;
		PERFORM cz_write_audit(jobId,databaseName,procedureName,'Starting ANALYSIS_TYPE LOOP, pass: ',lcount,stepCt,'Done');

		-- Analysis_Type: check for any records that do not have a match in the taxonomy
		BEGIN
		INSERT INTO Cz_Rwg_Invalid_Terms (
			Study_Id,
			Category_Name,
			Term_Name )
		SELECT DISTINCT
			UPPER ( analysis.Study_Id ),
			'Analysis_Type',
			TRIM ( Parse_Nth_Value ( analysis.Analysis_Type, lcount, ';' ) )
		FROM
			TM_LZ.Rwg_Analysis analysis
		WHERE
			UPPER ( analysis.Study_Id ) = UPPER ( trialID )
			AND NOT EXISTS (
				SELECT
					UPPER ( Tax.Term_Name )
				FROM
					Searchapp.Search_Taxonomy Tax
				WHERE
					UPPER ( TRIM ( Parse_Nth_Value ( analysis.Analysis_Type, Lcount, ';' ) ) )
						= UPPER ( Tax.Term_Name ) )
			AND TRIM ( Parse_Nth_Value ( analysis.Analysis_Type, Lcount, ';' ) ) IS NOT NULL;

		-- Analysis_Type: insert terms into attribute table
		INSERT INTO Biomart.Bio_Analysis_Attribute (
			Study_Id,
			Bio_Assay_Analysis_Id,
			Term_Id,
			Source_Cd )
		SELECT
			UPPER ( analysis.study_id ),
			baa.bio_assay_analysis_id,
			tax.term_id,
			UPPER ( 'ANALYSIS_TYPE:' || TRIM ( Parse_Nth_Value ( analysis.Analysis_Type,
						lcount,
						';' ) ) )
		FROM
			TM_LZ.Rwg_Analysis analysis,
			Searchapp.Search_Taxonomy Tax,
			Biomart.Bio_Assay_Analysis Baa
		WHERE
			UPPER ( TRIM ( Parse_Nth_Value ( analysis.Analysis_Type,
						Lcount,
						';' ) ) )
				= UPPER ( Tax.Term_Name )
			AND analysis.bio_assay_analysis_id = Baa.bio_assay_analysis_id
			AND UPPER ( Baa.Etl_Id )
				LIKE '%' || UPPER ( analysis.Study_Id ) || '%'
			AND UPPER ( analysis.Study_Id ) = UPPER ( Trialid )
			AND TRIM ( Parse_Nth_Value ( analysis.Analysis_Type, Lcount, ';' ) ) IS NOT NULL;

		GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'LOOP: Insert ANALYSIS_TYPE into Bio_Analysis_Attribute', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;
	END LOOP;

	stepCt := stepCt + 1;
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(Jobid,Databasename,Procedurename,'END ANALYSIS_TYPE LOOP',rowCt,stepCt,'Done');
	-- END ANALYSIS TYPE

	-- search_area: check for any records that do not have a match in the taxonomy
	BEGIN
	INSERT INTO Cz_Rwg_Invalid_Terms (
		Study_Id,
		Category_Name,
		Term_Name )
	SELECT DISTINCT
		UPPER ( ext.Study_Id ),
		'search_area',
		ext.search_area
	FROM
		TM_LZ.clinical_trial_metadata_ext Ext
	WHERE
		UPPER ( ext.Study_Id ) = UPPER ( trialID )
		AND NOT EXISTS (
			SELECT
				UPPER ( Tax.Term_Name )
			FROM
				Searchapp.Search_Taxonomy Tax
			WHERE
				UPPER ( ext.search_area ) = UPPER ( Tax.Term_Name ) );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'search_area: register invalid terms (with no match in the taxonomy)', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- search_area: insert terms into attribute table
	BEGIN
	INSERT INTO Biomart.Bio_Analysis_Attribute (
		Study_Id,
		Bio_Assay_Analysis_Id,
		Term_Id,
		Source_Cd )
	SELECT DISTINCT
		UPPER ( Ext.Study_Id ),
		Xref.Bio_Assay_Analysis_Id,
		Tax.Term_Id,
		UPPER ( 'search_area:' || Ext.search_area )
	FROM
		TM_LZ.Clinical_Trial_Metadata_Ext Ext,
		Biomart.Bio_Analysis_Cohort_Xref Xref,
		Searchapp.Search_Taxonomy Tax
	WHERE
		UPPER ( Xref.Study_Id ) = UPPER ( ext.Study_Id )
		AND UPPER ( Ext.Search_Area ) = UPPER ( Tax.Term_Name )
		AND UPPER ( ext.study_id ) = UPPER ( trialID );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert search_area into Bio_Analysis_Attribute', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- data source: check for any records that do not have a match in the taxonomy
	BEGIN
	INSERT INTO Cz_Rwg_Invalid_Terms (
		Study_Id,
		Category_Name,
		Term_Name )
	SELECT DISTINCT
		UPPER ( ext.Study_Id ),
		'DATA_SOURCE',
		ext.data_source
	FROM
		TM_LZ.Clinical_Trial_Metadata_Ext Ext
	WHERE
		UPPER ( ext.Study_Id ) = UPPER ( trialID )
		AND NOT EXISTS (
			SELECT
				UPPER ( Tax.Term_Name )
			FROM
				Searchapp.Search_Taxonomy Tax
			WHERE
				UPPER ( ext.data_source ) = UPPER ( Tax.Term_Name ) );
	
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'data source: register invalid terms (with no match in the taxonomy)', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;
	
	-- data source: insert terms into attribute table
	BEGIN
	INSERT INTO Biomart.Bio_Analysis_Attribute (
		Study_Id,
		Bio_Assay_Analysis_Id,
		Term_Id,
		Source_Cd )
	SELECT DISTINCT
		UPPER ( Ext.Study_Id ),
		Xref.Bio_Assay_Analysis_Id,
		Tax.Term_Id,
		UPPER ( 'DATA_SOURCE:' || Ext.data_source )
	FROM
		TM_LZ.Clinical_Trial_Metadata_Ext Ext,
		Biomart.Bio_Analysis_Cohort_Xref Xref,
		Searchapp.Search_Taxonomy Tax
	WHERE
		UPPER ( Xref.Study_Id ) = UPPER ( ext.Study_Id )
		AND UPPER ( Ext.data_source ) = UPPER ( Tax.Term_Name )
		AND UPPER ( ext.study_id ) = UPPER ( trialID );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert DATA_SOURCE into Bio_Analysis_Attribute', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- study_design: check for any records that do not have a match in the taxonomy
	BEGIN
	INSERT INTO Cz_Rwg_Invalid_Terms (
		Study_Id,
		Category_Name,
		Term_Name )
	SELECT DISTINCT
		UPPER ( ext.Study_Id ),
		'study_design',
		ext.study_design
	FROM
		TM_LZ.Clinical_Trial_Metadata_Ext Ext
	WHERE
		UPPER ( ext.Study_Id ) = UPPER ( trialID )
		AND NOT EXISTS (
			SELECT
				UPPER ( Tax.Term_Name )
			FROM
				Searchapp.Search_Taxonomy Tax
			WHERE
				UPPER ( ext.experimental_design ) = UPPER ( Tax.Term_Name ) );
	
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'study design: register invalid terms (with no match in the taxonomy)', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	-- study_design: insert terms into attribute table
	BEGIN
	INSERT INTO Biomart.Bio_Analysis_Attribute (
		Study_Id,
		Bio_Assay_Analysis_Id,
		Term_Id,
		Source_Cd )
	SELECT DISTINCT
		UPPER ( Ext.Study_Id ),
		Xref.Bio_Assay_Analysis_Id,
		Tax.Term_Id,
		UPPER ( 'study_design:' || Ext.experimental_design )
	FROM
		TM_LZ.Clinical_Trial_Metadata_Ext Ext,
		Biomart.Bio_Analysis_Cohort_Xref Xref,
		Searchapp.Search_Taxonomy Tax
	WHERE
		UPPER ( Xref.Study_Id ) = UPPER ( ext.Study_Id )
		AND UPPER ( ( CASE
					WHEN Ext.experimental_design = 'Clinical' THEN 'Clinical Trial'
					ELSE ext.experimental_design
				END ) )
			= UPPER ( Tax.Term_Name )
		AND UPPER ( ext.study_id ) = UPPER ( trialID );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert study_design into Bio_Analysis_Attribute', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;

	--	populate biomart.bio_analysis_attribute_lineage in one shot
	BEGIN
	INSERT INTO biomart.bio_analysis_attribute_lineage (
		bio_analysis_attribute_id,
		ancestor_term_id,
		ancestor_search_keyword_id )
	SELECT
		baa.bio_analysis_attribute_id,
		baa.term_id,
		st.search_keyword_id
	FROM
		biomart.bio_analysis_attribute baa,
		searchapp.search_taxonomy st
	WHERE
		UPPER ( baa.study_id ) = UPPER ( trialID )
		AND baa.term_id = st.term_id;

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert attribute links into bio_analysis_attribute_lineage', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;
	/* END populate */

	/*Update the 'analysis_update_date' in bio_assay_analysis (this date is used by solr for incremental updates*/
	BEGIN
	UPDATE BIOMART.bio_assay_analysis baa
	SET
		ANALYSIS_UPDATE_DATE = now()
	WHERE
		UPPER ( baa.etl_id ) LIKE UPPER ( trialID || '%' );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Update ANALYSIS_UPDATE_DATE with LOCALTIMESTAMP', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
	END;
	PERFORM cz_write_audit(jobId,databaseName,procedureName,'End FUNCTION',0,stepCt,'Done');

	---Cleanup OVERALL JOB if this proc is being run standalone    
	IF newJobFlag = 1
		THEN
		PERFORM cz_end_audit (jobID, 'SUCCESS');
	END IF;
EXCEPTION
	WHEN SQLSTATE 'AA001' then
		stepCt := stepCt + 1;
		GET DIAGNOSTICS rowCt := ROW_COUNT;
		PERFORM cz_write_audit(Jobid,Databasename,Procedurename,'ERR: Check for analysis in rwg_analysis not in biomart.bio_assay_analysis',rowCt,stepCt,'Done');
		--Handle errors.
		PERFORM cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		--End Proc
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := 16;		
	WHEN OTHERS THEN
	errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		rtn_code := -16;
		RETURN;
END;

$$;


ALTER FUNCTION tm_cz.rwg_load_analysis_metadata(trialid text, i_study_data_category text, i_study_category_display text, currentjobid bigint, OUT rtn_code bigint) OWNER TO tm_cz;

--
-- Name: rwg_load_heat_map_results(text, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION rwg_load_heat_map_results(in_study_id text, currentjobid bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE

/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	--Audit variables
	newJobFlag    smallint;
	databaseName  varchar(100);
	procedureName varchar(100);
	jobID         bigint;
	stepCt        bigint;
	rowCt         bigint;
	errorNumber   varchar;
	errorMessage  varchar;

	sqlText    varchar(500);
	partExists boolean;
	partTable  text;
	i          integer;
	/*
	cursor cInsert is
	Select Distinct Decode(B1.Study_Id, 'C0524T03_RWG', 'C0524T03', B1.Study_Id) Study_Id, B1.Bio_Assay_Analysis_Id, Cohort_Id
	from biomart.bio_analysis_attribute b1, biomart.bio_analysis_cohort_xref b2
	Where B1.Bio_Assay_Analysis_Id = B2.Bio_Assay_Analysis_Id
	and upper(b1.study_id)=upper(in_study_id);
	Cursor Cdelete Is
	Select Distinct Bio_Assay_Analysis_Id
	From biomart.Heat_Map_Results
	where upper(trial_name) = upper(in_study_id);
	cursor ctaIds is
	select bio_assay_analysis_id
	from biomart.bio_assay_analysis
	where etl_id = upper(in_study_id) || ':RWG';
	cInsertRow cInsert%rowtype;
	cDeleteRow cDelete%rowtype;
	cCtaId ctaIds%rowtype;
	 */

BEGIN
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	SELECT current_user INTO databaseName; --(sic)
	procedureName := 'RWG_LOAD_HEAT_MAP_RESULTS';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF (coalesce(jobID::text, '') = '' OR jobID < 1)
		THEN
		newJobFlag := 1; -- True
		SELECT cz_start_audit(procedureName, databaseName) INTO jobID;
	END IF;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Start FUNCTION', 0, stepCt, 'Done');
	stepCt := 1;

	partTable := 'heat_map_results_' || lower(in_study_id);

	--	check if partition exists
	SELECT
		EXISTS (
			SELECT
				*
			FROM
				pg_tables
			WHERE
				schemaname = 'biomart'
				AND tablename = partTable )
		INTO partExists;

	IF NOT partExists THEN
		--	needed to add partition to table
		sqlText := 'CREATE TABLE biomart.' || partTable || '(' ||
			'CHECK (trial_name = ''' || upper(in_study_id) || ''') ' ||
			')'
			'INHERITS (biomart.heat_map_results) ' ||
			'TABLESPACE indx';

		BEGIN
		EXECUTE(sqlText);
		PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Adding partition to BIOMART.HEAT_MAP_RESULTS', 0, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

		sqlText := 'CREATE OR REPLACE RULE ' || partTable || '_insert AS ' ||
			'ON INSERT TO biomart.heat_map_results WHERE ' ||
			'(trial_name = ''' || upper(in_study_id) || ''') ' ||
			'DO INSTEAD INSERT INTO biomart.' || partTable || ' ' ||
			'VALUES(NEW.*)';
		BEGIN
		EXECUTE(sqlText);
		PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Adding rule to main table', 0, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

		-- this index is small and very effective for making the UI responsive
		sqlText := 'CREATE INDEX ' || partTable || '_sign_index ' ||
			'ON biomart.' || partTable || '(significant) ' ||
			'TABLESPACE indx';
		BEGIN
		EXECUTE(sqlText);
		PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Adding index to partition', 0, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;
	ELSE
		--truncate partition
		sqlText := 'TRUNCATE TABLE biomart.' || partTable;

		BEGIN
		EXECUTE(sqlText);
		GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Truncate partition in BIOMART.HEAT_MAP_RESULTS', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;
	END IF;

	--	Delete existing data for study from cta_results
	BEGIN
	DELETE
	FROM
		biomart.cta_results
	WHERE
		bio_assay_analysis_id IN (
			SELECT
				x.bio_assay_analysis_id
			FROM
				biomart.bio_assay_analysis x
			WHERE
				x.etl_id = UPPER ( in_study_id ) || ':RWG' );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete records for study from cta_results', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	--	changed to use sql instead of view, view pulled back all studies   20121203 JEA
	BEGIN
	INSERT INTO biomart.heat_map_results (
		subject_id,
		log_intensity,
		cohort_id,
		probe_id,
		bio_assay_feature_group_id,
		fold_change_ratio,
		tea_normalized_pvalue,
		bio_marker_name,
		bio_marker_id,
		search_keyword_id,
		bio_assay_analysis_id,
		trial_name,
		significant,
		gene_id,
		assay_id,
		preferred_pvalue )
	SELECT
		REPLACE ( REPLACE ( pd.sourcesystem_cd, xref.study_id, '' ),
			':', '' ) AS subject_id,
		md.log_intensity,
		cex.cohort_id,
		dma.probeset,
		baad.bio_assay_feature_group_id,
		baad.Fold_Change_Ratio,
		baad.tea_normalized_pvalue AS tea_normalized_pvalue,
		f.bio_marker_name,
		f.bio_marker_id,
		i.SEARCH_KEYWORD_ID,
		xref.bio_assay_analysis_id,
		xref.study_id,
		CASE
			WHEN ( ABS ( baaD.Fold_Change_Ratio ) > baa.Fold_Change_Cutoff
				OR COALESCE ( baaD.Fold_Change_Ratio ::TEXT, '' ) = '' )
			AND COALESCE ( baad.preferred_pvalue, baad.tea_normalized_pvalue )
				< baa.pvalue_cutoff
			AND ( ( baad.lsmean1 > baa.lsmean_cutoff
					OR baad.lsmean2 > baa.lsmean_cutoff )
				OR ( COALESCE ( baad.lsmean1 ::TEXT, '' ) = ''
					AND COALESCE ( baad.lsmean2 ::TEXT, '' ) = '' ) )
			THEN 1
			ELSE 0
		END Significant,
		f.Primary_External_Id,
		sm.assay_id,
		baad.preferred_pvalue
	FROM
		biomart.bio_analysis_cohort_xref xref
	INNER
		JOIN biomart.bio_cohort_exp_xref cex ON xref.study_id = cex.study_id
		AND xref.cohort_id = cex.cohort_id
	INNER
		JOIN deapp.de_subject_sample_mapping sm ON xref.study_id = sm.trial_name
		AND cex.exp_id = sm.assay_id::varchar
	INNER
		JOIN deapp.de_subject_microarray_data md ON md.trial_name = xref.study_id
		AND cex.exp_id = md.assay_id::varchar
	INNER
		JOIN tm_cz.probeset_deapp dma -- use tm_cz.probeset_deapp because there is only a single record for the probeset
		ON md.probeset_id = dma.probeset_id
	INNER
		JOIN i2b2demodata.patient_dimension pd ON sm.patient_id = pd.patient_num
	INNER
		JOIN biomart.bio_assay_analysis_data baad ON xref.bio_assay_analysis_id = baad.bio_assay_analysis_id
		AND baad.feature_group_name = dma.probeset
	INNER JOIN biomart.bio_assay_data_annotation e ON e.bio_assay_feature_group_id = baad.bio_assay_feature_group_id
	INNER JOIN biomart.bio_marker f ON f.bio_marker_id = e.bio_marker_id
	INNER
		JOIN biomart.bio_assay_analysis baa ON xref.bio_assay_analysis_id = baa.bio_assay_analysis_id
	INNER
		JOIN biomart.bio_marker_correl_mv h ON f.bio_marker_id = h.asso_bio_marker_id
		AND h.correl_type IN ( 'GENE', 'HOMOLOGENE_GENE', 'PROTEIN TO GENE' )
	INNER
		JOIN searchapp.search_keyword i ON f.bio_marker_id = i.bio_data_id
	WHERE
		xref.study_id = UPPER ( in_study_id );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert study to heat_map_results', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	BEGIN
	UPDATE BIOMART.bio_assay_analysis baa
	SET
		analysis_update_date = now()
	WHERE
		baa.bio_assay_analysis_id IN (
			SELECT
				x.bio_assay_analysis_id
			FROM
				biomart.bio_assay_analysis x
			WHERE
				x.etl_id = UPPER ( in_study_id ) || ':RWG' );

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Updated analysis_update_date for analyses of study', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	BEGIN
	INSERT INTO biomart.cta_results (
		bio_assay_analysis_id,
		search_keyword_id,
		keyword,
		bio_marker_id,
		bio_marker_name,
		gene_id,
		probe_id,
		fold_change,
		preferred_pvalue,
		organism )
	SELECT
		DISTINCT h.bio_assay_analysis_id,
		h.search_keyword_id,
		UPPER ( s.keyword ),
		h.bio_marker_id,
		b.bio_marker_name,
		b.primary_external_id,
		h.probe_id,
		h.fold_change_ratio,
		h.preferred_pvalue,
		b.organism
	FROM
		biomart.heat_map_results h,
		biomart.bio_marker b,
		searchapp.search_keyword s
	WHERE
		h.trial_name = UPPER ( in_study_id )
		AND h.bio_marker_id = b.bio_marker_id
		AND h.search_keyword_id = s.search_keyword_id;

	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Insert records for study into cta_results', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	PERFORM cz_write_audit(jobId,databaseName,procedureName,'FUNCTION Complete',0,stepCt,'Done');
	RETURN 0;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
		THEN
		PERFORM cz_end_audit (jobID, 'SUCCESS');
	END IF;
EXCEPTION
	WHEN OTHERS THEN
	errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
END;
$$;


ALTER FUNCTION tm_cz.rwg_load_heat_map_results(in_study_id text, currentjobid bigint) OWNER TO tm_cz;

--
-- Name: rwg_remove_study(text, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION rwg_remove_study(trialid text, currentjobid bigint DEFAULT NULL::bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
--Audit variables
	newJobFlag    smallint;
	databaseName  varchar(100);
	procedureName varchar(100);
	jobID         bigint;
	stepCt        bigint;
	rowCt         bigint;
	errorNumber   varchar;
	errorMessage  varchar;

	sqlText      varchar(500);
	partExists   boolean;
	V_BIO_EXP_ID bigint;
	partTable    text;

BEGIN
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	SELECT current_user INTO databaseName; --(sic)
	procedureName := 'RWG_REMOVE_STUDY';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF (coalesce(jobID::text, '') = '' OR jobID < 1)
		THEN
		newJobFlag := 1; -- True
		SELECT cz_start_audit(procedureName, databaseName) INTO jobID;
	END IF;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Start FUNCTION', 0, stepCt, 'Done');
	stepCt := 1;

	partTable := 'heat_map_results_' || lower(trialID);

	BEGIN
	SELECT bio_experiment_id INTO V_BIO_EXP_ID
	FROM biomart.bio_experiment
	WHERE UPPER ( accession ) LIKE UPPER ( trialID );
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Retrieved exp id ' || V_BIO_EXP_ID || ' for trial ' || upper(trialID), rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	--check that the experiment id exists
	IF NOT FOUND THEN
		RAISE 'Experiment is missing';
	END IF;

	/************* Delete existing records for study ******************/
	BEGIN
	DELETE
	FROM
		biomart.bio_analysis_attribute_lineage baal
	WHERE
		baal.bio_analysis_attribute_id IN (
			SELECT
				baa.bio_analysis_attribute_id
			FROM
				biomart.bio_analysis_attribute baa
			WHERE
				UPPER ( baa.study_id ) = UPPER ( trialID ) );
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing records from Biomart.bio_analysis_attribute_lineage', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	BEGIN
	DELETE
	FROM
		biomart.bio_analysis_attribute baa
	WHERE
		UPPER ( baa.study_id ) = UPPER ( trialID );
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing records from Biomart.bio_analysis_attribute', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	BEGIN
	DELETE
	FROM
		biomart.bio_analysis_cohort_xref bacx
	WHERE
		UPPER ( bacx.study_id ) = UPPER ( trialID );
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing records from Biomart.bio_analysis_cohort_xref', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	BEGIN
	DELETE
	FROM
		biomart.bio_cohort_exp_xref bcex
	WHERE
		UPPER ( bcex.study_id ) = UPPER ( trialID );
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing records from Biomart.bio_cohort_exp_xref', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	BEGIN
	DELETE
	FROM
		biomart.bio_assay_cohort bac
	WHERE
		UPPER ( bac.study_id ) = UPPER ( trialID );
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing records from Biomart.bio_assay_cohort', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	BEGIN
	DELETE
	FROM
		biomart.bio_assay_analysis_data baad
	WHERE
		baad.bio_experiment_id = V_BIO_EXP_ID;
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing records from Biomart.bio_assay_analysis_data', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	BEGIN
	DELETE
	FROM
		biomart.bio_assay_analysis baa
	WHERE
		baa.bio_assay_analysis_id IN (
			SELECT
				DISTINCT hmr.bio_assay_analysis_id
			FROM
				biomart.heat_map_results hmr
			WHERE
				hmr.trial_name = UPPER ( trialID ) );
	GET DIAGNOSTICS rowCt := ROW_COUNT;
	PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Delete existing records from Biomart.bio_assay_analysis', rowCt, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;

	/***********************************/
	/**** Remove Heat_map_resultes ***/
	/***********************************/
	/* Check if partition exist, truncate if so, create it if not */
	SELECT
		EXISTS (
			SELECT *
			FROM pg_tables
			WHERE
				schemaname = 'biomart'
				AND tablename = partTable )
    INTO partExists;

	IF partExists THEN
		sqlText := 'DROP TABLE biomart.' || partTable || ' CASCADE';
		BEGIN
		EXECUTE(sqlText);
		PERFORM cz_write_audit(jobId, databaseName, procedureName,
		'Drop partition table of heat_map_results', 0, stepCt, 'Done');
	stepCt := stepCt + 1;
	EXCEPTION
		WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
	END;
	END IF;

	PERFORM cz_write_audit(jobId,databaseName,procedureName,'FUNCTION Complete',0,stepCt,'Done');
	RETURN 0;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
		THEN
		PERFORM cz_end_audit (jobID, 'SUCCESS');
	END IF;
EXCEPTION
	WHEN OTHERS THEN
	errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		PERFORM cz_error_handler(jobID, procedureName, errorNumber, errorMessage);
		PERFORM cz_end_audit (jobID, 'FAIL');
		RETURN -16;
END;
$$;


ALTER FUNCTION tm_cz.rwg_remove_study(trialid text, currentjobid bigint) OWNER TO tm_cz;

--
-- Name: set_bio_data_uid_dis(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION set_bio_data_uid_dis() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  --jobRunID CONTROL.SYSTEM_JOB_RUN.JOB_RUN_ID%TYPE;
  --jobStepID CONTROL.SYSTEM_JOB_STEP.JOB_STEP_ID%TYPE;
--CREATE or REPLACE  SYNONYM genego for pictor.genego;

BEGIN

-------------------------------------------------------------------------------
-- Loads data from PICTOR into biomart_LZ
--  emt@20090310
--------------------------------------------------------------------------------
--  jobrunid := control.insert_system_job_run('LoadGeneGOPathways', 'Load All Pathways from GENEGO in PICTOR');

begin

  --jobStepID := control.insert_system_job_step(jobRunID, 'Insert disease pathways into bio_marker for GENEGO disease pathways'
  --, 'Insert disease pathways into bio_marker for GENEGO disease pathways', 22);
  EXECUTE 'delete from biomart.bio_data_uid where unique_id in
                    (select bio_disease_uid(mesh_code) from biomart.bio_disease)';
  EXECUTE 'insert into biomart.bio_data_uid(
                    bio_data_id, unique_id, bio_data_type)
                    PERFORM
                    bio_disease_id, bio_disease_uid(mesh_code), ''BIO_DISEASE''
                    from biomart.bio_disease
                    where not exists
                      (select 1 from biomart.bio_data_uid
                      where bio_disease_uid(bio_disease.mesh_code) = bio_data_uid.unique_id)';

  --control.update_system_job_step_pass(jobStepID, SQL%ROWCOUNT);
  commit;

end;
/*
control.update_system_job_run_pass(jobRunID);
exception
when others then
  control.update_system_job_step_fail(jobStepID, sqlcode, sqlerrm()
  , dbms_utility.format_error_stack, dbms_utility.format_error_backtrace);
  control.update_system_job_run_fail(jobRunID);
  */
end;






 
$$;


ALTER FUNCTION tm_cz.set_bio_data_uid_dis() OWNER TO tm_cz;

--
-- Name: set_bio_data_uid_path(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION set_bio_data_uid_path() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

 -- jobRunID CONTROL.SYSTEM_JOB_RUN.JOB_RUN_ID%TYPE;
 -- jobStepID CONTROL.SYSTEM_JOB_STEP.JOB_STEP_ID%TYPE;
--CREATE or REPLACE  SYNONYM genego for pictor.genego;

BEGIN

-------------------------------------------------------------------------------
-- Loads data from PICTOR into biomart_LZ
--  emt@20090310
--------------------------------------------------------------------------------
  --jobrunid := control.insert_system_job_run('LoadGeneGOPathways', 'Load All Pathways from GENEGO in PICTOR');



  --jobStepID := control.insert_system_job_step(jobRunID, 'Insert disease pathways into bio_marker for GENEGO disease pathways'
  --, 'Insert disease pathways into bio_marker for GENEGO disease pathways', 22);
  EXECUTE 'delete from biomart.bio_data_uid where unique_id in
                    (select biomarker_pathway_uid(primary_source_code, primary_external_id)
                    from bio_marker)';
  EXECUTE 'delete from biomart.bio_data_uid where unique_id in
                    (select biomarker_gene_uid(primary_external_id)
                    from bio_marker)';
  EXECUTE 'insert into biomart.bio_data_uid(
                    bio_data_id, unique_id, bio_data_type)
                    PERFORM
                    bio_marker_id
                    , biomarker_pathway_uid(primary_source_code, primary_external_id)
                    , ''BIO_MARKER.PATHWAY''
                    from bio_marker
                    where bio_marker_type=''PATHWAY''
                    and not exists
                      (select 1 from biomart.bio_data_uid
                      where biomarker_pathway_uid(bio_marker.primary_source_code, bio_marker.primary_external_id) =
                      bio_data_uid.unique_id)';
  EXECUTE 'insert into biomart.bio_data_uid(
                    bio_data_id, unique_id, bio_data_type)
                    PERFORM
                    bio_marker_id
                    , biomarker_gene_uid(primary_external_id)
                    , ''BIO_MARKER.GENE''
                    from bio_marker
                    where bio_marker_type=''GENE''
                    and not exists
                      (select 1 from biomart.bio_data_uid
                      where biomarker_gene_uid(bio_marker.primary_external_id) = bio_data_uid.unique_id)';


  --control.update_system_job_step_pass(jobStepID, SQL%ROWCOUNT);
  commit;


--control.update_system_job_run_pass(jobRunID);
--exception
--when others then
  --control.update_system_job_step_fail(jobStepID, sqlcode, sqlerrm()
  --, dbms_utility.format_error_stack, dbms_utility.format_error_backtrace);
  --control.update_system_job_run_fail(jobRunID);
end;






 
$$;


ALTER FUNCTION tm_cz.set_bio_data_uid_path() OWNER TO tm_cz;

--
-- Name: sf_xtab(character varying, numeric, character varying, bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION sf_xtab(v_variable character varying, v_protocol numeric, v_subject character varying, v_rowid bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


/******************************************************************************
   NAME:       sf_xtab
   PURPOSE:    This function serves to flatten the SAS to Oracle Conversion via
               the SLM Process. 

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        5/14/2009   George Kuebrich

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     sf_xtab
      Sysdate:         5/14/2009
      Date and Time:   5/14/2009, 8:33:45 AM, and 5/14/2009 8:33:45 AM
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
sqlstmt varchar(1000);
tmpVar varchar(500);

BEGIN
   
   tmpVar := null;
   EXECUTE 'select distinct value into STRICT  tmpVar
     from sideshow_eav a,
          protocol b,
          variable c
    where a.protocol_id=b.protocol_id
      and a.protocol_id=c.protocol_id
      and a.protocol_id=2 
      and a.variable_id=c.variable_id
      and a.subject_id=3
      and c.variable_name in (4)
      and a.row_id =5' USING v_protocol,v_subject,v_variable,v_rowid;
    
    --EXECUTE IMMEDIATE sqlstmt USING v_protocol,v_subject,v_variable;
  
   RETURN tmpVar;
    EXCEPTION
     WHEN NO_DATA_FOUND THEN
       NULL;
     
END sf_xtab; 
 
$$;


ALTER FUNCTION tm_cz.sf_xtab(v_variable character varying, v_protocol numeric, v_subject character varying, v_rowid bigint) OWNER TO tm_cz;

--
-- Name: tea_npv_precompute(double precision, double precision, double precision); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tea_npv_precompute(foldchg double precision, mu double precision, sigma double precision) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
 -------------------------------------------------------------------------------
  -- param foldChg: input is fold change ratio from from analysis_data table
  -- param mu: mean of all analsyis_data records for a given analysis
  -- param sigma: std dev of all analsyis_data records for a given analysis
  -------------------------------------------------------------------------------
  npv double precision;
  outlier_cutoff double precision:=1.0e-5;

BEGIN
  -- normalized p-value
  SELECT 1.0 - tm_cz.cum_normal_dist(abs(foldChg),mu,sigma) INTO npv;

  -- cap outliers to minimum value
  IF npv<outlier_cutoff THEN npv:= outlier_cutoff; END IF;

  RETURN npv;

END;
$$;


ALTER FUNCTION tm_cz.tea_npv_precompute(foldchg double precision, mu double precision, sigma double precision) OWNER TO tm_cz;

--
-- Name: text_parser(text); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION text_parser(text_to_parse text) RETURNS text[]
    LANGUAGE plpgsql
    AS $$
DECLARE

   start_pos bigint;
   end_pos   bigint;
   string_length integer;
   string_tokens varchar(32676);
   counter integer;
   token_value varchar(100);

   list_values text_table;


BEGIN
  -------------------------------------------------------------------------------
   -- Populates a temp_token table with parsed values for any comma separated list.
   -- Requires a type so that multiple records can exist for different uses.
   -- KCR@20090106 - First rev.
   -- Copyright c 2009 Recombinant Data Corp.
   -------------------------------------------------------------------------------

  --Add a delimiter to the end of the string so we dont lose last value
  string_tokens := text_to_parse || ',';

  --Initialize the collection
  list_values := _text() ;

  --get length of string
  string_length := length(string_tokens);

  --set start and end for first token
  start_pos := 1;
  end_pos   := instr(string_tokens,',',1,1);
  counter := 1;
  LOOP
    --Get substring
    token_value := substr(string_tokens, start_pos, end_pos - start_pos);

    --add values to collection
   list_values.EXTEND;
   list_values(list_Values.LAST):= token_value;

    --Check to see if we are done
    IF end_pos = string_length
    THEN
      EXIT;
    ELSE
      -- Increment Start Pos and End Pos
      start_pos := end_pos + 1;
      --increment counter
      counter := counter + 1;
      end_pos := instr(string_tokens, ',',1, counter);

    END IF;
  END LOOP;

  return list_values;

END text_parser;
 
$$;


ALTER FUNCTION tm_cz.text_parser(text_to_parse text) OWNER TO tm_cz;

--
-- Name: tf_trg_antigen_deapp(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_antigen_deapp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.ANTIGEN_ID is null then
 select nextval('tm_cz.SEQ_ANTIGEN_ID') into NEW.ANTIGEN_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_antigen_deapp() OWNER TO tm_cz;

--
-- Name: tf_trg_az_test_run_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_az_test_run_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.TEST_RUN_ID is null then
 select nextval('tm_cz.SEQ_CZ_TEST') into NEW.TEST_RUN_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_az_test_run_id() OWNER TO tm_cz;

--
-- Name: tf_trg_az_test_step_act_result(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_az_test_step_act_result() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.TEST_STEP_ACT_RESULT_ID is null then
 select nextval('tm_cz.SEQ_CZ_TEST') into NEW.TEST_STEP_ACT_RESULT_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_az_test_step_act_result() OWNER TO tm_cz;

--
-- Name: tf_trg_az_test_step_run_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_az_test_step_run_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.TEST_STEP_RUN_ID is null then
 select nextval('tm_cz.SEQ_CZ_TEST') into NEW.TEST_STEP_RUN_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_az_test_step_run_id() OWNER TO tm_cz;

--
-- Name: tf_trg_cz_data_file_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_cz_data_file_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.DATA_FILE_ID is null then
 select nextval('tm_cz.SEQ_CZ_DATA_FILE') into NEW.DATA_FILE_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_data_file_id() OWNER TO tm_cz;

--
-- Name: tf_trg_cz_data_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_cz_data_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.DATA_ID is null then
 select nextval('tm_cz.SEQ_CZ_DATA') into NEW.DATA_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_data_id() OWNER TO tm_cz;

--
-- Name: tf_trg_cz_dw_version_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_cz_dw_version_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.DW_VERSION_ID is null then
 select nextval('tm_cz.SEQ_CZ_DW_VERSION_ID') into NEW.DW_VERSION_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_dw_version_id() OWNER TO tm_cz;

--
-- Name: tf_trg_cz_form_layout_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_cz_form_layout_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.FORM_LAYOUT_ID is null then
 select nextval('tm_cz.SEQ_FORM_LAYOUT_ID') into NEW.FORM_LAYOUT_ID ;
if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_form_layout_id() OWNER TO tm_cz;

--
-- Name: tf_trg_cz_job_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_cz_job_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
      if NEW.JOB_ID is null then
        select nextval('tm_cz.SEQ_CZ_JOB_MASTER') into NEW.JOB_ID ;       
      end if;       
  RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_job_id() OWNER TO tm_cz;

--
-- Name: tf_trg_cz_message_seq_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_cz_message_seq_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if NEW.SEQ_ID is null then
 select nextval('tm_cz.SEQ_CZ_JOB_MESSAGE') into NEW.SEQ_ID ;
end if;
       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_message_seq_id() OWNER TO tm_cz;

--
-- Name: tf_trg_cz_personid(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_cz_personid() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin            
if NEW.PERSON_ID is null then          
select nextval('tm_cz.SEQ_CZ_PERSON_ID') into NEW.PERSON_ID ;       end if;      RETURN NEW; end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_personid() OWNER TO tm_cz;

--
-- Name: tf_trg_cz_seq_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_cz_seq_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
      if NEW.SEQ_ID is null then
        select nextval('tm_cz.SEQ_CZ_JOB_AUDIT') into NEW.SEQ_ID ;       
      end if;       
       RETURN NEW;
  end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_seq_id() OWNER TO tm_cz;

--
-- Name: tf_trg_cz_test_category_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_cz_test_category_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin            
if NEW.TEST_CATEGORY_ID is null then          
select nextval('tm_cz.SEQ_CZ') into NEW.TEST_CATEGORY_ID ;       end if;       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_test_category_id() OWNER TO tm_cz;

--
-- Name: tf_trg_cz_test_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_cz_test_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin      
if NEW.TEST_ID is null then          
select nextval('tm_cz.SEQ_CZ') into NEW.TEST_ID ;       end if;       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_test_id() OWNER TO tm_cz;

--
-- Name: tf_trg_cz_test_result_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_cz_test_result_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
if NEW.TEST_RESULT_ID is null then          
select nextval('tm_cz.SEQ_CZ') into NEW.TEST_RESULT_ID ;       end if;       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_test_result_id() OWNER TO tm_cz;

--
-- Name: tf_trg_cz_xtrial_ctrl_vocab_id(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_cz_xtrial_ctrl_vocab_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
if NEW.CTRL_VOCAB_ID is null then          
select nextval('tm_cz.SEQ_CZ') into NEW.CTRL_VOCAB_ID ;       end if;       RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_cz_xtrial_ctrl_vocab_id() OWNER TO tm_cz;

--
-- Name: tf_trg_probeset_deapp(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION tf_trg_probeset_deapp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
			if NEW.PROBESET_ID is null then
				select nextval('tm_cz.SEQ_PROBESET_ID') into NEW.PROBESET_ID ;       
			end if;   
	RETURN NEW;
end;
$$;


ALTER FUNCTION tm_cz.tf_trg_probeset_deapp() OWNER TO tm_cz;

--
-- Name: upgrade_mrna_data(bigint); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION upgrade_mrna_data(currentjobid bigint DEFAULT NULL::bigint) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

  
	--Audit variables
	newJobFlag 	integer(1);
	databaseName 	varchar(100);
	procedureName varchar(100);
	jobID 		bigint;
	stepCt 		bigint;
  
	gexStudy	varchar(200);
	gexSource	varchar(200);
	pExists		integer;
	tText		varchar(2000);
  
	Type gex_study_rec is record
	(trial_name	varchar(200)
	)
	);
  
	Type gex_study_tab is table of gex_study_rec;
  
	gex_study_array gex_study_tab;
  
	-- JEA@20120602	New


BEGIN

    stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Start upgrade_mrna_data',0,stepCt,'Done');
    COMMIT;
	
	--	get trial_names for all gex data
	
	select distinct trial_name
		  ,coalesce(source_cd,'STD') as source_cd
	bulk collect into gex_study_array
	from de_subject_sample_mapping
	where platform = 'MRNA_AFFYMETRIX'
	order by trial_name
			,source_cd;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Bulk Collect trial_names',SQL%ROWCOUNT,stepCt,'Done');
	
	for i in gex_study_array.first .. gex_study_array.last
	loop
		gexStudy := gex_study_array(i).trial_name;
		gexSource := gex_study_array(i).source_cd;
		
		--	check if new table is partitioned and if partition exists
		
		select count(*) into pExists
		from all_tables
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA_NEW'
		  and partitioned = 'YES';
		  
		if pExists > 0 then
			select count(*) into pExists
			from all_tab_partitions
			where table_name = 'DE_SUBJECT_MICROARRAY_DATA_NEW'
			  and partition_name = gexStudy || ':' || gexSource;
			  
			if pExists = 0 then
				tText := 'alter table deapp.de_subject_microarray_data_new add PARTITION "' || gexStudy || ':' || gexSource || 
						'"  VALUES (' || '''' || gexStudy || ':' || gexSource || '''' || ') ' ||
						   'NOLOGGING COMPRESS TABLESPACE "TRANSMART" ';
				EXECUTE(tText);
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Added ' || gexStudy || ':' || gexSource || ' partition to de_subject_microarray_data_new',0,stepCt,'Done');
			end if;
		end if;
		
		insert into deapp.de_subject_microarray_data_new
		(trial_source
		,trial_name
		,probeset_id
		,assay_id
		,patient_id
		,raw_intensity
		,log_intensity
		,zscore
		)
		PERFORM sm.trial_name || ':' || coalesce(sm.source_cd,'STD')
			  ,sm.trial_name
			  ,sd.probeset_id
			  ,sm.assay_id
			  ,sm.patient_id
			  ,sd.raw_intensity
			  ,sd.log_intensity
			  ,sd.zscore
		from de_subject_sample_mapping sm
			,de_subject_microarray_data sd
		where sm.trial_name = gexStudy
		  and sm.source_cd = gexSource
		  and sm.platform = 'MRNA_AFFYMETRIX'
		  and sm.assay_id = sd.assay_id;
		  
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Inserted ' || gexStudy || ':' || gexSource || ' to new table',SQL%ROWCOUNT,stepCt,'Done');
		COMMIT;	
			
	end loop;
		
	--	drop indexes on de_subject_microarray_data
	
	i2b2_mrna_index_maint('DROP',null,jobId);
	
	--	rename existing de_subject_microarray_data to _old
	
	EXECUTE('alter table deapp.de_subject_microarray_data rename to de_subject_microarray_data_old');
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Rename old de_subject_microarray_data',0,stepCt,'Done');
		
	--	rename _new to de_subject_microarray_data
	
	EXECUTE('alter table deapp.de_subject_microarray_data_new rename to de_subject_microarray_data');
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Rename old de_subject_microarray_data',0,stepCt,'Done');
		
	--	add indexes to de_subject_microarray_data
	
	i2b2_mrna_index_maint('ADD',null,jobId);
			
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_audit',0,stepCt,'Done');
	
    COMMIT;
	--Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;

	EXCEPTION
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		--End Proc
		cz_end_audit (jobID, 'FAIL');
	
END;

 
$_$;


ALTER FUNCTION tm_cz.upgrade_mrna_data(currentjobid bigint) OWNER TO tm_cz;

--
-- Name: util_create_synonym_all(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_create_synonym_all(v_fromzone character varying DEFAULT NULL::character varying, v_whattype character varying DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS'::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_CREATE or REPLACE _SYNONYM_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
	--The name of the table, proc, function or view.
	V_OBJNAME varchar(50);

	--Dynamic SQL line
	V_CMDLINE varchar(200);

	--Table list
	L_TABLE CURSOR FOR
		SELECT TABLE_NAME FROM ALL_TABLES WHERE OWNER = UPPER(V_FROMZONE);
	--View List
	L_VIEW CURSOR FOR
		SELECT VIEW_NAME FROM ALL_VIEWS WHERE OWNER = UPPER(V_FROMZONE);
	--Procedure and function list (OBJTYPE are PROCEDURE, FUNCTION, TRIGGER)
	L_PROCEDURE CURSOR (OBJTYPE character varying) FOR
		SELECT DISTINCT OBJECT_NAME FROM ALL_PROCEDURES
			WHERE OWNER = UPPER(V_FROMZONE) AND OBJECT_TYPE = OBJTYPE
      AND UPPER(OBJECT_NAME) NOT LIKE 'UTIL%';


BEGIN

	-- Create synonyms for Tables
	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN

		OPEN L_TABLE;
			FETCH L_TABLE INTO V_OBJNAME;
		WHILE L_TABLE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_TABLE  INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				RAISE NOTICE '%%', 'ERROR ' ,  V_CMDLINE;
				RAISE NOTICE '%', SQLERRM;
			END;
		END;
       END LOOP;
       CLOSE L_TABLE;
   end if;

	--CREATE or REPLACE  SYNONYMS FOR VIEWS
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN

		OPEN L_VIEW;
			FETCH L_VIEW INTO V_OBJNAME;
		WHILE L_VIEW%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_VIEW INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				RAISE NOTICE '%%', 'ERROR ' ,  V_CMDLINE;
				RAISE NOTICE '%', SQLERRM;
			END;
		END;
		END LOOP;
		CLOSE L_VIEW;
   END IF;

-- CREATE or REPLACE  SYNONYMS FOR PROCEDURES
	IF UPPER(V_WHATTYPE) LIKE '%FUNCTION%' THEN

		OPEN L_PROCEDURE('FUNCTION');
			FETCH L_PROCEDURE INTO V_OBJNAME;
		WHILE L_PROCEDURE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH l_procedure INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				RAISE NOTICE '%%', 'ERROR ' ,  V_CMDLINE;
				RAISE NOTICE '%', SQLERRM;
			END;
		END;
		END LOOP;
		CLOSE l_procedure;
   end if;

-- CREATE or REPLACE  SYNONYMS FOR FUNCTIONS
	IF UPPER(V_WHATTYPE) LIKE '%FUNCTION%' THEN

		OPEN l_procedure('FUNCTION');
			FETCH l_procedure INTO V_OBJNAME;
		WHILE l_procedure%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_PROCEDURE INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				RAISE NOTICE '%%', 'ERROR ' ,  V_CMDLINE;
				RAISE NOTICE '%', SQLERRM;
			END;
		END;
		END LOOP;
		CLOSE L_PROCEDURE;
   END IF;
END;
 
$$;


ALTER FUNCTION tm_cz.util_create_synonym_all(v_fromzone character varying, v_whattype character varying) OWNER TO tm_cz;

--
-- Name: util_drop_all(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_drop_all(v_whattype character varying DEFAULT 'PROCEDURES,FUNCTIONS,VIEWS,SYNONYMS'::character varying, v_dropifempty character varying DEFAULT 'Y'::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_DROP_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
   v_procname varchar(50);
   v_objtype varchar(50);
   v_table_name varchar(50);
   v_view_name varchar(50);
   v_synonym_name varchar(50);
   v_constraint_name varchar(50);


   l_table CURSOR FOR
     SELECT table_name from user_tables;

   l_view CURSOR FOR
     SELECT view_name from user_views;

   l_procedure CURSOR FOR
     SELECT distinct object_name, object_type from user_procedures;

   l_synonym CURSOR FOR
     SELECT synonym_name from user_synonyms;

   l_constraint CURSOR FOR
     SELECT distinct table_name, constraint_name from user_constraints;


BEGIN

   --util_make_object_list(v_whattype, v_things);

   -- drop procedure(s) or function(s)
   if upper(v_whattype) like 'FUNCTION' or upper(v_whattype) like 'FUNCTION' then
      open l_procedure;
      fetch l_procedure into v_procname, v_objtype;
      while l_procedure%FOUND
      loop
         -- dbms_output.put_line( v_objtype || '  ' || v_procname);
         EXECUTE 'drop '|| v_objtype || ' ' || v_procname;

         fetch l_procedure into v_procname, v_objtype;
      end loop;
      close l_procedure;
   end if;


   -- drop table(s)
   if upper(v_whattype) like 'TABLE' then
      open l_table;
      fetch l_table into v_table_name;
      while l_table%FOUND
      loop
         -- dbms_output.put_line( v_table_name);
         EXECUTE 'drop table '|| v_table_name || ' cascade constraints ';

         fetch l_table into v_table_name;
      end loop;
      close l_table;
   end if;

   -- drop synonyms(s)
   if upper(v_whattype) like 'SYNONYM' then
      open l_synonym;
      fetch l_synonym into v_synonym_name;
      while l_synonym%FOUND
      loop
         -- dbms_output.put_line( v_synonym_name);
         EXECUTE 'drop synonym ' || v_synonym_name ;

         fetch l_synonym into v_synonym_name;
      end loop;
      close l_synonym;
   end if;


   -- drop view(s)
   if upper(v_whattype) like 'VIEW' then
      open l_view;
      fetch l_view into v_view_name;
      while l_view%FOUND
      loop
         -- dbms_output.put_line( v_view_name);
         EXECUTE 'drop view '|| v_table_name ;

         fetch l_view into v_view_name;
      end loop;
      close l_view;
   end if;


   -- drop constraint(s)
   if upper(v_whattype) like 'CONSTRAINT' then
      open l_constraint;
      fetch l_constraint into v_table_name, v_constraint_name;
      while l_constraint%FOUND
      loop
         -- dbms_output.put_line( v_constraint_name);
         EXECUTE 'alter table '|| v_table_name || ' drop constraint '|| v_constraint_name ;

         fetch l_constraint into v_table_name, v_constraint_name;
      end loop;
      close l_constraint;
   end if;

END;
 
$$;


ALTER FUNCTION tm_cz.util_drop_all(v_whattype character varying, v_dropifempty character varying) OWNER TO tm_cz;

--
-- Name: util_drop_anything(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_drop_anything(v_objname character varying DEFAULT NULL::character varying, v_objtype character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_DROP_ANYTHING
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
   v_cmdline varchar(100);


BEGIN

   if upper(v_objtype) like 'TABLE%' then
       v_cmdline := 'drop '|| v_objtype || ' '|| v_objname || ' cascade constraint';
   else
       v_cmdline := 'drop '|| v_objtype || ' '|| v_objname;
   end if;

   BEGIN
      EXECUTE v_cmdline;
      RAISE NOTICE '%%', 'SUCCESS ' ,  v_cmdline;
   EXCEPTION
      WHEN OTHERS THEN
         RAISE NOTICE '%%', 'ERROR ' ,  v_cmdline;
   END;
END;
 
$$;


ALTER FUNCTION tm_cz.util_drop_anything(v_objname character varying, v_objtype character varying) OWNER TO tm_cz;

--
-- Name: util_drop_synonym(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_drop_synonym(v_objname character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_DROP_SYNONYM
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
   v_cmdline varchar(100);

   ts CURSOR FOR
     SELECT 'drop synonym ' || synonym_name || ' ' from user_synonyms;



BEGIN

  OPEN ts;
   FETCH ts INTO v_cmdline;
   WHILE ts%FOUND
   LOOP

      BEGIN
         BEGIN

            BEGIN
               EXECUTE v_cmdline;
               RAISE NOTICE '%%', 'SUCCESS ' ,  v_cmdline;
            END;
         EXCEPTION
            WHEN OTHERS THEN

               BEGIN
                  RAISE NOTICE '%%', 'ERROR ' ,  v_cmdline;
               END;
         END;
         FETCH ts INTO v_cmdline;
      END;
   END LOOP;
   CLOSE ts;
END;
 
$$;


ALTER FUNCTION tm_cz.util_drop_synonym(v_objname character varying) OWNER TO tm_cz;

--
-- Name: util_drop_synonym_by_owner(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_drop_synonym_by_owner(v_owner character varying, v_dropifempty character varying DEFAULT 'Y'::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_DROP_SYNONYM_BY_OWNER
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
   v_procname varchar(50);
   v_objtype varchar(50);
   v_table_name varchar(50);
   v_view_name varchar(50);
   v_synonym_name varchar(50);
   v_constraint_name varchar(50);


   l_synonym CURSOR FOR
     SELECT synonym_name from all_synonyms
	 where owner = v_owner;



BEGIN

   -- drop synonyms(s)

      open l_synonym;
      fetch l_synonym into v_synonym_name;
      while l_synonym%FOUND
      loop
         -- dbms_output.put_line( v_synonym_name);
         EXECUTE( 'drop synonym ' || v_synonym_name) ;

         fetch l_synonym into v_synonym_name;
      end loop;
      close l_synonym;



END;
 
$$;


ALTER FUNCTION tm_cz.util_drop_synonym_by_owner(v_owner character varying, v_dropifempty character varying) OWNER TO tm_cz;

--
-- Name: util_drop_table(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_drop_table(v_tabname character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_DROP_TABLE
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
  v_exists integer;
  v_cmdline varchar(200);


BEGIN

  --Check if table exists
  select count(*)
  into v_exists
  from user_tables
  where table_name = v_tabname;

  if v_exists > 0 then
     v_cmdline := 'drop table ' || v_tabname;
     EXECUTE v_cmdline;
  end if;

END;
 
$$;


ALTER FUNCTION tm_cz.util_drop_table(v_tabname character varying) OWNER TO tm_cz;

--
-- Name: util_grant_all(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_grant_all(username character varying DEFAULT 'DATATRUST'::character varying, v_whattype character varying DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES'::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER

	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names

    v_user      text2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  
BEGIN

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    RAISE NOTICE '%%%%', 'Owner ' ,  v_user  ,  '   Grantee ' ,  username;
    RAISE NOTICE 'Tables';

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          EXECUTE 'grant select on ' || L_TABLE.table_name || ' to ' || username;

       else
          --Grant full permissions on regular tables
          EXECUTE 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;

     END LOOP; --TABLE LOOP
     end if;

	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    RAISE NOTICE '%%%%', 'Owner ' ,  v_user  ,  '   Grantee ' ,  username;
    RAISE NOTICE 'Views';

     for L_VIEW in (select view_name from user_views ) LOOP
          EXECUTE 'grant select on ' || L_VIEW.view_name || ' to ' || username;

     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    RAISE NOTICE '%%', chr(10) ,  'Procedures, functions and packages';

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('FUNCTION', 'FUNCTION', 'PACKAGE') )
     LOOP

       EXECUTE 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
$$;


ALTER FUNCTION tm_cz.util_grant_all(username character varying, v_whattype character varying) OWNER TO tm_cz;

--
-- Name: util_grant_execute(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_grant_execute(v_to_zone character varying DEFAULT NULL::character varying, v_type character varying DEFAULT 'TABLES,VIEWS'::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_EXECUTE
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

   v_object_name varchar(50);
   v_cmdline varchar(200);

   l_table CURSOR FOR
        SELECT table_name from all_tables where owner = v_to_zone;

   l_view CURSOR FOR
        SELECT view_name from all_views where owner = v_to_zone;


BEGIN

   if upper(v_type) like '%TABLE%' then
       OPEN l_table;
       FETCH l_table INTO v_object_name;
       WHILE l_table%FOUND
       LOOP
          BEGIN
             v_cmdline := 'grant select on ' || v_object_name || ' to ' || v_to_zone;

             BEGIN

                BEGIN
                   EXECUTE v_cmdline;
                   RAISE NOTICE '%%', 'SUCCESS ' ,  v_cmdline;
                END;
             EXCEPTION
                WHEN OTHERS THEN

                   BEGIN
                      RAISE NOTICE '%%', 'ERROR ' ,  v_cmdline;
                   END;
             END;

             FETCH l_table INTO v_object_name;
          END;
       END LOOP;
       CLOSE l_table;
   end if;

   if upper(v_type) like '%VIEW%' then
       OPEN l_view;
       FETCH l_view INTO v_object_name;
       WHILE l_view%FOUND
       LOOP
          BEGIN

             v_cmdline := 'grant select on ' || v_object_name || ' to ' || v_to_zone;

             BEGIN

                BEGIN
                   EXECUTE v_cmdline;
                   RAISE NOTICE '%%', 'SUCCESS ' ,  v_cmdline;
                END;
             EXCEPTION
                WHEN OTHERS THEN

                   BEGIN
                      RAISE NOTICE '%%', 'ERROR ' ,  v_cmdline;
                   END;
             END;

             FETCH l_view INTO v_object_name;
          END;
       END LOOP;
       CLOSE l_view;
   end if;

END;
 
$$;


ALTER FUNCTION tm_cz.util_grant_execute(v_to_zone character varying, v_type character varying) OWNER TO tm_cz;

--
-- Name: util_grant_select(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_grant_select(username character varying DEFAULT 'DATATRUST'::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS SELECT PERMISSIONS to DATATRUST (default) or specified user
    --ON OBJECTS OWNED BY THE CURRENT USER

	--	JEA@20110927	New, cloned from UTIL_GRANT_ALL

    v_user      text2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  
BEGIN

    RAISE NOTICE '%%%%', 'Owner ' ,  v_user  ,  '   Grantee ' ,  username;
    RAISE NOTICE 'Tables';

     for L_TABLE in (select table_name from user_tables) LOOP

	 EXECUTE 'grant select on ' || L_TABLE.table_name || ' to ' || username;
          RAISE NOTICE '%%%%', 'grant select on ' ,  L_TABLE.table_name ,  ' to ' ,  username;

     END LOOP; --TABLE LOOP

 --  dbms_output.put_line(chr(10) || 'Views');

 --   for L_VIEW in (select object_name from user_objects where object_type = 'VIEW' )
  --   LOOP

   --    execute immediate 'grant select on ' || L_VIEW.object_name || ' to ' || username;
   --    DBMS_OUTPUT.put_line('grant select on ' || L_VIEW.object_name || ' to ' || username);

   --  END LOOP; --VIEW LOOP

END;
 
$$;


ALTER FUNCTION tm_cz.util_grant_select(username character varying) OWNER TO tm_cz;

--
-- Name: util_is_populated(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_is_populated(tabname character varying, OUT retval integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_IS_POPULATED
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
  sqltext varchar(500);
  l_count integer;


BEGIN

   sqltext := 'select count(*) into result from ' || tabname;

   EXECUTE sqltext into l_count;


   if l_count > 0 then
   retval :=1;
   else
    retval := 0;
   end if;

   --dbms_output.put_line(l_count);

end;
 
$$;


ALTER FUNCTION tm_cz.util_is_populated(tabname character varying, OUT retval integer) OWNER TO tm_cz;

--
-- Name: util_make_object_list(character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_make_object_list(v_whattype character varying DEFAULT NULL::character varying, OUT v_things character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_MAKE_OBJECT_LIST
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------


BEGIN

   v_things := REPLACE(UPPER(v_whattype), 'PROCEDURES', 'P,PC') ;
   v_things := REPLACE(UPPER(v_things), 'FUNCTION', 'P,PC') ;
   v_things := REPLACE(UPPER(v_things), 'CONSTRAINTS', 'PK,F') ;
   v_things := REPLACE(UPPER(v_things), 'CONSTRAINT', 'PK,F') ;
   v_things := REPLACE(UPPER(v_things), 'FUNCTIONS', 'FN') ;
   v_things := REPLACE(UPPER(v_things), 'FUNCTION', 'FN') ;
   v_things := REPLACE(UPPER(v_things), 'TABLES', 'U') ;
   v_things := REPLACE(UPPER(v_things), 'TABLE', 'U') ;
   v_things := REPLACE(UPPER(v_things), 'VIEWS', 'V') ;
   v_things := REPLACE(UPPER(v_things), 'VIEW', 'V') ;

   -- add more common names for things
   -- but now transform a,b into 'a','b'
   v_things := REPLACE(UPPER(v_things), ',', ''',''') ;
   v_things := '''' || v_things || '''' ;
END;
 
$$;


ALTER FUNCTION tm_cz.util_make_object_list(v_whattype character varying, OUT v_things character varying) OWNER TO tm_cz;

--
-- Name: util_recompile_all(); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_recompile_all() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_RECOMPILE_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
   v_proclist CURSOR FOR
     SELECT distinct 'alter '|| object_type || ' ' || object_name || ' compile '
     FROM user_procedures;

   v_procname varchar(50);


BEGIN

   OPEN v_proclist;
   FETCH v_proclist INTO v_procname;
   WHILE v_proclist%FOUND
   LOOP

      BEGIN
         BEGIN

            BEGIN
               EXECUTE v_procname;
               RAISE NOTICE '%%', 'succesfully compiled ' ,  v_procname;
            END;
         EXCEPTION
            WHEN OTHERS THEN

               BEGIN
                  RAISE NOTICE '%%', 'error compiling ' ,  v_procname;
               END;
         END;
         FETCH v_proclist INTO v_procname;
      END;
   END LOOP;
   -- while loop
   CLOSE v_proclist;-- procedure
END;
 
$$;


ALTER FUNCTION tm_cz.util_recompile_all() OWNER TO tm_cz;

--
-- Name: util_truncate_table(character varying, character varying); Type: FUNCTION; Schema: tm_cz; Owner: tm_cz
--

CREATE FUNCTION util_truncate_table(v_tabname character varying DEFAULT NULL::character varying, v_dummyarg character varying DEFAULT 'Y'::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

-------------------------------------------------------------------------------------
-- NAME: UTIL_TRUNCATE_TABLE
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
   v_cmdlist CURSOR IS
     /* disable all foreign key constraints on this table */
     PERFORM 'alter table ' || t1.owner ||'.' || t1.table_name ||' disable constraint '|| t1.constraint_name || '' cmd
     FROM user_constraints t1, user_constraints t2
     WHERE T1.CONSTRAINT_TYPE='R' and T1.R_CONSTRAINT_NAME=T2.CONSTRAINT_NAME and
        T2.TABLE_NAME = v_tabname
     UNION ALL
     /* finally actually truncate the table */
     PERFORM 'truncate table ' || v_tabname || '' cmd
     
     UNION ALL
     /* do a delete just incase the truncate failed */
     PERFORM 'delete from ' || v_tabname || '' cmd
     ;

   v_cmdline varchar(200);
   v_drop_if_populated integer;


BEGIN

   /* done with the SQL select - now process each command we selected */
   OPEN v_cmdlist;
   FETCH v_cmdlist INTO v_cmdline;
   WHILE v_cmdlist%FOUND
   LOOP

      BEGIN
         BEGIN

            BEGIN
               EXECUTE v_cmdline;
               RAISE NOTICE '%%', 'SUCCESS ' ,  v_cmdline;
            END;
         EXCEPTION
            WHEN OTHERS THEN

               BEGIN
                  RAISE NOTICE '%%', 'ERROR ' ,  v_cmdline;
               END;
         END;
         FETCH v_cmdlist INTO v_cmdline;
      END;
   END LOOP;
   -- while loop
   CLOSE v_cmdlist;-- procedure
END;
 
$$;


ALTER FUNCTION tm_cz.util_truncate_table(v_tabname character varying, v_dummyarg character varying) OWNER TO tm_cz;

SET search_path = tm_dataloader, pg_catalog;

--
-- Name: _final_median(anyarray); Type: FUNCTION; Schema: tm_dataloader; Owner: weymouth
--

CREATE FUNCTION _final_median(anyarray) RETURNS numeric
    LANGUAGE sql IMMUTABLE
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $_$
   SELECT AVG(val)
   FROM (
     SELECT val
     FROM unnest($1) val
     ORDER BY 1
     LIMIT  2 - MOD(array_upper($1, 1), 2)
     OFFSET CEIL(array_upper($1, 1) / 2.0) - 1
   ) sub;
$_$;


ALTER FUNCTION tm_dataloader._final_median(anyarray) OWNER TO weymouth;

--
-- Name: _final_median(double precision[]); Type: FUNCTION; Schema: tm_dataloader; Owner: weymouth
--

CREATE FUNCTION _final_median(double precision[]) RETURNS double precision
    LANGUAGE sql IMMUTABLE
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $_$
   SELECT AVG(val)
   FROM (
     SELECT val
     FROM unnest($1) val
     ORDER BY 1
     LIMIT  2 - MOD(array_upper($1, 1), 2)
     OFFSET CEIL(array_upper($1, 1) / 2.0) - 1
   ) sub;
$_$;


ALTER FUNCTION tm_dataloader._final_median(double precision[]) OWNER TO weymouth;

--
-- Name: cz_end_audit(numeric, character varying); Type: FUNCTION; Schema: tm_dataloader; Owner: weymouth
--

CREATE FUNCTION cz_end_audit(jobid numeric, jobstatus character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
declare
	endDate timestamp;
	rtnCd	numeric;

BEGIN

	select current_timestamp into endDate;

	begin
	update cz_job_master
		set
			active='N',
			end_date = endDate,
			time_elapsed_secs = coalesce(((DATE_PART('day', endDate - START_DATE) * 24 +
				   DATE_PART('hour', endDate - START_DATE)) * 60 +
				   DATE_PART('minute', endDate - START_DATE)) * 60 +
				   DATE_PART('second', endDate - START_DATE),0),
			job_status = jobStatus
		where active='Y'
		and job_id=jobID;
	end;

	return 1;

	exception
	when OTHERS then
		--raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
		select cz_write_error(jobId,SQLSTATE,SQLERRM,null,null) into rtnCd;
		return -16;
END;
$$;


ALTER FUNCTION tm_dataloader.cz_end_audit(jobid numeric, jobstatus character varying) OWNER TO weymouth;

--
-- Name: cz_error_handler(numeric, character varying, character varying, character varying); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION cz_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
	databaseName VARCHAR(100);
	--errorNumber		character varying;	--	PostgreSQL SQLSTATE is alphanumeric
	--errorNumber NUMBER(18,0);
	--errorMessage VARCHAR(1000);
	errorStack VARCHAR(4000);
	errorBackTrace VARCHAR(4000);
	stepNo numeric(18,0);

	rtnCd	integer;

BEGIN
	--Get DB Name
	select database_name INTO databaseName
	from cz_job_master
	where job_id=jobID;

	--Get Latest Step
	select max(step_number) into stepNo from cz_job_audit where job_id = jobID;

	--Get all error info, passed in as parameters, only available from EXCEPTION block
	--errorNumber := SQLSTATE;
	--errorMessage := SQLERRM;

	--	No corresponding functionality in PostgreSQL
	--errorStack := dbms_utility.format_error_stack;
	--errorBackTrace := dbms_utility.format_error_backtrace;

	--Update the audit step for the error
	select cz_write_audit(jobID, databaseName,procedureName, 'Job Failed: See error log for details',1, stepNo, 'FAIL') into rtnCd;

	--write out the error info
	select cz_write_error(jobID, errorNumber, errorMessage, errorStack, errorBackTrace) into rtnCd;

	return 1;

END;

$$;


ALTER FUNCTION tm_dataloader.cz_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) OWNER TO postgres;

--
-- Name: cz_start_audit(character varying, character varying); Type: FUNCTION; Schema: tm_dataloader; Owner: weymouth
--

CREATE FUNCTION cz_start_audit(jobname character varying, databasename character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
declare
	rtnCd	integer;
	jobId	numeric;
BEGIN
	begin
		insert into cz_job_master
			(start_date,
			active,
			database_name,
			job_name,
			job_status)
		VALUES(
			CURRENT_TIMESTAMP,
			'Y',
			databaseName,
			jobName,
			'Running')
	  RETURNING job_id INTO jobID;
	end;

  return jobID;

  exception
	when OTHERS then
		select cz_write_error(jobId,SQLERRML,SQLSTATE,SQLERRM,null,null) into rtnCd;
		return -16;

END;

$$;


ALTER FUNCTION tm_dataloader.cz_start_audit(jobname character varying, databasename character varying) OWNER TO weymouth;

--
-- Name: cz_write_audit(numeric, character varying, character varying, character varying, numeric, numeric, character varying); Type: FUNCTION; Schema: tm_dataloader; Owner: weymouth
--

CREATE FUNCTION cz_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
  /*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
DECLARE
        lastTime timestamp;
        currTime timestamp;
        elapsedSecs        numeric;
        rtnCd                numeric;

BEGIN

        select max(job_date)
    into lastTime
    from cz_job_audit
    where job_id = jobID;

        --        clock_timestamp() is the current system time

        select clock_timestamp() into currTime;

        elapsedSecs :=        coalesce(((DATE_PART('day', currTime - lastTime) * 24 +
                                   DATE_PART('hour', currTime - lastTime)) * 60 +
                                   DATE_PART('minute', currTime - lastTime)) * 60 +
                                   DATE_PART('second', currTime - lastTime),0);

        begin
        insert         into cz_job_audit
        (job_id
        ,database_name
         ,procedure_name
         ,step_desc
        ,records_manipulated
        ,step_number
        ,step_status
    ,job_date
    ,time_elapsed_secs
        )
        values(
                jobId,
                databaseName,
                procedureName,
                stepDesc,
                recordsManipulated,
                stepNumber,
                stepStatus,
                currTime,
                elapsedSecs
        );
          --raise notice '% / % / % seconds', stepDesc, recordsManipulated, elapsedSecs;
          raise notice '%: % [% / % recs / %s]', lastval(), stepDesc, stepStatus, recordsManipulated, round(elapsedSecs, 3);
        exception
        when OTHERS then
                --raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
                select cz_write_error(jobId,0::varchar,SQLSTATE::varchar,SQLERRM::varchar,null::varchar) into rtnCd;
                return -16;
        end;

        return 1;
END;
$$;


ALTER FUNCTION tm_dataloader.cz_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) OWNER TO weymouth;

--
-- Name: cz_write_error(numeric, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: tm_dataloader; Owner: weymouth
--

CREATE FUNCTION cz_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
  /*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

BEGIN

	begin
	insert into cz_job_error(
		job_id,
		error_number,
		error_message,
		error_stack,
		error_backtrace,
		seq_id)
	select
		jobID,
		errorNumber,
		errorMessage,
		errorStack,
		errorBackTrace,
		max(seq_id)
  from cz_job_audit
  where job_id=jobID;

  end;

  return 1;

  exception
	when OTHERS then
		raise notice 'proc failed state=%  errm=%', SQLSTATE, SQLERRM;
		return -16;

END;
$$;


ALTER FUNCTION tm_dataloader.cz_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) OWNER TO weymouth;

--
-- Name: i2b2_add_node(character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_add_node(trialid character varying, path character varying, path_name character varying, currentjobid numeric) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

  root_node		varchar(2000);
  root_level	integer;
  rtnCd			integer;
  
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
  
BEGIN
    
	stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := current_schema();
	procedureName := 'I2B2_ADD_NODE';
	
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobId;
	END IF;
  
	select parse_nth_value(path, 2, '\') into root_node;
	
	select c_hlevel into root_level
	from i2b2metadata.table_access
	where c_name = root_node;
  
	if path = ''  or path = '%' or path_name = ''
	then 
		select cz_write_audit(jobId,databaseName,procedureName,'Path or Path name missing, no action taken',0,stepCt,'Done') into rtnCd;
		return 1;
	end if;
	

	--Delete existing data.

	DELETE FROM i2b2demodata.OBSERVATION_FACT 	
	USING i2b2metadata.I2B2 WHERE i2b2metadata.I2B2.C_FULLNAME = PATH AND i2b2demodata.OBSERVATION_FACT.concept_cd = i2b2metadata.I2B2.C_BASECODE;
	--WHERE concept_cd IN (SELECT C_BASECODE FROM i2b2metadata.I2B2 WHERE C_FULLNAME = PATH);
	
	--get diagnostics rowCt := ROW_COUNT;
	--stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Deleted any concepts for path from I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--CONCEPT DIMENSION
	DELETE FROM i2b2demodata.CONCEPT_DIMENSION
	WHERE CONCEPT_PATH = path;
	--get diagnostics rowCt := ROW_COUNT;
	--stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Deleted any concepts for path from I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCd;
    
	--I2B2
	DELETE FROM i2b2metadata.i2b2
	WHERE C_FULLNAME = PATH;
	--get diagnostics rowCt := ROW_COUNT;
	--stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Deleted path from I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

	--	Insert new node
	
	--CONCEPT DIMENSION
	INSERT INTO i2b2demodata.CONCEPT_DIMENSION
	(CONCEPT_CD, CONCEPT_PATH, NAME_CHAR,  UPDATE_DATE,  DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD)
	VALUES
	(cast(nextval('i2b2demodata.concept_id') as varchar),
	path,
	path_name,
	current_timestamp,
	current_timestamp,
	current_timestamp,
	TrialID
	);
	--get diagnostics rowCt := ROW_COUNT;
	--stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Inserted concept for path into I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCD;

	--I2B2
	INSERT INTO i2b2metadata.I2B2
	(c_hlevel, C_FULLNAME, C_NAME, C_VISUALATTRIBUTES, c_synonym_cd, C_FACTTABLECOLUMN, C_TABLENAME, C_COLUMNNAME,
	C_DIMCODE, C_TOOLTIP, UPDATE_DATE, DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD, c_basecode, C_OPERATOR, c_columndatatype, c_comment,
	m_applied_path)
	SELECT 
	(length(concept_path) - coalesce(length(replace(concept_path, '\','')),0)) / length('\') - 2 + root_level,
	CONCEPT_PATH,
	NAME_CHAR,
	case when ((length(concept_path) - coalesce(length(replace(concept_path, '\','')),0)) / length('\') - 2 + root_level)=1 then 'FAS' else 'FA' end,
	'N',
	'CONCEPT_CD',
	'CONCEPT_DIMENSION',
	'CONCEPT_PATH',
	CONCEPT_PATH,
	CONCEPT_PATH,
	current_timestamp,
	current_timestamp,
	current_timestamp,
	SOURCESYSTEM_CD,
	CONCEPT_CD,
	'LIKE',
	'T',
	case when TrialID is null then null else 'trial:' || TrialID end,
	'@'
	FROM i2b2demodata.CONCEPT_DIMENSION
	WHERE 
	CONCEPT_PATH = path;

	--I2B2_secure
	INSERT INTO i2b2metadata.I2B2_SECURE
	(c_hlevel, C_FULLNAME, C_NAME, C_VISUALATTRIBUTES, c_synonym_cd, C_FACTTABLECOLUMN, C_TABLENAME, C_COLUMNNAME,
	C_DIMCODE, C_TOOLTIP, UPDATE_DATE, DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD, c_basecode, C_OPERATOR, c_columndatatype, c_comment,
	m_applied_path, secure_obj_token)
	SELECT
	(length(concept_path) - coalesce(length(replace(concept_path, '\','')),0)) / length('\') - 2 + root_level,
	CONCEPT_PATH,
	NAME_CHAR,
	'FA',
	'N',
	'CONCEPT_CD',
	'CONCEPT_DIMENSION',
	'CONCEPT_PATH',
	CONCEPT_PATH,
	CONCEPT_PATH,
	current_timestamp,
	current_timestamp,
	current_timestamp,
	SOURCESYSTEM_CD,
	CONCEPT_CD,
	'LIKE',
	'T',
	case when TrialID is null then null else 'trial:' || TrialID end,
	'@',
	'EXP:PUBLIC'
	FROM i2b2demodata.CONCEPT_DIMENSION
	WHERE
	CONCEPT_PATH = path;
	--get diagnostics rowCt := ROW_COUNT;
	--stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Inserted path into I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

      ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select cz_end_audit (jobID, 'SUCCESS') into rtnCD;
	END IF;

	return 1;
	
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

  
END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_add_node(trialid character varying, path character varying, path_name character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_add_root_node(character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_add_root_node(root_node character varying, currentjobid numeric) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
DECLARE
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);

	rootNode		varchar(200);
	rootPath		varchar(200);
	errorNumber		character varying;
	errorMessage	character varying;

	rtnCd			integer;

Begin
	rootNode := root_node;
	rootPath := '\' || rootNode || '\';

    stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := current_schema();
	procedureName := 'I2B2_ADD_ROOT_NODE';


	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobId;
	END IF;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Start ' || procedureName,0,stepCt,'Done') into rtnCd;

	begin

	insert into i2b2metadata.table_access
	(c_table_cd
	,c_table_name
	,c_protected_access
	,c_hlevel
	,c_fullname
	,c_name
	,c_synonym_cd
	,c_visualattributes
	,c_totalnum
	,c_basecode
	,c_metadataxml
	,c_facttablecolumn
	,c_dimtablename
	,c_columnname
	,c_columndatatype
	,c_operator
	,c_dimcode
	,c_comment
	,c_tooltip
	,c_entry_date
	,c_change_date
	,c_status_cd
	,valuetype_cd
	)
	select rootNode as c_table_cd
		  ,'i2b2' as c_table_name
		  ,'N' as protected_access
		  ,0 as c_hlevel
		  ,rootPath as c_fullname
		  ,rootNode as c_name
		  ,'N' as c_synonym_cd
		  ,'CAP' as c_visualattributes
		  ,null as c_totalnum
		  ,null as c_basecode
		  ,null as c_metadataxml
		  ,'concept_cd' as c_facttablecolumn
		  ,'concept_dimension' as c_dimtablename
		  ,'concept_path' as c_columnname
		  ,'T' as c_columndatatype
		  ,'LIKE' as c_operator
		  ,rootPath as c_dimcode
		  ,null as c_comment
		  ,rootPath as c_tooltip
		  ,current_timestamp as c_entry_date
		  ,null as c_change_date
		  ,null as c_status_cd
		  ,null as valuetype_cd
	where not exists
		(select 1 from i2b2metadata.table_access x
		 where x.c_table_cd = rootNode);
	get diagnostics rowCt := ROW_COUNT;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert to table_access',rowCt,stepCt,'Done') into rtnCd;

	--	insert root_node into i2b2

	insert into i2b2metadata.i2b2
	(c_hlevel
	,c_fullname
	,c_name
	,c_synonym_cd
	,c_visualattributes
	,c_totalnum
	,c_basecode
	,c_metadataxml
	,c_facttablecolumn
	,c_tablename
	,c_columnname
	,c_columndatatype
	,c_operator
	,c_dimcode
	,c_comment
	,c_tooltip
	,m_applied_path
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,valuetype_cd
	,m_exclusion_cd
	,c_path
	,c_symbol
	--,i2b2_id
	)
	select 0 as c_hlevel
		  ,rootPath as c_fullname
		  ,rootNode as c_name
		  ,'N' as c_synonym_cd
		  ,'CAP' as c_visualattributes
		  ,null as c_totalnum
		  ,null as c_basecode
		  ,null as c_metadataxml
		  ,'concept_cd' as c_facttablecolumn
		  ,'concept_dimension' as c_tablename
		  ,'concept_path' as c_columnname
		  ,'T' as c_columndatatype
		  ,'LIKE' as c_operator
		  ,rootPath as c_dimcode
		  ,null as c_comment
		  ,rootPath as c_tooltip
		  ,'@' as m_applied_path
		  ,current_timestamp as update_date
		  ,null as download_date
		  ,current_timestamp as import_date
		  ,null as sourcesystem_cd
		  ,null as valuetype_cd
		  ,null as m_exclusion_cd
		  ,null as c_path
		  ,null as c_symbol
		  --	add trigger on i2b2 insert
		  --,nextval('i2b2metadata.i2b2_id_seq')
		  --,I2B2_ID_SEQ.nextval as i2b2_id
	where not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where x.c_name = rootNode);
	get diagnostics rowCt := ROW_COUNT;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert root_node ' || rootNode || ' to i2b2',rowCt,stepCt,'Done') into rtnCd;

	--	insert root_node into i2b2

	insert into i2b2metadata.i2b2_secure
	(c_hlevel
	,c_fullname
	,c_name
	,c_synonym_cd
	,c_visualattributes
	,c_totalnum
	,c_basecode
	,c_metadataxml
	,c_facttablecolumn
	,c_tablename
	,c_columnname
	,c_columndatatype
	,c_operator
	,c_dimcode
	,c_comment
	,c_tooltip
	,m_applied_path
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,valuetype_cd
	,m_exclusion_cd
	,c_path
	,c_symbol
	,secure_obj_token
	--,i2b2_id
	)
	select 0 as c_hlevel
		  ,rootPath as c_fullname
		  ,rootNode as c_name
		  ,'N' as c_synonym_cd
		  ,'CA' as c_visualattributes
		  ,null as c_totalnum
		  ,null as c_basecode
		  ,null as c_metadataxml
		  ,'concept_cd' as c_facttablecolumn
		  ,'concept_dimension' as c_tablename
		  ,'concept_path' as c_columnname
		  ,'T' as c_columndatatype
		  ,'LIKE' as c_operator
		  ,rootPath as c_dimcode
		  ,null as c_comment
		  ,rootPath as c_tooltip
		  ,'@' as m_applied_path
		  ,current_timestamp as update_date
		  ,null as download_date
		  ,current_timestamp as import_date
		  ,null as sourcesystem_cd
		  ,null as valuetype_cd
		  ,null as m_exclusion_cd
		  ,null as c_path
		  ,null as c_symbol
		  ,'EXP:PUBLIC'
		  --	add trigger on i2b2 insert
		  --,nextval('i2b2metadata.i2b2_id_seq')
		  --,I2B2_ID_SEQ.nextval as i2b2_id
	where not exists
		 (select 1 from i2b2metadata.i2b2_secure x
		  where x.c_name = rootNode);
	get diagnostics rowCt := ROW_COUNT;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert root_node ' || rootNode || ' to i2b2_secure',rowCt,stepCt,'Done') into rtnCd;

	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done') into rtnCD;

	--Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_add_root_node(root_node character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_create_concept_counts(character varying, numeric, character varying); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_create_concept_counts(path character varying, currentjobid numeric DEFAULT (-1), buildtree character varying DEFAULT 'Y'::character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;
  
BEGIN
     IF(buildTree = 'Y')
	THEN
		SELECT I2B2_CREATE_FULL_TREE(path, currentJobID) INTO rtnCd;
	END IF;


	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := current_schema();
	procedureName := 'I2B2_CREATE_CONCEPT_COUNTS';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;
    	
	stepCt := 0;
  
	begin
	delete from i2b2demodata.concept_counts
	where concept_path like path || '%' escape '`';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete counts for trial from I2B2DEMODATA concept_counts',rowCt,stepCt,'Done') into rtnCd;

	--	Join each node (folder or leaf) in the path to it's leaf in the work table to count patient numbers

	begin
	insert into i2b2demodata.concept_counts
	(concept_path
	,parent_concept_path
	,patient_count
	)
	select fa.c_fullname
		  ,ltrim(SUBSTR(fa.c_fullname, 1,instr(fa.c_fullname, '\',-1,2)))
		  ,count(distinct tpm.patient_num)
	from i2b2metadata.i2b2 fa
	    ,i2b2metadata.i2b2 la
		,i2b2demodata.observation_fact tpm
		,i2b2demodata.patient_dimension p
		,I2B2_LOAD_TREE_FULL tree
	where fa.c_fullname like path || '%' escape '`'
	  and substr(fa.c_visualattributes,2,1) != 'H'
	  --and la.c_fullname like fa.c_fullname || '%' escape '`'
	  and fa.RECORD_ID = tree.IDROOT 
	  and la.RECORD_ID = tree.IDCHILD
	  and la.c_visualattributes like 'L%'
	  and tpm.patient_num = p.patient_num
	  and la.c_basecode = tpm.concept_cd   -- outer join in oracle ???
	group by fa.c_fullname
			,ltrim(SUBSTR(fa.c_fullname, 1,instr(fa.c_fullname, '\',-1,2)));
	get diagnostics rowCt := ROW_COUNT;		
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert counts for trial into I2B2DEMODATA concept_counts',rowCt,stepCt,'Done') into rtnCd;
	
	/*SELECT count(*) INTO rowCt FROM
(
	select fa.c_fullname
		  ,ltrim(SUBSTR(fa.c_fullname, 1,instr(fa.c_fullname, '\',-1,2)))
		  ,count(distinct tpm.patient_num)
	from i2b2metadata.i2b2 fa
	    ,i2b2metadata.i2b2 la
		,i2b2demodata.observation_fact tpm
		,i2b2demodata.patient_dimension p
		,I2B2_LOAD_TREE_FULL tree
	where fa.c_fullname like '\Private Studies\Jace_Study_C0168T37' || '%' escape '`'
	  and substr(fa.c_visualattributes,2,1) != 'H'
	 -- and la.c_fullname like fa.c_fullname || '%' escape '`'
	  and fa.RECORD_ID = tree.IDROOT 
	  and la.RECORD_ID = tree.IDCHILD
	  and la.c_visualattributes like 'L%'
	  and tpm.patient_num = p.patient_num
	  and la.c_basecode = tpm.concept_cd   -- outer join in oracle ???
	group by fa.c_fullname
			,ltrim(SUBSTR(fa.c_fullname, 1,instr(fa.c_fullname, '\',-1,2)))

) t;

	select cz_write_audit(jobId,databaseName,procedureName,'Insert TEST counts for trial into I2B2DEMODATA concept_counts',rowCt,stepCt,'Done') into rtnCd;*/
	
	--SET ANY NODE WITH MISSING OR ZERO COUNTS TO HIDDEN

	begin
	update i2b2metadata.i2b2
	set c_visualattributes = substr(c_visualattributes,1,1) || 'H' || substr(c_visualattributes,3,1)
	where c_fullname like path || '%' escape '`'
	  and (not exists
			 (select 1 from concept_counts nc
				  where c_fullname = nc.concept_path)
				 or
			 exists
				 (select 1 from concept_counts zc
				  where c_fullname = zc.concept_path
					and zc.patient_count = 0)
			  )
		and c_name != 'SECURITY';
	get diagnostics rowCt := ROW_COUNT;	
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Nodes hidden with missing/zero counts for trial into I2B2DEMODATA concept_counts',rowCt,stepCt,'Done') into rtnCd;
		
	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_create_concept_counts(path character varying, currentjobid numeric, buildtree character varying) OWNER TO postgres;

--
-- Name: i2b2_create_full_tree(character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_create_full_tree(path character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
DECLARE
	parent_c CURSOR FOR
	SELECT p.PATH, p.record_id, p.PATH_LEN FROM I2B2_LOAD_PATH p;
	rowCt			numeric(18,0);
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	rtnCd			numeric;
BEGIN

	databaseName := current_schema();
	procedureName := 'I2B2_CREATE_FULL_TREE';


	DELETE FROM I2B2_LOAD_PATH;

	--Remove duplicates
	INSERT INTO I2B2_LOAD_PATH(PATH, RECORD_ID, PATH_LEN)
	SELECT P, MIN(RECORD_ID), LENGTH(P) FROM
	(
		SELECT  LOWER(SUBSTR(p.c_fullname, LENGTH(path), LENGTH(p.c_fullname) - LENGTH(path) + 1)) as P, p.RECORD_ID, 0 as PATH_LEN
		from i2b2metadata.i2b2 p
		where p.c_fullname like path || '%' escape '`'
	) t
	GROUP BY P;

	UPDATE I2B2_LOAD_PATH p SET PATH200 = SUBSTR(p.PATH, 1, 200), PATH150 = SUBSTR(p.PATH, 1, 150), PATH100 = SUBSTR(p.PATH, 1, 100), PATH50 = SUBSTR(p.PATH, 1, 50);

	ANALYZE I2B2_LOAD_PATH;

	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(currentjobid, databaseName, procedureName,'Inserted into I2B2_LOAD_PATH',rowCt,0,'Done') into rtnCd;

	--execute immediate('analyze table I2B2_LOAD_PATH compute statistics');
	--execute immediate('truncate table I2B2_LOAD_TREE_FULL');

	DROP INDEX IF EXISTS TM_WZ_IDX_ROOT;
	DROP INDEX IF EXISTS TM_WZ_IDX_CHILD;
	DELETE FROM I2B2_LOAD_TREE_FULL;

	/*FOR p IN parent_c LOOP
		BEGIN
			INSERT INTO I2B2_LOAD_TREE_FULL(IDROOT, IDCHILD)
			SELECT p.RECORD_ID, c.RECORD_ID
			from I2B2_LOAD_PATH c
			where c.PATH_LEN >= p.PATH_LEN AND c.PATH like p.PATH || '%' escape '`';
		END;
	END LOOP;*/

	--PROCESS 200 < LENS
	INSERT INTO I2B2_LOAD_TREE_FULL(IDROOT, IDCHILD)
	SELECT p.RECORD_ID, c.RECORD_ID
	from I2B2_LOAD_PATH c, I2B2_LOAD_PATH p
	where p.PATH_LEN > 200 AND c.PATH200 = p.PATH200 AND c.PATH_LEN >= p.PATH_LEN AND c.PATH like p.PATH || '%' escape '`';

	--PROCESS 200 >= LENS > 150
	INSERT INTO I2B2_LOAD_TREE_FULL(IDROOT, IDCHILD)
	SELECT p.RECORD_ID, c.RECORD_ID
	from I2B2_LOAD_PATH c, I2B2_LOAD_PATH p
	where p.PATH_LEN > 150 AND p.PATH_LEN <= 200 AND c.PATH150 = p.PATH150 AND c.PATH_LEN >= p.PATH_LEN AND c.PATH like p.PATH || '%' escape '`';


	--PROCESS 150 >= LENS > 100
	INSERT INTO I2B2_LOAD_TREE_FULL(IDROOT, IDCHILD)
	SELECT p.RECORD_ID, c.RECORD_ID
	from I2B2_LOAD_PATH c, I2B2_LOAD_PATH p
	where p.PATH_LEN > 100 AND p.PATH_LEN <= 150 AND c.PATH100 = p.PATH100 AND c.PATH_LEN >= p.PATH_LEN AND c.PATH like p.PATH || '%' escape '`';

	--PROCESS 100 >= LENS > 50
	INSERT INTO I2B2_LOAD_TREE_FULL(IDROOT, IDCHILD)
	SELECT p.RECORD_ID, c.RECORD_ID
	from I2B2_LOAD_PATH c, I2B2_LOAD_PATH p
	where p.PATH_LEN > 50  AND p.PATH_LEN <= 100 AND c.PATH50 = p.PATH50 AND c.PATH_LEN >= p.PATH_LEN AND c.PATH like p.PATH || '%' escape '`';

	--PROCESS LENS < 50
	INSERT INTO I2B2_LOAD_TREE_FULL(IDROOT, IDCHILD)
	SELECT p.RECORD_ID, c.RECORD_ID
	from I2B2_LOAD_PATH c, I2B2_LOAD_PATH p
	where p.PATH_LEN <= 50 AND c.PATH_LEN >= p.PATH_LEN AND c.PATH like p.PATH || '%' escape '`';

	SELECT COUNT(*) FROM I2B2_LOAD_TREE_FULL INTO rowCt;
	--get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(currentjobid, databaseName, procedureName,'Inserted into I2B2_LOAD_TREE_FULL',rowCt,0,'Done') into rtnCd;

	CREATE INDEX TM_WZ_IDX_ROOT ON I2B2_LOAD_TREE_FULL (IDROOT, IDCHILD);
	CREATE INDEX TM_WZ_IDX_CHILD ON I2B2_LOAD_TREE_FULL (IDCHILD, IDROOT);

	--VERY SLOW IN POSTGRESQL
	/*INSERT INTO I2B2_LOAD_TREE_FULL
	SELECT p.RECORD_ID, c.RECORD_ID
	from I2B2_LOAD_PATH p ,I2B2_LOAD_PATH c
	where c.PATH like p.PATH || '%' escape '`';*/

	RETURN 0;
END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_create_full_tree(path character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_delete_1_node(character varying); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_delete_1_node(path character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare
 
	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;
	
BEGIN

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;
    	
	stepCt := 0;
	--stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_delete_1_node: ' || path,0,stepCt,'Done') into rtnCd;
	
	if coalesce(path,'') = ''  or path = '%' 
	then 
		select cz_write_audit(jobId,databaseName,procedureName,'Path missing, no action taken',0,stepCt,'Done') into rtnCd;
		return 1;
	end if;
	
    --I2B2
	begin
    delete from i2b2demodata.observation_fact 
    where concept_cd in (select c_basecode from i2b2metadata.i2b2 where c_fullname = path);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	--stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;

      --CONCEPT DIMENSION
	begin
    delete from i2b2demodata.concept_dimension
    WHERE CONCEPT_PATH = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	--stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Delete data from concept_dimension',rowCt,stepCt,'Done') into rtnCd;
    
    --I2B2
	begin
    delete from i2b2metadata.i2b2
    where c_fullname = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	--stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Delete data from i2b2',rowCt,stepCt,'Done') into rtnCd;
	
	--i2b2_secure
	begin
    delete from i2b2metadata.i2b2_secure
    where c_fullname = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	--stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Delete data from i2b2_secure',rowCt,stepCt,'Done') into rtnCd;

	--concept_counts
	begin
    delete from i2b2demodata.concept_counts
    where concept_path = path;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;	
	end;
	--stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Delete data from concept_counts',rowCt,stepCt,'Done') into rtnCd;
		
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_delete_1_node',rowCt,stepCt,'Done') into rtnCd;
	
	return 1;
  
END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_delete_1_node(path character varying) OWNER TO postgres;

--
-- Name: i2b2_delete_all_data(character varying, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: weymouth
--

CREATE FUNCTION i2b2_delete_all_data(trial_id character varying, path_string character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
Declare
  TrialID   varchar(100);
  pathString  VARCHAR(700);
  TrialType 	VARCHAR(250);
  sourceCD  	VARCHAR(250);

  -- vcf datasets
  vcfDataSetId varchar(100);
  vcfDataSets CURSOR is
    select distinct v.dataset_id
    from  deapp.de_subject_sample_mapping sm, deapp.de_variant_subject_summary v
    where sm.assay_id = v.assay_id;

  --Audit variables
  rowCt		numeric(18,0);
  trialCount INTEGER;
  pathCount INTEGER;
  countNodeUnderTop INTEGER;
  topNode	VARCHAR(500);
  topNodeCount	INTEGER;
  isExistTopNode integer;
  sourceCDCount INTEGER;
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID numeric(18,0);
  stepCt numeric(18,0);
  rtnCd	 integer;
BEGIN
  databaseName := current_schema();
  procedureName := 'i2b2_delete_all_data';

  select case when coalesce(currentjobid, -1) < 1 then cz_start_audit(procedureName, databaseName) else currentjobid end into jobId;

  if (path_string is not null) then
	  pathString := REGEXP_REPLACE('\' || path_string || '\','(\\){2,}', '\','g');
  end if;

  if (trial_id is null) then
	  select count(distinct trial_name) into trialCount
		from DEAPP.de_subject_sample_mapping where concept_code in (
			select concept_cd from I2B2DEMODATA.concept_dimension where concept_path like path_string || '%' ESCAPE '`'
		);
    if (trialCount = 1) then
      select distinct trial_name into TrialId
        from DEAPP.de_subject_sample_mapping where concept_code in (
          select concept_cd from I2B2DEMODATA.concept_dimension where concept_path like path_string || '%' ESCAPE '`'
        );
    ELSIF ( trialCount = 0 ) THEN
      TrialId := null;
    else
      stepCt := stepCt + 1;
      select cz_write_audit(jobId,databasename,procedurename,'Please select right path to study',1,stepCt,'ERROR') into rtnCd;
      select cz_error_handler(jobid, procedurename, '-1', 'Application raised error') into rtnCd;
      select cz_end_audit (jobId,'FAIL') into rtnCd;
      return -16;
    end if;
  else
	  TrialId := trial_id;
  end if;

  if (path_string is null) then
    SELECT DISTINCT ON (i2b2.sourcesystem_cd) i2b2.c_fullname into pathString
    FROM i2b2metadata.i2b2
    WHERE i2b2.sourcesystem_cd = TrialID
    ORDER BY i2b2.sourcesystem_cd, char_length(i2b2.c_fullname::text);

    if pathString is null then
      stepCt := stepCt + 1;
      select cz_write_audit(jobId,databasename,procedurename, 'No study with id ''' || TrialId || ''' found',1,stepCt,'ERROR') into rtnCd;
      select cz_error_handler(jobid, procedurename, '-1', 'Application raised error') into rtnCd;
      select cz_end_audit (jobId,'FAIL') into rtnCd;
      return -16;
    end if;
  else
    pathString := path_string;
  end if;

  select count(parent_concept_path) into topNodeCount
    from I2B2DEMODATA.concept_counts
    where
    concept_path = pathString;

  if (topNodeCount > 0) then
    select parent_concept_path into topNode
      from I2B2DEMODATA.concept_counts
      where
      concept_path = pathString;
  else
    topNode := substring(pathString from 1 for position('\' in substring(pathString from 2))+1);
  end if;


  stepCt := 0;

  if pathString != '' or pathString != '%' then
	  stepCt := stepCt + 1;
    if (TrialID is null) then
      select cz_write_audit(jobId,databaseName,procedureName,'Starting I2B2_DELETE_ALL_DATA for ''' || pathString || '''',0,stepCt,'Done') into rtnCd;
    else
      select cz_write_audit(jobId,databaseName,procedureName,'Starting I2B2_DELETE_ALL_DATA for ''' || pathString || ''' with id: ' || TrialId,0,stepCt,'Done') into rtnCd;
    end if;

  --	delete all i2b2 nodes

  select i2b2_delete_all_nodes(pathString,jobId) into rtnCd;

  --	delete any table_access data
  delete from i2b2metadata.table_access
  where c_fullname like pathString || '%' ESCAPE '`';
	--	delete any i2b2_tag data

	delete from i2b2metadata.i2b2_tags
	where path like pathString || '%' ESCAPE '`';
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_tags',rowCt,stepCt,'Done') into rtnCd;


	--	delete clinical data
	if (trialId is not NUll)
	then
		delete from lz_src_clinical_data
		where study_id = trialId;
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from lz_src_clinical_data',rowCt,stepCt,'Done') into rtnCd;

    FOR vcfDataSet in vcfDataSets LOOP
      vcfDataSetId := vcfDataSet.dataset_id;

      /*Deleting data from de_variant_subject_summary*/
      delete from deapp.de_variant_subject_summary v
      where v.dataset_id = vcfDataSetId;

      stepCt := stepCt + 1;
      get diagnostics rowCt := ROW_COUNT;
      select cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_variant_subject_summary',rowCt,stepCt,'Done') into rtnCd;

      delete from deapp.de_variant_population_data where dataset_id = vcfDataSetId;
      stepCt := stepCt + 1;
      get diagnostics rowCt := ROW_COUNT;
      select cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_variant_population_data',rowCt,stepCt,'Done') into rtnCd;

      delete from deapp.de_variant_population_info where dataset_id = vcfDataSetId;
      stepCt := stepCt + 1;
      get diagnostics rowCt := ROW_COUNT;
      select cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_variant_population_info',rowCt,stepCt,'Done') into rtnCd;

      delete from deapp.de_variant_subject_detail where dataset_id = vcfDataSetId;
      stepCt := stepCt + 1;
      get diagnostics rowCt := ROW_COUNT;
      select cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_variant_subject_detail',rowCt,stepCt,'Done') into rtnCd;

      delete from deapp.de_variant_subject_idx where dataset_id = vcfDataSetId;
      stepCt := stepCt + 1;
      get diagnostics rowCt := ROW_COUNT;
      select cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_variant_subject_idx',rowCt,stepCt,'Done') into rtnCd;


      delete from deapp.de_variant_dataset where dataset_id = vcfDataSetId;
      stepCt := stepCt + 1;
      get diagnostics rowCt := ROW_COUNT;

      select cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_variant_dataset',rowCt,stepCt,'Done') into rtnCd;
    END LOOP;

		--	delete observation_fact SECURITY data, do before patient_dimension delete
		select count(x.source_cd) into sourceCDCount
			  from deapp.de_subject_sample_mapping x
			  where x.trial_name = trialId;
    if (sourceCDCount <>0) then
      select distinct x.source_cd into sourceCD
          from deapp.de_subject_sample_mapping x
          where x.trial_name = trialId;
    else
      sourceCD := null;
    end if;

		delete from i2b2demodata.observation_fact f
		where f.concept_cd = 'SECURITY'
		  and f.patient_num in
			 (select distinct p.patient_num from i2b2demodata.patient_dimension p
			  where p.sourcesystem_cd like trialId || ':%');
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,'Delete SECURITY data for trial from I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;
		/*commit;*/


		delete from deapp.de_subject_microarray_data
		where trial_name = trialId
		and assay_id in (
		  select dssm.assay_id from
			lt_src_mrna_subj_samp_map ltssm
			left join
			deapp.de_subject_sample_mapping dssm
			on
			dssm.trial_name = ltssm.trial_name
			and dssm.gpl_id = ltssm.platform
			and dssm.subject_id = ltssm.subject_id
			and dssm.sample_cd  = ltssm.sample_cd
		  where
			dssm.trial_name = trialId
			and coalesce(dssm.source_cd,'STD') = sourceCd
		);
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from deapp de_subject_microarray_data',rowCt,stepCt,'Done') into rtnCd;
		/*commit;*/

		delete from deapp.de_subject_sample_mapping where
		  assay_id in (
			select dssm.assay_id from
			  lt_src_mrna_subj_samp_map ltssm
			  left join
			  deapp.de_subject_sample_mapping dssm
			  on
			  dssm.trial_name     = ltssm.trial_name
			  and dssm.gpl_id     = ltssm.platform
			  and dssm.subject_id = ltssm.subject_id
			  and dssm.sample_cd  = ltssm.sample_cd
			where
			  dssm.trial_name = trialID
			  and coalesce(dssm.source_cd,'STD') = sourceCd);

		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

		/*commit;*/


		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

		/*commit;*/
		--	delete patient data

		delete from i2b2demodata.patient_dimension
		where sourcesystem_cd like trialId || ':%';
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_dimension',rowCt,stepCt,'Done') into rtnCd;
		/*commit;*/

		delete from i2b2demodata.patient_trial
		where trial=  trialId;
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',rowCt,stepCt,'Done') into rtnCd;
		/*commit;*/
	end if;

	/*Check and delete top node, if removed node is last*/
    stepCt := stepCt + 1;
    select cz_write_audit(jobId,databaseName,procedureName,'Check and delete top node '||topNode||' if removed node is last',0,stepCt,'Done') into rtnCd;
    select count(*) into countNodeUnderTop
    from I2B2DEMODATA.concept_counts
    where parent_concept_path = topNode;

      stepCt := stepCt + 1;
	  get diagnostics rowCt := ROW_COUNT;
      select cz_write_audit(jobId,databaseName,procedureName,'Check if need to remove top node '||topNode,rowCt,stepCt,'Done') into rtnCd;

      if (countNodeUnderTop = 0)
      then
        select count(*) into isExistTopNode
             from I2B2METADATA.i2b2
            where c_fullname = topNode;

        if (isExistTopNode !=0 ) then
          select i2b2_delete_all_data(null, topNode, jobID) into rtnCd;
        end if;
      end if;

  end if;

  perform cz_end_audit (jobID, 'SUCCESS') where coalesce(currentJobId, -1) <> jobId;

  return 1;
END;
$$;


ALTER FUNCTION tm_dataloader.i2b2_delete_all_data(trial_id character varying, path_string character varying, currentjobid numeric) OWNER TO weymouth;

--
-- Name: i2b2_load_annotation_deapp(numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: weymouth
--

CREATE FUNCTION i2b2_load_annotation_deapp(currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;

	gplId			character varying;

BEGIN

	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := current_schema();
	procedureName := 'I2B2_LOAD_ANNOTATION_DEAPP';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_annotation_deapp',0,stepCt,'Done') into rtnCd;

	--	get GPL id from external table

	select distinct gpl_id into gplId from lt_src_deapp_annot;

	--	delete any existing data from annotation_deapp

	begin
	delete from annotation_deapp
	where gpl_id = gplId;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from annotation_deapp',rowCt,stepCt,'Done') into rtnCd;

	--	delete any existing data from deapp.de_mrna_annotation

	begin
	delete from deapp.de_mrna_annotation
	where gpl_id = gplId;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;

	--	update organism for existing probesets in probeset_deapp

	begin
	with upd as (select distinct t.gpl_id, t.probe_id, t.organism from lt_src_deapp_annot t)
	update probeset_deapp
	set organism=upd.organism
	from upd
	where platform = upd.gpl_id
	  and probeset = upd.probe_id
	and exists
		 (select 1 from lt_src_deapp_annot x
		  where platform = x.gpl_id
		    and probeset = x.probe_id);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Update organism in probeset_deapp',rowCt,stepCt,'Done') into rtnCd;

	--	insert any new probesets into probeset_deapp

	begin
	insert into probeset_deapp
	(probeset
	,organism
	,platform)
	select distinct probe_id
		  ,coalesce(organism,'Homo sapiens')
	      ,gpl_id
	from lt_src_deapp_annot t
	where not exists
		 (select 1 from probeset_deapp x
		  where t.gpl_id = x.platform
		    and t.probe_id = x.probeset
			and coalesce(t.organism,'Homo sapiens') = coalesce(x.organism,'Homo sapiens'));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert new probesets into probeset_deapp',rowCt,stepCt,'Done') into rtnCd;

	--	insert data into annotation_deapp

	begin
	insert into annotation_deapp
	(gpl_id
	,probe_id
	,gene_symbol
	,gene_id
	,probeset_id
	,organism)
	select distinct d.gpl_id
	,d.probe_id
	,d.gene_symbol
	,d.gene_id
	,p.probeset_id
	,coalesce(d.organism,'Homo sapiens')
	from lt_src_deapp_annot d
	,probeset_deapp p
	where d.probe_id = p.probeset
	  and d.gpl_id = p.platform
	  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into REFERENCE annotation_deapp',rowCt,stepCt,'Done') into rtnCd;

	--	insert data into deapp.de_mrna_annotation

	begin
	insert into deapp.de_mrna_annotation
	(gpl_id
	,probe_id
	,gene_symbol
	,gene_id
	,probeset_id
	,organism)
	select distinct d.gpl_id
	,d.probe_id
	,d.gene_symbol
	,case when d.gene_id is null then null else d.gene_id::numeric end as gene_id
	,p.probeset_id
	,coalesce(d.organism,'Homo sapiens')
	from lt_src_deapp_annot d
	,probeset_deapp p
	where d.probe_id = p.probeset
	  and d.gpl_id = p.platform
	  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;

	--	update gene_id if null

	begin
	with upd as (select b.bio_marker_name as gene_symbol, b.organism, min(b.primary_external_id::numeric) as gene_id
				 from biomart.bio_marker b
				 where upper(b.bio_marker_type) = 'GENE'
				 group by b.bio_marker_name, b.organism)
	update deapp.de_mrna_annotation a
	set gene_id=upd.gene_id
	from upd
	where a.gpl_id = gplId
	  and a.gene_id is null
	  and a.gene_symbol is not null
	  and a.gene_symbol = upd.gene_symbol
	  and upper(a.organism) = upper(upd.organism)
	  and exists
	      (select 1 from biomart.bio_marker x
              where a.gene_symbol = x.bio_marker_name
                and upper(x.organism) = upper(a.organism)
             	and upper(x.bio_marker_type) = 'GENE');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated missing gene_id in de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;

	--	update gene_symbol if null

	begin
	with upd as (select b.primary_external_id::numeric as gene_id, b.organism, min(b.bio_marker_name) as gene_symbol
				 from biomart.bio_marker b
				 where upper(b.bio_marker_type) = 'GENE'
				 group by b.primary_external_id, b.organism)
	update deapp.de_mrna_annotation a
	set gene_symbol=upd.gene_symbol
	from upd
	where a.gpl_id = gplId
	  and a.gene_symbol is null
	  and a.gene_id is not null
	  and a.gene_id = upd.gene_id
	  and upper(a.organism) = upper(upd.organism)
	  and exists
	      (select 1 from biomart.bio_marker x
              where a.gene_symbol = x.bio_marker_name
                and upper(x.organism) = upper(a.organism)
             	and upper(x.bio_marker_type) = 'GENE');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated missing gene_symbol in de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_annotation_deapp',0,stepCt,'Done') into rtnCd;

       --Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_load_annotation_deapp(currentjobid numeric) OWNER TO weymouth;

--
-- Name: i2b2_load_clinical_data(character varying, character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_load_clinical_data(trial_id character varying, top_node character varying, secure_study character varying DEFAULT 'N'::character varying, highlight_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;

	topNode			varchar(2000);
	topLevel		numeric(10,0);
	root_node		varchar(2000);
	root_level		integer;
	study_name		varchar(2000);
	TrialID			varchar(100);
	secureStudy		varchar(200);
	etlDate			timestamp;
	tPath			varchar(2000);
	pCount			integer;
	pExists			integer;
	rtnCode			integer;
	tText			varchar(2000);

	addNodes CURSOR is
	select DISTINCT leaf_node, node_name
	from  wt_trial_nodes a;

	--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

	delNodes CURSOR is
	select distinct c_fullname
	from  i2b2metadata.i2b2
	where c_fullname like topNode || '%' escape '`'
      and substr(c_visualattributes,2,1) = 'H';

	--	cursor to determine if any leaf nodes exist in i2b2 that are not used in this reload (node changes from text to numeric or numeric to text)

	delUnusedLeaf cursor is
	select l.c_fullname
	from i2b2metadata.i2b2 l
	where l.c_visualattributes like 'L%'
	  and l.c_fullname like topNode || '%' escape '`'
	  and l.c_fullname not in
		 (select t.leaf_node
		  from wt_trial_nodes t
		  union
		  select m.c_fullname
		  from deapp.de_subject_sample_mapping sm
			  ,i2b2metadata.i2b2 m
		  where sm.trial_name = TrialId
		    and sm.concept_code = m.c_basecode
			and m.c_visualattributes like 'L%');
BEGIN

	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);

	databaseName := current_schema();
	procedureName := 'I2B2_LOAD_CLINICAL_DATA';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	select case when coalesce(currentjobid, -1) < 1 then cz_start_audit(procedureName, databaseName) else currentjobid end into jobId;

	stepCt := 0;
	stepCt := stepCt + 1;
	tText := 'Start i2b2_load_clinical_data for ' || TrialId;
	select cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done') into rtnCd;

	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;

	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\', 'g');

	--	figure out how many nodes (folders) are at study name and above
	--	\Public Studies\Clinical Studies\Pancreatic_Cancer_Smith_GSE22780\: topLevel = 4, so there are 3 nodes
	--	\Public Studies\GSE12345\: topLevel = 3, so there are 2 nodes

	select length(topNode)-length(replace(topNode,'\','')) into topLevel;

	if topLevel < 3 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Path specified in top_node must contain at least 2 nodes',0,stepCt,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	delete any existing data from lz_src_clinical_data and load new data
	begin
	delete from lz_src_clinical_data
	where study_id = TrialId;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	get diagnostics rowCt := ROW_COUNT;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from lz_src_clinical_data',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into lz_src_clinical_data
	(study_id
	,site_id
	,subject_id
	,visit_name
	,data_label
	,data_value
	,category_cd
	,etl_job_id
	,etl_date
	,ctrl_vocab_code)
	select study_id
		  ,site_id
		  ,subject_id
		  ,visit_name
		  ,data_label
		  ,data_value
		  ,category_cd
		  ,jobId
		  ,etlDate
		  ,ctrl_vocab_code
	from lt_src_clinical_data;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert data into lz_src_clinical_data',rowCt,stepCt,'Done') into rtnCd;

	--	truncate wrk_clinical_data and load data from external file

	execute ('truncate table wrk_clinical_data');

	--	insert data from lt_src_clinical_data to wrk_clinical_data

	begin
	insert into wrk_clinical_data
	(study_id
	,site_id
	,subject_id
	,visit_name
	,data_label
	,data_value
	,category_cd
	,ctrl_vocab_code
	)
	select study_id
		  ,site_id
		  ,subject_id
		  ,visit_name
		  ,data_label
		  ,data_value
		  ,category_cd
		  ,ctrl_vocab_code
	from lt_src_clinical_data;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load lt_src_clinical_data to work table',rowCt,stepCt,'Done') into rtnCd;

	-- Get root_node from topNode

	select parse_nth_value(topNode, 2, '\') into root_node;

	select count(*) into pExists
	from i2b2metadata.table_access
	where c_name = root_node;

	select count(*) into pCount
	from i2b2metadata.i2b2
	where c_name = root_node;

	if pExists = 0 or pCount = 0 then
		select i2b2_add_root_node(root_node, jobId) into rtnCd;
	end if;

	select c_hlevel into root_level
	from i2b2metadata.table_access
	where c_name = root_node;

	-- Get study name from topNode

	select parse_nth_value(topNode, topLevel, '\') into study_name;

	--	Add any upper level nodes as needed

	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount;

	if pCount > 2 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Adding upper-level nodes',0,stepCt,'Done') into rtnCd;
		select i2b2_fill_in_tree(null, tPath, jobId) into rtnCd;
	end if;

	select count(*) into pExists
	from i2b2metadata.i2b2
	where c_fullname = topNode;

	--	add top node for study

	if pExists = 0 then
		select i2b2_add_node(TrialId, topNode, study_name, jobId) into rtnCd;
	end if;

	--	Set data_type, category_path, and usubjid

	update wrk_clinical_data
	set data_type = 'T'
	   ,category_path = replace(replace(category_cd,'_',' '),'+','\')
	   ,usubjid = REGEXP_REPLACE(TrialID || ':' || coalesce(site_id,'') || ':' || subject_id,
                   '(::){1,}', ':', 'g');
	 get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Set columns in wrk_clinical_data',rowCt,stepCt,'Done') into rtnCd;

	--	Delete rows where data_value is null

	begin
	delete from wrk_clinical_data
	where coalesce(data_value, '') = '';
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete null data_values in wrk_clinical_data',rowCt,stepCt,'Done') into rtnCd;

	--Remove Invalid pipes in the data values.
	--RULE: If Pipe is last or first, delete it
	--If it is in the middle replace with a dash

	begin
	update wrk_clinical_data
	set data_value = replace(trim('|' from data_value), '|', '-')
	where data_value like '%|%';
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Remove pipes in data_value',rowCt,stepCt,'Done') into rtnCd;

	--Remove invalid Parens in the data
	--They have appeared as empty pairs or only single ones.

	begin
	update wrk_clinical_data
	set data_value = replace(data_value,'(', '')
	where data_value like '%()%'
	   or data_value like '%( )%'
	   or (data_value like '%(%' and data_value NOT like '%)%');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 1',rowCt,stepCt,'Done') into rtnCd;

	begin
	update wrk_clinical_data
	set data_value = replace(data_value,')', '')
	where data_value like '%()%'
	   or data_value like '%( )%'
	   or (data_value like '%)%' and data_value NOT like '%(%');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 2',rowCt,stepCt,'Done') into rtnCd;

	--Replace the Pipes with Commas in the data_label column
	begin
	update wrk_clinical_data
    set data_label = replace (data_label, '|', ',')
    where data_label like '%|%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Replace pipes with comma in data_label',rowCt,stepCt,'Done') into rtnCd;

	--	set visit_name to null when there's only a single visit_name for the catgory

	begin
	update wrk_clinical_data tpm
	set visit_name=null
	where (tpm.category_cd) in
		  (select x.category_cd
		   from wrk_clinical_data x
		   group by x.category_cd
		   having count(distinct upper(x.visit_name)) = 1);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Set single visit_name to null',rowCt,stepCt,'Done') into rtnCd;

	--	set data_label to null when it duplicates the last part of the category_path
	--	Remove data_label from last part of category_path when they are the same

	begin
	update wrk_clinical_data tpm
	--set data_label = null
	set category_path=substr(tpm.category_path,1,instr(tpm.category_path,'\',-2,1)-1)
	   ,category_cd=substr(tpm.category_cd,1,instr(tpm.category_cd,'+',-2,1)-1)
	where (tpm.category_cd, tpm.data_label) in
		  (select distinct t.category_cd
				 ,t.data_label
		   from wrk_clinical_data t
		   where upper(substr(t.category_path,instr(t.category_path,'\',-1,1)+1,length(t.category_path)-instr(t.category_path,'\',-1,1)))
			     = upper(t.data_label)
		     and t.data_label is not null)
	  and tpm.data_label is not null AND instr(tpm.category_path,'\',-2, 1) > 0 AND instr(tpm.category_cd,'+',-2, 1) > 0;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Set data_label to null when found in category_path',rowCt,stepCt,'Done') into rtnCd;

	--	set visit_name to null if same as data_label

	begin
	update wrk_clinical_data t
	set visit_name=null
	where (t.category_cd, t.visit_name, t.data_label) in
	      (select distinct tpm.category_cd
				 ,tpm.visit_name
				 ,tpm.data_label
		  from wrk_clinical_data tpm
		  where tpm.visit_name = tpm.data_label);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when found in data_label',rowCt,stepCt,'Done') into rtnCd;

	--	set visit_name to null if same as data_value

	begin
	update wrk_clinical_data t
	set visit_name=null
	where (t.category_cd, t.visit_name, t.data_value) in
	      (select distinct tpm.category_cd
				 ,tpm.visit_name
				 ,tpm.data_value
		  from wrk_clinical_data tpm
		  where tpm.visit_name = tpm.data_value);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when found in data_value',rowCt,stepCt,'Done') into rtnCd;

	--	set visit_name to null if only DATALABEL in category_cd

	-- TR: disabled!!!!
	/*
	begin
	update wrk_clinical_data t
	set visit_name=null
	where t.category_cd like '%DATALABEL%'
	  and t.category_cd not like '%VISITNAME%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when only DATALABE in category_cd',rowCt,stepCt,'Done') into rtnCd; */

	--	change any % to Pct and & and + to ' and ' and _ to space in data_label only

	begin
	update wrk_clinical_data
	set data_label=replace(replace(replace(replace(data_label,'%',' Pct'),'&',' and '),'+',' and '),'_',' ')
	   ,data_value=replace(replace(replace(data_value,'%',' Pct'),'&',' and '),'+',' and ')
	   ,category_cd=replace(replace(category_cd,'%',' Pct'),'&',' and ')
	   ,category_path=replace(replace(category_path,'%',' Pct'),'&',' and ');
	   exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

  --Trim trailing and leadling spaces as well as remove any double spaces, remove space from before comma, remove trailing comma

	begin
	update wrk_clinical_data
	set data_label  = trim(trailing ',' from trim(replace(replace(data_label,'  ', ' '),' ,',','))),
		data_value  = trim(trailing ',' from trim(replace(replace(data_value,'  ', ' '),' ,',','))),
--		sample_type = trim(trailing ',' from trim(replace(replace(sample_type,'  ', ' '),' ,',','))),
		visit_name  = trim(trailing ',' from trim(replace(replace(visit_name,'  ', ' '),' ,',',')));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Remove leading, trailing, double spaces',rowCt,stepCt,'Done') into rtnCd;

    --1. DETERMINE THE DATA_TYPES OF THE FIELDS
	--	replaced cursor with update, used temp table to store category_cd/data_label because correlated subquery ran too long

	execute ('truncate table wt_num_data_types');

	begin
	insert into wt_num_data_types
	(category_cd
	,data_label
	,visit_name
	)
    select category_cd,
           data_label,
           visit_name
    from wrk_clinical_data
    where data_value is not null
    group by category_cd
	        ,data_label
            ,visit_name
      having sum(is_numeric(data_value)) = 0;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert numeric data into WZ wt_num_data_types',rowCt,stepCt,'Done') into rtnCd;

	--	Check if any duplicate records of key columns (site_id, subject_id, visit_name, data_label, category_cd) for numeric data
	--	exist.  Raise error if yes

	execute ('truncate table wt_clinical_data_dups');

	begin
	insert into wt_clinical_data_dups
	(site_id
	,subject_id
	,visit_name
	,data_label
	,category_cd)
	select w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd
	from wrk_clinical_data w
	where exists
		 (select 1 from wt_num_data_types t
		 where coalesce(w.category_cd,'@') = coalesce(t.category_cd,'@')
		   and coalesce(w.data_label,'@') = coalesce(t.data_label,'@')
		   and coalesce(w.visit_name,'@') = coalesce(t.visit_name,'@')
		  )
	group by w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd
	having count(*) > 1;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Check for duplicate key columns',rowCt,stepCt,'Done') into rtnCd;

	if rowCt > 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Duplicate values found in key columns',0,stepCt,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check for multiple visit_names for category_cd, data_label, data_value

     select max(case when x.null_ct > 0 and x.non_null_ct > 0
					 then 1 else 0 end) into pCount
      from (select category_cd, data_label, data_value
				  ,sum(case when visit_name is null then 1 else 0 end) as null_ct
				  ,sum(case when visit_name is null then 0 else 1 end) as non_null_ct
			from lt_src_clinical_data
			where (category_cd like '%VISITNAME%' or
				   category_cd not like '%DATALABEL%')
			group by category_cd, data_label, data_value) x;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Check for multiple visit_names for category/label/value ',rowCt,stepCt,'Done') into rtnCd;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Multiple visit names for category/label/value',0,stepCt,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	begin
	update wrk_clinical_data t
	set data_type='N'
	where exists
	     (select 1 from wt_num_data_types x
	      where coalesce(t.category_cd,'@') = coalesce(x.category_cd,'@')
			and coalesce(t.data_label,'**NULL**') = coalesce(x.data_label,'**NULL**')
			and coalesce(t.visit_name,'**NULL**') = coalesce(x.visit_name,'**NULL**')
		  );
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated data_type flag for numeric data_types',rowCt,stepCt,'Done') into rtnCd;

	-- Build all needed leaf nodes in one pass for both numeric and text nodes

	execute ('truncate table wt_trial_nodes');

	begin
	insert into wt_trial_nodes
	(leaf_node
	,category_cd
	,visit_name
	,data_label
	,data_value
	,data_type
	)
    select DISTINCT
    Case
	--	Text data_type (default node)
	When a.data_type = 'T'
	     then case
		    when a.category_path like '%DATALABEL%' and a.category_path like '%DATAVALUE%' and a.category_path like '%VISITNAME%'
				then regexp_replace(topNode || replace(replace(replace(coalesce(a.category_path, ''),'DATALABEL',coalesce(a.data_label, '')),'VISITNAME',coalesce(a.visit_name, '')), 'DATAVALUE',coalesce(a.data_value, ''))  || '\','(\\){2,}', '\')
		 	when a.category_path like '%DATALABEL%' and a.category_path like '%VISITNAME%'
				then regexp_replace(topNode || replace(replace(coalesce(a.category_path, ''),'DATALABEL',coalesce(a.data_label, '')),'VISITNAME',coalesce(a.visit_name, '')) || '\' || coalesce(a.data_value, '') || '\','(\\){2,}', '\')
			when a.CATEGORY_PATH like '%DATALABEL%'
				then case
				when a.category_path like '%\VISITNFST' -- TR: support visit first
					then regexp_replace(topNode || replace(replace(coalesce(a.category_path, ''),'\VISITNFST', ''), 'DATALABEL',coalesce(a.data_label, '')) || '\' || coalesce(a.visit_name, '') || '\' || coalesce(a.data_value, '') || '\', '(\\){2,}', '\')
					else regexp_replace(topNode || replace(coalesce(a.category_path, ''), 'DATALABEL',coalesce(a.data_label, '')) || '\' || coalesce(a.data_value, '') || '\' || coalesce(a.visit_name, '') || '\', '(\\){2,}', '\')
				end
			ELSE case
			when a.category_path like '%\VISITNFST' -- TR: support visit first
				then REGEXP_REPLACE(TOPNODE || replace(coalesce(a.category_path, ''),'\VISITNFST', '') || '\'  || coalesce(a.data_label, '') || '\' || coalesce(a.visit_name, '') || '\' || coalesce(a.data_value, '') || '\', '(\\){2,}', '\')
				else REGEXP_REPLACE(TOPNODE || coalesce(a.category_path, '') || '\'  || coalesce(a.DATA_LABEL, '') || '\' || coalesce(a.DATA_VALUE, '') || '\' || coalesce(a.VISIT_NAME, '') || '\', '(\\){2,}', '\')
			end
	end
	--	else is numeric data_type and default_node
	else case when a.category_path like '%DATALABEL%' and a.category_path like '%VISITNAME%'
		      then regexp_replace(topNode || replace(replace(replace(coalesce(a.category_path, ''),'DATALABEL',coalesce(a.data_label, '')),'VISITNAME',coalesce(a.visit_name, '')), '\VISITNFST', '') || '\','(\\){2,}', '\')
			  when a.CATEGORY_PATH like '%DATALABEL%'
			  then regexp_replace(topNode || replace(replace(coalesce(a.category_path, ''),'DATALABEL',coalesce(a.data_label, '')), '\VISITNFST', '') || '\' || coalesce(a.visit_name, '') || '\', '(\\){2,}', '\')
			  else REGEXP_REPLACE(topNode || replace(coalesce(a.category_path, ''), '\VISITNFST', '') ||
                   '\'  || coalesce(a.data_label, '') || '\' || coalesce(a.visit_name, '') || '\',
                   '(\\){2,}', '\')
			  end
	end as leaf_node,
    a.category_cd,
    a.visit_name,
	a.data_label,
	case when a.data_type = 'T' then a.data_value else null end as data_value
    ,a.data_type
	from  wrk_clinical_data a;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes for trial',rowCt,stepCt,'Done') into rtnCd;

	--	set node_name

	begin
	update wt_trial_nodes
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated node name for leaf nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert subjects into patient_dimension if needed

	execute ('truncate table wt_subject_info');

	begin
	insert into wt_subject_info
	(usubjid,
     age_in_years_num,
     sex_cd,
     race_cd
    )
	select a.usubjid,
	      coalesce(max(case when upper(a.data_label) = 'AGE'
					   then case when is_numeric(a.data_value) = 1 then 0 else floor(a.data_value::numeric) end
		               when upper(a.data_label) like '%(AGE)'
					   then case when is_numeric(a.data_value) = 1 then 0 else floor(a.data_value::numeric) end
					   else null end),0) as age,
		  coalesce(max(case when upper(a.data_label) = 'SEX' then a.data_value
		           when upper(a.data_label) like '%(SEX)' then a.data_value
				   when upper(a.data_label) = 'GENDER' then a.data_value
				   else null end),'Unknown') as sex,
		  max(case when upper(a.data_label) = 'RACE' then a.data_value
		           when upper(a.data_label) like '%(RACE)' then a.data_value
				   else null end) as race
	from wrk_clinical_data a
	group by a.usubjid;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert subject information into temp table',rowCt,stepCt,'Done') into rtnCd;

	--	Delete dropped subjects from patient_dimension if they do not exist in de_subject_sample_mapping

	begin
	delete from i2b2demodata.patient_dimension
	where sourcesystem_cd in
		 (select distinct pd.sourcesystem_cd from i2b2demodata.patient_dimension pd
		  where pd.sourcesystem_cd like TrialId || ':%'
		  except
		  select distinct cd.usubjid from wrk_clinical_data cd)
	  and patient_num not in
		  (select distinct sm.patient_id from deapp.de_subject_sample_mapping sm);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete dropped subjects from patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	update patients with changed information
	begin
	with nsi as (select t.usubjid, t.sex_cd, t.age_in_years_num, t.race_cd from wt_subject_info t)
	update i2b2demodata.patient_dimension
	set sex_cd=nsi.sex_cd
	   ,age_in_years_num=nsi.age_in_years_num
	   ,race_cd=nsi.race_cd
	   from nsi
	where sourcesystem_cd = nsi.usubjid;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Update subjects with changed demographics in patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	insert new subjects into patient_dimension

	begin
	insert into i2b2demodata.patient_dimension
    (patient_num,
     sex_cd,
     age_in_years_num,
     race_cd,
     update_date,
     download_date,
     import_date,
     sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num'),
		   t.sex_cd,
		   t.age_in_years_num,
		   t.race_cd,
		   current_timestamp,
		   current_timestamp,
		   current_timestamp,
		   t.usubjid
    from wt_subject_info t
	where t.usubjid in
		 (select distinct cd.usubjid from wt_subject_info cd
		  except
		  select distinct pd.sourcesystem_cd from i2b2demodata.patient_dimension pd
		  where pd.sourcesystem_cd like TrialId || ':%');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert new subjects into patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	delete leaf nodes that will not be reused, if any

	 FOR r_delUnusedLeaf in delUnusedLeaf Loop

    --	deletes unused leaf nodes for a trial one at a time

		select i2b2_delete_1_node(r_delUnusedLeaf.c_fullname) into rtnCd;
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Deleted unused leaf node: ' || r_delUnusedLeaf.c_fullname,1,stepCt,'Done') into rtnCd;

	END LOOP;

	--	bulk insert leaf nodes
	begin
	with ncd as (select t.leaf_node, t.node_name from wt_trial_nodes t)
	update i2b2demodata.concept_dimension
	set name_char=ncd.node_name
	from ncd
	where concept_path = ncd.leaf_node;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Update name_char in concept_dimension for changed names',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into i2b2demodata.concept_dimension
    (concept_cd
	,concept_path
	,name_char
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	)
    select nextval('i2b2demodata.concept_id')
	     ,x.leaf_node
		 ,x.node_name
		 ,current_timestamp
		 ,current_timestamp
		 ,current_timestamp
		 ,TrialId
	from (select distinct c.leaf_node
				,c.node_name::text as node_name
		  from wt_trial_nodes c
		  where not exists
			(select 1 from i2b2demodata.concept_dimension x
			where c.leaf_node = x.concept_path)
		 ) x;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Inserted new leaf nodes into I2B2DEMODATA concept_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	update i2b2 with name, data_type and xml for leaf nodes
	begin
	with ncd as (select t.leaf_node, t.node_name, t.data_type from wt_trial_nodes t)
	update i2b2metadata.i2b2
	set c_name=ncd.node_name
	   ,c_columndatatype='T'
	   ,c_metadataxml=case when ncd.data_type = 'T'
					  then null
					  else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
					  end
	from ncd
	where c_fullname = ncd.leaf_node;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated name and data type in i2b2 if changed',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into i2b2metadata.i2b2
    (c_hlevel
	,c_fullname
	,c_name
	,c_visualattributes
	,c_synonym_cd
	,c_facttablecolumn
	,c_tablename
	,c_columnname
	,c_dimcode
	,c_tooltip
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,c_basecode
	,c_operator
	,c_columndatatype
	,c_comment
	,m_applied_path
	,c_metadataxml
	)
    select (length(c.concept_path) - coalesce(length(replace(c.concept_path, '\','')),0)) / length('\') - 2 + root_level
		  ,c.concept_path
		  ,c.name_char
		  ,'LA'
		  ,'N'
		  ,'CONCEPT_CD'
		  ,'CONCEPT_DIMENSION'
		  ,'CONCEPT_PATH'
		  ,c.concept_path
		  ,c.concept_path
		  ,current_timestamp
		  ,current_timestamp
		  ,current_timestamp
		  ,c.sourcesystem_cd
		  ,c.concept_cd
		  ,'LIKE'	--'T'
		  , 'T' --t.data_type
		  ,'trial:' || TrialID
		  ,'@'
		  ,case when t.data_type = 'T' then null
		   else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
		   end
    from i2b2demodata.concept_dimension c
		,wt_trial_nodes t
    where c.concept_path = t.leaf_node
	  and not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where c.concept_path = x.c_fullname);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Inserted leaf nodes into I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;


	--New place form fill_in_tree
	select i2b2_fill_in_tree(TrialId, topNode, jobID) into rtnCd;

	--	delete from observation_fact all concept_cds for trial that are clinical data, exclude concept_cds from biomarker data

	begin
	delete from i2b2demodata.observation_fact f
	where f.modifier_cd = TrialId
	  and f.concept_cd not in
		 (select distinct concept_code as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and concept_code is not null
		  union
		  select distinct platform_cd as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and platform_cd is not null
		  union
		  select distinct sample_type_cd as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and sample_type_cd is not null
		  union
		  select distinct tissue_type_cd as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and tissue_type_cd is not null
		  union
		  select distinct timepoint_cd as concept_cd from deapp.de_subject_sample_mapping
		  where trial_name = TrialId
		    and timepoint_cd is not null
		  union
		  select distinct concept_cd as concept_cd from deapp.de_subject_snp_dataset
		  where trial_name = TrialId
		    and concept_cd is not null);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete clinical data for study from observation_fact',rowCt,stepCt,'Done') into rtnCd;

	DROP INDEX IF EXISTS fact_modifier_patient;
	DROP INDEX IF EXISTS idx_ob_fact_2;
	DROP INDEX IF EXISTS idx_ob_fact_1;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Drop observation facts indexes',0,stepCt,'Done') into rtnCd;

	--Insert into observation_fact
	begin
	insert into i2b2demodata.observation_fact
	(encounter_num,
     patient_num,
     concept_cd,
     start_date,
     modifier_cd,
     valtype_cd,
     tval_char,
     nval_num,
     sourcesystem_cd,
     import_date,
     valueflag_cd,
     provider_id,
     location_cd,
     instance_num
	)
	select distinct c.patient_num,
		   c.patient_num,
		   i.c_basecode,
		   current_timestamp,
		   a.study_id,
		   a.data_type,
		   case when a.data_type = 'T' then a.data_value
				else 'E'  --Stands for Equals for numeric types
				end,
		   case when a.data_type = 'N' then a.data_value::numeric
				else null --Null for text types
				end,
		   a.study_id,
		   current_timestamp,
		   '@',
		   '@',
		   '@',
                   0
	from wrk_clinical_data a
		,i2b2demodata.patient_dimension c
		,wt_trial_nodes t
		,i2b2metadata.i2b2 i
	where a.usubjid = c.sourcesystem_cd
	  and coalesce(a.category_cd,'@') = coalesce(t.category_cd,'@')
	  and coalesce(a.data_label,'**NULL**') = coalesce(t.data_label,'**NULL**')
	  and coalesce(a.visit_name,'**NULL**') = coalesce(t.visit_name,'**NULL**')
	  and case when a.data_type = 'T' then a.data_value else '**NULL**' end = coalesce(t.data_value,'**NULL**')
	  and t.leaf_node = i.c_fullname
--	  and not exists		-- don't insert if lower level node exists
--		 (select 1 from wt_trial_nodes x
--		  where x.leaf_node like t.leaf_node || '%_' escape '`')
--	  and a.data_value is not null;
	  and not exists		-- don't insert if lower level node exists
		(
			select 1 from wt_trial_nodes x
		  	--where x.leaf_node like t.leaf_node || '%_'
			--Jule 2013. Performance fix by TR. Find if any leaf parent node is current
			where (SUBSTR(x.leaf_node, 1, INSTR(x.leaf_node, '\', -2))) = t.leaf_node
		)
	  and a.data_value is not null AND NOT (a.data_type = 'N' AND a.data_value = '');

	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert trial into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;


	--July 2013. Performance fix by TR. Prepare precompute tree
	SELECT I2B2_CREATE_FULL_TREE(topNode, jobId) INTO rtnCd;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create i2b2 full tree', 0, stepCt,'Done') into rtnCd;

	CREATE INDEX fact_modifier_patient ON i2b2demodata.observation_fact(modifier_cd, patient_num) tablespace indx;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create fact_modifier_patient index', 0, stepCt,'Done') into rtnCd;

	CREATE INDEX idx_ob_fact_2 ON observation_fact (concept_cd,patient_num,encounter_num) tablespace indx;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create idx_ob_fact_2 index', 0, stepCt,'Done') into rtnCd;

	CREATE INDEX idx_ob_fact_1 ON observation_fact (concept_cd) tablespace indx;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create idx_ob_fact_1 index', 0, stepCt,'Done') into rtnCd;


   DELETE FROM i2b2_load_path_with_count;

   insert into i2b2_load_path_with_count
   select p.c_fullname, count(*)
				 from i2b2metadata.i2b2 p
					--,i2b2metadata.i2b2 c
					,I2B2_LOAD_TREE_FULL tree
				 where p.c_fullname like topNode || '%' escape '`'
				   --and c.c_fullname like p.c_fullname || '%'
					and p.RECORD_ID = tree.IDROOT
					--and c.rowid = tree.IDCHILD
				 group by P.C_FULLNAME;


	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create i2b2 full tree counts', 0, stepCt,'Done') into rtnCd;

	--	update c_visualattributes for all nodes in study, done to pick up node that changed c_columndatatype
	begin
	/*with upd as (select p.c_fullname, count(*) as nbr_children
				 from i2b2metadata.i2b2 p
					 ,i2b2metadata.i2b2 c
				 where p.c_fullname like topNode || '%' escape '`'
				   and c.c_fullname like p.c_fullname || '%' escape '`'
				 group by p.c_fullname)*/
	update i2b2metadata.i2b2 b
	set c_visualattributes=case when u.nbr_children = 1
								then 'L' || substr(b.c_visualattributes,2,2)
								else 'F' || substr(b.c_visualattributes,2,1) ||
									case when u.c_fullname = topNode and highlight_study = 'Y'
										 then 'J' else substr(b.c_visualattributes,3,1) end
								end
		,c_columndatatype=case when u.nbr_children > 1 then 'T' else b.c_columndatatype end
	from i2b2_load_path_with_count u
	where b.c_fullname = u.c_fullname
	  and b.c_fullname in
		 (select x.c_fullname from i2b2metadata.i2b2 x
		  where x.c_fullname like topNode || '%' escape '`');
  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Set c_visualattributes in i2b2',rowCt,stepCt,'Done') into rtnCd;

	-- final procs
    --moved earlier
	--select i2b2_fill_in_tree(TrialId, topNode, jobID) into rtnCd;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Finish fill in tree',0, stepCt,'Done') into rtnCd;

	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes

	begin
	update i2b2metadata.i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper-level nodes',rowCt,stepCt,'Done') into rtnCd;

	select i2b2_create_concept_counts(topNode, jobID, 'N') into rtnCd;

	--	delete each node that is hidden after create concept counts

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		select i2b2_delete_1_node(r_delNodes.c_fullname) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		select cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;

	END LOOP;

	select i2b2_create_security_for_trial(TrialId, secureStudy, jobID) into rtnCd;
	select i2b2_load_security_data(TrialId, jobID) into rtnCd;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_clinical_data',0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	perform cz_end_audit (jobID, 'SUCCESS') where coalesce(currentJobId, -1) <> jobId;

	return 1;
/*
	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
*/
END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_load_clinical_data(trial_id character varying, top_node character varying, secure_study character varying, highlight_study character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_load_metabolomics_annot(numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_load_metabolomics_annot(currentjobid numeric DEFAULT NULL::numeric) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
*This stored procedure is for ETL to load METABOLOMICS ANNOTATION
* Date:12/29/2013
******************************************************************/
DECLARE
	--Audit variables
	newJobFlag numeric(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID numeric(18,0);
	stepCt numeric(18,0);
	idREF	varchar(100);
	rowCt integer;
	gplId VARCHAR(100);

BEGIN
  	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName :=  current_schema();
	procedureName := 'I2B2_LOAD_METABOLOMICS_ANNOTATION';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

    stepCt := stepCt + 1;
    perform cz_write_audit(jobId,databaseName,procedureName,'Starting I2B2_LOAD_METABOLOMICS_ANNOTTATION',0,stepCt,'Done');

    --    get  id_ref  from external table

	select distinct gpl_id into gplId from lt_metabolomic_annotation;

  --    delete any existing data from de_metabolite_sub_pathways

  begin
    delete from deapp.de_metabolite_sub_pathways
    where gpl_id = gplId;
    exception
    when others then
      perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
      perform cz_end_audit (jobID, 'FAIL');
      return -16;
  end;

  stepCt := stepCt + 1;
  get diagnostics rowCt := ROW_COUNT;

  perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_metabolite_sub_pathways',rowCt,stepCt,'Done');

  --    delete any existing data from de_metabolite_super_pathways

	begin
    delete from deapp.de_metabolite_super_pathways
    where gpl_id = gplId;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

    perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_metabolite_super_pathways',rowCt,stepCt,'Done');

	--    delete any existing data from de_metabolite_sub_pathways
	begin
	delete from deapp.de_metabolite_sub_pathways where gpl_id = gplId;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

    perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_metabolite_sub_pathways',rowCt,stepCt,'Done');

	--    delete any existing data from de_metabolite_sub_pway_metab
	begin
	delete from deapp.de_metabolite_sub_pway_metab where not exists (select id from deapp.de_metabolite_sub_pathways where de_metabolite_sub_pathways.id = de_metabolite_sub_pway_metab.sub_pathway_id) ;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

    perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_metabolite_sub_pway_metab',rowCt,stepCt,'Done');

    --    delete any existing data from deapp.de_metabolite_annotation
	begin
        delete from deapp.de_metabolite_annotation
        where gpl_id = gplId;
       exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

    perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_metabolite_annotation',rowCt,stepCt,'Done');


	begin
    insert into  deapp.de_metabolite_annotation
        (
        id
        ,gpl_id
        ,biochemical_name
        ,biomarker_id
        ,hmdb_id
        )
    select
        nextval('deapp.metabolomics_annot_id')
        ,d.gpl_id
    ,trim(d.biochemical_name)
    ,b.primary_external_id
    ,d.hmdb_id
    from lt_metabolomic_annotation d
    left outer join biomart.bio_marker b on b.bio_marker_name = d.biochemical_name
    --,peptide_deapp p
    where d.gpl_id = gplId;
    exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

    perform cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_metabolite_annotation',rowCt,stepCt,'Done');

	begin
     insert into deapp.de_metabolite_super_pathways
        (
        id
        ,gpl_id
        ,super_pathway_name
        )
    select
        nextval('deapp.metabolite_sup_pth_id')
        ,d.gpl_id
    ,d.super_pathway
    from (select distinct gpl_id,super_pathway from lt_metabolomic_annotation ) d
    where d.gpl_id = gplId;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

    perform cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_metabolite_super_pathways',rowCt,stepCt,'Done');

		begin
        insert into  deapp.de_metabolite_sub_pathways
        (
        id
        ,gpl_id
        ,sub_pathway_name
        ,super_pathway_id
        )
        select
        nextval('deapp.metabolite_sub_pth_id')
        ,d.gpl_id
    ,trim(d.sub_pathway)
        ,sp.id
    from (select unnest(regexp_split_to_array(sub_pathway, ';')) AS sub_pathway ,gpl_id,super_pathway
        FROM lt_metabolomic_annotation) as d
    ,deapp.de_metabolite_super_pathways sp
    where
        trim(d.super_pathway) = trim(sp.super_pathway_name)
        and d.gpl_id = gplId
        and sp.gpl_id = gplId;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

    perform cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_metabolite_sub_pathways',rowCt,stepCt,'Done');

    begin
        insert into  deapp.de_metabolite_sub_pway_metab
        (
          metabolite_id
          ,sub_pathway_id
        )
	   select d.id, sp.id from deapp.de_metabolite_annotation d, deapp.de_metabolite_sub_pathways sp,
	(select unnest(regexp_split_to_array(sub_pathway, ';')) AS sub_pathway ,biochemical_name, gpl_id
			FROM lt_metabolomic_annotation) as lma
	where trim(lma.biochemical_name) = trim(d.biochemical_name)
	and trim(lma.sub_pathway) = trim (sp.sub_pathway_name)
	and d.gpl_id =gplId
			and lma.gpl_id=gplId;
		exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

    perform cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_metabolite_sub_pway_metab',rowCt,stepCt,'Done');

    --    update biomarker_id if null

	begin
        update deapp.de_metabolite_annotation t
    set biomarker_id=(select min(b.bio_marker_name) as biomarker_id
                 from biomart.mirna_bio_marker b
                 where t.biomarker_id::text = b.primary_external_id
                   and upper(b.bio_marker_type) = 'metabolomic')
    where t.gpl_id = gplId
      and t.biomarker_id is null
      and t.biochemical_name is not null
      and exists
         (select 1 from biomart.mirna_bio_marker x
          where t.biomarker_id::text = x.primary_external_id
            and upper(x.bio_marker_type) = 'metabolomic');
    exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	get diagnostics rowCt := ROW_COUNT;

    perform cz_write_audit(jobId,databaseName,procedureName,'Updated missing uniprotid in de_protien_annotation',rowCt,stepCt,'Done');

    --    insert probesets into biomart.bio_assay_feature_group
    begin
    insert into biomart.mirna_bio_assay_feature_group
    (feature_group_name
    ,feature_group_type)
    select distinct t.biochemical_name, 'METABOLOMIC' --ask
    from lt_metabolomic_annotation t
    where not exists
         (select 1 from biomart.mirna_bio_assay_feature_group x
          where t.gpl_id = x.feature_group_name);
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

    perform cz_write_audit(jobId,databaseName,procedureName,'Insert peptides into biomart.mirna_bio_assay_feature_group',rowCt,stepCt,'Done');

    --    insert probesets into biomart.mirna_bio_assay_data_annotation

	begin
    insert into biomart.mirna_bio_assay_data_annot
    (bio_assay_feature_group_id
    ,bio_marker_id)
    select distinct fg.bio_assay_feature_group_id
          ,coalesce(bgs.bio_marker_id,bgi.bio_marker_id)
    from lt_metabolomic_annotation t
        inner join biomart.mirna_bio_assay_feature_group fg on t.biochemical_name = fg.feature_group_name
        left outer join biomart.mirna_bio_marker bgs on t.biochemical_name = bgs.bio_marker_name
        left outer join biomart.mirna_bio_marker bgi on t.hmdb_id::text= bgi.primary_external_id
    where (t.hmdb_id is not null)
      and coalesce(bgs.bio_marker_id,bgi.bio_marker_id,-1) > 0
      and not exists
         (select 1 from biomart.mirna_bio_assay_data_annot x
          where fg.bio_assay_feature_group_id = x.bio_assay_feature_group_id
            and coalesce(bgs.bio_marker_id,bgi.bio_marker_id,-1) = x.bio_marker_id);
            exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
    perform cz_write_audit(jobId,databaseName,procedureName,'Link feature_group to bio_marker in biomart.mirna_bio_assay_data_annotation',rowCt,stepCt,'Done');

        -- Inserts subpathways into search_keyword,
-- subpathways into search_keyword_term,
-- superpathways into search_keyword,
-- superpathways into search_keyword_term
			begin
          INSERT INTO searchapp.search_keyword (
            keyword,
            bio_data_id,
            unique_id,
            data_category,
            display_data_category)
          SELECT
            CONCAT(CONCAT(subp.sub_pathway_name, '_'), subp.gpl_id),
            subp.id,
            CONCAT('METABOLITE_SUBPATHWAY:', subp.id),
            'METABOLITE_SUBPATHWAY',
            'Metabolite subpathway'
          FROM
            deapp.de_metabolite_sub_pathways subp
            where subp.gpl_id = gplId;
exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
    perform cz_write_audit(jobId,databaseName,procedureName,'Insert subpathways into search_keyword',rowCt,stepCt,'Done');

		begin
            INSERT INTO searchapp.search_keyword_term (
              keyword_term,
              search_keyword_id,
              rank,
              term_length)
            SELECT
              upper_keyword,
              search_keyword_id,
              1,
              LENGTH(upper_keyword)
            FROM (
              SELECT
                UPPER(skw.keyword) AS upper_keyword,
                skw.search_keyword_id AS search_keyword_id
              FROM
                searchapp.search_keyword skw
              WHERE
                data_category = 'METABOLITE_SUBPATHWAY'
              AND
                bio_data_id IN (
                  SELECT
                    subp.id
                  FROM
                    deapp.de_metabolite_sub_pathways subp
                    where subp.gpl_id = gplId
                )
            ) as s;

            stepCt := stepCt + 1;
            perform cz_write_audit(jobId,databaseName,procedureName,'Insert subpathways into search_keyword_term',rowCt,stepCt,'Done');

            INSERT INTO searchapp.search_keyword (
              keyword,
              bio_data_id,
              unique_id,
              data_category,
              display_data_category)
            SELECT
              CONCAT(CONCAT(supp.super_pathway_name, '_'), supp.gpl_id),
              supp.id,
              CONCAT('METABOLITE_SUPERPATHWAY:', supp.id),
              'METABOLITE_SUPERPATHWAY',
              'Metabolite superpathway'
            FROM
              deapp.de_metabolite_super_pathways supp
              where supp.gpl_id = gplId;
			  exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

            perform cz_write_audit(jobId,databaseName,procedureName,'Insert superpathways into search_keyword',rowCt,stepCt,'Done');

			begin
            INSERT INTO searchapp.search_keyword_term (
              keyword_term,
              search_keyword_id,
              rank,
              term_length)
            SELECT
              upper_keyword,
              search_keyword_id,
              1,
              LENGTH(upper_keyword)
            FROM (
              SELECT
                UPPER(skw.keyword) AS upper_keyword,
                skw.search_keyword_id AS search_keyword_id
              FROM
                searchapp.search_keyword skw
              WHERE
                data_category = 'METABOLITE_SUPERPATHWAY'
              AND
                bio_data_id IN (
                  SELECT
                    supp.id
                  FROM
                    deapp.de_metabolite_super_pathways supp
                    where supp.gpl_id = gplId
                )
            ) as s;
			exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

        stepCt := stepCt + 1;
        perform cz_write_audit(jobId,databaseName,procedureName,'Insert superpathways into search_keyword_term',rowCt,stepCt,'Done');

	begin
    INSERT INTO biomart.bio_marker (
          bio_marker_name,
          bio_marker_description,
          primary_external_id,
          bio_marker_type)
        SELECT
          CONCAT('PRIVATE:', annotation.id),
          CONCAT('PRIVATE:', annotation.id),
          CONCAT('PRIVATE:', annotation.id),
          'METABOLITE'
        FROM
          deapp.de_metabolite_annotation annotation
        WHERE
          annotation.hmdb_id IS NULL;
         exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
        perform cz_write_audit(jobId,databaseName,procedureName,'Insert into biomart.bio_marker',rowCt,stepCt,'Done');

		begin
        UPDATE deapp.de_metabolite_annotation annotation
        SET  hmdb_id = CONCAT('PRIVATE:', annotation.id)
        WHERE  annotation.hmdb_id IS NULL;
		exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;

        perform cz_write_audit(jobId,databaseName,procedureName,'Update deapp.de_metabolite_annotation',rowCt,stepCt,'Done');

        stepCt := stepCt + 1;
    perform cz_write_audit(jobId,databaseName,procedureName,'End I2B2_LOAD_METABOLOMICS_ANNOT',0,stepCt,'Done');

       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
   perform cz_end_audit (jobID, 'SUCCESS');
  END IF;

  return 1;

END;
$$;


ALTER FUNCTION tm_dataloader.i2b2_load_metabolomics_annot(currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_load_mirna_annot_deapp(numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_load_mirna_annot_deapp(currentjobid numeric DEFAULT NULL::numeric) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
*This stored procedure is for ETL to load QPCR MIRNA ANNOTATION
* Date:10/29/2013
******************************************************************/
DECLARE
	--Audit variables
	newJobFlag numeric(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID numeric(18,0);
	stepCt numeric(18,0);
	idREF	varchar(100);
	rowCt integer;

BEGIN

	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := current_schema();
	procedureName := 'I2B2_LOAD_MIRNA_ANNOT_DEAPP';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_MIRNA_annot_deapp',0,stepCt,'Done');

	begin
	delete from mirna_annotation_deapp
	where id_ref in ( select distinct id_ref from tm_lz.lt_qpcr_mirna_annotation)
  and gpl_id in ( select distinct gpl_id from tm_lz.lt_qpcr_mirna_annotation);
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from mirna_annotation_deapp',rowCt,stepCt,'Done');

        begin
        delete from deapp.de_qpcr_mirna_annotation
	where id_ref in (select distinct id_ref from tm_lz.lt_qpcr_mirna_annotation)
  and gpl_id in(select gpl_id from tm_lz.lt_qpcr_mirna_annotation);
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_qpcr_mirna_annotation',rowCt,stepCt,'Done');

	begin
	insert into mirna_probeset_deapp
	(probeset
	,organism
	,platform)
	select distinct id_ref
		  ,coalesce(organism,'Homo sapiens')
	      ,gpl_id
	from tm_lz.lt_qpcr_mirna_annotation t
	where not exists
		 (select 1 from mirna_probeset_deapp x
		  where
                         t.id_ref = x.probeset
                         and t.gpl_id = x.platform
			--and coalesce(t.organism,'Homo sapiens') = coalesce(x.organism,'Homo sapiens')
                        )
	;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;


	--where id_ref is not null
	--   or mirna_symbol is not null;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert new probesets into mirna_probeset_deapp',rowCt,stepCt,'Done');

                --	update organism for existing probesets in mirna_probeset_deapp

	begin
	update mirna_probeset_deapp p
	set organism=(select distinct t.organism from tm_lz.lt_qpcr_mirna_annotation t
				  where p.probeset = t.id_ref
				    --and p.probeset = t.probe_id
                                    )
	where exists
		 (select 1 from tm_lz.lt_qpcr_mirna_annotation x
		  where p.platform = x.gpl_id
		    and p.probeset = x.id_ref);
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update organism in mirna_probeset_deapp',rowCt,stepCt,'Done');



	--	insert data into mirna_annotation_deapp
	begin
	insert into mirna_annotation_deapp
	(id_ref
	,probe_id
	,mirna_symbol
	,mirna_id
	,probeset_id
	,organism
  ,gpl_id)
	select distinct d.id_ref
	,null
	,null
	,d.mirna_id
	,p.probeset_id
	,coalesce(d.organism,'Homo sapiens')
  ,d.gpl_id
	from tm_lz.lt_qpcr_mirna_annotation d
	,mirna_probeset_deapp p
	where d.id_ref = p.probeset
    and p.platform = d.gpl_id
	  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens')
	  --and (d.id_ref is not null or d.mirna_symbol is not null)
	  ;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into REFERENCE mirna_annotation_deapp',rowCt,stepCt,'Done');

	--	insert data into deapp.de_qpcr_mirna_annotation

	begin
	insert into
        deapp.de_qpcr_mirna_annotation
	(id_ref
	,probe_id
	,mirna_symbol
	,mirna_id
	,probeset_id
	,organism
  ,gpl_id)
	select distinct d.id_ref
	,null
	,null --d.mirna_symbol
	,lower(d.mirna_id) as mirna_id
	,p.probeset_id
	,coalesce(d.organism,'Homo sapiens')
  ,d.gpl_id
	from tm_lz.lt_qpcr_mirna_annotation d
	,mirna_probeset_deapp p
	where d.id_ref = p.probeset
	  and p.platform = d.gpl_id
	  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens');
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_qpcr_mirna_annotation',rowCt,stepCt,'Done');

	insert into biomart.mirna_bio_assay_feature_group
	(feature_group_name
	,feature_group_type)
	select distinct t.id_ref, 'PROBESET'
	from tm_lz.lt_qpcr_mirna_annotation t
	where not exists
		 (select 1 from biomart.mirna_bio_assay_feature_group x
		  where t.id_ref = x.feature_group_name);

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert probesets into biomart.mirna_bio_assay_feature_group',rowCt,stepCt,'Done');

	--	insert probesets into biomart.mirna_bio_assay_data_annotation
	begin
	insert into biomart.mirna_bio_assay_data_annot
	(bio_assay_feature_group_id
	,bio_marker_id)
	select distinct fg.bio_assay_feature_group_id
		  ,bgi.bio_marker_id
	from tm_lz.lt_qpcr_mirna_annotation t left outer join biomart.bio_marker bgi on bio_marker_type = 'MIRNA' and t.mirna_id::varchar = bgi.primary_external_id
		,biomart.mirna_bio_assay_feature_group fg
	where (
               t.mirna_id is not null)
	  and t.id_ref = fg.feature_group_name
	  and upper(coalesce(t.organism,'Homo sapiens')) = upper(bgi.organism)
	  and coalesce(bgi.bio_marker_id,-1) > 0
	  and not exists
		 (select 1 from biomart.mirna_bio_assay_data_annot x
		  where fg.bio_assay_feature_group_id = x.bio_assay_feature_group_id
		    and coalesce(bgi.bio_marker_id,-1) = x.bio_marker_id);
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Link feature_group to bio_marker in biomart.mirna_bio_assay_data_annotation',rowCt,stepCt,'Done');

	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_MIRNA_annot_deapp',0,stepCt,'Done');

       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    perform cz_end_audit (jobID, 'SUCCESS');
  END IF;

  return 1;
  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
    --End Proc
    perform cz_end_audit (jobID, 'FAIL');

    return -16;
END;
$$;


ALTER FUNCTION tm_dataloader.i2b2_load_mirna_annot_deapp(currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_load_proteomics_annot(numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: weymouth
--

CREATE FUNCTION i2b2_load_proteomics_annot(currentjobid numeric DEFAULT NULL::numeric) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
*This stored procedure is for ETL to load proteomics ANNOTATION 
* Date:10/29/2013
******************************************************************/
Declare
	--Audit variables
	newJobFlag NUMERIC(1);
	databaseName character varying(100);
	procedureName character varying(100);
	jobID numeric(18,0); 
	stepCt numeric(18,0); 
	gplId	character varying(100);
	rtnCd integer;
	errorNumber character varying;
	errorMessage character varying;
	rowCt integer;

BEGIN

	stepCt := 0; 

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := current_schema();
	procedureName := 'I2B2_LOAD_PROTEOMICS_ANNOT';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting I2B2_LOAD_PROTEOMICS_ANNOTTATION',0,stepCt,'Done') into rtnCd;

	--	get  id_ref  from external table
	
      select distinct gpl_id into gplId from lt_protein_annotation ;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_protein_annotation',rowCt,stepCt,'Done') into rtnCd;
        --	delete any existing data from deapp.de_protien_annotation
        begin
		delete from deapp.de_protein_annotation
		where gpl_id =gplId;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_protien_annotation',rowCt,stepCt,'Done') into rtnCd;
	begin
	insert into  deapp.de_protein_annotation
	(gpl_id
	,peptide 
	,uniprot_id
	--,biomarker_id
	,uniprot_name
	,organism)
	select distinct d.gpl_id
	,trim(d.peptide)
	,d.uniprot_id
	--,p.bio_marker_id
	,d.uniprot_id
	,coalesce(d.organism,'Homo sapiens')
	from lt_protein_annotation d
	--,biomart.bio_marker p
	where d.gpl_id = gplId
        --and p.primary_external_id = d.uniprot_id
	--  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens')
	 -- and (d.gpl_id is not null or d.gene_symbol is not null)
	  ;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated missing uniprot_id in de_protien_annotation',rowCt,stepCt,'Done') into rtnCd;

	/*begin
        update DEAPP.DE_PROTEIN_ANNOTATION set uniprot_name = (select bio_marker_name
        from BIOMART.BIO_MARKER
        WHERE biomart.bio_marker.primary_external_id = deapp.de_protein_annotation.uniprot_id)
        where gpl_id = gplId;
        exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;  
        
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Update uniprot_name in DEAPP de_protein_annotation',rowCt,stepCt,'Done') into rtnCd;*/
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_proteomics_annottation',0,stepCt,'Done') into rtnCd;
	
       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    select cz_end_audit (jobID, 'SUCCESS') into rtnCd; 
  END IF; 

  return rtnCd;
  
  EXCEPTION 
  WHEN OTHERS THEN
    errorNumber := SQLSTATE;
    errorMessage := SQLERRM;
    select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
    select cz_end_audit (jobID, 'FAIL') into rtnCd;

  return rtnCd;
END;
$$;


ALTER FUNCTION tm_dataloader.i2b2_load_proteomics_annot(currentjobid numeric) OWNER TO weymouth;

--
-- Name: i2b2_load_rbm_annotation(bigint); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_load_rbm_annotation(currentjobid bigint DEFAULT NULL::bigint) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
DECLARE

/*************************************************************************
* This is for RBM Annotation ETL for Sanofi
* Date:12/05/2013
******************************************************************/

	--Audit variables
	newJobFlag numeric(1);
	databaseName character varying(100);
	procedureName character varying(100);
	jobID bigint;
	stepCt bigint;
	gplId	character varying(100);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	rowCt			numeric(18,0);

BEGIN

	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := 'TM_CZ';
	procedureName := 'I2B2_LOAD_RBM_ANNOTATION';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName, jobID) into jobId;
	END IF;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_rbm_annotation',0,stepCt,'Done') into rtnCd;

	--	get GPL id from external table

	select distinct gpl_id into gplId from LT_SRC_RBM_ANNOTATION;


	--	delete any existing data from antigen_deapp

	begin
	delete from antigen_deapp
	where platform = gplId;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from REFERENCE antigen_deapp',rowCt,stepCt,'Done') into rtnCd;


	--	delete any existing data from annotation_deapp
	begin
	delete from annotation_deapp
	where gpl_id = gplId;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from annotation_deapp',rowCt,stepCt,'Done') into rtnCd;

	--	delete any existing data from deapp.de_mrna_annotation
	begin
	delete from deapp.DE_RBM_ANNOTATION
	where gpl_id = gplId;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_mrna_annotation',rowCt,stepCt,'Done') into rtnCd;

	--	insert any new probesets into probeset_deapp
	begin
	insert into antigen_deapp
	(antigen_name
	,platform)
	select distinct antigen_name
	      ,gpl_id
	from LT_SRC_RBM_ANNOTATION t
	where not exists
		 (select 1 from antigen_deapp x
		  where t.gpl_id = x.platform
		    and t.antigen_name = x.antigen_name
		);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert new probesets into antigen_deapp',rowCt,stepCt,'Done') into rtnCd;

	--	insert data into annotation_deapp
	begin
	insert into annotation_deapp
	(gpl_id
	,probe_id
	,gene_symbol
	,gene_id
	,probeset_id
	,organism)
	select distinct d.gpl_id
	,d.uniprotid
	,d.gene_symbol
	,d.gene_id
	,p.antigen_id
	,'Homo sapiens'
	from LT_SRC_RBM_ANNOTATION d
	,antigen_deapp p
	where d.antigen_name = p.antigen_name
	  and d.gpl_id = p.platform
	  and ((d.gene_id IS NOT NULL AND d.gene_id::text <> '') or (d.gene_symbol IS NOT NULL AND d.gene_symbol::text <> '')) ;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into REFERENCE annotation_deapp',rowCt,stepCt,'Done') into rtnCd;

	--	insert data into deapp.de_rbm_annotation
	begin
	insert into DEAPP.DE_RBM_ANNOTATION
	(gpl_id
        ,id
	,antigen_name
        ,uniprot_id
	,gene_symbol
	,gene_id
	)
	select  distinct d.gpl_id
        ,antigen_id
	,d.antigen_name
        ,d.uniprotid
	,d.gene_symbol
	,CASE WHEN d.gene_id = null THEN null ELSE d.gene_id::numeric END as gene_id
	from LT_SRC_RBM_ANNOTATION d
	,antigen_deapp p --check
	where d.antigen_name = p.antigen_name
	  and d.gpl_id = p.platform;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_rbm_annotation',rowCt,stepCt,'Done') into rtnCd;

	--	update gene_id if null
	begin
	update DEAPP.DE_RBM_ANNOTATION t
	set gene_id=(select min(b.primary_external_id)::numeric as gene_id
				 from biomart.bio_marker b
				 where t.gene_symbol = b.bio_marker_name
				  -- and upper(b.organism) = upper(t.organism)
				   and upper(b.bio_marker_type) = 'RBM')
	where t.gpl_id = gplId
	  and coalesce(t.gene_id::text, '') = ''
	  and (t.gene_symbol IS NOT NULL AND t.gene_symbol::text <> '')
	  and exists
		 (select 1 from biomart.bio_marker x
		  where t.gene_symbol = x.bio_marker_name
			--and upper(x.organism) = upper(t.organism)
			and upper(x.bio_marker_type) = 'RBM');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated missing gene_id in de_rbm_annotation',rowCt,stepCt,'Done') into rtnCd;

	--	update gene_symbol if null
	begin
	update DEAPP.DE_RBM_ANNOTATION t
	set gene_symbol=(select min(b.bio_marker_name) as gene_symbol
				 from biomart.bio_marker b
				 where t.gene_id::varchar = b.primary_external_id
				 --  and upper(b.organism) = upper(t.organism)
				   and upper(b.bio_marker_type) = 'RBM')
	where t.gpl_id = gplId
	  and coalesce(t.gene_symbol::text, '') = ''
	  and (t.gene_id IS NOT NULL AND t.gene_id::text <> '')
	  and exists
		 (select 1 from biomart.bio_marker x
		  where t.gene_id::varchar = x.primary_external_id
			--and upper(x.organism) = upper(t.organism)
			and upper(x.bio_marker_type) = 'RBM');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated missing gene_id in de_rbm_annotation',rowCt,stepCt,'Done') into rtnCd;

	--	insert probesets into biomart.bio_assay_feature_group
	begin
	insert into biomart.bio_assay_feature_group
	(feature_group_name
	,feature_group_type)
	select distinct t.uniprotid, 'PROTEIN'
	from LT_SRC_RBM_ANNOTATION t
	where not exists
		 (select 1 from biomart.bio_assay_feature_group x
		  where t.uniprotid = x.feature_group_name)
		and (t.uniprotid IS NOT NULL AND t.uniprotid::text <> '');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert probesets into biomart.bio_assay_feature_group',rowCt,stepCt,'Done') into rtnCd;

	--	insert probesets into biomart.bio_assay_data_annotation
	begin
	insert into biomart.bio_assay_data_annotation
	(bio_assay_feature_group_id
	,bio_marker_id)
	select distinct fg.bio_assay_feature_group_id
		  ,coalesce(bgs.bio_marker_id,bgi.bio_marker_id)
	from LT_SRC_RBM_ANNOTATION t
	INNER JOIN biomart.bio_assay_feature_group fg on t.uniprotid = fg.feature_group_name
	LEFT OUTER JOIN biomart.bio_marker bgs on t.gene_symbol = bgs.bio_marker_name
	LEFT OUTER JOIN biomart.bio_marker bgi on t.gene_id::varchar = bgi.primary_external_id
	where ((t.gene_symbol IS NOT NULL AND t.gene_symbol::text <> '') or (t.gene_id IS NOT NULL AND t.gene_id::text <> ''))
	  and coalesce(bgs.bio_marker_id,bgi.bio_marker_id,-1) > 0
	  and not exists
		 (select 1 from biomart.bio_assay_data_annotation x
		  where fg.bio_assay_feature_group_id = x.bio_assay_feature_group_id
		    and coalesce(bgs.bio_marker_id,bgi.bio_marker_id,-1) = x.bio_marker_id);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Link feature_group to bio_marker in biomart.bio_assay_data_annotation',rowCt,stepCt,'Done') into rtnCd;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_rbm_annotation',0,stepCt,'Done') into rtnCd;

       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
  END IF;

  return 1;

END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_load_rbm_annotation(currentjobid bigint) OWNER TO postgres;

--
-- Name: i2b2_load_rbm_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_load_rbm_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_code character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT NULL::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
DECLARE

/*************************************************************************

* This store procedure is for ETL  to load  RBM data for Sanofi
* Date: 12/05/2013

******************************************************************/
--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint	

  TrialID		varchar(100);
  RootNode		varchar(2000);
  root_level	integer;
  topNode		varchar(2000);
  topLevel		integer;
  tPath			varchar(2000);
  study_name	varchar(100);
  sourceCd		varchar(50);
  secureStudy	varchar(1);

  dataType		varchar(10);
  sqlText		varchar(1000);
  tText			varchar(1000);
  gplTitle		varchar(1000);
  pExists		bigint;
  partTbl   	bigint;
  partExists 	bigint;
  sampleCt		bigint;
  idxExists 	bigint;
  logBase		bigint;
  pCount		integer;
  sCount		integer;
  tablespaceName	varchar(200);
  v_bio_experiment_id	bigint;
  partitioniD	numeric(18,0);
  partitionName	varchar(100);
  partitionIndx	varchar(100);
  
    --Audit variables
  newJobFlag integer;
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  rowCt			numeric(18,0);
  errorNumber		character varying;
  errorMessage	character varying;
  rtnCd			integer;

	addNodes CURSOR FOR
	SELECT distinct t.leaf_node
          ,t.node_name
	from  WT_RBM_NODES t
	where not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where t.leaf_node = x.c_fullname);

 
--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  delNodes CURSOR FOR
  SELECT distinct c_fullname 
  from  i2b2metadata.i2b2
  where c_fullname like topNode || '%'
    and substring(c_visualattributes from 2 for 1) = 'H';


	uploadI2b2 CURSOR FOR
    select category_cd,display_value,display_label,display_unit from
    lt_src_rbm_display_mapping;



BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\','g');
	select length(topNode)-length(replace(topNode,'\','')) into topLevel ;
	
	if coalesce(data_type::text, '') = '' then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;
	
	logBase := coalesce(log_base, 2);
	sourceCd := upper(coalesce(source_code,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  databaseName := current_schema();
	procedureName := 'I2B2_LOAD_RBM_DATA';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName, jobID) into jobId;
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_rbm_data',0,stepCt,'Done') into rtnCd;
	
	--	Get count of records in LT_SRC_RBM_SUBJ_SAMP_MAP
	
	select count(*) into sCount
	from LT_SRC_RBM_SUBJ_SAMP_MAP;
	
	--	check if all subject_sample map records have a platform, If not, abort run
       /* if sCount > 0 then
		select cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
	end if;
	*/
	select count(*) into pCount
	from LT_SRC_RBM_SUBJ_SAMP_MAP
	where coalesce(platform::text, '') = '';
	
	if pCount > 0 then
		select cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
	end if;
  
  	--	check if platform exists in de_rbm_annotation .  If not, abort run.
	
	select count(*) into pCount
	from LT_SRC_RBM_ANNOTATION --change
	where gpl_id in (select distinct m.platform from LT_SRC_RBM_SUBJ_SAMP_MAP m);
	
	select count(*) into pCount
	from DEAPP.DE_gpl_info
	where platform in (select distinct m.platform from LT_SRC_RBM_SUBJ_SAMP_MAP m);
	
	if PCOUNT = 0 then
		select cz_write_audit(jobId,databasename,procedurename,'Platform not found in de_rbm_annotation',1,stepCt,'ERROR') into rtnCd;
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 163;
	end if;
		
	--	check if all subject_sample map records have a tissue_type, If not, abort run
	
	select count(*) into pCount
	from LT_SRC_RBM_SUBJ_SAMP_MAP
	where coalesce(tissue_type::text, '') = '';
	
	if pCount > 0 then
		select cz_write_audit(jobId,databasename,procedurename,'Tissue Type data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select CZ_END_AUDIT (JOBID,'FAIL') into rtnCd;
		return 162;  
	end if;
	
	--	check if there are multiple platforms, if yes, then platform must be supplied in LT_SRC_RBM_DATA

	select count(*) into pCount
	from (select sample_cd
		  from LT_SRC_RBM_SUBJ_SAMP_MAP
		  group by sample_cd
		  having count(distinct platform) > 1) as x;
	
	if pCount > 0 then
		select cz_write_audit(jobId,databasename,procedurename,'Multiple platforms for sample_cd in LT_SRC_RBM_SUBJ_SAMP_MAP',1,stepCt,'ERROR') into rtnCd;
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 164;
	end if;
		
	-- Get root_node from topNode
  
	select parse_nth_value(topNode, 2, '\') into RootNode ;
	
	select count(*) into pExists
	from i2b2metadata.table_access
	where c_name = rootNode;
	
	if pExists = 0 then
		perform i2b2_add_root_node(rootNode, jobId);
	end if;
	
	select c_hlevel into root_level
	from i2b2metadata.i2b2
	where c_name = RootNode;
	
	-- Get study name from topNode
  
	select parse_nth_value(topNode, topLevel, '\') into study_name ;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount ;

	if pCount > 2 then
		perform i2b2_fill_in_tree(null, tPath, jobId);
	end if;

	--	uppercase study_id in lt_src_rbm_subj_samp_map in case curator forgot
	begin
	update LT_SRC_RBM_SUBJ_SAMP_MAP
	set trial_name=upper(trial_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in LT_SRC_RBM_SUBJ_SAMP_MAP',rowCt,stepCt,'Done') into rtnCd;

	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd
	begin
	insert into i2b2demodata.patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from LT_SRC_RBM_SUBJ_SAMP_MAP s
		     ,DEAPP.DE_gpl_info g
		 where (s.subject_id IS NOT NULL AND s.subject_id::text <> '')
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = 'RBM'
		   and not exists
			  (select 1 from i2b2demodata.patient_dimension x
			   where x.sourcesystem_cd = 
				  regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) as x;
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	pCount := rowCt;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',pCount,stepCt,'Done') into rtnCd;
	
	perform i2b2_create_security_for_trial(TrialId, secureStudy, jobID);

	--	Delete existing observation_fact data, will be repopulated
	begin
	delete from i2b2demodata.observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from deapp.DE_SUBJECT_SAMPLE_MAPPING x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = 'RBM');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;
	
	select count(*) into partExists
	from deapp.de_subject_sample_mapping sm
	where sm.trial_name = TrialId
	and coalesce(sm.source_cd,'STD') = sourceCd
	and sm.platform = 'RBM'
	and sm.partition_id is not null;
	
	if partExists = 0 then
		select nextval('deapp.seq_rbm_partition_id') into partitionId;
	else
		select distinct partition_id into partitionId
		from deapp.de_subject_sample_mapping sm
		where sm.trial_name = TrialId
		and coalesce(sm.source_cd,'STD') = sourceCd
		and sm.platform = 'RBM';
	end if;

	partitionName := 'deapp.de_subject_rbm_data_' || partitionId::text;
	partitionIndx := 'de_subject_rbm_data_' || partitionId::text;

	--	Cleanup any existing data in de_subject_sample_mapping.  
	begin
	delete from deapp.DE_SUBJECT_SAMPLE_MAPPING 
	where trial_name = TrialID 
	  and coalesce(source_cd,'STD') = sourceCd
	  and platform = 'RBM'; --Making sure only rbm data is deleted
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

--	truncate tmp node table

	EXECUTE('truncate table WT_RBM_NODES');
	
--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
--	from wt_subject_rbm_data

	EXECUTE('truncate table WT_RBM_NODE_VALUES');
	begin
	insert into WT_RBM_NODE_VALUES
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from LT_SRC_RBM_SUBJ_SAMP_MAP a
	    ,DEAPP.DE_gpl_info g 
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = 'RBM'
	  and g.title = (select min(x.title) from DEAPP.DE_gpl_info x where coalesce(a.platform,'GPL570') = x.platform)
	  ;
	  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
      
	--  and decode(dataType,'R',sign(a.intensity_value),1) = 1;	--	take all values when dataType T, only >0 for dataType R
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP wt_rbm_node_values',rowCt,stepCt,'Done') into rtnCd;
	
	begin
	insert into WT_RBM_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
        ,attribute_2
	,node_type
	)
			select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g')
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  WT_RBM_NODE_VALUES;
		   	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_rbm_nodes',rowCt,stepCt,'Done') into rtnCd;
	
	--	insert for platform node so platform concept can be populated
	
	begin
	insert into WT_RBM_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
        ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  WT_RBM_NODE_VALUES;
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		   
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in wt_rbm_nodes',rowCt,stepCt,'Done') into rtnCd;

	
	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd

	begin
	insert into WT_RBM_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  WT_RBM_NODE_VALUES
	where category_cd like '%ATTR1%'
	  and (attribute_1 IS NOT NULL AND attribute_1::text <> '');
	  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		   
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in WT_RBM_NODES',rowCt,stepCt,'Done') into rtnCd;

	
	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd
	begin
	insert into WT_RBM_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
		select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
		substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  WT_RBM_NODE_VALUES
	where category_cd like '%ATTR2%'
	  and (attribute_2 IS NOT NULL AND attribute_2::text <> '');
	  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		   
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_RBM_NODES',rowCt,stepCt,'Done') into rtnCd;

	
	--	insert for tissue_type node so sample_type_cd can be populated
	begin
	insert into WT_RBM_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  WT_RBM_NODE_VALUES
	where category_cd like '%TISSUETYPE%';
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		   
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_qpcr_rbm_nodes',rowCt,stepCt,'Done') into rtnCd;

	begin
	update WT_RBM_NODES
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_rbm_nodes',rowCt,stepCt,'Done') into rtnCd;

		
--	add leaf nodes for RBM data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)
		begin
		perform i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId);
			get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;
		
		select cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;
		
		perform i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID);

	END LOOP;  
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
	begin
	update i2b2metadata.i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end; 
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done') into rtnCd;

		
--	update concept_cd for nodes, this is done to make the next insert easier
	begin
	update WT_RBM_NODES t
	set concept_cd=(select c.concept_cd from i2b2demodata.concept_dimension c
	                where c.concept_path = t.leaf_node 
				   )
    where exists
         (select 1 from i2b2demodata.concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and coalesce(t.concept_cd::text, '') = '';
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Update WT_RBM_NODES with newly created concept_cds',rowCt,stepCt,'Done') into rtnCd;

	 

  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_rbm_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in wt_rbm_nodes
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in wt_rbm_nodes
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in wt_rbm_nodes
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in wt_rbm_nodes
  --PLATFORM        = RBM - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in wt_rbm_nodes
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_rbm_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd
  
  --ASSAY_ID        = generated by trigger
	begin
	insert into deapp.DE_SUBJECT_SAMPLE_MAPPING
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
	,partition_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
		  ,partitionId
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,'RBM' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+RBM+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from LT_SRC_rbm_subj_samp_map a
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join i2b2demodata.patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = b.sourcesystem_cd
		inner join WT_RBM_NODES ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'@') = coalesce(ln.attribute_1,'@')
			and coalesce(a.attribute_2,'@') = coalesce(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join WT_RBM_NODES pn
			on a.platform = pn.platform
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(pn.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(pn.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'	  
		left outer join WT_RBM_NODES ttp
			on a.tissue_type = ttp.tissue_type
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = coalesce(ttp.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(ttp.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'		  
		left outer join WT_RBM_NODES a1
			on a.attribute_1 = a1.attribute_1
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a1.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a1.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'		  
		left outer join WT_RBM_NODES a2
			on a.attribute_2 = a1.attribute_2
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a2.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a2.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'			  
		left outer join i2b2demodata.patient_dimension sid
			 on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  (ln.concept_cd IS NOT NULL AND ln.concept_cd::text <> '')) as t;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

--	Insert records for patients and samples into observation_fact
	begin
	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,INSTANCE_NUM
    )
    select distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,1
    from  deapp.DE_SUBJECT_SAMPLE_MAPPING m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCD
      and m.platform = 'RBM';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	  
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

    
    
	--	Insert sample facts 
	begin
	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    select distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  deapp.DE_SUBJECT_SAMPLE_MAPPING m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCd
      and m.platform = 'RBM'
	 and m.patient_id != m.sample_id;
	  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

    
    
	--Update I2b2 for correct data type
	begin
	update i2b2metadata.i2b2 t
	set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
	where t.c_basecode in (select distinct x.concept_cd from WT_RBM_NODES x);
  	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	    stepCt := stepCt + 1;
    select cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',rowCt,stepCt,'Done') into rtnCd;
    
     ---INSERT sample_dimension
	 begin
      INSERT INTO I2B2DEMODATA.SAMPLE_DIMENSION(SAMPLE_CD)
         SELECT DISTINCT SAMPLE_CD FROM
           DEAPP.DE_SUBJECT_SAMPLE_MAPPING WHERE SAMPLE_CD NOT IN (SELECT SAMPLE_CD FROM I2B2DEMODATA.SAMPLE_DIMENSION) ;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
       stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'insert distinct sample_cd in sample_dimension from de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

		---- update c_metedataxml in i2b2
	begin	
		   for ul in uploadI2b2
			loop
		 update i2b2metadata.i2b2 n
		SET n.c_columndatatype = 'T',
		  --Static XML String
			n.c_metadataxml =  ('<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>N</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue>
					<HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue>
					<LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue>
					<EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion>
					<UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits>
					<ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor>
					</ConvertingUnits></UnitValues><Analysis><Enums /><Counts />
					<New /></Analysis>'||(select xmlelement(name "SeriesMeta",xmlforest(m.display_value as "Value",m.display_unit as "Unit",m.display_label as "DisplayName")) as hi
		  from lt_src_rbm_display_mapping m where m.category_cd=ul.category_cd)||
					'</ValueMetadata>') where n.c_fullname=(select leaf_node from WT_RBM_NODES where category_cd=ul.category_cd  and leaf_node=n.c_fullname);
					
					end loop;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',rowCt,stepCt,'Done')into rtnCd;

	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	begin
	update i2b2metadata.i2b2 a
    set c_visualattributes = 'LAH'
	where a.c_basecode in (select distinct x.concept_code from deapp.DE_SUBJECT_SAMPLE_MAPPING x
						   where x.trial_name = TrialId
						     and x.platform = 'RBM'
							 and (x.concept_code IS NOT NULL AND x.concept_code::text <> ''));
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;  
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;
  
begin
    update i2b2metadata.i2b2 a
	set c_visualattributes='FAS'
        where a.c_fullname = substr(topNode,1,instr(topNode,'\',1,3));
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
        
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for study nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done');
    
  
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for rbm data
  
    perform i2b2_create_concept_counts(topNode ,jobID );
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done') into rtnCd;
	
	--	delete each node that is hidden

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time
	begin
		perform i2b2_delete_1_node(r_delNodes.c_fullname);
			get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		
		select cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;

	END LOOP;  	


  --Reload Security: Inserts one record for every I2B2 record into the security table

    perform i2b2_load_security_data(jobId);
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done') into rtnCd;

--	tag data with probeset_id from reference.probeset_deapp
  
	EXECUTE ('truncate table WT_SUBJECT_RBM_PROBESET');
	
	--	note: assay_id represents a unique subject/site/sample
	begin
	insert into WT_SUBJECT_RBM_PROBESET  --mod
    (probeset
--    ,expr_id
    ,intensity_value
    --  ,num_calls
    --  ,pvalue
        ,assay_id
        ,patient_id
        ,sample_id
    ,subject_id
    ,trial_name
        ,timepoint
        ,sample_type
        ,platform
        ,tissue_type    
    )
    select md.analyte
          ,avg(md.avalue::numeric)
                  ,sd.assay_id
                  ,sd.patient_id
          ,md.sample_id
                  ,sd.subject_id
                  ,TrialId
                  ,sd.timepoint
                  ,sd.sample_type
                  ,sd.gpl_id   --UAT_142 25/feb/14 changes
                  ,sd.tissue_type
    from deapp.de_subject_sample_mapping sd
        ,LT_SRC_RBM_DATA md
    where sd.sample_cd = md.sample_id
     and sd.platform = 'RBM'
      and sd.trial_name =TrialId
      and sd.source_cd = sourceCd
     -- and sd.gpl_id = gs.id_ref   --check
    --and trim(substr(md.analyte,1,instr(md.analyte,'(')-1)) =trim(gs.antigen_name)
    and (CASE WHEN dataType = 'R' THEN sign(md.avalue::numeric) ELSE 1 END) <> -1  --UAT 154 changes done on 19/03/2014
    and sd.subject_id in (select subject_id from LT_SRC_RBM_SUBJ_SAMP_MAP)
    group by md.analyte
          ,sd.patient_id,sd.assay_id
                  ,md.sample_id
                  ,sd.subject_id
                  ,sd.timepoint
                  ,sd.sample_type
                  ,sd.gpl_id
                  ,sd.tissue_type;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_rbm_probeset',rowCt,stepCt,'Done') into rtnCd;
	
--mod

	--	Calculate ZScores and insert data into de_subject_rbm_data.  The 'L' parameter indicates that the gene expression data will be selected from
	--	wt_subject_rbm_probeset as part of a Load.  

		if dataType = 'R' or dataType = 'L' then
			perform i2b2_rbm_zscore_calc_new(TrialID, partitionName, partitionindx,partitioniD,'L',jobId,dataType,logBase,sourceCD);
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',0,stepCt,'Done') into rtnCd;
		end if;

    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_LOAD_RBM_DATA',0,stepCt,'Done') into rtnCd;

	IF newJobFlag = 1
	THEN
		select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 0 ; 
END;
 
$$;


ALTER FUNCTION tm_dataloader.i2b2_load_rbm_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base numeric, secure_study character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_load_samples(character varying, character varying, character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_load_samples(trial_id character varying, top_node character varying, platform_type character varying, source_cd character varying DEFAULT 'STD'::character varying, secure_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;

	TrialID			varchar(100);
	RootNode		varchar(2000);
	root_level		integer;
	topNode			varchar(2000);
	topLevel		integer;
	tPath			varchar(2000);
	study_name		varchar(100);
	sourceCd		varchar(50);
	secureStudy		varchar(1);

	tText			varchar(1000);
	pExists			numeric;
	partExists 		numeric;
	pCount			integer;
	sCount			integer;
	partitionId		numeric(18,0);

	--	cursor to add leaf nodes, cursor is used here because there are few nodes to be added

	addNodes CURSOR is
	select distinct t.leaf_node
          ,t.node_name
	from  wt_mrna_nodes t
	where not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where t.leaf_node = x.c_fullname);

	--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

	delNodes CURSOR is
	select distinct c_fullname
	from  i2b2metadata.i2b2
	where c_fullname like topNode || '%' escape '`'
      and substr(c_visualattributes,2,1) = 'H';

BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	databaseName := current_schema();
	procedureName := 'I2B2_LOAD_SAMPLES';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_samples',0,stepCt,'Done') into rtnCd;

	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;

	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\','g');
	select length(topNode)-length(replace(topNode,'\','')) into topLevel;

	sourceCd := upper(coalesce(source_cd,'STD'));

	--	Get count of records in lt_src_mrna_subj_samp_map

	select count(*) into sCount
	from lt_src_mrna_subj_samp_map sm
	where sm.source_cd = upper(coalesce(sourceCd, 'STD'));

	--	check if all subject_sample map records have a subject_id, If not, abort run

	select count(*) into pCount
	from lt_src_mrna_subj_samp_map t
	where subject_id is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'subject_id missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a sample_cd, If not, abort run

	select count(*) into pCount
	from lt_src_mrna_subj_samp_map t
	where sample_cd is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'sample_cd missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a platform, If not, abort run

	select count(*) into pCount
	from lt_src_mrna_subj_samp_map t
	where platform is null;

	if pCount > 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Platform missing in lt_src_mrna_subj_samp_map',0,pCount,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if entry in deapp.de_gpl_info for every Gene Expression platform, if not, abort run

	select count(*) into pCount
	from lt_src_mrna_subj_samp_map sm
	where coalesce(sm.platform, '') <> '' and not exists
		 (select 1 from deapp.de_gpl_info gi
		  where sm.platform = gi.platform
		    and gi.marker_type = 'Gene Expression'
			and gi.title is not null);

	if pCount > 0 then
		select cz_write_audit(jobId,databaseName,procedureName,'deapp.de_gpl_info entry missing for one or more platforms',0,pCount,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if all subject_sample map records have a tissue_type, If not, abort run

	select count(*) into pCount
	from lt_src_mrna_subj_samp_map
	where tissue_type is null;

	if pCount > 0 then
		select cz_write_audit(jobId,databaseName,procedureName,'Tissue_Type is null for subjects',0,pCount,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	--	check if there are multiple platforms for a single sample   if yes, then different source_cd must be used to load the samples.

	select count(*) into pCount
	from (select sample_cd
		  from lt_src_mrna_subj_samp_map
		  group by sample_cd
		  having count(distinct platform) > 1) x;

	if pCount > 0 then
		select cz_write_audit(jobId,databaseName,procedureName,'Multiple platforms for single sample',0,pCount,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	-- Get root_node from topNode

	select parse_nth_value(topNode, 2, '\') into RootNode;

	select count(*) into pExists
	from i2b2metadata.i2b2 i2, i2b2metadata.table_access ta
	where i2.c_name = rootNode and ta.c_name = rootNode;

	if pExists = 0 then
		select i2b2_add_root_node(rootNode, jobId) into rtnCd;
	end if;

	select c_hlevel into root_level
	from i2b2metadata.table_access
	where c_name = RootNode;

	-- Get study name from topNode

	select parse_nth_value(topNode, topLevel, '\') into study_name;

	--	Add any upper level nodes as needed

	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount;

	if pCount > 2 then
		select i2b2_fill_in_tree('', tPath, jobId) into rtnCd;
	end if;

	--	uppercase study_id in lt_src_mrna_subj_samp_map in case curator forgot

	begin
	update lt_src_mrna_subj_samp_map
	set trial_name=upper(trial_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in lt_src_mrna_subj_samp_map',rowCt,stepCt,'Done') into rtnCd;

	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd

	begin
	insert into i2b2demodata.patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,current_timestamp
		  ,current_timestamp
		  ,current_timestamp
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from lt_src_mrna_subj_samp_map s
		 where s.subject_id is not null
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and not exists
			  (select 1 from i2b2demodata.patient_dimension x
			   where x.sourcesystem_cd =
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) x;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	--	add security for trial if new subjects added to patient_dimension

	if pCount > 0 then
		select i2b2_create_security_for_trial(TrialId, secureStudy, jobID) into rtnCd;
	end if;

	--	Delete existing observation_fact data, will be repopulated

	begin
	delete from i2b2demodata.observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from deapp.de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = platform_type);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--	check if trial/source_cd already loaded, if yes, get existing partition_id else get new one

	select count(*) into partExists
	from deapp.de_subject_sample_mapping sm
	where sm.trial_name = TrialId
	  and coalesce(sm.source_cd,'STD') = sourceCd
	  and sm.platform = platform_type
	  and sm.partition_id is not null;

	if partExists = 0 then
		select nextval('deapp.seq_mrna_partition_id') into partitionId;
	else
		select distinct partition_id into partitionId
		from deapp.de_subject_sample_mapping sm
		where sm.trial_name = TrialId
		  and coalesce(sm.source_cd,'STD') = sourceCd
		  and sm.platform = platform_type;
	end if;

	--	truncate tmp node table

	execute ('truncate table wt_mrna_nodes');

	--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
	--	from wt_subject_mrna_data

	execute ('truncate table wt_mrna_node_values');

	begin
	insert into wt_mrna_node_values
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	         ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from lt_src_mrna_subj_samp_map a
    left join deapp.de_gpl_info g
    on a.platform = g.platform and upper(g.marker_type) = 'GENE EXPRESSION'
	where a.trial_name = TrialID
	  and a.source_cd = sourceCD;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP wt_mrna_node_values',rowCt,stepCt,'Done') into rtnCd;

	--	inserts that create the ontology for the leaf nodes

	begin
	insert into wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
  ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       category_cd,'PLATFORM',coalesce(title,'')),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g')
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  wt_mrna_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for platform node so platform concept can be populated

	begin
	insert into wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
  ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'PLATFORM',coalesce(title,'')),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'PLATFORM'
	from  wt_mrna_node_values
	where category_cd like '%PLATFORM%';

	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd

	begin
	insert into wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
  ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM',coalesce(title,'')),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else '' end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'ATTR1'
	from  wt_mrna_node_values
	where category_cd like '%ATTR1%'
	  and attribute_1 is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd

	begin
	insert into wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
  ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM',coalesce(title,'')),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else '' end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else '' end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  wt_mrna_node_values
	where category_cd like '%ATTR2%'
	  and attribute_2 is not null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for tissue_type node so sample_type_cd can be populated

	begin
	insert into wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM',coalesce(title,'')),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else '' end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else '' end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else '' end as attribute_2
		  ,'TISSUETYPE'
	from  wt_mrna_node_values
	where category_cd like '%TISSUETYPE%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	set node_name

	begin
	update wt_mrna_nodes
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_mrna_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	add leaf nodes for mRNA data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)

		select i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;

		select cz_write_audit(jobId,databaseName,procedureName,tText,1,stepCt,'Done') into rtnCd;

		select i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID) into rtnCd;

	END LOOP;

	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes

	begin
	update i2b2metadata.i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done') into rtnCd;

	--	update concept_cd for nodes, this is done to make the next insert easier

	begin
	update wt_mrna_nodes t
	set concept_cd=(select c.concept_cd from i2b2demodata.concept_dimension c
	                where c.concept_path = t.leaf_node
				   )
    where exists
         (select 1 from i2b2demodata.concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and t.concept_cd is null;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Update wt_mrna_nodes with newly created concept_cds',rowCt,stepCt,'Done') into rtnCd;

	--Update or insert DE_SUBJECT_SAMPLE_MAPPING from wt_subject_mrna_data

	--PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
	--SITE_ID         = site_id
	--SUBJECT_ID      = subject_id
	--SUBJECT_TYPE    = NULL
	--CONCEPT_CODE    = from LEAF records in wt_mrna_nodes
	--SAMPLE_TYPE    	= TISSUE_TYPE
	--SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in wt_mrna_nodes
	--TRIAL_NAME      = TRIAL_NAME
	--TIMEPOINT		= attribute_2
	--TIMEPOINT_CD	= concept_cd from ATTR2 records in wt_mrna_nodes
	--TISSUE_TYPE     = attribute_1
	--TISSUE_TYPE_CD  = concept_cd from ATTR1 records in wt_mrna_nodes
	--PLATFORM        = MRNA_AFFYMETRIX - this is required by ui code
	--PLATFORM_CD     = concept_cd from PLATFORM records in wt_mrna_nodes
	--DATA_UID		= concatenation of concept_cd-patient_num
	--GPL_ID			= platform from wt_subject_mrna_data
	--CATEGORY_CD		= category_cd that generated ontology
	--SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
	--SAMPLE_CD		= sample_cd
	--SOURCE_CD		= sourceCd
	--PARTITION_ID	= partitionId

	--ASSAY_ID        = generated by trigger

	begin
	with upd as (select a.site_id, a.subject_id, a.sample_cd,
					ln.concept_cd as concept_code, ttp.concept_cd as sample_type_cd, a2.concept_cd as timepoint_cd, a1.concept_cd as tissue_type_cd, a.category_cd,
					pn.concept_cd as platform_cd, pd.patient_num as patient_id, ln.concept_cd || '-' || pd.patient_num::text as data_uid,
					ln.tissue_type as sample_type, ln.attribute_1 as tissue_type, ln.attribute_2 as timepoint, a.platform as gpl_id
				 from lt_src_mrna_subj_samp_map a
				 inner join i2b2demodata.patient_dimension pd
					on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = pd.sourcesystem_cd
				 inner join wt_mrna_nodes ln
					on 	a.platform = ln.platform
					and a.tissue_type = ln.tissue_type
					and coalesce(a.attribute_1,'') = coalesce(ln.attribute_1,'')
					and coalesce(a.attribute_2,'') = coalesce(ln.attribute_2,'')
					and ln.node_type = 'LEAF'
				 left join wt_mrna_nodes pn
					on  a.platform = pn.platform
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(pn.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(pn.attribute_1,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(pn.attribute_2,'')
					and pn.node_type = 'PLATFORM'
				 left outer join wt_mrna_nodes ttp
					on  a.tissue_type = ttp.tissue_type
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '' end = coalesce(ttp.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(ttp.attribute_1,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(ttp.attribute_2,'')
					and ttp.node_type = 'TISSUETYPE'
				 left outer join wt_mrna_nodes a1
					on  a.attribute_1 = a1.attribute_1
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a1.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a1.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(a1.attribute_2,'')
					and a1.node_type = 'ATTR1'
				 left outer join wt_mrna_nodes a2
					on  a.attribute_2 = a2.attribute_2
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a2.platform,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a2.tissue_type,'')
					and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(a2.attribute_1,'')
					and a2.node_type = 'ATTR2')
		update deapp.de_subject_sample_mapping pd
		set concept_code=upd.concept_code
			,sample_type_cd=upd.sample_type_cd
			,timepoint_cd=upd.timepoint_cd
			,tissue_type_cd=upd.tissue_type_cd
			,category_cd=upd.category_cd
			,platform_cd=upd.platform_cd
			,patient_id=upd.patient_id
			,data_uid=upd.data_uid
			,sample_type=upd.sample_type
			,tissue_type=upd.tissue_type
			,timepoint=upd.timepoint
			,omic_patient_id=upd.patient_id
			,partition_id=partitionId
		from upd
		where pd.trial_name = TrialID
		  and pd.source_cd = sourceCD
		  and coalesce(pd.site_id,'') = coalesce(upd.site_id,'')
		  and pd.subject_id = upd.subject_id
		  and pd.sample_cd = upd.sample_cd;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Update existing data in de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
	pcount := rowCt;	--	set counter to check that all subject_sample mapping records were added/updated
	--	insert any site/subject/samples that are not in de_subject_sample_mapping

	begin
	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
	,partition_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
		  ,partitionId
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,NULLIF(a.attribute_2, '') as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,NULLIF(a.attribute_1, '') as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,platform_type as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+Gene_Expression+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from lt_src_mrna_subj_samp_map a
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join i2b2demodata.patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = b.sourcesystem_cd
		inner join wt_mrna_nodes ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'') = coalesce(ln.attribute_1,'')
			and coalesce(a.attribute_2,'') = coalesce(ln.attribute_2,'')
			and ln.node_type = 'LEAF'
		left join wt_mrna_nodes pn
			on a.platform = pn.platform
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(pn.tissue_type,'')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(pn.attribute_1,'')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(pn.attribute_2,'')
			and pn.node_type = 'PLATFORM'
		left outer join wt_mrna_nodes ttp
			on a.tissue_type = ttp.tissue_type
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '' end = coalesce(ttp.platform,'')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(ttp.attribute_1,'')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(ttp.attribute_2,'')
			and ttp.node_type = 'TISSUETYPE'
		left outer join wt_mrna_nodes a1
			on a.attribute_1 = a1.attribute_1
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a1.platform,'')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a1.tissue_type,'')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '' end = coalesce(a1.attribute_2,'')
			and a1.node_type = 'ATTR1'
		left outer join wt_mrna_nodes a2
			on a.attribute_2 = a2.attribute_2
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '' end = coalesce(a2.platform,'')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '' end = coalesce(a2.tissue_type,'')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '' end = coalesce(a2.attribute_1,'')
			and a2.node_type = 'ATTR2'
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  ln.concept_cd is not null
		  and not exists
			  (select 1 from deapp.de_subject_sample_mapping x
			   where a.trial_name = x.trial_name
			     and coalesce(a.source_cd,'STD') = x.source_cd
				 and x.platform = platform_type
				 and coalesce(a.site_id,'') = coalesce(x.site_id,'')
				 and a.subject_id = x.subject_id
				 and a.sample_cd = x.sample_cd
				 )) t;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
	pCount := pCount + rowCt;

	--	check if all records from lt_src_mrna_subj_samp_map were added/updated

	if scount <> pCount then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Not all records in lt_src_mrna_subj_samp_map inserted/updated in de_subject_sample_mapping',0,stepCt,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;
	--	Insert records for subjects into observation_fact
	begin
	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    select distinct m.patient_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,current_timestamp
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  deapp.de_subject_sample_mapping m
    where m.trial_name = TrialID
	  and m.source_cd = sourceCD
      and m.platform = platform_type;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--Update I2b2 for correct c_columndatatype, c_visualattributes, c_metadataxml

	begin
	with upd as (select x.concept_cd, min(case when x.node_type = 'LEAF' then 0 else 1 end) as node_type from wt_mrna_nodes x group by x.concept_cd)
	update i2b2metadata.i2b2 t
	set c_columndatatype = 'T'
	   ,c_metadataxml = null
	   ,c_visualattributes=case when upd.node_type = 0 then 'LAH' else 'FA' end
	from upd
	where t.c_basecode = upd.concept_cd;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type, visualattributes and xml in i2b2',rowCt,stepCt,'Done') into rtnCd;

  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for mRNA data

  select i2b2_create_concept_counts(topNode ,jobID ) into rtnCd;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done') into rtnCd;

	--	delete each node that is hidden

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		select i2b2_delete_1_node(r_delNodes.c_fullname) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;

		select cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done') into rtnCd;

	END LOOP;

	--Reload Security: Inserts one record for every I2B2 record into the security table

    perform i2b2_load_security_data(TrialID, jobID);
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done') into rtnCd;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_samples',0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_load_samples(trial_id character varying, top_node character varying, platform_type character varying, source_cd character varying, secure_study character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_load_security_data(numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_load_security_data(currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			numeric;

BEGIN

	--Set Audit Parameters
	databaseName := current_schema();
	procedureName := 'I2B2_LOAD_SECURITY';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	select case when coalesce(currentjobid, -1) < 1 then cz_start_audit(procedureName, databaseName) else currentjobid end into jobId;

	truncate table I2B2METADATA.i2b2_secure;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Truncate I2B2METADATA i2b2_secure',0,stepCt,'Done') into rtnCd;

	insert into I2B2METADATA.i2b2_secure
	(C_HLEVEL,
     C_FULLNAME,
     C_NAME,
     C_SYNONYM_CD,
     C_VISUALATTRIBUTES,
     C_TOTALNUM,
     C_BASECODE,
     C_METADATAXML,
     C_FACTTABLECOLUMN,
     C_TABLENAME,
     C_COLUMNNAME,
     C_COLUMNDATATYPE,
     C_OPERATOR,
     C_DIMCODE,
     C_COMMENT,
     C_TOOLTIP,
     UPDATE_DATE,
     DOWNLOAD_DATE,
     IMPORT_DATE,
     SOURCESYSTEM_CD,
     VALUETYPE_CD,
	 secure_obj_token)
  select
    b.C_HLEVEL,
    b.C_FULLNAME,
    b.C_NAME,
    b.C_SYNONYM_CD,
    b.C_VISUALATTRIBUTES,
    b.C_TOTALNUM,
    b.C_BASECODE,
    b.C_METADATAXML,
    b.C_FACTTABLECOLUMN,
    b.C_TABLENAME,
    b.C_COLUMNNAME,
    b.C_COLUMNDATATYPE,
    b.C_OPERATOR,
    b.C_DIMCODE,
    b.C_COMMENT,
    b.C_TOOLTIP,
    b.UPDATE_DATE,
    b.DOWNLOAD_DATE,
    b.IMPORT_DATE,
    b.SOURCESYSTEM_CD,
    b.VALUETYPE_CD,
	coalesce(f.tval_char,'EXP:PUBLIC')
    from I2B2METADATA.I2B2 b
	left outer join (select distinct modifier_cd, tval_char from i2b2demodata.observation_fact where concept_cd = 'SECURITY') f
		 on b.sourcesystem_cd = f.modifier_cd;
	get diagnostics rowCt := ROW_COUNT;
    stepCt := stepCt + 1;
    select cz_write_audit(jobId,databaseName,procedureName,'Insert security data into I2B2METADATA i2b2_secure',rowCt,stepCt,'Done') into rtnCd;

    ---Cleanup OVERALL JOB if this proc is being run standalone
	perform cz_end_audit (jobID, 'SUCCESS') where coalesce(currentJobId, -1) <> jobId;

	return 1;

	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;

END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_load_security_data(currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_load_security_data(character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_load_security_data(sourcesystemcd character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;

BEGIN
	--Set Audit Parameters
	databaseName := current_schema();
	procedureName := 'I2B2_LOAD_SECURITY';

	select case when coalesce(currentjobid, -1) < 1 then cz_start_audit(procedureName, databaseName) else currentjobid end into jobId;

	delete from I2B2METADATA.i2b2_secure where sourcesystem_cd = sourcesystemCd;

  get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Clean-up I2B2METADATA i2b2_secure',rowCt,stepCt,'Done');

	insert into I2B2METADATA.i2b2_secure
	(C_HLEVEL,
     C_FULLNAME,
     C_NAME,
     C_SYNONYM_CD,
     C_VISUALATTRIBUTES,
     C_TOTALNUM,
     C_BASECODE,
     C_METADATAXML,
     C_FACTTABLECOLUMN,
     C_TABLENAME,
     C_COLUMNNAME,
     C_COLUMNDATATYPE,
     C_OPERATOR,
     C_DIMCODE,
     C_COMMENT,
     C_TOOLTIP,
     UPDATE_DATE,
     DOWNLOAD_DATE,
     IMPORT_DATE,
     SOURCESYSTEM_CD,
     VALUETYPE_CD,
	 secure_obj_token)
  select
    b.C_HLEVEL,
    b.C_FULLNAME,
    b.C_NAME,
    b.C_SYNONYM_CD,
    b.C_VISUALATTRIBUTES,
    b.C_TOTALNUM,
    b.C_BASECODE,
    b.C_METADATAXML,
    b.C_FACTTABLECOLUMN,
    b.C_TABLENAME,
    b.C_COLUMNNAME,
    b.C_COLUMNDATATYPE,
    b.C_OPERATOR,
    b.C_DIMCODE,
    b.C_COMMENT,
    b.C_TOOLTIP,
    b.UPDATE_DATE,
    b.DOWNLOAD_DATE,
    b.IMPORT_DATE,
    b.SOURCESYSTEM_CD,
    b.VALUETYPE_CD,
	coalesce(f.tval_char,'EXP:PUBLIC')
    from I2B2METADATA.I2B2 b
	left outer join (select distinct modifier_cd, tval_char from i2b2demodata.observation_fact where concept_cd = 'SECURITY') f
		 on b.sourcesystem_cd = f.modifier_cd
	where b.sourcesystem_cd = sourcesystemCd;

	get diagnostics rowCt := ROW_COUNT;
  stepCt := stepCt + 1;
  perform cz_write_audit(jobId,databaseName,procedureName,'Insert security data into I2B2METADATA i2b2_secure',rowCt,stepCt,'Done');

    ---Cleanup OVERALL JOB if this proc is being run standalone
	perform cz_end_audit (jobID, 'SUCCESS') where coalesce(currentJobId, -1) <> jobId;

	return 1;

	EXCEPTION
	WHEN OTHERS THEN
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);
		--End Proc
		perform cz_end_audit (jobID, 'FAIL');
		return -16;

END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_load_security_data(sourcesystemcd character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_metabolomics_zscore_calc(character varying, character varying, character varying, numeric, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, source_cd character varying, run_type character varying DEFAULT 'L'::character varying, currentjobid numeric DEFAULT (-1), data_type character varying DEFAULT 'R'::character varying, log_base numeric DEFAULT 2) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
DECLARE

/*************************************************************************
This Stored Procedure is used in ETL load METABOLOMICS data
Date:1/3/2014
******************************************************************/

  TrialID varchar(100);
  sourceCD	varchar(50);
  sqlText varchar(2000);
  runType varchar(10);
  dataType varchar(10);
  stgTrial varchar(100);
  idxExists numeric;
  pExists	numeric;
  nbrRecs numeric;
  logBase numeric;
  partitionName varchar(200);
  partitionindx varchar(200);


  --Audit variables
  newJobFlag integer;
  databaseName varchar(100);
  procedureName varchar(100);
  jobID numeric;
  stepCt numeric;
  rowCt			bigint;
  rtnCd			integer;
  errorNumber		character varying;
  errorMessage	character varying;

BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	  RAISE NOTICE 'DK0';
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  partitionindx := partition_indx;
  partitionName := partition_name;

  databaseName := 'TM_CZ';
  procedureName := 'i2b2_metabolomics_zscore_calc';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName, jobID) into jobId;
  END IF;

  stepCt := 0;

	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done');

	if runType != 'L' then
		stepCt := stepCt + 1;
		perform cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting'
,0,stepCt,'Done');
		select cz_error_handler(jobid,procedurename, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return;
	end if;

--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_METABOLOMICS_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from WT_SUBJECT_MBOLOMICS_PROBESET;

		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			perform cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in WT_SUBJECT_MBOLOMICS_PROBESET - procedure exiting'
,0,stepCt,'Done');
select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			select cz_end_audit (jobId,'FAIL') into rtnCd;
			return;
		end if;
	end if;

--	remove Reload processing
--	For Reload, make sure that the TrialId passed as parameter has data in de_subject_METABOLOMICS_data
--	If not, raise exception

	if runType = 'R' then
		select count(*) into idxExists
		from DE_SUBJECT_METABOLOMICS_DATA
		where trial_name = TrialId;

		if idxExists = 0 then
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'No data for TrialId in de_subject_rbm_data - procedure exiting'
,0,stepCt,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return;
		end if;
	end if;

	EXECUTE('truncate table WT_SUBJECT_METABOLOMICS_LOGS');
	EXECUTE('truncate table WT_SUBJECT_METABOLOMICS_CALCS');
	EXECUTE('truncate table WT_SUBJECT_METABOLOMICS_MED');

	EXECUTE('drop index if exists WT_SUBJECT_MBOLOMICS_LOGS_I1');
	EXECUTE('drop index if exists WT_SUBJECT_METABOLOMICS_CALCS_I1');

	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');

	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value
	begin
	if dataType = 'L' then
		insert into WT_SUBJECT_METABOLOMICS_LOGS
			(probeset
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
			,subject_id
			)
			select probeset
				  ,intensity_value
				  ,assay_id
				  ,intensity_value
				  ,patient_id
				  ,subject_id
			from WT_SUBJECT_MBOLOMICS_PROBESET
			where trial_name = TrialId;
	else
			insert into WT_SUBJECT_METABOLOMICS_LOGS
			(probeset
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
			,subject_id
			)
			select probeset
				  ,intensity_value
				  ,assay_id
				  ,CASE WHEN intensity_value <= 0 THEN log(2,(intensity_value + 0.001)) ELSE log(2,intensity_value) END
				  ,patient_id
				  ,subject_id
			from WT_SUBJECT_MBOLOMICS_PROBESET
			where trial_name = TrialId;
	end if;
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;

	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_mirna_logs',rowCt,stepCt,'Done');

	EXECUTE('create index WT_SUBJECT_MBOLOMICS_LOGS_I1 on WT_SUBJECT_METABOLOMICS_LOGS (trial_name, probeset) tablespace "indx"');
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_MBOLOMICS_LOGS_I1',0,stepCt,'Done');

--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe
	begin
	insert into WT_SUBJECT_METABOLOMICS_CALCS
	(trial_name
	,probeset
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
	select d.trial_name
		  ,d.probeset
		  ,avg(log_intensity)
		  ,median(log_intensity)
		  ,coalesce(stddev(log_intensity),0)
	from WT_SUBJECT_METABOLOMICS_LOGS d
	group by d.trial_name
			,d.probeset;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ WT_SUBJECT_METABOLOMICS_CALCS',rowCt,stepCt,'Done');

-- calculate zscore
	begin
        insert into WT_SUBJECT_METABOLOMICS_MED
	(probeset
	,intensity_value
	,log_intensity
	,assay_id
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,patient_id
	,subject_id
	)
	select d.probeset
		  ,d.intensity_value
		  ,d.log_intensity
		  ,d.assay_id
		  ,c.mean_intensity
		  ,c.stddev_intensity
		  ,c.median_intensity
		  ,(CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END)
		  ,d.patient_id
		  ,d.subject_id
    from WT_SUBJECT_METABOLOMICS_LOGS d
		,WT_SUBJECT_METABOLOMICS_CALCS c
    where trim(d.probeset) = c.probeset;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ WT_SUBJECT_METABOLOMICS_MED',rowCt,stepCt,'Done');

    begin
	sqlText := 'insert into ' || partitionName ||
	'(partition_id, trial_source ,trial_name ,metabolite_annotation_id ' ||
	',assay_id ,subject_id ,raw_intensity ,log_intensity ,zscore ,patient_id) ' ||
	'select ' || partitioniD::text || ', ''' || TrialId || '''' ||
		  ',''' || TrialId || ''',d.id ,m.assay_id ,m.subject_id ' ||
           ',m.intensity_value ,round(m.log_intensity,4) ' ||
            ',round(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE round(m.zscore,5) END,5) ' ||
            ',m.patient_id ' ||
			'from WT_SUBJECT_METABOLOMICS_MED m, ' ||
        '(select distinct mp.source_cd,mp.platform From LT_SRC_METABOLOMIC_MAP mp where mp.trial_name = ''' || TrialId || ''') as mpp ' ||
		', DE_METABOLITE_ANNOTATION d ' ||
        'where trim(d.biochemical_name) = trim(m.probeset) ' ||
        'and d.gpl_id = mpp.platform ';
        raise notice 'sqlText= %', sqlText;
	execute sqlText;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial in DEAPP DE_SUBJECT_METABOLOMICS_DATA',rowCt,stepCt,'Done');

	sqlText := ' create index ' || partitionIndx || '_idx1 on ' || partitionName || ' using btree (partition_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx2 on ' || partitionName || ' using btree (assay_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx3 on ' || partitionName || ' using btree (metabolite_annotation_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx4 on ' || partitionName || ' using btree (assay_id, metabolite_annotation_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;

    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    perform cz_end_audit (jobID, 'SUCCESS');
  END IF;

END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_metabolomics_zscore_calc(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) OWNER TO postgres;

--
-- Name: i2b2_mirna_zscore_calc(character varying, character varying, numeric, character varying, numeric, character varying); Type: FUNCTION; Schema: tm_dataloader; Owner: weymouth
--

CREATE FUNCTION i2b2_mirna_zscore_calc(trial_id character varying, run_type character varying DEFAULT 'L'::character varying, currentjobid numeric DEFAULT NULL::numeric, data_type character varying DEFAULT 'R'::character varying, log_base numeric DEFAULT 2, source_cd character varying DEFAULT NULL::character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
This Stored Procedure is used in ETL load MIRNA data
Date:12/9/2013
******************************************************************/
Declare
  TrialID character varying(50);
  sourceCD	character varying(50);
  sqlText character varying(2000);
  runType character varying(10);
  dataType character varying(10);
  stgTrial character varying(50);
  idxExists numeric;
  pExists	numeric;
  nbrRecs numeric;
  logBase numeric;
   
  --Audit variables
  newJobFlag numeric(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID numeric(18,0);
  stepCt numeric(18,0);
  rtnCd integer;
  rowCt integer;
  
BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  databaseName := current_schema();
  procedureName := 'I2B2_MIRNA_ZSCORE_CALC';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName) into jobID;
  END IF;
   
  stepCt := 0;
  
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done') into rtnCd;
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting',rowCt,stepCt,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName) into rtnCd;  
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return 150;
	end if;
  
--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_mirna_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from WT_SUBJECT_MIRNA_PROBESET;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			get diagnostics rowCt := ROW_COUNT;
			select cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in WT_SUBJECT_MIRNA_PROBESET - procedure exiting',rowCt,stepCt,'Done') into rtnCd;
			select cz_error_handler(jobID, procedureName) into rtnCd;
			select cz_end_audit (jobID, 'FAIL') into rtnCd;
			return 161;
		end if;
	end if;
   
--	truncate tmp tables
	begin
		execute ('truncate table WT_SUBJECT_MIRNA_LOGS');
		execute ('truncate table WT_SUBJECT_MIRNA_CALCS');
		execute ('truncate table WT_SUBJECT_MIRNA_MED');
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	--drop index if exists WT_SUBJECT_MIRNA_LOGS_I1;
	--drop index if exists WT_SUBJECT_MIRNA_CALCS_I1;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done') into rtnCd;
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value


	if dataType = 'L' then
		begin
		insert into WT_SUBJECT_MIRNA_LOGS 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
		--	,subject_id
			)
			select probeset_id
				  ,intensity_value ----UAT 154 changes done on 19/03/2014
				  ,assay_id 
				  ,round((case when intensity_value<=0 then 0
                                  when intensity_value>0 then log(2,intensity_value)
                                  else 0 end),5)
				  ,patient_id
			--	  ,sample_cd
			--	  ,subject_id
			from WT_SUBJECT_MIRNA_PROBESET
			where trial_name = TrialId;
		exception
		when others then
			perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
			perform cz_end_audit (jobID, 'FAIL');
			return -16;
		end;
	else	
		begin
                	insert into WT_SUBJECT_MIRNA_LOGS 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
		--	,subject_id
			)
			select probeset_id
				  ,intensity_value  ----UAT 154 changes done on 19/03/2014
				  ,assay_id 
				  ,-(intensity_value)  ----UAT 154 changes done on 19/03/2014
				  ,patient_id
		--		  ,sample_cd
		--		  ,subject_id
			from WT_SUBJECT_MIRNA_PROBESET
			where trial_name = TrialId;
		exception
		when others then
			perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
			perform cz_end_audit (jobID, 'FAIL');
			return -16;
		end;
	end if;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_mirna_logs',rowCt,stepCt,'Done') into rtnCd;

	
    
	--execute ('create index WT_SUBJECT_MIRNA_LOGS_I1 on WT_SUBJECT_MIRNA_LOGS (trial_name, probeset_id)');
	stepCt := stepCt + 1;
	--select cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_MIRNA_LOGS_I1',0,stepCt,'Done') into rtnCd;
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe

	begin
	insert into WT_SUBJECT_MIRNA_CALCS
	(trial_name
	,probeset_id
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
	select d.trial_name 
		  ,d.probeset_id
		  ,avg(log_intensity)
		  ,median(log_intensity)
		  ,stddev(log_intensity)
	from WT_SUBJECT_MIRNA_LOGS d 
	group by d.trial_name 
			,d.probeset_id;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ WT_SUBJECT_MIRNA_CALCS',rowCt,stepCt,'Done') into rtnCd;

	

	--execute ('create index wt_subject_mirna_calcs_i1 on WT_SUBJECT_MIRNA_CALCS (trial_name, probeset_id) nologging tablespace "INDX"');
	--stepCt := stepCt + 1;
	--cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ WT_SUBJECT_MIRNA_CALCS',0,stepCt,'Done');
		
-- calculate zscore

	begin
	insert into WT_SUBJECT_MIRNA_MED 
	(probeset_id
	,intensity_value
	,log_intensity
	,assay_id
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,patient_id
--	,sample_cd
--	,subject_id
	)
	select d.probeset_id
		  ,d.intensity_value 
		  ,d.log_intensity 
		  ,d.assay_id  
		  ,c.mean_intensity 
		  ,c.stddev_intensity 
		  ,c.median_intensity 
		  ,(CASE WHEN stddev_intensity=0 THEN 0 ELSE (d.log_intensity - c.median_intensity ) / c.stddev_intensity END)
		  ,d.patient_id
	--	  ,d.sample_cd
	--	  ,d.subject_id
    from WT_SUBJECT_MIRNA_LOGS d 
		,WT_SUBJECT_MIRNA_CALCS c 
    where d.probeset_id = c.probeset_id;
    	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ WT_SUBJECT_MIRNA_MED',rowCt,stepCt,'Done') into rtnCd;

	--select count(*) into pExists from de_subject_mirna_data where trial_name=TrialId;
	
	begin
	insert into de_subject_mirna_data
	(trial_source
	,trial_name
	,assay_id
	,probeset_id
	,raw_intensity 
	,log_intensity
	,zscore
	,patient_id
	--,sample_id
	--,subject_id
	)
	select (TrialId || ':' || sourceCD)
		  ,TrialId
	      ,m.assay_id
	      ,cast(m.probeset_id AS INTEGER)
		  ,case when dataType = 'R' then m.intensity_value
				when dataType = 'L' 
				then m.intensity_value
				else null
				end as raw_intensity
	    --  ,decode(dataType,'R',m.intensity_value,'L',power(logBase, m.log_intensity),null)
		  ,case when dataType = 'R' then -(m.intensity_value)
				when dataType = 'L' 
				then m.log_intensity
				else null
				end
	      ,(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE round(m.zscore,5) END)
              --,m.zscore
		  ,m.patient_id
	--	  ,m.sample_id
	--	  ,m.subject_id
	from wt_subject_MIRNA_med m;
        exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial in DEAPP DE_SUBJECT_MIRNA_DATA',rowCt,stepCt,'Done') into rtnCd;

	/*
	if pExists > 0 then
		perform I2B2_MIRNA_INC_SUB_ZSCORE(TrialId,dataType);
		stepCt := stepCt + 1;
		perform cz_write_audit(jobId,databaseName,procedureName,'update zscore in de_subject_MIRNA_data ',0,stepCt,'Done');
	end if;
	*/
	---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    perform cz_end_audit (jobID, 'SUCCESS');
  END IF;
  return 0;	
END;
$$;


ALTER FUNCTION tm_dataloader.i2b2_mirna_zscore_calc(trial_id character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric, source_cd character varying) OWNER TO weymouth;

--
-- Name: i2b2_move_study_by_path(character varying, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_move_study_by_path(old_path_in character varying, new_path_in character varying, currentjobid numeric DEFAULT (-1)) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$

  DECLARE
--Audit variables
    newJobFlag              INTEGER;
    databaseName            VARCHAR(100);
    procedureName           VARCHAR(100);
    jobID                   NUMERIC(18, 0);
    stepCt                  NUMERIC(18, 0);
    tText                   VARCHAR(2000);
    rtnCd                   integer;
    rowCt			              numeric(18,0);
	  errorNumber		          character varying;
	  errorMessage	          character varying;

    old_path                VARCHAR(2000);
    new_path                VARCHAR(2000);
    old_root_node           VARCHAR(2000);
    new_root_node           VARCHAR(2000);
    new_root_node_name      VARCHAR(2000);
    new_path_last_node_name VARCHAR(2000);
    rowsExists              INTEGER;
    counter                 INTEGER;
    substringPos            INTEGER;
    substringPos2           INTEGER;
    lvl_num_to_remove       INTEGER;
    old_level_num           INTEGER;
    new_level_num           INTEGER;
    parent_path_node        VARCHAR(2000);
    current_path            VARCHAR(2000);
    current_path_level      INTEGER;
    current_path_attr_name  VARCHAR(2000);
    tmp                     VARCHAR(2000);

  BEGIN

--Audit JOB Initialization
    stepCt := 0;

--Set Audit Parameters
    newJobFlag := 0; -- False (Default)

    jobID := currentJobID;
    databaseName := current_schema();
    procedureName := 'I2B2_MOVE_STUDY_BY_PATH';

--If Job ID does not exist, then this is a single procedure run and we need to create it
    IF (jobID IS NULL OR jobID < 1)
    THEN
      newJobFlag := 1; -- True
      select cz_start_audit (procedureName, databaseName) into jobID;
    END IF;

    old_path := trim(old_path_in);
    new_path := trim(new_path_in);

    stepCt := 0;
    stepCt := stepCt + 1;
    tText := 'Start i2b2_move_study_by_path from ' || coalesce(old_path, '<NULL>') || ' to ' || coalesce(new_path, '<NULL>');
    select cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done') into rtnCd;

    IF old_path = null or new_path = null
      or old_path = '' or new_path = ''
    THEN
      stepCt := stepCt + 1;
      select cz_write_audit(jobId,databaseName,procedureName,'New or old path is empty. Please check input parameters',0,stepCt,'Done') into rtnCd;
      select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
      select cz_end_audit (jobID, 'FAIL') into rtnCd;
      return -16;
    END IF;

    -- update slashes
    old_path := REGEXP_REPLACE('\' || old_path || '\','(\\){2,}', '\','g');
    new_path := REGEXP_REPLACE('\' || new_path || '\','(\\){2,}', '\','g');

    -- check duplicates
    IF old_path = new_path
    THEN
      stepCt := stepCt + 1;
      select cz_write_audit(jobId,databaseName,procedureName,'Please select different old and new paths',0,stepCt,'Done') into rtnCd;
      select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
      select cz_end_audit (jobID, 'FAIL') into rtnCd;
      return -16;
    END IF;
    -- check old root node exists
    SELECT
      count(*)
    INTO rowsExists
    FROM i2b2metadata.i2b2
    WHERE c_fullname = old_path;

    IF rowsExists = 0
    THEN
      stepCt := stepCt + 1;
      select cz_write_audit(jobId,databaseName,procedureName,'Please select exists study path to move',0,stepCt,'Done') into rtnCd;
      select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
      select cz_end_audit (jobID, 'FAIL') into rtnCd;
      return -16;
    END IF;

    old_root_node := REGEXP_REPLACE(old_path, '(\\(\w|\s)*\\)(.*)', '\1');
    new_root_node := REGEXP_REPLACE(new_path, '(\\(\w|\s)*\\)(.*)', '\1');
    new_root_node_name := REGEXP_REPLACE(new_path, '\\((\w|\s)*)\\(.*)', '\1');
    new_path_last_node_name := REGEXP_REPLACE(new_path, '(.*)\\((\w|\s)*)\\', '\2');

-- check new path is not root node
    IF new_root_node = new_path
    THEN
      stepCt := stepCt + 1;
      select cz_write_audit(jobId,databaseName,procedureName,
            'Please select new study target path: it can not be root node',0,stepCt,'Done') into rtnCd;
      select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
      select cz_end_audit (jobID, 'FAIL') into rtnCd;
      return -16;
    END IF;

-- check new path exists
    SELECT
      count(*)
    INTO rowsExists
    FROM i2b2metadata.i2b2
    WHERE c_fullname = new_path;

    SELECT position (new_path in old_path)
              INTO substringPos;

    IF rowsExists > 0 and substringPos = 0
    THEN
      stepCt := stepCt + 1;
      select cz_write_audit(jobId,databaseName,procedureName,'Study target path is already exists',0,stepCt,'Done') into rtnCd;
      select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
      select cz_end_audit (jobID, 'FAIL') into rtnCd;
      return -16;
    END IF;

-- check that new path is not subnode of exists study
        -- parse new_path to levels
        /*DROP TABLE IF EXISTS temp_t CASCADE;
        CREATE TEMP TABLE temp_t AS SELECT node_name
        FROM regexp_split_to_table(new_path, '\\') AS node_name;

        DELETE FROM temp_t WHERE node_name='';

        DROP TABLE IF EXISTS temp_t_levels CASCADE;
        CREATE TEMP TABLE temp_t_levels (lvl integer, parent_lvl integer,node_name varchar);

        FOR i IN 0..((select count(*) from temp_t)-1) LOOP
           INSERT INTO temp_t_levels (node_name) SELECT node_name FROM temp_t LIMIT 1 OFFSET i;
           UPDATE temp_t_levels SET lvl=i+1, parent_lvl=i  WHERE node_name=(SELECT node_name FROM temp_t LIMIT 1 OFFSET i);
        END LOOP;

        DROP TABLE IF EXISTS temp_t_paths CASCADE;
        CREATE TEMP TABLE temp_t_paths (lvl integer, parent_lvl integer,node_name varchar,node_path varchar);

        WITH RECURSIVE temp_t_paths ("lvl", "parent_lvl", "node_name", "node_path") AS (
        SELECT  T1.lvl,T1.parent_lvl, T1.node_name,  '\'|| T1.node_name
            FROM temp_t_levels T1 WHERE T1.lvl=1
        union
        select T2.lvl, T2.parent_lvl, T2.node_name, temp_t_paths.node_path ||'\'|| T2.node_name
             FROM temp_t_levels T2 INNER JOIN temp_t_paths ON (temp_t_paths.lvl= T2.parent_lvl))
             INSERT INTO temp_t_paths (select * from temp_t_paths);

        UPDATE temp_t_paths set node_path=node_path || '\';

        select count(*) INTO counter from temp_t_paths where lvl > 1;
        IF counter > 0
          THEN
          FOR i IN 1..counter LOOP
              SELECT node_path INTO current_path FROM temp_t_paths WHERE lvl=i+1;

              SELECT
                count(*)
              INTO rowsExists
              FROM i2b2metadata.i2b2
              WHERE c_fullname = current_path;

              -- check cases with adding/removing new level /a/b/c/ -> /a/b/ and reverse /a/b/-> /a/b/c/
              SELECT position (current_path in old_path)
              INTO substringPos;

              SELECT position (old_path in current_path)
              INTO substringPos2;

              IF rowsExists > 0 and substringPos = 0 and substringPos2 = 0
              THEN
                stepCt := stepCt + 1;
                select cz_write_audit(jobId,databaseName,procedureName,
                'Please select new study target path: target path can not be subnode of exists study',0,stepCt,'Done') into rtnCd;
                select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
                select cz_end_audit (jobID, 'FAIL') into rtnCd;
                return -16;
              END IF;

          END LOOP;
        END IF;*/

-- check new root node exists

    SELECT
      count(*)
    INTO rowsExists
    FROM i2b2metadata.i2b2
    WHERE c_fullname = new_root_node;

    IF rowsExists = 0
    THEN
    -- create new root in table_access,
      BEGIN
      select i2b2_add_root_node(new_root_node_name, jobID) into rtnCd;
      get diagnostics rowCt := ROW_COUNT;
      exception
          when others then
            errorNumber := SQLSTATE;
            errorMessage := SQLERRM;
            --Handle errors.
            select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
            --End Proc
            select cz_end_audit (jobID, 'FAIL') into rtnCd;
            return -16;
      END;
      stepCt := stepCt + 1;
		  select cz_write_audit(jobId,databaseName,procedureName,'New root node was added',rowCt,stepCt,'Done') into rtnCd;
    END IF;

    -- check if old root has another child
    SELECT
      count(c_fullname)
    INTO counter
    FROM i2b2metadata.i2b2
    WHERE c_fullname LIKE old_root_node || '%' ESCAPE '`' AND
          c_fullname NOT IN
          (SELECT
             c_fullname
           FROM i2b2metadata.i2b2
           WHERE c_fullname LIKE old_path || '%' ESCAPE '`');

    IF old_root_node <> new_root_node AND counter = 1
    THEN

    -- if has not - remove old root node from i2b2, i2b2_secure, table_access
      begin
      DELETE FROM i2b2metadata.i2b2
      WHERE c_fullname = old_root_node;
      DELETE FROM i2b2metadata.i2b2_secure
      WHERE c_fullname = old_root_node;
      DELETE FROM i2b2metadata.table_access
      WHERE c_fullname = old_root_node;
      DELETE FROM i2b2demodata.concept_dimension
      WHERE concept_path = old_root_node;

      get diagnostics rowCt := ROW_COUNT;
      exception
        when others then
          errorNumber := SQLSTATE;
          errorMessage := SQLERRM;
          --Handle errors.
          select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
          --End Proc
          select cz_end_audit (jobID, 'FAIL') into rtnCd;
          return -16;
      end;

      stepCt := stepCt + 1;
      select cz_write_audit(jobId, databaseName, procedureName, 'Remove old root node from i2b2, i2b2_secure, table_access',
                     rowCt, stepCt, 'Done')  into rtnCd;


    END IF;


-- check new level need to be added
    SELECT
      length(old_path) - length(replace(old_path, '\', ''))
    INTO old_level_num;

    SELECT
      length(new_path) - length(replace(new_path, '\', ''))
    INTO new_level_num;

-- rename paths in i2b2 and i2b2_secure
    begin
    UPDATE i2b2metadata.i2b2
    SET c_fullname=replace(c_fullname, old_path, new_path),
      c_dimcode=replace(c_dimcode, old_path, new_path),
      c_tooltip=replace(c_tooltip, old_path, new_path)
    WHERE c_fullname LIKE old_path || '%' ESCAPE '`';

    UPDATE i2b2metadata.i2b2_secure
    SET c_fullname=replace(c_fullname, old_path, new_path),
      c_dimcode=replace(c_dimcode, old_path, new_path),
      c_tooltip=replace(c_tooltip, old_path, new_path)
    WHERE c_fullname LIKE old_path || '%' ESCAPE '`';


    get diagnostics rowCt := ROW_COUNT;
    exception
        when others then
          errorNumber := SQLSTATE;
          errorMessage := SQLERRM;
          --Handle errors.
          select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
          --End Proc
          select cz_end_audit (jobID, 'FAIL') into rtnCd;
          return -16;
    end;

    stepCt := stepCt + 1;
    select cz_write_audit(jobId, databaseName, procedureName, 'Rename paths in i2b2 and i2b2_secure', rowCt, stepCt,
                   'Done') into rtnCd;


-- rename c_name in i2b2 and i2b2_secure
    begin
    UPDATE i2b2metadata.i2b2
    SET c_name=new_path_last_node_name
    WHERE c_fullname = new_path;
    UPDATE i2b2metadata.i2b2_secure
    SET c_name=new_path_last_node_name
    WHERE c_fullname = new_path;

    get diagnostics rowCt := ROW_COUNT;
    exception
        when others then
          errorNumber := SQLSTATE;
          errorMessage := SQLERRM;
          --Handle errors.
          select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
          --End Proc
          select cz_end_audit (jobID, 'FAIL') into rtnCd;
          return -16;
    end;

    stepCt := stepCt + 1;
    select cz_write_audit(jobId, databaseName, procedureName, 'Update c_name in i2b2 and i2b2_secure', rowCt, stepCt,
                   'Done') into rtnCd;

--rename paths in concept_dimension
    begin
    UPDATE i2b2demodata.concept_dimension
    SET concept_path = replace(concept_path, old_path, new_path)
    WHERE concept_path LIKE old_path || '%' ESCAPE '`';

    get diagnostics rowCt := ROW_COUNT;
    exception
        when others then
          errorNumber := SQLSTATE;
          errorMessage := SQLERRM;
          --Handle errors.
          select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
          --End Proc
          select cz_end_audit (jobID, 'FAIL') into rtnCd;
          return -16;
    end;

    stepCt := stepCt + 1;
    select cz_write_audit(jobId, databaseName, procedureName, 'Rename paths in concept_dimension', rowCt, stepCt,
                   'Done') into rtnCd;

-- rename old_root_node in concept_counts
    begin
    UPDATE i2b2demodata.concept_counts
    SET parent_concept_path=new_root_node
    WHERE concept_path = old_path;
    get diagnostics rowCt := ROW_COUNT;
    exception
        when others then
          errorNumber := SQLSTATE;
          errorMessage := SQLERRM;
          --Handle errors.
          select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
          --End Proc
          select cz_end_audit (jobID, 'FAIL') into rtnCd;
          return -16;
    end;

    stepCt := stepCt + 1;
    select cz_write_audit(jobId, databaseName, procedureName, 'Update parent_concept_path in concept_counts', rowCt,
                   stepCt, 'Done') into rtnCd;
-- update concept_counts
    begin
    UPDATE i2b2demodata.concept_counts
    SET concept_path=replace(concept_path, old_path, new_path),
      parent_concept_path=replace(parent_concept_path, old_path, new_path)
    WHERE concept_path LIKE old_path || '%' ESCAPE '`';

    get diagnostics rowCt := ROW_COUNT;
    exception
        when others then
          errorNumber := SQLSTATE;
          errorMessage := SQLERRM;
          --Handle errors.
          select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
          --End Proc
          select cz_end_audit (jobID, 'FAIL') into rtnCd;
          return -16;
    end;

    stepCt := stepCt + 1;
    select cz_write_audit(jobId, databaseName, procedureName, 'Rename paths in concept_counts', rowCt, stepCt, 'Done') into rtnCd;

    -- Fill in levels if levels are added
    select i2b2_fill_in_tree(null, new_path, jobID) into rtnCd;

    -- Remove empty levels
    IF new_level_num <= old_level_num
    THEN
        DROP TABLE IF EXISTS temp_t CASCADE;
        CREATE TEMP TABLE temp_t AS SELECT node_name
        FROM regexp_split_to_table(old_path, '\\') AS node_name;

        DELETE FROM temp_t WHERE node_name='';

        DROP TABLE IF EXISTS temp_t_levels CASCADE;
        CREATE TEMP TABLE temp_t_levels (lvl integer, parent_lvl integer,node_name varchar);

        FOR i IN 0..((select count(*) from temp_t)-1) LOOP
           INSERT INTO temp_t_levels (node_name) SELECT node_name FROM temp_t LIMIT 1 OFFSET i;
           UPDATE temp_t_levels SET lvl=i+1, parent_lvl=i  WHERE node_name=(SELECT node_name FROM temp_t LIMIT 1 OFFSET i);
        END LOOP;

        DROP TABLE IF EXISTS temp_t_paths CASCADE;
        CREATE TEMP TABLE temp_t_paths (lvl integer, parent_lvl integer,node_name varchar,node_path varchar);

        WITH RECURSIVE temp_t_paths ("lvl", "parent_lvl", "node_name", "node_path") AS (
        SELECT  T1.lvl,T1.parent_lvl, T1.node_name,  '\'|| T1.node_name
            FROM temp_t_levels T1 WHERE T1.lvl=1
        union
        select T2.lvl, T2.parent_lvl, T2.node_name, temp_t_paths.node_path ||'\'|| T2.node_name
             FROM temp_t_levels T2 INNER JOIN temp_t_paths ON (temp_t_paths.lvl= T2.parent_lvl))
             INSERT INTO temp_t_paths (select * from temp_t_paths);

        UPDATE temp_t_paths set node_path=node_path || '\';

        FOR i IN REVERSE (select count(*) from temp_t_paths)..1 LOOP
              SELECT node_path INTO current_path FROM temp_t_paths WHERE lvl=i;
              SELECT count(*) INTO rowsExists FROM i2b2metadata.i2b2
              WHERE c_fullname LIKE current_path || '%' ESCAPE '`';

              IF rowsExists = 1
              THEN
                select i2b2_delete_1_node(current_path) into rtnCd;
                select cz_write_audit(jobId, databaseName, procedureName,
                                 'Remove empty level: ' || current_path, rowCt, stepCt,
                                 'Done') into rtnCd;
              END IF;
         END LOOP;

        stepCt := stepCt + 1;
        select cz_write_audit(jobId, databaseName, procedureName,
                                 'Remove empty levels from i2b2', rowCt, stepCt,
                                 'Done') into rtnCd;
    END IF;

    -- Update c_hlevels in i2b2 and i2b2_secure
    begin
      UPDATE i2b2metadata.i2b2
      SET C_HLEVEL = (length(C_FULLNAME) - coalesce(length(replace(C_FULLNAME, '\', '')), 0)) / length('\') - 2
      WHERE c_fullname LIKE new_path || '%' ESCAPE '`';
      get diagnostics rowCt := ROW_COUNT;
       exception
          when others then
            errorNumber := SQLSTATE;
            errorMessage := SQLERRM;
            --Handle errors.
            select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
            --End Proc
            select cz_end_audit (jobID, 'FAIL') into rtnCd;
            return -16;
    end;

    stepCt := stepCt + 1;
    select cz_write_audit(jobId, databaseName, procedureName,
                                 'Update levels in i2b2metadata.i2b2', rowCt, stepCt,
                                 'Done') into rtnCd;

    begin
      UPDATE i2b2metadata.i2b2_secure
      SET C_HLEVEL = (length(C_FULLNAME) - coalesce(length(replace(C_FULLNAME, '\', '')), 0)) / length('\') - 2
      WHERE c_fullname LIKE new_path || '%' ESCAPE '`';
      get diagnostics rowCt := ROW_COUNT;
      exception
          when others then
            errorNumber := SQLSTATE;
            errorMessage := SQLERRM;
            --Handle errors.
            select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
            --End Proc
            select cz_end_audit (jobID, 'FAIL') into rtnCd;
            return -16;

    end;

     stepCt := stepCt + 1;
     select cz_write_audit(jobId, databaseName, procedureName,
                                 'Update levels in i2b2metadata.i2b2_secure', rowCt, stepCt,
                                 'Done') into rtnCd;

    ---Cleanup OVERALL JOB if this proc is being run standalone
    IF newJobFlag = 1
    THEN
      select cz_end_audit (jobID, 'SUCCESS') into rtnCD;
    END IF;

    return 1;
  END;

  $$;


ALTER FUNCTION tm_dataloader.i2b2_move_study_by_path(old_path_in character varying, new_path_in character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_process_metabolomic_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_process_metabolomic_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_code character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$

/*************************************************************************

* This store procedure is for ETL for Sanofi to load  metabolomics data
* Date: 1/2/2014

******************************************************************
--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint
*************************************/

Declare
  TrialID		varchar(100);
  RootNode		varchar(2000);
  root_level	integer;
  topNode		varchar(2000);
  topLevel		integer;
  tPath			varchar(2000);
  study_name	varchar(100);
  sourceCd		varchar(50);
  secureStudy	varchar(1);

  dataType		varchar(10);
  sqlText		varchar(1000);
  tText			varchar(1000);
  gplTitle		varchar(1000);
  pExists		numeric;
  partTbl   	numeric;
  partExists 	numeric;
  sampleCt		numeric;
  idxExists 	numeric;
  logBase		numeric;
  pCount		integer;
  sCount		integer;
  tablespaceName	varchar(200);
  v_bio_experiment_id	numeric;
  rtn_code		integer;
  partitioniD	numeric(18,0);
  partitionName	varchar(100);
  partitionIndx	varchar(100);
  
    --Audit variables
  newJobFlag integer;
  databaseName varchar(100);
  procedureName varchar(100);
  jobID numeric;
  stepCt numeric;
  rowCt			numeric(18,0);
  errorNumber		character varying;
  errorMessage	character varying;
  rtnCd			integer;
  
	addNodes CURSOR FOR
	SELECT distinct t.leaf_node
          ,t.node_name
	from  WT_METABOLOMIC_NODES t
	where not exists
		 (select 1 from i2b2 x
		  where t.leaf_node = x.c_fullname);

 
--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  delNodes CURSOR FOR
  SELECT distinct c_fullname 
  from  i2b2
  where c_fullname like topNode || '%'
    and substring(c_visualattributes from 2 for 1) = 'H';
    --and c_visualattributes like '_H_';


     uploadI2b2 cursor for
    select category_cd,display_value,display_label,display_unit from
    lt_src_METABOLOMICS_display_mapping;
    



BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\');	
	select length(topNode)-length(replace(topNode,'\','')) into topLevel ;
	
	if coalesce(data_type::text, '') = '' then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;
	
	logBase := log_base;
	sourceCd := upper(coalesce(source_code,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

	databaseName := current_schema();
	procedureName := 'I2B2_PROCESS_METABOLOMIC_DATA';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName, jobID) into jobId;
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_metabolomics_data',0,stepCt,'Done');
	
	--	Get count of records in LT_SRC_METABOLOMIC_MAP
	
	select count(*) into sCount
	from LT_SRC_METABOLOMIC_MAP;
	
	--	check if all subject_sample map records have a platform, If not, abort run
	select count(*) into pCount
	from LT_SRC_METABOLOMIC_MAP
	where coalesce(platform::text, '') = '';
	
	if pCount > 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
	end if;
  
  	--	check if platform exists in de_qpcr_mirna_annotation .  If not, abort run.
	
	select count(*) into pCount
	from LT_METABOLOMIC_ANNOTATION
	where gpl_id in (select distinct m.platform from LT_SRC_METABOLOMIC_MAP m);
	
	select count(*) into pCount
	from DE_gpl_info
	where platform in (select distinct m.platform from LT_SRC_METABOLOMIC_MAP m);
	
	if PCOUNT = 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Platform not found in lt_metabolomic_annotation',1,stepCt,'ERROR');
		perform CZ_ERROR_HANDLER(JOBID,PROCEDURENAME, '-1', 'Application raised error');
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		RETURN 163;
	end if;
		
	--	check if all subject_sample map records have a tissue_type, If not, abort run
	
	select count(*) into pCount
	from LT_SRC_METABOLOMIC_MAP
	where coalesce(tissue_type::text, '') = '';
	
	if pCount > 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Tissue Type data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		select CZ_END_AUDIT (JOBID,'FAIL') into rtnCd;
		return 162;
	end if;
	
	--	check if there are multiple platforms, if yes, then platform must be supplied in LT_SRC_METABOLOMIC_MAP
	
	select count(*) into pCount
	from (select sample_cd
		  from LT_SRC_METABOLOMIC_MAP
		  group by sample_cd
		  having count(distinct platform) > 1)as s;
	
	if pCount > 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Multiple platforms for sample_cd in LT_SRC_METABOLOMIC_MAP',1,stepCt,'ERROR');
		perform CZ_ERROR_HANDLER(JOBID,PROCEDURENAME, '-1', 'Application raised error');
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		RETURN 164;
	end if;
		
	-- Get root_node from topNode
  
	select parse_nth_value(topNode, 2, '\') into RootNode ;
	
	select count(*) into pExists
	from table_access
	where c_name = rootNode;
	
	if pExists = 0 then
		perform i2b2_add_root_node(rootNode, jobId);
	end if;
	
	select c_hlevel into root_level
	from i2b2
	where c_name = RootNode;
	
	-- Get study name from topNode
  
	select parse_nth_value(topNode, topLevel, '\') into study_name ;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,null),'(\\){2,}', '\');
	select length(tPath) - length(replace(tPath,'\',null)) into pCount ;

	if pCount > 2 then
		perform i2b2_fill_in_tree(null, tPath, jobId);
	end if;

	--	uppercase study_id in LT_SRC_METABOLOMIC_MAP in case curator forgot
	begin
	update LT_SRC_METABOLOMIC_MAP
	set trial_name=upper(trial_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in LT_SRC_METABOLOMIC_MAP',rowCt,stepCt,'Done');
	
	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd
	begin
	insert into patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from LT_SRC_METABOLOMIC_MAP s
		     ,de_gpl_info g
		 where (s.subject_id IS NOT NULL AND s.subject_id::text <> '')
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = 'METABOLOMICS'
		   and not exists
			  (select 1 from patient_dimension x
			   where x.sourcesystem_cd = 
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) as x;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',rowCt,stepCt,'Done');
	
	perform i2b2_create_security_for_trial(TrialId, secureStudy, jobID);

	--	Delete existing observation_fact data, will be repopulated
	begin
	delete from observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = 'METABOLOMICS');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done');

	select count(*) into partExists
	from deapp.de_subject_sample_mapping sm
	where sm.trial_name = TrialId
	and coalesce(sm.source_cd,'STD') = sourceCd
	and sm.platform = 'METABOLOMICS'
	and sm.partition_id is not null;
	
	if partExists = 0 then
		select nextval('deapp.seq_metabolomics_partition_id') into partitionId;
	else
		select distinct partition_id into partitionId
		from deapp.de_subject_sample_mapping sm
		where sm.trial_name = TrialId
		and coalesce(sm.source_cd,'STD') = sourceCd
		and sm.platform = 'METABOLOMICS';
	end if;

	partitionName := 'deapp.de_subject_metabolomics_data_' || partitionId::text;
	partitionIndx := 'de_subject_metabolomics_data_' || partitionId::text;

	--	Cleanup any existing data in de_subject_sample_mapping.  
	begin
	delete from DE_SUBJECT_SAMPLE_MAPPING 
	where trial_name = TrialID 
	  and coalesce(source_cd,'STD') = sourceCd
	  and platform = 'METABOLOMICS'; --Making sure only metabolomic data is deleted
	  get diagnostics rowCt := ROW_COUNT;
	  exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		  
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done');

--	truncate tmp node table

	EXECUTE('truncate table WT_METABOLOMIC_NODES');
	
--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
--	from wt_subject_mirna_data

	EXECUTE('truncate table WT_METABOLOMIC_NODE_VALUES');
	begin
	insert into WT_METABOLOMIC_NODE_VALUES
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from LT_SRC_METABOLOMIC_MAP a
	    ,de_gpl_info g 
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = 'METABOLOMICS'
	  and g.title = (select min(x.title) from de_gpl_info x where coalesce(a.platform,'GPL570') = x.platform)
	  ;
	  get diagnostics rowCt := ROW_COUNT;
      exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP WT_METABOLOMIC_NODE_VALUES',rowCt,stepCt,'Done');
	
	begin
	insert into WT_METABOLOMIC_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g')
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  WT_METABOLOMIC_NODE_VALUES;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		   
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_metabolomics_nodes',rowCt,stepCt,'Done');
	
	--	insert for platform node so platform concept can be populated
	begin
	insert into WT_METABOLOMIC_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  WT_METABOLOMIC_NODE_VALUES;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in WT_METABOLOMIC_NODES',rowCt,stepCt,'Done');

	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd
	begin
	insert into WT_METABOLOMIC_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  WT_METABOLOMIC_NODE_VALUES
	where category_cd like '%ATTR1%'
	  and (attribute_1 IS NOT NULL AND attribute_1::text <> '');
	  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in WT_METABOLOMIC_NODES',rowCt,stepCt,'Done');
	
	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd
	begin
	insert into WT_METABOLOMIC_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
		substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  WT_METABOLOMIC_NODE_VALUES
	where category_cd like '%ATTR2%'
	  and (attribute_2 IS NOT NULL AND attribute_2::text <> '');
	  get diagnostics rowCt := ROW_COUNT;
	  exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		   
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_METABOLOMIC_NODES',rowCt,stepCt,'Done');
	
	--	insert for tissue_type node so sample_type_cd can be populated
	begin
	insert into WT_METABOLOMIC_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  WT_METABOLOMIC_NODE_VALUES
	where category_cd like '%TISSUETYPE%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_METABOLOMIC_NODES',rowCt,stepCt,'Done');
	
	begin
	update WT_METABOLOMIC_NODES
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_metabolomics_nodes',rowCt,stepCt,'Done');
		
--	add leaf nodes for metabolomics data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)
		begin
		perform i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId);
		get diagnostics rowCt := ROW_COUNT;
		exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;
		
		perform cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done');
		
		perform i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID);

	END LOOP;  
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
	begin
	update i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	  get diagnostics rowCt := ROW_COUNT;
	  exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	  	
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done');
		
--	update concept_cd for nodes, this is done to make the next insert easier
	begin
	update WT_METABOLOMIC_NODES t
	set concept_cd=(select c.concept_cd from concept_dimension c
	                where c.concept_path = t.leaf_node
				   )
    where exists
         (select 1 from concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and coalesce(t.concept_cd::text, '') = '';
	  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update WT_METABOLOMIC_NODES with newly created concept_cds',rowCt,stepCt,'Done'); 
	
  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_metabolomics_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in WT_METABOLOMIC_NODES
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in WT_METABOLOMIC_NODES
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in WT_METABOLOMIC_NODES
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in WT_METABOLOMIC_NODES
  --PLATFORM        = metabolomics - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in WT_METABOLOMIC_NODES
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_metabolomics_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd
  
  --ASSAY_ID        = generated by trigger
	begin
	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
	,partition_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
		  ,partitionId
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,'METABOLOMICS' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+metabolomics+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from LT_SRC_METABOLOMIC_MAP a		
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = b.sourcesystem_cd
		inner join WT_METABOLOMIC_NODES ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'@') = coalesce(ln.attribute_1,'@')
			and coalesce(a.attribute_2,'@') = coalesce(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join WT_METABOLOMIC_NODES pn
			on a.platform = pn.platform
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(pn.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(pn.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'	  
		left outer join WT_METABOLOMIC_NODES ttp
			on a.tissue_type = ttp.tissue_type
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = coalesce(ttp.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(ttp.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'		  
		left outer join WT_METABOLOMIC_NODES a1
			on a.attribute_1 = a1.attribute_1
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a1.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a1.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'		  
		left outer join WT_METABOLOMIC_NODES a2
			on a.attribute_2 = a1.attribute_2
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a2.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a2.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'			  
		left outer join patient_dimension sid
			on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  (ln.concept_cd IS NOT NULL AND ln.concept_cd::text <> '')) t;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done');

--	Insert records for patients and samples into observation_fact
	begin
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,INSTANCE_NUM
    )
    select distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,1
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCD
      and m.platform = 'METABOLOMICS';
	  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	  
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done');

	--	Insert sample facts 
	begin
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    select distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCd
      and m.platform = 'METABOLOMICS'
	 and m.patient_id != m.sample_id;
	 get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	  
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done');

	--Update I2b2 for correct data type
	begin
	update i2b2 t
	set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
	where t.c_basecode in (select distinct x.concept_cd from WT_METABOLOMIC_NODES x);
  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',rowCt,stepCt,'Done');
	


 ---INSERT sample_dimension
	begin
      INSERT INTO I2B2DEMODATA.SAMPLE_DIMENSION(SAMPLE_CD) 
         SELECT DISTINCT SAMPLE_CD FROM 
	   DEAPP.DE_SUBJECT_SAMPLE_MAPPING WHERE SAMPLE_CD NOT IN (SELECT SAMPLE_CD FROM I2B2DEMODATA.SAMPLE_DIMENSION) ;
	   get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'insert distinct sample_cd in sample_dimension from de_subject_sample_mapping',rowCt,stepCt,'Done');

    ---- update c_metedataxml in i2b2
	begin
       for ul in uploadI2b2
        loop
	 update i2b2 n
	SET n.c_columndatatype = 'N',
      --Static XML String
		c_metadataxml =  ('<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue>
                <HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue>
                <LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue>
                <EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion>
                <UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits>
                <ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor>
                </ConvertingUnits></UnitValues><Analysis><Enums /><Counts />
                <New /></Analysis>'||(select xmlelement(name "SeriesMeta",xmlforest(m.display_value as "Value",m.display_unit as "Unit",m.display_label as "DisplayName")) as hi 
      from lt_src_display_mapping m where m.category_cd=ul.category_cd)||
                '</ValueMetadata>') where n.c_fullname=ul.category_cd;
                
                end loop;
		 get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end; 
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',rowCt,stepCt,'Done');
	    
	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	begin
	update i2b2 a
    set c_visualattributes = 'LAH'
	where a.c_basecode in (select distinct x.concept_code from de_subject_sample_mapping x
						   where x.trial_name = TrialId
						     and x.platform = 'METABOLOMICS'
							 and (x.concept_code IS NOT NULL AND x.concept_code::text <> ''));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done');
  
  begin
    update i2b2metadata.i2b2 a
	set c_visualattributes='FAS'
        where a.c_fullname = substr(topNode,1,instr(topNode,'\',1,3));
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
        
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for study nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done');
    
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for metabolomic data
  
    perform i2b2_create_concept_counts(topNode ,jobID );
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done');
	
	--	delete each node that is hidden

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		perform i2b2_delete_1_node(r_delNodes.c_fullname);
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		
		perform cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done');

	END LOOP;  	


  --Reload Security: Inserts one record for every I2B2 record into the security table
	begin
    perform i2b2_load_security_data(jobId);
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done');

--	tag data with probeset_id from reference.probeset_deapp
  
	EXECUTE ('truncate table WT_SUBJECT_MBOLOMICS_PROBESET');
	
	--	note: assay_id represents a unique subject/site/sample
	begin
	insert into WT_SUBJECT_MBOLOMICS_PROBESET  --mod
	(probeset
	,intensity_value
	,patient_id
	,subject_id
	,trial_name
	,assay_id
	)
	select md.biochemical
		  ,avg(md.intensity_value::numeric)
                  ,sd.patient_id
                  ,sd.subject_id
		  ,TrialId
		  ,sd.assay_id
	from deapp.de_subject_sample_mapping sd
		,LT_SRC_METABOLOMIC_DATA md   
	where sd.sample_cd = md.expr_id
	  and sd.platform = 'METABOLOMICS'
	  and sd.trial_name =TrialId
	  and sd.source_cd = sourceCd
	 and (CASE WHEN dataType = 'R' THEN sign(md.intensity_value::numeric) ELSE 1 END) = 1
		group by md.biochemical, subject_id
		,sd.patient_id, sd.assay_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_mbolomics_probeset',rowCt,stepCt,'Done') into rtnCd;

	select count(*) into pExists
	from information_schema.tables
	where table_name = partitionindx;

	if pExists = 0 then
	sqlText := 'create table ' || partitionName || ' ( constraint metabolomics_' || partitionId::text || '_check check ( partition_id = ' || partitionId::text ||
	')) inherits (deapp.de_subject_metabolomics_data)';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create partition ' || partitionName,1,stepCt,'Done') into rtnCd;
	else
	sqlText := 'drop index if exists ' || partitionIndx || '_idx1';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx2';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx3';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx4';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on ' || partitionName,1,stepCt,'Done') into rtnCd;
	sqlText := 'truncate table ' || partitionName;
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Truncate ' || partitionName,1,stepCt,'Done') into rtnCd;
	end if;
	
	--	insert into de_subject_mirna_data when dataType is T (transformed)

	if dataType = 'T' then
        sqlText := 'insert into ' || partitionName || 
	'(partition_id,trial_source ,trial_name ,metabolite_annotation_id ' ||
	',assay_id ,subject_id ,raw_intensity ,log_intensity ,zscore ,patient_id ) ' ||
                'select ' || partitioniD::text || ', m.trial_name || '':'' || mpp.source_cd, ' ||
                  '''' || TrialId || '''' ||
                ',d.Id ,m.assay_id ,m.subject_id ,m.intensity_value ' ||
                  ' ,log(2,m.intensity_value) ' ||
			  ',case when m.intensity_value < -2.5 ' ||
			        'then -2.5 ' ||
					'when m.intensity_value > 2.5 ' ||
					'then 2.5 ' ||
					'else m.intensity_value ' ||
			   'end as zscore' ||
                           ',m.patient_id ' ||
                'from WT_SUBJECT_MBOLOMICS_PROBESET  m, ' ||
                '(select distinct mp.source_cd,mp.platform From LT_SRC_METABOLOMIC_MAP mp and mp.trial_name = ''' || TrialID || ''') mpp ' ||
                ',DEAPP.DE_METABOLITE_ANNOTATION d ' ||
		'where m.trial_name = TrialID ' ||
                'and d.biochemical_name = m.probeset ' ||
                'and mpp.platform = d.gpl_id' ;
		
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
		perform cz_write_audit(jobId,databaseName,procedureName,'Insert transformed into DEAPP DE_SUBJECT_METABOLOMICS_DATA',rowCt,stepCt,'Done');

	else
		
	--	Calculate ZScores and insert data into de_subject_mirna_data.  The 'L' parameter indicates that the gene expression data will be selected from
	--	WT_SUBJECT_MBOLOMICS_PROBESET as part of a Load.  

		if dataType = 'R' or dataType = 'L' then
			perform I2B2_METABOLOMICS_ZSCORE_CALC(TrialID, partitionName, partitionindx,partitioniD,sourceCD,'L',jobId,dataType,logBase);
			stepCt := stepCt + 1;
			perform cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',0,stepCt,'Done');
		end if;
	
	end if;

    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1;
	perform cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_metabolomics_data',0,stepCt,'Done');

	IF newJobFlag = 1
	THEN
		perform cz_end_audit (jobID, 'SUCCESS');
	END IF;

	select 0 into rtn_code ;
	return 0;

END;
 
$$;


ALTER FUNCTION tm_dataloader.i2b2_process_metabolomic_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base numeric, secure_study character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_process_mrna_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_process_mrna_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_cd character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;

	TrialID			varchar(100);
	sourceCd		varchar(50);

	dataType		varchar(10);
	sqlText			varchar(1000);
	pExists			numeric;
	partExists 		numeric;
	logBase			numeric;
	pCount			integer;
	partitioniD		numeric(18,0);
	partitionName	varchar(100);
	partitionIndx	varchar(100);
	res numeric;
BEGIN
	TrialID := upper(trial_id);

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	databaseName := current_schema();
	procedureName := 'I2B2_PROCESS_MRNA_DATA';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_mrna_data',0,stepCt,'Done') into rtnCd;

	if data_type is null then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;

	logBase := coalesce(log_base, 2);
	sourceCd := upper(coalesce(source_cd,'STD'));

	--	check if platform exists in probeset_deapp .  If not, abort run.
	select count(*) into pCount
	from probeset_deapp
	where platform in (select distinct m.platform from lt_src_mrna_subj_samp_map m);

	if pCount = 0 then
		select cz_write_audit(jobId,databaseName,procedureName,'No Gene Expression platforms in deapp.de_mrna_annotation',0,pCount,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;

	select I2B2_LOAD_SAMPLES(trial_id, top_node, 'MRNA_AFFYMETRIX', sourceCd, secure_study, jobID) into res;
	if res < 0 then
	  return res;
	end if;

	--	check if trial/source_cd already loaded, if yes, get existing partition_id else get new one
	select count(*) into partExists
	from deapp.de_subject_sample_mapping sm
	where sm.trial_name = TrialId
	  and coalesce(sm.source_cd,'STD') = sourceCd
	  and sm.platform = 'MRNA_AFFYMETRIX'
	  and sm.partition_id is not null;

	if partExists = 0 then
		select nextval('deapp.seq_mrna_partition_id') into partitionId;
	else
		select distinct partition_id into partitionId
		from deapp.de_subject_sample_mapping sm
		where sm.trial_name = TrialId
		  and coalesce(sm.source_cd,'STD') = sourceCd
		  and sm.platform = 'MRNA_AFFYMETRIX';
	end if;

	partitionName := 'deapp.de_subject_microarray_data_' || partitionId::text;
	partitionIndx := 'de_subject_microarray_data_' || partitionId::text;

	--	tag data with probeset_id from reference.probeset_deapp

	execute ('truncate table wt_subject_mrna_probeset');

	--	note: assay_id represents a unique subject/site/sample

	begin
	insert into wt_subject_mrna_probeset
	(probeset_id
	,intensity_value
	,assay_id
	,trial_name
	)
	select gs.probeset_id
		  ,avg(md.intensity_value::double precision)
		  ,sd.assay_id
		  ,TrialId
	from
	  lt_src_mrna_data md
      inner join deapp.de_subject_sample_mapping sd
        inner join probeset_deapp gs
        on sd.gpl_id = gs.platform
      on md.expr_id = sd.sample_cd and md.probeset = gs.probeset
	where sd.platform = 'MRNA_AFFYMETRIX'
	  and sd.trial_name = TrialId
	  and sd.source_cd = sourceCd
	  and case when dataType = 'R'
			   then case when md.intensity_value::double precision > 0 then 1 else 0 end
			   else 1 end = 1         --	take only >0 for dataType R
	group by gs.probeset_id
		  ,sd.assay_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_mrna_probeset',rowCt,stepCt,'Done') into rtnCd;

	if rowCt = 0 then
		select cz_write_audit(jobId,databaseName,procedureName,'Unable to match probesets to platform in probeset_deapp',0,rowCt,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end if;
	
	--	add partition if it doesn't exist, drop indexes and truncate if it does (reload)

	select count(*) into pExists
	from information_schema.tables
	where table_name = partitionindx;
	
	if pExists = 0 then
		sqlText := 'create table ' || partitionName || ' ( constraint mrna_' || partitionId::text || '_check check ( partition_id = ' || partitionId::text ||
					')) inherits (deapp.de_subject_microarray_data)';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Create partition ' || partitionName,1,stepCt,'Done') into rtnCd;
	else
        -- Keep this statement for backward compatibility
		sqlText := 'drop index if exists ' || partitionIndx || '_idx1';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		sqlText := 'drop index if exists ' || partitionIndx || '_idx2';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		sqlText := 'drop index if exists ' || partitionIndx || '_idx3';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		sqlText := 'drop index if exists ' || partitionIndx || '_idx4';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on ' || partitionName,1,stepCt,'Done') into rtnCd;

    sqlText := 'delete from ' || partitionName || ' where assay_id in (' ||
     'select sm.assay_id from deapp.de_subject_sample_mapping sm, lt_src_mrna_subj_samp_map tsm'
     || ' where sm.trial_name = ''' || TrialID || ''' and sm.source_cd = '''|| sourceCD || ''''
     || ' and coalesce(sm.site_id, '''') = coalesce(tsm.site_id, '''') and sm.subject_id = tsm.subject_id and sm.sample_cd = tsm.sample_cd)';
    raise notice 'sqlText= %', sqlText;
    execute sqlText;
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Truncate ' || partitionName,1,stepCt,'Done') into rtnCd;
	end if;

	--	insert into de_subject_microarray_data when dataType is T (transformed)

	if dataType = 'T' or dataType = 'Z' then -- Z is for compatibility with TR ETL default settings
		sqlText := 'insert into ' || partitionName || ' (partition_id, trial_name, probeset_id, assay_id, log_intensity, zscore) ' ||
				   'select ' || partitionId::text || ', trial_name, probeset_id, assay_id, intensity_value, ' ||
				   'case when intensity_value < -2.5 then -2.5 when intensity_value > 2.5 then 2.5 else intensity_value end ' ||
				   'from wt_subject_mrna_probeset';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		get diagnostics rowCt := ROW_COUNT;
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Inserted data into ' || partitionName,rowCt,stepCt,'Done') into rtnCd;
	else
		--	calculate zscore and insert to partition

		execute ('drop index if exists wt_subject_mrna_logs_i1');
		execute ('drop index if exists wt_subject_mrna_calcs_i1');
		execute ('truncate table wt_subject_microarray_logs');
		execute ('truncate table wt_subject_microarray_calcs');
		execute ('truncate table wt_subject_microarray_med');
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Drop indexes and truncate zscore work tables',1,stepCt,'Done') into rtnCd;

		begin
		insert into wt_subject_microarray_logs
		(probeset_id
		,assay_id
		,raw_intensity
		,log_intensity
		,trial_name
		)
		select probeset_id
			  ,assay_id
			  ,case when dataType = 'R' then intensity_value else 
				    case when logBase = -1 then 0 else power(logBase::double precision, intensity_value::double precision) end
			   end
			  ,case when dataType = 'L' then intensity_value else ln(intensity_value::double precision) / ln(logBase::double precision) end
			  ,trial_name
		from wt_subject_mrna_probeset;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in wt_subject_microarray_logs',rowCt,stepCt,'Done') into rtnCd;

		execute ('create index wt_subject_mrna_logs_i1 on wt_subject_microarray_logs (probeset_id) tablespace "indx"');
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Create index on wt_subject_microarray_logs',0,stepCt,'Done') into rtnCd;

		--	calculate mean_intensity, median_intensity, and stddev_intensity per probeset

		begin
		insert into wt_subject_microarray_calcs
		(probeset_id
		,mean_intensity
		,median_intensity
		,stddev_intensity
		,trial_name
		)
		select d.probeset_id
			  ,avg(log_intensity)
			  ,median(log_intensity::double precision)
			  ,stddev(log_intensity)
			  ,TrialID
		from wt_subject_microarray_logs d
		group by d.probeset_id;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
		end;
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in wt_subject_microarray_calcs',rowCt,stepCt,'Done') into rtnCd;

		execute ('create index wt_subject_mrna_calcs_i1 on wt_subject_microarray_calcs (probeset_id) tablespace "indx"');
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Create index on wt_subject_microarray_calcs',0,stepCt,'Done') into rtnCd;

		-- calculate zscore and insert into partition

		sqlText := 'insert into ' || partitionName || ' (partition_id, trial_name, probeset_id, assay_id, raw_intensity, log_intensity, zscore) ' ||
				   'select ' || partitionId::text || ', d.trial_name, d.probeset_id, d.assay_id, d.raw_intensity, d.log_intensity, ' ||
				   'case when c.stddev_intensity = 0 then 0 else ' ||
				   'case when (d.log_intensity - c.median_intensity ) / c.stddev_intensity < -2.5 then -2.5 ' ||
				   'when (d.log_intensity - c.median_intensity ) / c.stddev_intensity > 2.5 then 2.5 else ' ||
				   '(d.log_intensity - c.median_intensity ) / c.stddev_intensity end end ' ||
				   'from wt_subject_microarray_logs d ' ||
				   ',wt_subject_microarray_calcs c ' ||
				   'where d.probeset_id = c.probeset_id';
		raise notice 'sqlText= %', sqlText;
		execute sqlText;
		get diagnostics rowCt := ROW_COUNT;
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score and insert into ' || partitionName,rowCt,stepCt,'Done') into rtnCd;
	end if;

	--	create indexes on partition
	sqlText := ' create index ' || partitionIndx || '_idx2 on ' || partitionName || ' using btree (assay_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx3 on ' || partitionName || ' using btree (probeset_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx4 on ' || partitionName || ' using btree (assay_id, probeset_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
    ---Cleanup OVERALL JOB if this proc is being run standalone

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_mrna_data',0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_process_mrna_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_process_proteomics_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: weymouth
--

CREATE FUNCTION i2b2_process_proteomics_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_cd character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT NULL::character varying, currentjobid numeric DEFAULT NULL::numeric) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************

* This store procedure is for ETL for Sanofi to load  proteomics data
* Date: 9/12/2013

******************************************************************/
--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint	
Declare
  TrialID		character varying(100);
  RootNode		character varying(2000);
  root_level	integer;
  topNode		character varying(2000);
  topLevel		integer;
  tPath			character varying(2000);
  study_name	character varying(100);
  sourceCd		character varying(50);
  secureStudy	character varying(1);
  rtnCd			integer;
  dataType		character varying(10);
  sqlText		character varying(1000);
  tText			character varying(1000);
  gplTitle		character varying(1000);
  pExists		numeric;
  partTbl   	numeric;
  partExists 	numeric;
  sampleCt		numeric;
  idxExists 	numeric;
  logBase		numeric;
  pCount		integer;
  sCount		integer;
  tablespaceName	character varying(200);
  v_bio_experiment_id	numeric(18,0);
  errorNumber		character varying;
  errorMessage	character varying;
  
    --Audit variables
  newJobFlag numeric(1);
  databaseName character varying(100);
  procedureName character varying(100);
  jobID numeric(18,0);
  stepCt numeric(18,0);
  rowCt numeric(18,0);
  
	addNodes CURSOR is
	select distinct t.leaf_node
          ,t.node_name
	from  WT_PROTEOMICS_NODES t
	where not exists
		 (select 1 from i2b2 x
		  where t.leaf_node = x.c_fullname);

 
--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  delNodes CURSOR is
  select distinct c_fullname 
  from  i2b2
  where c_fullname like topNode || '%'
    and substr(c_visualattributes,2,1) = 'H';
    --and c_visualattributes like '_H_';

    uploadI2b2 cursor  is 
    select category_cd,display_value,display_label,display_unit from
    lt_src_protein_display_mapping;

BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\', 'g');	
	select length(topNode)-length(replace(topNode,'\','')) into topLevel;
	
	if data_type is null then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;
	
	logBase := log_base;
	sourceCd := upper(coalesce(source_cd,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  databaseName := current_schema();
  procedureName := 'I2B2_PROCESS_PROTEOMICS_DATA';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit(procedureName, databaseName) into jobID;
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_proteomics_data',0,stepCt,'Done') into rtnCd;
	
	--	Get count of records in LT_SRC_PROTEOMICS_SUB_SAM_MAP
	
	select count(*) into sCount
	from LT_SRC_PROTEOMICS_SUB_SAM_MAP;

	select count(*) into pCount
	from LT_SRC_PROTEOMICS_SUB_SAM_MAP
	where platform is null;
	
	if pCount > 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select cz_error_handler(jobid,procedurename, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
	end if;
	
	/*select count(*) into pCount
	from LT_PROTEIN_ANNOTATION
	where gpl_id in (select distinct m.platform from LT_SRC_PROTEOMICS_SUB_SAM_MAP m);

	if pCount = 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databasename,procedurename,'Platform not found in LT_PROTEIN_ANNOTATION',1,stepCt,'ERROR') into rtnCd;
		select CZ_ERROR_HANDLER(JOBID,PROCEDURENAME, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 163;
	end if;*/
	
	select count(*) into pCount
	from DE_gpl_info
	where platform in (select distinct m.platform from LT_SRC_PROTEOMICS_SUB_SAM_MAP m);
	
	if pCount = 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databasename,procedurename,'Platform not found in DE_GPL_INFO',1,stepCt,'ERROR') into rtnCd;
		select CZ_ERROR_HANDLER(JOBID,PROCEDURENAME, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 16;
	end if;
		
	--	check if all subject_sample map records have a tissue_type, If not, abort run
	
	select count(*) into pCount
	from LT_SRC_PROTEOMICS_SUB_SAM_MAP
	where tissue_type is null;
	
	if pCount > 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databasename,procedurename,'Tissue Type data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select cz_error_handler(jobid,procedurename, '-1', 'Application raised error') into rtnCd;
		select CZ_END_AUDIT (JOBID,'FAIL') into rtnCd;
		return 162;
	end if;
	
	--	check if there are multiple platforms, if yes, then platform must be supplied in LT_SRC_PROTEOMICS_SUB_SAM_MAP
	
	select count(*) into pCount
	from (select sample_cd
		  from LT_SRC_PROTEOMICS_SUB_SAM_MAP
		  group by sample_cd
		  having count(distinct platform) > 1) as vtbl;
	
	if pCount > 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databasename,procedurename,'Multiple platforms for sample_cd in LT_SRC_PROTEOMICS_SUB_SAM_MAP',1,stepCt,'ERROR') into rtnCd;
		select CZ_ERROR_HANDLER(JOBID,PROCEDURENAME, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 164;
	end if;
		
	-- Get root_node from topNode
  
	select parse_nth_value(topNode, 2, '\') into RootNode;
	
	select count(*) into pExists
	from table_access
	where c_name = rootNode;
	
	if pExists = 0 then
		select i2b2_add_root_node(rootNode, jobId) into rtnCd;
	end if;
	
	select c_hlevel into root_level
	from i2b2
	where c_name = RootNode;
	
	-- Get study name from topNode
  
	select parse_nth_value(topNode, topLevel, '\') into study_name;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount;

	if pCount > 2 then
		select i2b2_fill_in_tree(null, tPath, jobId) into rtnCd;
	end if;

	--	uppercase study_id in LT_SRC_PROTEOMICS_SUB_SAM_MAP in case curator forgot
	begin
	update LT_SRC_PROTEOMICS_SUB_SAM_MAP
	set trial_name=upper(trial_name);
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in LT_SRC_PROTEOMICS_SUB_SAM_MAP',rowCt,stepCt,'Done') into rtnCd;	
	
	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd

	begin
	insert into patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,now()
		  ,now()
		  ,now()
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from LT_SRC_PROTEOMICS_SUB_SAM_MAP s
		     ,de_gpl_info g
		 where s.subject_id is not null
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = 'PROTEOMICS'
		   and not exists
			  (select 1 from patient_dimension x
			   where x.sourcesystem_cd = 
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) x;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',rowCt,stepCt,'Done') into rtnCd;	
	select i2b2_create_security_for_trial(TrialId, secureStudy, jobID) into rtnCd;

	--	Delete existing observation_fact data, will be repopulated

	begin
	delete from observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = 'PROTEIN');
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;

	begin
	delete from DE_SUBJECT_PROTEIN_DATA
	where trial_name = TrialId ;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete data from DE_SUBJECT_PROTEIN_DATA',rowCt,stepCt,'Done') into rtnCd;
		
	--	Cleanup any existing data in de_subject_sample_mapping.  

	begin
	delete from DE_SUBJECT_SAMPLE_MAPPING ssm
	where trial_name = TrialID 
	  and coalesce(ssm.source_cd,'STD') = sourceCd
	  and platform = 'PROTEIN'
	; --Making sure only miRNA data is deleted
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		  
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;
	begin
	execute('truncate table WT_PROTEOMICS_NODES');
	execute('truncate table WT_PROTEOMICS_NODE_VALUES');
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	begin
	insert into WT_PROTEOMICS_NODE_VALUES
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
				   ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from LT_SRC_PROTEOMICS_SUB_SAM_MAP a
	    ,de_gpl_info g 
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = 'PROTEOMICS'
	  and g.title = (select min(x.title) from de_gpl_info x where coalesce(a.platform,'GPL570') = x.platform)
      -- and upper(g.organism) = 'HOMO SAPIENS'
	  ;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
      
	--  and decode(dataType,'R',sign(a.intensity_value),1) = 1;	--	take all values when dataType T, only >0 for dataType R
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP WT_PROTEOMICS_NODE_VALUES',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into WT_PROTEOMICS_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g') 
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  WT_PROTEOMICS_NODE_VALUES;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_proteomics_nodes',rowCt,stepCt,'Done') into rtnCd;
	--	insert for platform node so platform concept can be populated

	begin
	insert into WT_PROTEOMICS_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  WT_PROTEOMICS_NODE_VALUES;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in WT_PROTEOMICS_NODES',rowCt,stepCt,'Done') into rtnCd;
	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd

	begin
	insert into WT_PROTEOMICS_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  WT_PROTEOMICS_NODE_VALUES
	where category_cd like '%ATTR1%'
	  and attribute_1 is not null;
	  exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in WT_PROTEOMICS_NODES',rowCt,stepCt,'Done') into rtnCd;
	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd

	begin
	insert into WT_PROTEOMICS_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  WT_PROTEOMICS_NODE_VALUES
	where category_cd like '%ATTR2%'
	  and attribute_2 is not null;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_PROTEOMICS_NODES',rowCt,stepCt,'Done') into rtnCd;
	--	insert for tissue_type node so sample_type_cd can be populated

	begin
	insert into WT_PROTEOMICS_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  WT_PROTEOMICS_NODE_VALUES
	where category_cd like '%TISSUETYPE%';
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_PROTEOMICS_NODES',rowCt,stepCt,'Done') into rtnCd;
	begin
	update WT_PROTEOMICS_NODES
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_proteomics_nodes',rowCt,stepCt,'Done') into rtnCd;
--	add leaf nodes for proteomics data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)

		select i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId) into rtnCd;
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		if rtnCd > 1 then
			select cz_write_audit(jobId,databasename,procedurename,'Error while executing i2b2_add_node(' || TrialID || ',' || r_addNodes.leaf_node || ',' || r_addNodes.node_name || ',' || jobId || ')' ,1,stepCt,'ERROR') into rtnCd;
			select cz_end_audit (jobId,'FAIL') into rtnCd;
			return 168;
		end if;	
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;
		select cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;
		select i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID) into rtnCd;
		if rtnCd > 1 then
			select cz_write_audit(jobId,databasename,procedurename,'Error while executing i2b2_fill_in_tree(' || TrialID || ',' || r_addNodes.leaf_node || ',' || jobId || ')' ,1,stepCt,'ERROR') into rtnCd;
			select cz_end_audit (jobId,'FAIL') into rtnCd;
			return 170;
		end if;	
	END LOOP;  
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes

	begin
	update i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	  	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done') into rtnCd;
--	update concept_cd for nodes, this is done to make the next insert easier

	begin
	update WT_PROTEOMICS_NODES t
	set concept_cd=(select c.concept_cd from concept_dimension c
	                where c.concept_path = t.leaf_node limit 1
				   )
    where exists
         (select 1 from concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and t.concept_cd is null;
	  exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Update WT_PROTEOMICS_NODES with newly created concept_cds',rowCt,stepCt,'Done') into rtnCd;
  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_proteomics_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in wt_proteomics_nodes
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in wt_proteomics_nodes
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in wt_proteomics_nodes
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in wt_proteomics_nodes
  --PLATFORM        = PROTEOMICS - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in wt_proteomics_nodes
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_proteomics_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd
  
  --ASSAY_ID        = generated by trigger

	begin
	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,'PROTEIN' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+PROTEOMICS+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from lt_src_proteomics_sub_sam_map a		
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = b.sourcesystem_cd
		inner join WT_PROTEOMICS_NODES ln
			on a.platform = ln.platform
			and a.category_cd=ln.category_cd
			and coalesce(a.tissue_type,'') = coalesce(ln.tissue_type,'')
			and coalesce(a.attribute_1,'@') = coalesce(ln.attribute_1,'@')
			and coalesce(a.attribute_2,'@') = coalesce(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join WT_PROTEOMICS_NODES pn
			on a.platform = pn.platform
			and  pn.category_cd=substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(pn.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(pn.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'	  
		left outer join WT_PROTEOMICS_NODES ttp
			on a.tissue_type = ttp.tissue_type
			and ttp.category_cd=substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = coalesce(ttp.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(ttp.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'		  
		left outer join WT_PROTEOMICS_NODES a1
			on a.attribute_1 = a1.attribute_1
			and a1.category_cd=substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a1.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a1.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'		  
		left outer join WT_PROTEOMICS_NODES a2
			on a.attribute_2 = a1.attribute_2
			and a2.category_cd=substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a2.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a2.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'			  
		left outer join patient_dimension sid
			on  regexp_replace(TrialId || ':' || coalesce(a.site_id,'') || ':' || a.subject_id || ':' || a.sample_cd,
							  '(::){1,}', ':', 'g') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  ln.concept_cd is not null) t;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
         ,sample_cd
        ,INSTANCE_NUM
        
    )
    select distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null::numeric	--	not numeric for qpcr_mirna
		  ,m.trial_name
		  ,now()
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                   ,m.sample_cd
                   ,1
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCD
      and m.platform = 'PROTEIN';
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;
	--	Insert sample facts 

	begin
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
         ,sample_cd
        ,INSTANCE_NUM
    )
    select distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null::numeric	--	not numeric for miRNA
		  ,m.trial_name
		  ,now()
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                   ,m.sample_cd
                  ,1
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCd
      and m.platform = 'PROTEIN'
	 and m.patient_id != m.sample_id;
    exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;
	--Update I2b2 for correct data type
	begin
	update i2b2 t
	set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
	where t.c_basecode in (select distinct x.concept_cd from WT_PROTEOMICS_NODES x);
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
  
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',rowCt,stepCt,'Done') into rtnCd;

	 ---INSERT sample_dimension
	begin
      INSERT INTO I2B2DEMODATA.SAMPLE_DIMENSION(SAMPLE_CD) 
         SELECT DISTINCT SAMPLE_CD FROM 
	   DEAPP.DE_SUBJECT_SAMPLE_MAPPING WHERE SAMPLE_CD NOT IN (SELECT SAMPLE_CD FROM I2B2DEMODATA.SAMPLE_DIMENSION) ;
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
    stepCt := stepCt + 1;
    get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'insert distinct sample_cd in sample_dimension from de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

    ---- update c_metedataxml in i2b2

       for ul in uploadI2b2
        loop
        begin
	 update i2b2 n
	SET n.c_columndatatype = 'T',
      --Static XML String
		n.c_metadataxml =  ('<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue>
                <HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue>
                <LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue>
                <EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion>
                <UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits>
                <ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor>
                </ConvertingUnits></UnitValues><Analysis><Enums /><Counts />
                <New /></Analysis>'||(select xmlelement(name "SeriesMeta",xmlforest(m.display_value as "Value",m.display_unit as "Unit",m.display_label as "DisplayName")) as hi 
      from lt_src_protein_display_mapping m where m.category_cd=ul.category_cd)||
                '</ValueMetadata>') where n.c_fullname=(select leaf_node from WT_PROTEOMICS_NODES where category_cd=ul.category_cd and leaf_node=n.c_fullname);
        exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
                end loop;
		  
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	begin
	update i2b2 a
        set c_visualattributes = 'LAH'
	where a.c_basecode in (select distinct x.concept_code from de_subject_sample_mapping x
						   where x.trial_name = TrialId
						     and x.platform = 'PROTEIN'
							 and x.concept_code is not null);
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	  
	stepCt := stepCt + 1;
	get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;
  
        begin
	update i2b2 a
	set c_visualattributes='FAS'
        where a.c_fullname = substr(topNode,1,instr(topNode,'\',1,3));
        exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
        
        stepCt := stepCt + 1;
        get diagnostics rowCt := ROW_COUNT;
	select cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for study nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;
  
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for miRNA data
  
    select i2b2_create_concept_counts(topNode ,jobID ) into rtnCd;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done') into rtnCd;
	
	--	delete each node that is hidden

	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		select i2b2_delete_1_node(r_delNodes.c_fullname) into rtnCd;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;

	END LOOP;  	


  --Reload Security: Inserts one record for every I2B2 record into the security table

    select i2b2_load_security_data(jobId) into rtnCd;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done') into rtnCd;

--	tag data with probeset_id from reference.probeset_deapp
	begin
	execute('truncate table WT_SUBJECT_PROTEOMICS_PROBESET');
	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	--	note: assay_id represents a unique subject/site/sample

	begin
	insert into WT_SUBJECT_PROTEOMICS_PROBESET  --mod
	(probeset
--	,expr_id
	,intensity_value
	,patient_id
--	,sample_cd
	,subject_id
	,trial_name
	,assay_id
	)
	select    md.peptide
		  ,avg(md.intensity_value::numeric)
                  ,sd.patient_id
                  ,sd.subject_id
		  ,TrialId
		  ,sd.assay_id
	from deapp.de_subject_sample_mapping sd
		,LT_SRC_PROTEOMICS_DATA md   
              --  ,peptide_deapp p
	where sd.sample_cd = md.m_p_id
	  and sd.platform = 'PROTEIN'
	  and sd.trial_name =TrialId
	  and sd.source_cd = sourceCd
	 -- and sd.gpl_id = gs.id_ref
	--  and md.peptide =p.peptide-- gs.mirna_id
	 and CASE WHEN dataType = 'R' THEN sign(md.intensity_value::numeric) ELSE 1 END <> -1   --UAT 154 changes done on 19/03/2014
	 and sd.subject_id in (select subject_id from lt_src_proteomics_sub_sam_map) 
	group by md.peptide ,subject_id
		  ,sd.patient_id,sd.assay_id;

	exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	get diagnostics rowCt := ROW_COUNT;
	pExists := rowCt;
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP WT_SUBJECT_PROTEOMICS_PROBESET',rowCt,stepCt,'Done') into rtnCd;
		
	if pExists = 0 then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databasename,procedurename,'Unable to match probesets to platform in probeset_deapp',1,stepCt,'ERROR') into rtnCd;
		select CZ_ERROR_HANDLER(JOBID,PROCEDURENAME, '-1', 'Application raised error') into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 165;
	end if;

	--	insert into de_subject_mirna_data when dataType is T (transformed)

	if dataType = 'T' then

	begin
		insert into DE_SUBJECT_PROTEIN_DATA
		(trial_name
	,protein_annotation_id
	,component
	,gene_symbol
	,gene_id
	,assay_id
	,subject_id
	,intensity 
	,zscore
        ,log_intensity
	,patient_id
		)
		select TrialId 
                  ,d.id
		  ,m.probeset
                  ,d.uniprot_id
                  ,d.biomarker_id
		  ,m.assay_id
                  ,m.subject_id 
                   ,m.intensity_value as intensity ----UAT 154 changes done on 19/03/2014
			  ,case when m.intensity_value < -2.5
			        then -2.5
					when m.intensity_value > 2.5
					then 2.5
					else m.intensity_value
			   end as zscore
                           /*, case when m.intensity_value > 0 then round(log(2, m.intensity_value),6)
                            else 0 
                            end */
                            ,round(log(2, m.intensity_value + 0.001),6)  ----UAT 154 changes done on 19/03/2014
                            ,m.patient_id
		from WT_SUBJECT_PROTEOMICS_PROBESET  m
                ,DEAPP.DE_PROTEIN_ANNOTATION d
		where trial_name = TrialID
                 and d.peptide=m.probeset;
        exception
	when others then
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		stepCt := stepCt + 1;
		get diagnostics rowCt := ROW_COUNT;
		select cz_write_audit(jobId,databaseName,procedureName,'Insert transformed into DEAPP DE_SUBJECT_PROTEIN_DATA',rowCt,stepCt,'Done') into rtnCd;
	else
		
	--	Calculate ZScores and insert data into de_subject_mirna_data.  The 'L' parameter indicates that the gene expression data will be selected from
	--	WT_SUBJECT_PROTEOMICS_PROBESET as part of a Load.  

		if dataType = 'R' or dataType = 'L' then
			select I2B2_PROTEOMICS_ZSCORE_CALC(TrialID,'L',jobId,dataType,logBase,sourceCD) into rtnCd;
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',0,stepCt,'Done') into rtnCd;
		end if;
	
	end if;

    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_proteomics_data',0,stepCt,'Done') into rtnCd;

	IF newJobFlag = 1
	THEN
		select cz_end_audit(jobID, 'SUCCESS') into rtnCd;
	END IF;

	return rtnCd;
END;
$$;


ALTER FUNCTION tm_dataloader.i2b2_process_proteomics_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric) OWNER TO weymouth;

--
-- Name: i2b2_process_qpcr_mirna_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric, character varying); Type: FUNCTION; Schema: tm_dataloader; Owner: weymouth
--

CREATE FUNCTION i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_cd character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT NULL::character varying, currentjobid numeric DEFAULT NULL::numeric, mirna_type character varying DEFAULT NULL::character varying) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************

* This store procedure is for ETL for Sanofi to load  qpcr or seq miRNA data
* Date: 12/05/2013

******************************************************************/


--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint	
Declare
  TrialID		varchar(100);
  RootNode		varchar(2000);
  root_level	integer;
  topNode		varchar(2000);
  topLevel		integer;
  tPath			varchar(2000);
  study_name	varchar(100);
  sourceCd		varchar(50);
  secureStudy	varchar(1);

  dataType		varchar(10);
  sqlText		varchar(1000);
  tText			varchar(1000);
  gplTitle		varchar(1000);
  pExists		numeric;
  partTbl   	numeric;
  partExists 	numeric;
  sampleCt		numeric;
  idxExists 	numeric;
  logBase		numeric;
  pCount		integer;
  sCount		integer;
  tablespaceName	varchar(200);
  v_bio_experiment_id	numeric(18,0);
  mirnaType varchar(15);
 -- mirnaPlatform varchar(20);
  
    --Audit variables
  newJobFlag numeric(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID numeric(18,0);
  stepCt numeric(18,0);
  rowCt	integer;
  errorNumber		character varying;
  errorMessage	character varying;
    
	addNodes CURSOR is
	select distinct t.leaf_node
          ,t.node_name
	from  wt_qpcr_mirna_nodes t
	where not exists
		 (select 1 from i2b2 x
		  where t.leaf_node = x.c_fullname);

 
--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  delNodes CURSOR for
  select distinct c_fullname 
  from  i2b2
  where c_fullname like topNode || '%'
    and substr(c_visualattributes,2,1) = 'H';
    --and c_visualattributes like '_H_';

    uploadI2b2 cursor for 
    select category_cd,display_value,display_label,display_unit from
    lt_src_mirna_display_mapping;



BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	mirnaType:=upper(mirna_type);
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\', 'g');	
	select length(topNode)-length(replace(topNode,'\','')) into topLevel ;
	
	if data_type is null then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;

	logBase := log_base;
	sourceCd := upper(coalesce(source_cd,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  databaseName := current_schema();
  procedureName := 'I2B2_PROCESS_QPCR_MIRNA_DATA';
  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit(procedureName, databaseName) into jobID;
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_qpcr_mirna_data',0,stepCt,'Done');
	
	--	Get count of records in LT_SRC_MIRNA_SUBJ_SAMP_MAP
	
	select count(*) into sCount
	from LT_SRC_MIRNA_SUBJ_SAMP_MAP;
	
	--	check if all subject_sample map records have a platform, If not, abort run
	
	select count(*) into pCount
	from LT_SRC_MIRNA_SUBJ_SAMP_MAP
	where platform is null;
	
	if pCount > 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		perform cz_end_audit (jobId,'FAIL');
		return 161;
	end if;
  
  	--	check if platform exists in de_qpcr_mirna_annotation .  If not, abort run.
	
	select count(*) into pCount
	from deapp.de_qpcr_mirna_annotation
	where gpl_id in (select distinct m.platform from LT_SRC_MIRNA_SUBJ_SAMP_MAP m);
	
	if PCOUNT = 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Unmapped platform',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		perform cz_end_audit (jobId,'FAIL');
		return 162;
	end if;--mod
	
	select count(*) into pCount
	from DE_gpl_info
	where platform in (select distinct m.platform from LT_SRC_MIRNA_SUBJ_SAMP_MAP m);
	
	if PCOUNT = 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'No platoform in de_gpl_info',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		perform cz_end_audit (jobId,'FAIL');
		return 163;
	end if;
		
	--	check if all subject_sample map records have a tissue_type, If not, abort run
	
	select count(*) into pCount
	from LT_SRC_MIRNA_SUBJ_SAMP_MAP
	where tissue_type is null;
	
	if pCount > 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Missing tissue',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		perform cz_end_audit (jobId,'FAIL');
		return 164;
	end if;
	
	--	check if there are multiple platforms, if yes, then platform must be supplied in LT_SRC_QPCR_MIRNA_DATA
	
	select count(*) into pCount
	from (select sample_cd
		  from LT_SRC_MIRNA_SUBJ_SAMP_MAP
		  group by sample_cd
		  having count(distinct platform) > 1) t;
	
	if pCount > 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'Multiple platforms',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		perform cz_end_audit (jobId,'FAIL');
		return 165;
	end if;
		
	-- Get root_node from topNode
  
	select parse_nth_value(topNode, 2, '\') into RootNode ;
	
	select count(*) into pExists
	from table_access
	where c_name = rootNode;
	
	if pExists = 0 then
		perform i2b2_add_root_node(rootNode, jobId);
	end if;
	
	select c_hlevel into root_level
	from i2b2
	where c_name = RootNode;
	
	-- Get study name from topNode
  
	select parse_nth_value(topNode, topLevel, '\') into study_name ;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount ;
	if pCount > 2 then
		perform i2b2_fill_in_tree(null, tPath, jobId);
	end if;

	--	uppercase study_id in lt_src_mirna_subj_samp_map in case curator forgot
	
	update LT_SRC_MIRNA_SUBJ_SAMP_MAP
	set trial_name=upper(trial_name);
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in LT_SRC_MIRNA_SUBJ_SAMP_MAP',rowCt,stepCt,'Done');	
	
	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd

	begin
	insert into patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,current_timestamp
		  ,current_timestamp
		  ,current_timestamp
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from LT_SRC_MIRNA_SUBJ_SAMP_MAP s
		     ,de_gpl_info g
		 where s.subject_id is not null
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = mirnaType
		   and not exists
			  (select 1 from patient_dimension x
			   where x.sourcesystem_cd = 
				 regexp_replace(TrialID || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g'))
		) x;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
			
	get diagnostics rowCt := ROW_COUNT;
	pCount := rowCt;
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension.',pCount,stepCt,'Done');
	
	begin
		perform i2b2_create_security_for_trial(TrialId, secureStudy, jobID);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	--	Delete existing observation_fact data, will be repopulated

	begin
	delete from observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = mirna_type);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done');
	
        begin
	delete from de_subject_mirna_data
	where trial_source = TrialId || ':' || sourceCd;
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete data from de_subject_mirna_data',rowCt,stepCt,'Done');
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	begin
	delete from deapp.DE_SUBJECT_SAMPLE_MAPPING d 
	where trial_name = TrialID 
	  and coalesce(d.source_cd,'STD') = sourceCd
	  and platform = mirna_type;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	  
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done');

	begin
		execute('truncate table WT_QPCR_MIRNA_NODES');
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	begin
		execute('truncate table WT_QPCR_MIRNA_NODE_VALUES');
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	begin
	insert into WT_QPCR_MIRNA_NODE_VALUES
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from LT_SRC_MIRNA_SUBJ_SAMP_MAP a
	    ,de_gpl_info g 
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = mirnaType
	  and g.title = (select min(x.title) from de_gpl_info x where coalesce(a.platform,'GPL570') = x.platform)
      -- and upper(g.organism) = 'HOMO SAPIENS'
	  ;
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	--  and decode(dataType,'R',sign(a.intensity_value),1) = 1;	--	take all values when dataType T, only >0 for dataType R
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP wt_qpcr_mirna_node_values',rowCt,stepCt,'Done');
	
	begin
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g') 
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  WT_QPCR_MIRNA_NODE_VALUES;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
    stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_mirna_nodes',rowCt,stepCt,'Done');
	
	
	--	insert for platform node so platform concept can be populated
	begin
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
        ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  WT_QPCR_MIRNA_NODE_VALUES;
		   
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in wt_qpcr_mirna_nodes',rowCt,stepCt,'Done');
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd
	begin
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
        ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  WT_QPCR_MIRNA_NODE_VALUES
	where category_cd like '%ATTR1%'
        and attribute_1 is not null;
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in WT_QPCR_MIRNA_NODES',rowCt,stepCt,'Done');
	
	
	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd

	begin
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
        ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  WT_QPCR_MIRNA_NODE_VALUES
	where category_cd like '%ATTR2%'
	  and attribute_2 is not null;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		   
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_QPCR_MIRNA_NODES',rowCt,stepCt,'Done');
	
	
	--	insert for tissue_type node so sample_type_cd can be populated
	begin
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
        ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1, '')),'ATTR2',coalesce(attribute_2, '')),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  WT_QPCR_MIRNA_NODE_VALUES
	where category_cd like '%TISSUETYPE%';
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	 
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_qpcr_mirna_nodes',rowCt,stepCt,'Done');
	
	begin			
	update WT_QPCR_MIRNA_NODES
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_mirna_nodes',rowCt,stepCt,'Done');
	
		
--	add leaf nodes for miRNA data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)
		begin
			perform i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId);
			stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
			tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;
		
			perform cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done');
		
			perform i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID);
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
			perform cz_end_audit (jobID, 'FAIL');
			return -16;
		end;

	END LOOP;  
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
	begin
	update i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done');

	begin
	update WT_QPCR_MIRNA_NODES t
	set concept_cd=(select c.concept_cd from concept_dimension c
	                where c.concept_path = t.leaf_node limit 1)
        where exists
         (select 1 from concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and t.concept_cd is null;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update WT_QPCR_MIRNA_NODES with newly created concept_cds',rowCt,stepCt,'Done');
	
	 
	
  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_mirna_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in wt_mirna_nodes
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in wt_mirna_nodes
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in wt_mirna_nodes
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in wt_mirna_nodes
  --PLATFORM        = MIRNA_AFFYMETRIX - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in wt_qpcr_mirna_nodes
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_mirna_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd
  
  --ASSAY_ID        = generated by trigger

	begin
	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,mirna_type as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::varchar as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+QPCR_MIRNA+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from lt_src_mirna_subj_samp_map a		
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = b.sourcesystem_cd
		inner join WT_QPCR_MIRNA_NODES ln
			on a.platform = ln.platform
			and a.category_cd=ln.category_cd
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'@') = coalesce(ln.attribute_1,'@')
			and coalesce(a.attribute_2,'@') = coalesce(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join WT_QPCR_MIRNA_NODES pn
			on a.platform = pn.platform
			and  pn.category_cd=substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(pn.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(pn.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'	  
		left outer join WT_QPCR_MIRNA_NODES ttp
			on a.tissue_type = ttp.tissue_type
			and ttp.category_cd=substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = coalesce(ttp.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(ttp.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'		  
		left outer join WT_QPCR_MIRNA_NODES a1
			on a.attribute_1 = a1.attribute_1
			and a1.category_cd=substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a1.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a1.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'		  
		left outer join WT_QPCR_MIRNA_NODES a2
			on a.attribute_2 = a1.attribute_2
			and a2.category_cd=substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5)
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a2.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a2.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'			  
		left outer join patient_dimension sid
			on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  ln.concept_cd is not null) t;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done');

--	Insert records for patients and samples into observation_fact
	begin
	insert into observation_fact
        (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,sample_cd
        ,INSTANCE_NUM
        )
        select distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null::numeric	--	not numeric for qpcr_mirna
		  ,m.trial_name
		  ,current_timestamp
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                   ,m.sample_cd
                  ,1
        from  de_subject_sample_mapping m
        where m.trial_name = TrialID 
        and m.source_cd = sourceCD
        and m.platform = mirna_type;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done');
    
	--	Insert sample facts 
	begin
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,sample_cd
        ,INSTANCE_NUM
    )
    select distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null::numeric--	not numeric for miRNA
		  ,m.trial_name
		  ,current_timestamp
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,m.sample_cd
                  ,1
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
    and m.source_cd = sourceCd
    and m.platform = mirna_type
    and m.patient_id != m.sample_id;
    exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	--Update I2b2 for correct data type
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done');
    
	begin
	update i2b2 t
	set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
	where t.c_basecode in (select distinct x.concept_cd from WT_QPCR_MIRNA_NODES x);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		
	 ---INSERT sample_dimension
      stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
      perform cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',rowCt,stepCt,'Done');
      
	  begin
      INSERT INTO I2B2DEMODATA.SAMPLE_DIMENSION(SAMPLE_CD) 
         SELECT DISTINCT SAMPLE_CD FROM 
           DEAPP.DE_SUBJECT_SAMPLE_MAPPING WHERE SAMPLE_CD NOT IN (SELECT SAMPLE_CD FROM I2B2DEMODATA.SAMPLE_DIMENSION) ;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'insert distinct sample_cd in sample_dimension from de_subject_sample_mapping',rowCt,stepCt,'Done');
	

    ---- update c_metedataxml in i2b2
 begin   
   for ul in uploadI2b2 loop
	 update i2b2 n
	SET c_columndatatype = 'T',
      --Static XML String
		c_metadataxml =  ('<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue>
                <HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue>
                <LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue>
                <EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion>
                <UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits>
                <ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor>
                </ConvertingUnits></UnitValues><Analysis><Enums /><Counts />
                <New /></Analysis>'||(select xmlelement(name "SeriesMeta",xmlforest(m.display_value as "Value",m.display_unit as "Unit",m.display_label as "DisplayName")) as hi 
      from lt_src_mirna_display_mapping m where m.category_cd=ul.category_cd)||
                '</ValueMetadata>') where n.c_fullname=(select leaf_node from WT_QPCR_MIRNA_NODES where category_cd=ul.category_cd and leaf_node=n.c_fullname);
     end loop;
      exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		  
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',rowCt,stepCt,'Done');

	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	begin
	update i2b2 a
        set c_visualattributes = 'LAH'
	where a.c_basecode in (select distinct x.concept_code from de_subject_sample_mapping x
						   where x.trial_name = TrialId
						     and x.platform = mirna_type
							 and x.concept_code is not null);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;

	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done');

	begin
    update i2b2 a
	set c_visualattributes='FAS'
        where a.c_fullname = substr(topNode,1,instr(topNode,'\',1,3));
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
        
        stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for study nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done');
    
	

  
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for miRNA data
  
        perform i2b2_create_concept_counts(topNode ,jobID );
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done');
	
	--	delete each node that is hidden
	begin
	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time
		
		perform i2b2_delete_1_node(r_delNodes.c_fullname);
		stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		get diagnostics rowCt := ROW_COUNT;
		perform cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done');

	END LOOP;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;  	


  --Reload Security: Inserts one record for every I2B2 record into the security table
	begin
		perform i2b2_load_security_data(jobId);
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done');

--	tag data with probeset_id from reference.probeset_deapp

	begin
	execute ('truncate table WT_SUBJECT_MIRNA_PROBESET');
	
	--	note: assay_id represents a unique subject/site/sample

	
	insert into WT_SUBJECT_MIRNA_PROBESET  --mod
	(probeset_id
--	,expr_id
	,intensity_value
	,patient_id
--	,sample_cd
--	,subject_id
	,trial_name
	,assay_id
	)
	select    p.probeset_id 
		  ,avg(md.intensity_value::numeric)
                  ,sd.patient_id
		  ,TrialId
		  ,sd.assay_id
	from LT_SRC_QPCR_MIRNA_DATA md left outer join deapp.de_subject_sample_mapping sd on sd.sample_cd = md.expr_id
                ,mirna_probeset_deapp p
	where sd.platform = mirna_type
	  and sd.trial_name =TrialId
	  and sd.source_cd = sourceCd
	 -- and sd.gpl_id = gs.id_ref
	  and md.probeset =p.probeset-- gs.mirna_id
	  and CASE WHEN dataType ='R' THEN sign(md.intensity_value::numeric) ELSE 1 END <> -1  ---UAT 163 changes done,UAT 154 changes on 19/03/2014
	  and sd.subject_id in (select subject_id from lt_src_mirna_subj_samp_map) 
    and sd.gpl_id = p.platform
	group by  p.probeset_id 
        ,sd.patient_id,sd.assay_id;
        exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);
		perform cz_end_audit (jobID, 'FAIL');
		return -16;
	end;
		  
	pExists := rowCt;
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_mirna_probeset',rowCt,stepCt,'Done');
	
			
	if pExists = 0 then
		perform cz_write_audit(jobId,databasename,procedurename,'No probeset records',1,stepCt,'ERROR');
		perform cz_error_handler(jobid,procedurename, '-1', 'Application raised error');
		perform cz_end_audit (jobId,'FAIL');
		return 165;
	end if;

	--	insert into de_subject_mirna_data when dataType is T (transformed)
 
	if dataType = 'T' then
		begin
		insert into de_subject_mirna_data
		(trial_source
		,probeset_id
		,assay_id
		,patient_id
		--,sample_id
		--,subject_id
		,trial_name
		,zscore
		)
		select (TrialId || ':' || sourceCd)
			  ,probeset_id
			  ,assay_id
			  ,patient_id
			  --,sample_id
			  --,subject_id
			  ,trial_name
			  /*,case when intensity_value < -2.5
			        then -2.5
					when intensity_value > 2.5
					then 2.5
					else intensity_value
			   end as zscore */
                           ,intensity_value as zscore
		from WT_SUBJECT_MIRNA_PROBESET --mod
		where trial_name = TrialID    ;
		stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
		perform cz_write_audit(jobId,databaseName,procedureName,'Insert transformed into DEAPP de_subject_mirna_data',rowCt,stepCt,'Done');
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);
			perform cz_end_audit (jobID, 'FAIL');
			return -16;
		end;	
	else
		
	--	Calculate ZScores and insert data into de_subject_mirna_data.  The 'L' parameter indicates that the gene expression data will be selected from
	--	wt_subject_mirna_probeset as part of a Load.  

		if dataType = 'R' or dataType = 'L' then
			begin
			 if mirna_type='MIRNA_QPCR' then
			perform i2b2_mirna_zscore_calc(TrialID,'L',jobId,'R',logBase,sourceCD);----donot do log transform
                        else
                        perform i2b2_mirna_zscore_calc(TrialID,'L',jobId,'L',logBase,sourceCD);----do log transform
                        end if;
			stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
			perform cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',0,stepCt,'Done');
			exception
			when others then
				errorNumber := SQLSTATE;
				errorMessage := SQLERRM;
				perform cz_error_handler (jobID, procedureName, errorNumber, errorMessage);	
				perform cz_end_audit (jobID, 'FAIL');
				return -16;
			end;
		end if;
	
	end if;

    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1; get diagnostics rowCt := ROW_COUNT;
	perform cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_QPCR_miRNA_DATA',0,stepCt,'Done');

	IF newJobFlag = 1
	THEN
		perform cz_end_audit (jobID, 'SUCCESS');
	END IF;
	
	return 0;
	
	EXCEPTION
	WHEN OTHERS THEN
		--Handle errors.
		perform cz_error_handler (jobID, procedureName, SQLSTATE, SQLERRM);
		--End Proc
		perform cz_end_audit (jobID, 'FAIL');
		return 16;
END;
$$;


ALTER FUNCTION tm_dataloader.i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, mirna_type character varying) OWNER TO weymouth;

--
-- Name: i2b2_process_rna_seq_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_code character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT NULL::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
DECLARE

/*************************************************************************
* This stored procedure is for ETL to load RNA sequencing
* Date:10/23/2013
******************************************************************/
--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint

  TrialID		varchar(100);
  RootNode		varchar(2000);
  root_level	integer;
  topNode		varchar(2000);
  topLevel		integer;
  tPath			varchar(2000);
  study_name	varchar(100);
  sourceCd		varchar(50);
  secureStudy	varchar(1);

  dataType		varchar(10);
  sqlText		varchar(1000);
  tText			varchar(1000);
  gplTitle		varchar(1000);
  pExists		bigint;
  partTbl   	bigint;
  partExists 	bigint;
  sampleCt		bigint;
  idxExists 	bigint;
  logBase		bigint;
  pCount		integer;
  sCount		integer;
  tablespaceName	varchar(200);
  v_bio_experiment_id	bigint;
   partitioniD	numeric(18,0);
  partitionName	varchar(100);
  partitionIndx	varchar(100);

    --Audit variables
  newJobFlag integer;
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  rowCt			numeric(18,0);
  errorNumber		character varying;
  errorMessage	character varying;
  rtnCd			integer;

	addNodes CURSOR FOR
	SELECT distinct t.leaf_node
          ,t.node_name
	from  wt_RNA_SEQ_nodes t
	where not exists
		 (select 1 from i2b2metadata.i2b2 x
		  where t.leaf_node = x.c_fullname);


--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  delNodes CURSOR FOR
  SELECT distinct c_fullname
  from  i2b2metadata.i2b2
  where c_fullname like topNode || '%'
    and substring(c_visualattributes from 2 for 1) = 'H';
    --and c_visualattributes like '_H_';

	uploadI2b2 CURSOR FOR
    select category_cd,display_value,display_label,display_unit from
    lt_src_rna_display_mapping;

BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);

	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;

	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\','g');
	select length(topNode)-length(replace(topNode,'\','')) into topLevel ;

	if coalesce(data_type::text, '') = '' then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;

	logBase := coalesce(log_base, 2);
	sourceCd := upper(coalesce(source_code,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  databaseName := current_schema();
	procedureName := 'I2B2_PROCESS_RNA_SEQ_DATA';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName, jobID) into jobId;
  END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_RNA_SEQ_data',0,stepCt,'Done') into rtnCd;
	--	Get count of records in lt_src_RNA_SEQ_subj_samp_map

	select count(*) into sCount
	from lt_src_RNA_SEQ_subj_samp_map;

	--	check if all subject_sample map records have a platform, If not, abort run

	select count(*) into pCount
	from lt_src_RNA_SEQ_subj_samp_map
	where coalesce(platform::text, '') = '';

	if pCount > 0 then
		select cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
	end if;

	--	check if all subject_sample map records have a tissue_type, If not, abort run

	select count(*) into pCount
	from lt_src_RNA_SEQ_subj_samp_map
	where coalesce(tissue_type::text, '') = '';

	if pCount > 0 then
		select cz_write_audit(jobId,databasename,procedurename,'Tissue Type data missing from one or more subject_sample mapping records',1,stepCt,'ERROR') into rtnCd;
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select CZ_END_AUDIT (JOBID,'FAIL') into rtnCd;
		return 162;
	end if;

	--	check if there are multiple platforms, if yes, then platform must be supplied in lt_src_RNA_SEQ_data

	select count(*) into pCount
	from (select sample_cd
		  from lt_src_RNA_SEQ_subj_samp_map
		  group by sample_cd
		  having count(distinct platform) > 1) as x;

	if pCount > 0 then
		select cz_write_audit(jobId,databasename,procedurename,'Multiple platforms for sample_cd in lt_src_RNA_SEQ_subj_samp_map',1,stepCt,'ERROR') into rtnCd;
		select CZ_ERROR_HANDLER(JOBID,PROCEDURENAME) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 164;
	end if;

	-- Get root_node from topNode

	select parse_nth_value(topNode, 2, '\') into RootNode ;

	select count(*) into pExists
	from i2b2metadata.table_access
	where c_name = rootNode;

	if pExists = 0 then
		perform i2b2_add_root_node(rootNode, jobId);
	end if;

	select c_hlevel into root_level
	from i2b2metadata.i2b2
	where c_name = RootNode;

	-- Get study name from topNode

	select parse_nth_value(topNode, topLevel, '\') into study_name ;

	--	Add any upper level nodes as needed

	tPath := REGEXP_REPLACE(replace(top_node,study_name,''),'(\\){2,}', '\', 'g');
	select length(tPath) - length(replace(tPath,'\','')) into pCount ;

	if pCount > 2 then
		perform i2b2_fill_in_tree(null, tPath, jobId);
	end if;

	--	uppercase study_id in lt_src_RNA_SEQ_subj_samp_map in case curator forgot
	begin
	update lt_src_RNA_SEQ_subj_samp_map
	set trial_name=upper(trial_name);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		-- select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	select count(*) into partExists
	from deapp.de_subject_sample_mapping sm
	where sm.trial_name = TrialId
	and coalesce(sm.source_cd,'STD') = sourceCd
	and sm.platform = 'RNA_AFFYMETRIX'
	and sm.partition_id is not null;

	if partExists = 0 then
		select nextval('deapp.seq_rna_partition_id') into partitionId;
	else
		select distinct partition_id into partitionId
		from deapp.de_subject_sample_mapping sm
		where sm.trial_name = TrialId
		and coalesce(sm.source_cd,'STD') = sourceCd
		and sm.platform = 'RNA_AFFYMETRIX';
	end if;

	partitionName := 'deapp.de_subject_rna_data_' || partitionId::text;
	partitionIndx := 'de_subject_rna_data_' || partitionId::text;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in lt_src_RNA_SEQ_subj_samp_map',rowCt,stepCt,'Done') into rtnCd;

	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd

	begin
	insert into i2b2demodata.patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select nextval('i2b2demodata.seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialId || ':' || coalesce(s.site_id,'') || ':' || s.subject_id,'(::){1,}', ':', 'g') as sourcesystem_cd
		 from lt_src_RNA_SEQ_subj_samp_map s
		 where (s.subject_id IS NOT NULL AND s.subject_id::text <> '')
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and not exists
			  (select 1 from i2b2demodata.patient_dimension x
			   where x.sourcesystem_cd =
				 regexp_replace(TrialID || ':' || coalesce(s.site_id, '') || ':' || s.subject_id,'(::){1,}', ':'))
		) as x;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',rowCt,stepCt,'Done') into rtnCd;

	perform i2b2_create_security_for_trial(TrialId, secureStudy, jobID);

	--	Delete existing observation_fact data, will be repopulated
	begin
	delete from i2b2demodata.observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from deapp.de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = 'RNA_AFFYMETRIX');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--	Cleanup any existing data in de_subject_sample_mapping.

	begin
	delete from deapp.DE_SUBJECT_SAMPLE_MAPPING
	where trial_name = TrialID
	  and coalesce(source_cd,'STD') = sourceCd
	  and platform = 'RNA_AFFYMETRIX'; --Making sure only RNA_sequencing data is deleted
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

--	truncate tmp node table

	EXECUTE('truncate table wt_RNA_SEQ_nodes');

--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
--	from wt_subject_RNA_sequencing_data

	EXECUTE('truncate table wt_RNA_SEQ_node_values');

	begin
	insert into wt_RNA_SEQ_node_values
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,''--g.title
    from lt_src_RNA_SEQ_subj_samp_map a
	where a.trial_name = TrialID
	  and a.source_cd = sourceCD;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP wt_RNA_SEQ_node_values',rowCt,stepCt,'Done') into rtnCd;

	begin
	insert into wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	category_cd,'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\','(\\){2,}', '\', 'g')
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  wt_RNA_SEQ_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_RNA_SEQ_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for platform node so platform concept can be populated
		begin
	insert into wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  wt_RNA_SEQ_node_values;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in wt_RNA_SEQ_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd
	begin
	insert into wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  wt_RNA_SEQ_node_values
	where category_cd like '%ATTR1%'
	  and (attribute_1 IS NOT NULL AND attribute_1::text <> '');
		   get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in wt_RNA_SEQ_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd
	begin
	insert into wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
		substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
		'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  wt_RNA_SEQ_node_values
	where category_cd like '%ATTR2%'
	  and (attribute_2 IS NOT NULL AND attribute_2::text <> '');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_RNA_SEQ_nodes',rowCt,stepCt,'Done') into rtnCd;

	--	insert for tissue_type node so sample_type_cd can be populated
	begin
	insert into wt_RNA_SEQ_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',coalesce(attribute_1,'')),'ATTR2',coalesce(attribute_2,'')),'TISSUETYPE',coalesce(tissue_type,'')),'+','\'),'_',' ') || '\',
	'(\\){2,}', '\', 'g')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  wt_RNA_SEQ_node_values
	where category_cd like '%TISSUETYPE%';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_RNA_SEQ_nodes',rowCt,stepCt,'Done') into rtnCd;

	begin
	update wt_RNA_SEQ_nodes
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\','')),'\');
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_RNA_SEQ_nodes',rowCt,stepCt,'Done') into rtnCd;

--	add leaf nodes for RNA_sequencing data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)
		begin
		perform i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId);
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;

		select cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;

		perform i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID);

	END LOOP;

	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
	begin
	update i2b2metadata.i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',rowCt,stepCt,'Done') into rtnCd;

--	update concept_cd for nodes, this is done to make the next insert easier
	begin
	update wt_RNA_SEQ_nodes t
	set concept_cd=(select c.concept_cd from i2b2demodata.concept_dimension c
	                where c.concept_path = t.leaf_node
				   )
    where exists
         (select 1 from i2b2demodata.concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and coalesce(t.concept_cd::text, '') = '';
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Update wt_RNA_SEQ_nodes with newly created concept_cds',rowCt,stepCt,'Done') into rtnCd;

  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_RNA_sequencing_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in wt_RNA_SEQ_nodes
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in wt_RNA_SEQ_nodes
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in wt_RNA_SEQ_nodes
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in wt_RNA_SEQ_nodes
  --PLATFORM        = RNA_sequencing_AFFYMETRIX - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in wt_RNA_SEQ_nodes
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_RNA_SEQ_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd

  --ASSAY_ID        = generated by trigger
	begin
	insert into deapp.de_subject_sample_mapping(
	partition_id
	,patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
    )
	select partitionId
		  ,t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,nextval('deapp.seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,'RNA_AFFYMETRIX' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || b.patient_num::text as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+RNA_SEQ+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from lt_src_RNA_SEQ_subj_samp_map a
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join i2b2demodata.patient_dimension b
		  on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':', 'g') = b.sourcesystem_cd
		inner join wt_RNA_SEQ_nodes ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'@') = coalesce(ln.attribute_1,'@')
			and coalesce(a.attribute_2,'@') = coalesce(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join wt_RNA_SEQ_nodes pn
			on a.platform = pn.platform
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(pn.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(pn.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'
		left outer join wt_RNA_SEQ_nodes ttp
			on a.tissue_type = ttp.tissue_type
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = coalesce(ttp.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(ttp.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'
		left outer join wt_RNA_SEQ_nodes a1
			on a.attribute_1 = a1.attribute_1
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a1.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a1.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'
		left outer join wt_RNA_SEQ_nodes a2
			on a.attribute_2 = a1.attribute_2
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a2.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a2.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'
		left outer join i2b2demodata.patient_dimension sid
			on regexp_replace(TrialID || ':' || coalesce(a.site_id,'') || ':' || a.subject_id,'(::){1,}', ':','g') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  (ln.concept_cd IS NOT NULL AND ln.concept_cd::text <> '')) as t;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

--	Insert records for patients and samples into observation_fact
	begin
	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,INSTANCE_NUM
    )
    select distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,1
    from  deapp.de_subject_sample_mapping m
    where m.trial_name = TrialID
	  and m.source_cd = sourceCD
      and m.platform = 'RNA_AFFYMETRIX';
	  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--	Insert sample facts
	begin
	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,INSTANCE_NUM
    )
    select distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,1
    from  deapp.de_subject_sample_mapping m
    where m.trial_name = TrialID
	  and m.source_cd = sourceCd
      and m.platform = 'RNA_AFFYMETRIX'
	  and m.patient_id != m.sample_id;
	  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',rowCt,stepCt,'Done') into rtnCd;

	--Update I2b2 for correct data type
    begin

     update i2b2metadata.i2b2 t
    set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
    where t.c_basecode in (select distinct x.concept_cd from wt_RNA_SEQ_nodes x);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
    select cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',rowCt,stepCt,'Done') into rtnCd;

 ---INSERT sample_dimension
	begin
      INSERT INTO I2B2DEMODATA.SAMPLE_DIMENSION(SAMPLE_CD)
         SELECT DISTINCT SAMPLE_CD FROM
           DEAPP.DE_SUBJECT_SAMPLE_MAPPING WHERE SAMPLE_CD NOT IN (SELECT SAMPLE_CD FROM I2B2DEMODATA.SAMPLE_DIMENSION) ;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
       stepCt := stepCt + 1;
    select cz_write_audit(jobId,databaseName,procedureName,'insert distinct sample_cd in sample_dimension from de_subject_sample_mapping',rowCt,stepCt,'Done') into rtnCd;

    ---- update c_metedataxml in i2b2
    begin
       for ul in uploadI2b2
        loop
     update i2b2metadata.i2b2 n
    SET c_columndatatype = 'T',
      --Static XML String
        c_metadataxml =  ('<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue>
                <HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue>
                <LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue>
                <EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion>
                <UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits>
                <ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor>
                </ConvertingUnits></UnitValues><Analysis><Enums /><Counts />
                <New /></Analysis>'||(select xmlelement(name "SeriesMeta",xmlforest(m.display_value as "Value",m.display_unit as "Unit",m.display_label as "DisplayName")) as hi
      from lt_src_rna_display_mapping m where m.category_cd=ul.category_cd)||
                '</ValueMetadata>') where n.c_fullname=(select leaf_node from wt_RNA_SEQ_nodes where category_cd=ul.category_cd and leaf_node=n.c_fullname);

                end loop;
         get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
    select cz_write_audit(jobId,databaseName,procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

    --UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	begin
    update i2b2metadata.i2b2 a
    set c_visualattributes = 'LAH'
    where a.c_basecode in (select distinct x.concept_code from deapp.de_subject_sample_mapping x
                           where x.trial_name = TrialId
                             and x.platform = 'RNA_AFFYMETRIX'
                             and x.concept_code is not null);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;

    stepCt := stepCt + 1;
    select cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

	begin
        update i2b2metadata.i2b2 a
    set c_visualattributes='FAS'
        where a.c_fullname = substr(topNode,1,instr(topNode,'\',1,3));
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
    select cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for study node in I2B2METADATA i2b2',rowCt,stepCt,'Done') into rtnCd;

	begin
   insert into probeset_deapp
   (
   probeset,
   platform
   )select distinct s.probeset
               ,m.platform
            from lt_src_rna_seq_data s,
                 lt_src_RNA_SEQ_subj_samp_map m
                 where s.trial_name=m.trial_name
                   and not exists
		 (select 1 from probeset_deapp x
		  where m.platform = x.platform
		    and s.probeset = x.probeset);
    get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
    stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert new probesets into probeset_deapp',rowCt,stepCt,'Done') into rtnCd;

  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for RNA_sequencing data
	begin
    perform i2b2_create_concept_counts(topNode ,jobID );
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',rowCt,stepCt,'Done') into rtnCd;

	--	delete each node that is hidden
	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time
		begin
		perform i2b2_delete_1_node(r_delNodes.c_fullname);
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;

		select cz_write_audit(jobId,databaseName,procedureName,tText,rowCt,stepCt,'Done') into rtnCd;

	END LOOP;

  --Reload Security: Inserts one record for every I2B2 record into the security table
	begin
    perform i2b2_load_security_data(jobId);
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Load security data',rowCt,stepCt,'Done') into rtnCd;

--	tag data with probeset_id from reference.probeset_deapp

	EXECUTE ('truncate table wt_subject_rna_probeset');

	--	note: assay_id represents a unique subject/site/sample
	begin
	insert into wt_subject_rna_probeset
	(probeset_id
--	,expr_id
	,intensity_value
	,patient_id
--	,sample_cd
--	,subject_id
	,trial_name
	,assay_id
	) select md.probeset
--		  ,sd.sample_cd
		 , avg(md.intensity_value::numeric) as intensity_value
		  ,sd.patient_id
--		  ,sd.sample_cd
--		  ,sd.subject_id
		 ,TrialId as trial_name
		  ,sd.assay_id
	from deapp.de_subject_sample_mapping sd
		,lt_src_RNA_SEQ_data md
		,probeset_deapp gs
	where sd.sample_cd = md.expr_id
	  and sd.platform = 'RNA_AFFYMETRIX'
	  and sd.trial_name = TrialId
	  and sd.source_cd = sourceCd
	and md.probeset = gs.probeset
	  and (CASE WHEN dataType = 'R' THEN sign(md.intensity_value::numeric) ELSE 1 END) = 1  --	take only >0 for dataType R
	  and sd.subject_id in (select subject_id from lt_src_rna_seq_subj_samp_map)
	group by md.probeset
		  ,sd.patient_id
		  ,sd.assay_id;
get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
	pExists := rowCt;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_rna_probeset',rowCt,stepCt,'Done') into rtnCd;

	--	insert into de_subject_rna_data when dataType is T (transformed)

	if dataType = 'T' then
	begin
		insert into deapp.de_subject_rna_data
		(trial_source
		,probeset_id
		,assay_id
		,patient_id
		,trial_name
		,zscore
		)
		select TrialId || ':' || sourceCd
			  ,probeset_id
			  ,assay_id
			  ,patient_id
			  ,trial_name
			  ,case when intensity_value < -2.5
			        then -2.5
					when intensity_value > 2.5
					then 2.5
					else intensity_value
			   end as zscore
		from wt_subject_rna_probeset
		where trial_name = TrialID;
		get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Insert transformed into DEAPP de_subject_rna_data',rowCt,stepCt,'Done') into rtnCd;

	else

	--	Calculate ZScores and insert data into de_subject_rna_data.  The 'L' parameter indicates that the RNA_sequencing  data will be selected from
	--	wt_subject_RNA_seq_probeset as part of a Load.

		if dataType = 'R' or dataType = 'L' then
			begin
			perform I2B2_RNA_SEQ_ZSCORE_CALC(TrialID, partitionName, partitionindx,partitioniD,'L',jobId,dataType,logBase,sourceCD);
			get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return -16;
	end;
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',rowCt,stepCt,'Done') into rtnCd;
		end if;

	end if;

    ---Cleanup OVERALL JOB if this proc is being run standalone

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_RNA_SEQ_data',0,stepCt,'Done') into rtnCd;

	IF newJobFlag = 1
	THEN
		select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 0;
END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base numeric, secure_study character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_process_snp_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_process_snp_data(trial_id character varying, top_node character varying, data_type character varying DEFAULT 'R'::character varying, source_cd character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;

	TrialID			varchar(100);
	sourceCd		varchar(50);

	sqlText			varchar(1000);
	pCount			integer;
	res numeric;
BEGIN
	TrialID := upper(trial_id);

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	databaseName := current_schema();
	procedureName := 'I2B2_PROCESS_SNP_DATA';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_snp_data',0,stepCt,'Done') into rtnCd;

	sourceCd := upper(coalesce(source_cd,'STD'));

	select I2B2_LOAD_SAMPLES(trial_id, top_node, 'SNP', sourceCd, secure_study, jobID) into res;
	if res < 0 then
	  return res;
	end if;

	  -- Load SNP data from temp tables
  delete from deapp.de_snp_calls_by_gsm
  where patient_num in (
    select sm.omic_patient_id
    from deapp.de_subject_sample_mapping sm, lt_src_mrna_subj_samp_map tsm
    where sm.trial_name = TrialID
      and sm.source_cd = sourceCD
		  and coalesce(sm.site_id, '') = coalesce(tsm.site_id, '')
		  and sm.subject_id = tsm.subject_id and sm.sample_cd = tsm.sample_cd
		  and sm.platform = 'SNP'
  );

  get diagnostics rowCt := ROW_COUNT;
  stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Cleanup de_snp_calls_by_gsm',rowCt,stepCt,'Done') into rtnCd;

  -- Load SNP calls
  insert into deapp.de_snp_calls_by_gsm
  (gsm_num, patient_num, snp_name, snp_calls)
  select sm.sample_cd as gsm_num, sm.omic_patient_id as patient_num, tmp.snp_name as snp_name, tmp.snp_calls as snp_calls
  from lt_snp_calls_by_gsm tmp
  inner join deapp.de_subject_sample_mapping sm
  on sm.sample_cd = tmp.gsm_num
  where sm.trial_name = TrialID;

  get diagnostics rowCt := ROW_COUNT;
  stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Fill de_snp_calls_by_gsm',rowCt,stepCt,'Done') into rtnCd;

  delete from deapp.de_snp_copy_number
  where patient_num in (
    select sm.omic_patient_id
    from deapp.de_subject_sample_mapping sm, lt_src_mrna_subj_samp_map tsm
    where sm.trial_name = TrialID
      and sm.source_cd = sourceCD
		  and coalesce(sm.site_id, '') = coalesce(tsm.site_id, '')
		  and sm.subject_id = tsm.subject_id and sm.sample_cd = tsm.sample_cd
		  and sm.platform = 'SNP'
  );

  get diagnostics rowCt := ROW_COUNT;
  stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Cleanup de_snp_copy_number',rowCt,stepCt,'Done') into rtnCd;

  insert into deapp.de_snp_copy_number
  (patient_num, snp_name, chrom, chrom_pos, copy_number)
  select sm.omic_patient_id as patient_num, tmp.snp_name as snp_name, tmp.chrom, tmp.chrom_pos, power(2::double precision, tmp.copy_number::double precision)
  from lt_snp_copy_number tmp
  inner join deapp.de_subject_sample_mapping sm
  on sm.sample_cd = tmp.gsm_num
  where sm.trial_name = TrialID;

  get diagnostics rowCt := ROW_COUNT;
  stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Fill de_snp_copy_number',rowCt,stepCt,'Done') into rtnCd;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_snp_data',0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_process_snp_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_process_vcf_data(character varying, character varying, character varying, character varying, numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_process_vcf_data(trial_id character varying, top_node character varying, source_cd character varying DEFAULT 'STD'::character varying, secure_study character varying DEFAULT 'N'::character varying, currentjobid numeric DEFAULT (-1)) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
Declare

	--Audit variables
	newJobFlag		integer;
	databaseName 	VARCHAR(100);
	procedureName 	VARCHAR(100);
	jobID 			numeric(18,0);
	stepCt 			numeric(18,0);
	rowCt			numeric(18,0);
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;

	TrialID			varchar(100);
	sourceCd		varchar(50);

	res numeric;
BEGIN
	TrialID := upper(trial_id);

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;
	databaseName := current_schema();
	procedureName := 'i2b2_process_vcf_data';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it

	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName) into jobID;
	END IF;

	stepCt := 0;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_vcf_data',0,stepCt,'Done') into rtnCd;

	sourceCd := upper(coalesce(source_cd,'STD'));

	select I2B2_LOAD_SAMPLES(trial_id, top_node, 'VCF', sourceCd, secure_study, jobID) into res;
	if res < 0 then
	  return res;
	end if;

	update deapp.de_variant_subject_summary v
	set assay_id = sm.assay_id
	from deapp.de_subject_sample_mapping sm
	where sm.platform = 'VCF' and sm.trial_name = TrialID and sm.sample_cd = v.subject_id;

  get diagnostics rowCt := ROW_COUNT;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Associate deapp.de_subject_sample_mapping with deapp.de_variant_subject_summary',rowCt,stepCt,'Done') into rtnCd;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_vcf_data',0,stepCt,'Done') into rtnCd;

	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
	END IF;

	return 1;

END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_process_vcf_data(trial_id character varying, top_node character varying, source_cd character varying, secure_study character varying, currentjobid numeric) OWNER TO postgres;

--
-- Name: i2b2_rbm_zscore_calc_new(character varying, character varying, character varying, numeric, character varying, bigint, character varying, bigint, character varying); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, run_type character varying DEFAULT 'L'::character varying, currentjobid bigint DEFAULT 0, data_type character varying DEFAULT 'R'::character varying, log_base bigint DEFAULT 2, source_cd character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
DECLARE

/*************************************************************************
This Stored Procedure is used in ETL load RBM data
Date:12/04/2013
******************************************************************/

  TrialID varchar(50);
  sourceCD	varchar(50);
  sqlText varchar(2000);
  runType varchar(10);
  dataType varchar(10);
  partitionName varchar(200);
  partitionindx varchar(200);
  stgTrial varchar(50);
  idxExists bigint;
  pExists	bigint;
  nbrRecs bigint;
  logBase bigint;
   
  --Audit variables
  newJobFlag integer;
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  rowCt			bigint;
  rtnCd			integer;  
  errorNumber		character varying;
  errorMessage	character varying;

BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	
	partitionindx := partition_indx;
	partitionName := partition_name;
	  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

	databaseName := current_schema();
	procedureName := 'i2b2_rbm_zscore_calc_new';

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    select cz_start_audit (procedureName, databaseName, jobID) into rtnCd;
  END IF;
   
  stepCt := 0;
  
  	select count(*) into pExists
	from information_schema.tables
	where table_name = partitionindx;

	if pExists = 0 then
	sqlText := 'create table ' || partitionName || ' ( constraint rbm_' || partitionId::text || '_check check ( partition_id = ' || partitionId::text ||
	')) inherits (deapp.de_subject_rbm_data)';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create partition ' || partitionName,1,stepCt,'Done') into rtnCd;
	else
	sqlText := 'drop index if exists ' || partitionIndx || '_idx1';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx2';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx3';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := 'drop index if exists ' || partitionIndx || '_idx4';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on ' || partitionName,1,stepCt,'Done') into rtnCd;
	sqlText := 'truncate table ' || partitionName;
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Truncate ' || partitionName,1,stepCt,'Done') into rtnCd;
	end if;
  
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done') into rtnCd;
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		select cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting'
,0,stepCt,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return;
	end if;
  
--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_mrna_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from WT_SUBJECT_RBM_PROBESET;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in WT_SUBJECT_RBM_PROBESET - procedure exiting'
,0,stepCt,'Done') into rtnCd;
			select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			select cz_end_audit (jobId,'FAIL') into rtnCd;
			return;
		end if;
	end if;

	--remove Reload processing
--	For Reload, make sure that the TrialId passed as parameter has data in de_subject_rbm_data
--	If not, raise exception

	if runType = 'R' then 
		select count(*) into idxExists
		from deapp.de_subject_rbm_data
		where trial_name = TrialId;
		
		if idxExists = 0 then
			stepCt := stepCt + 1;
			select cz_write_audit(jobId,databaseName,procedureName,'No data for TrialId in de_subject_rbm_data - procedure exiting'
,0,stepCt,'Done') into rtnCd;
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return;
		end if;
	end if;

   
--	truncate tmp tables

	EXECUTE('truncate table wt_subject_rbm_logs');
	EXECUTE('truncate table wt_subject_rbm_calcs');
	EXECUTE('truncate table wt_subject_rbm_med');

	EXECUTE('drop index if exists wt_subject_rbm_logs_i1');
		
	EXECUTE('drop index if exists wt_subject_rbm_calcs_i1');
	
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done') into rtnCd;
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value

	begin
		if dataType = 'L' then
			insert into wt_subject_rbm_logs
				(probeset_id
				,intensity_value
				,assay_id
				,log_intensity
				,patient_id
				)
				select probeset
					  ,intensity_value  
					  ,assay_id 
					  ,intensity_value
					  ,patient_id
				from wt_subject_rbm_probeset
				where trial_name = TrialId;
			   
			--end if;
		else	
			insert into wt_subject_rbm_logs
				(probeset_id
				,intensity_value
				,assay_id
				,log_intensity
				,patient_id
				)
				select probeset
					  ,intensity_value 
					  ,assay_id 
					  ,CASE WHEN intensity_value <= 0 THEN log(2,(intensity_value + 0.001)) ELSE log(2,intensity_value) END
					  ,patient_id
				from wt_subject_rbm_probeset
				where trial_name = TrialId;
		end if;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_rbm_logs',rowCt,stepCt,'Done') into rtnCd;
    
	EXECUTE('create index wt_subject_rbm_logs_i1 on wt_subject_rbm_logs (trial_name, probeset_id) tablespace "indx"');
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_rbm_logs',0,stepCt,'Done') into rtnCd;
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe
	begin
		insert into wt_subject_rbm_calcs
		(trial_name
		,probeset_id
		,mean_intensity
		,median_intensity
		,stddev_intensity
		)
		select d.trial_name 
			  ,d.probeset_id
			  ,avg(log_intensity)
			  ,median(log_intensity)
			  ,stddev(log_intensity)
		from wt_subject_rbm_logs d
		group by d.trial_name 
				,d.probeset_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ wt_subject_rbm_calcs',rowCt,stepCt,'Done') into rtnCd;


	EXECUTE('create index wt_subject_rbm_calcs_i1 on wt_subject_rbm_calcs (trial_name, probeset_id) tablespace "indx"');
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_rbm_calcs',0,stepCt,'Done') into rtnCd;
		
-- calculate zscore
	begin
		insert into wt_subject_rbm_med
		(probeset_id
		,intensity_value
		,log_intensity
		,assay_id
		,mean_intensity
		,stddev_intensity
		,median_intensity
		,zscore
		,patient_id
		)
		select d.probeset_id
			  ,d.intensity_value 
			  ,d.log_intensity 
			  ,d.assay_id  
			  ,c.mean_intensity 
			  ,c.stddev_intensity 
			  ,c.median_intensity 
			  ,(CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END)
			  ,d.patient_id
		from wt_subject_rbm_logs d
			,wt_subject_rbm_calcs c
		where d.probeset_id = c.probeset_id;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;
	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ wt_subject_rbm_med',rowCt,stepCt,'Done') into rtnCd;

	
	-- insert into de_subject_rbm_data when dataType is T (transformed)

  begin
	sqlText := 'insert into ' || partitionName || 
	'(partition_id, trial_name, antigen_name, patient_id, gene_symbol, gene_id, assay_id ' ||
        ',concept_cd, value, normalized_value, unit, zscore, id) ' ||
	'select ' || partitioniD::text || ', ''' || TrialId || '''' ||
              ',(CASE WHEN position(''('' in m.probeset_id) <> 0 THEN trim(substr(m.probeset_id,1,instr(m.probeset_id,''('')-1)) ELSE m.probeset_id END)' ||
              ',m.patient_id ' ||
              ',a.gene_symbol  ' ||
              ',a.gene_id::integer  ' ||
              ',m.assay_id ' ||
              ',d.concept_code ' ||
              ',m.intensity_value ' ||
              ',round(case when ''' || dataType || ''' = ''R'' then m.intensity_value::numeric ' ||
				'when ''' || dataType || ''' = ''L''  ' ||
				'then case when ''' || logBase || ''' = -1 then null else power( ''' || logBase || ''' , m.log_intensity)::numeric end ' ||
				'else null ' ||
				'end,4) as normalized_value ' ||
              ',(CASE WHEN position(''('' in m.probeset_id) <> 0 THEN trim(substr(m.probeset_id ,instr(m.probeset_id ,''('',-1,1),length(m.probeset_id ))) ELSE m.probeset_id END) ' ||
              ',(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE m.zscore END) ' ||
			  ',nextval(''deapp.RBM_ANNOTATION_ID'') '||
	'from wt_subject_rbm_med m ' ||
        ',wt_subject_rbm_probeset p ' ||
        ',deapp.DE_RBM_ANNOTATION a ' ||
        ',deapp.de_subject_sample_mapping d ' ||
        'where  ' ||
        '(CASE WHEN position(''('' in p.probeset) <> 0 THEN trim(substr(p.probeset,1,instr(p.probeset,''('')-1)) ELSE p.probeset END) = trim(a.antigen_name)' ||
      'and   d.subject_id=p.subject_id ' ||
        'and p.platform=a.gpl_id ' ||
        'and m.assay_id=p.assay_id ' ||
        'and d.gpl_id=p.platform ' ||
        'and d.patient_id=p.patient_id ' ||
        'and d.concept_code in (select concept_cd from  i2b2demodata.concept_dimension where concept_cd=d.concept_code) ' ||
        'and d.trial_name=''' || TrialId || '''' ||
        'and p.patient_id=m.patient_id ' ||
        'and p.probeset=m.probeset_id ' ;
		
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Inserted data into ' || partitionName,rowCt,stepCt,'Done') into rtnCd;

	begin
		-- FIXME: Drop constraint (and don't recover, because it don't work with inherited tables)
    ALTER TABLE deapp.de_rbm_data_annotation_join DROP CONSTRAINT IF EXISTS de_rbm_data_ann_jn_data_id_fk;

	insert into DEAPP.DE_RBM_DATA_ANNOTATION_JOIN
	select d.id, ann.id from deapp.de_subject_rbm_data d
	inner join deapp.de_rbm_annotation ann on ann.antigen_name = d.antigen_name
	inner join deapp.de_subject_sample_mapping ssm on ssm.assay_id = d.assay_id and ann.gpl_id = ssm.gpl_id
	where not exists( select * from deapp.de_rbm_data_annotation_join j where j.data_id = d.id AND j.annotation_id = ann.id );
  get diagnostics rowCt := ROW_COUNT;
	exception
	when others then
		errorNumber := SQLSTATE;
		errorMessage := SQLERRM;
		--Handle errors.
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		--End Proc
		select cz_end_audit (jobID, 'FAIL') into rtnCd;
		return;
	end;

	-- create indexes on partition
	sqlText := ' create index ' || partitionIndx || '_idx1 on ' || partitionName || ' using btree (partition_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx2 on ' || partitionName || ' using btree (assay_id) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx3 on ' || partitionName || ' using btree (antigen_name) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
	sqlText := ' create index ' || partitionIndx || '_idx4 on ' || partitionName || ' using btree (assay_id, antigen_name) tablespace indx';
	raise notice 'sqlText= %', sqlText;
	execute sqlText;
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN 
    select cz_end_audit (jobID, 'SUCCESS') into rtnCd; 
  END IF;

END;
 
$$;


ALTER FUNCTION tm_dataloader.i2b2_rbm_zscore_calc_new(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) OWNER TO postgres;

--
-- Name: i2b2_rna_seq_annotation(numeric); Type: FUNCTION; Schema: tm_dataloader; Owner: postgres
--

CREATE FUNCTION i2b2_rna_seq_annotation(currentjobid numeric DEFAULT NULL::numeric) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO tm_dataloader, tm_cz, tm_lz, tm_wz, i2b2demodata, i2b2metadata, deapp, pg_temp
    AS $$
DECLARE

	gpl_rtn bigint;
	newJobFlag numeric(1);
	databaseName character varying(100);
	procedureName character varying(100);
	jobID bigint;
	errorNumber		character varying;
	errorMessage	character varying;
	rtnCd			integer;
	rowCt			numeric(18,0);
	stepCt bigint;
BEGIN

	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	databaseName := current_schema();
	procedureName := 'I2B2_RNA_SEQ_ANNOTATION';

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(coalesce(jobID::text, '') = '' or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		select cz_start_audit (procedureName, databaseName, jobID) into jobId;
	END IF;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_rna_seq_annotation',0,stepCt,'Done') into rtnCd;

	select count(platform) into gpl_rtn from deapp.de_gpl_info where marker_type='RNASEQ' and (platform IS NOT NULL AND platform::text <> '');
	if gpl_rtn=0 then
		select cz_write_audit(jobId,databasename,procedurename,'Platform data missing from DEAPP.DE_GPL_INFO',1,stepCt,'ERROR') into rtnCd;
		select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
		select cz_end_audit (jobId,'FAIL') into rtnCd;
		return 161;
	end if;

	begin
		insert into deapp.DE_RNASEQ_ANNOTATION
		(
			GPL_ID
			,TRANSCRIPT_ID
			,GENE_SYMBOL
			,GENE_ID
			,ORGANISM
			,PROBESET_ID
		)
			select g.platform
				,a.transcript_id
				,a.gene_symbol
				,b.bio_marker_id
				,a.organism
				,pd.probeset_id
			from LT_RNASEQ_ANNOTATION a
				,(select platform from deapp.de_gpl_info where marker_type='RNASEQ') as g
				,biomart.bio_marker b
				,probeset_deapp pd
			where b.bio_marker_name=a.gene_symbol
						and a.transcript_id =pd.probeset;
		get diagnostics rowCt := ROW_COUNT;
		exception
		when others then
			errorNumber := SQLSTATE;
			errorMessage := SQLERRM;
			--Handle errors.
			select cz_error_handler (jobID, procedureName, errorNumber, errorMessage) into rtnCd;
			--End Proc
			select cz_end_audit (jobID, 'FAIL') into rtnCd;
			return -16;
	end;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'Insert new probesets into antigen_deapp',rowCt,stepCt,'Done') into rtnCd;

	stepCt := stepCt + 1;
	select cz_write_audit(jobId,databaseName,procedureName,'End i2b2_rna_seq_annotation',0,stepCt,'Done') into rtnCd;

       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    select cz_end_audit (jobID, 'SUCCESS') into rtnCd;
  END IF;

  return 0;

END;

$$;


ALTER FUNCTION tm_dataloader.i2b2_rna_seq_annotation(currentjobid numeric) OWNER TO postgres;

SET search_path = tm_lz, pg_catalog;

--
-- Name: i2b2_process_qpcr_mirna_data(character varying, character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: FUNCTION; Schema: tm_lz; Owner: tm_lz
--

CREATE FUNCTION i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, mirna_type character varying, data_type character varying DEFAULT 'R'::character varying, source_cd character varying DEFAULT 'STD'::character varying, log_base numeric DEFAULT 2, secure_study character varying DEFAULT NULL::character varying, currentjobid numeric DEFAULT (-1), OUT rtn_code numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*************************************************************************

* This store procedure is for ETL for Sanofi to load  qpcr or seq miRNA data
* Date: 12/05/2013

******************************************************************/









--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint	

  TrialID		varchar(100);
  RootNode		varchar(2000);
  root_level	integer;
  topNode		varchar(2000);
  topLevel		integer;
  tPath			varchar(2000);
  study_name	varchar(100);
  sourceCd		varchar(50);
  secureStudy	varchar(1);

  dataType		varchar(10);
  sqlText		varchar(1000);
  tText			varchar(1000);
  gplTitle		varchar(1000);
  pExists		bigint;
  partTbl   	bigint;
  partExists 	bigint;
  sampleCt		bigint;
  idxExists 	bigint;
  logBase		bigint;
  pCount		integer;
  sCount		integer;
  tablespaceName	varchar(200);
  v_bio_experiment_id	bigint;
  mirnaType varchar(15);
 -- mirnaPlatform varchar2(20);
  
    --Audit variables
  newJobFlag integer(1);
  databaseName varchar(100);
  procedureName varchar(100);
  jobID bigint;
  stepCt bigint;
  
  --unmapped_patients exception;
  missing_platform	exception;
  missing_tissue	EXCEPTION;
  unmapped_platform exception;
  multiple_platform	exception;
  no_probeset_recs	exception;
 -- missing_mirna_type	EXCEPTION;
  

  
	addNodes CURSOR FOR
	SELECT distinct t.leaf_node
          ,t.node_name
	from  wt_qpcr_mirna_nodes t
	where not exists
		 (select 1 from i2b2 x
		  where t.leaf_node = x.c_fullname);

 
--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  delNodes CURSOR FOR
  SELECT distinct c_fullname 
  from  i2b2
  where c_fullname like topNode || '%'
    and substring(c_visualattributes from 2 for 1) = 'H';
    --and c_visualattributes like '_H_';



BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	mirnaType:=upper(mirna_type);
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\');	
	PERFORM length(topNode)-length(replace(topNode,'\','')) into topLevel ;
	
	if coalesce(data_type::text, '') = '' then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;

	---check for mirna_type is not null if it is null raise an exception 
	/*if mirna_type is null then
	raise missing_mirna_type;
	end if;
	*/
	logBase := log_base;
	sourceCd := upper(coalesce(source_cd,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  PERFORM sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName ;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(coalesce(jobID::text, '') = '' or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_qpcr_mirna_data',0,stepCt,'Done');
	
	--	Get count of records in LT_SRC_MIRNA_SUBJ_SAMP_MAP
	
	select count(*) into sCount
	from LT_SRC_MIRNA_SUBJ_SAMP_MAP;
	
	--	check if all subject_sample map records have a platform, If not, abort run
	
	select count(*) into pCount
	from LT_SRC_MIRNA_SUBJ_SAMP_MAP
	where coalesce(platform::text, '') = '';
	
	if pCount > 0 then
		raise missing_platform;
	end if;
  
  	--	check if platform exists in de_qpcr_mirna_annotation .  If not, abort run.
	
	select count(*) into pCount
	from LT_QPCR_MIRNA_ANNOTATION
	where ID_REF in (select distinct m.platform from LT_SRC_MIRNA_SUBJ_SAMP_MAP m);
	
	--if PCOUNT = 0 then
		--RAISE UNMAPPED_platform;
	--end if;--mod
	
	select count(*) into pCount
	from DE_gpl_info
	where platform in (select distinct m.platform from LT_SRC_MIRNA_SUBJ_SAMP_MAP m);
	
	/*if PCOUNT = 0 then
		RAISE UNMAPPED_platform;
	end if;*/
		
	--	check if all subject_sample map records have a tissue_type, If not, abort run
	
	select count(*) into pCount
	from LT_SRC_MIRNA_SUBJ_SAMP_MAP
	where coalesce(tissue_type::text, '') = '';
	
	if pCount > 0 then
		raise missing_tissue;
	end if;
	
	--	check if there are multiple platforms, if yes, then platform must be supplied in LT_SRC_QPCR_MIRNA_DATA
	
	select count(*) into pCount
	from (select sample_cd
		  from LT_SRC_MIRNA_SUBJ_SAMP_MAP
		  group by sample_cd
		  GROUP BY xd.concept_Cd
		  having Max(xf.valtype_cd) = 'N');
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName, HAVING count(distinct platform) > 1);
	
	if pCount > 0 then
		raise multiple_platform;
	end if;
		
	-- Get root_node from topNode
  
	PERFORM parse_nth_value(topNode, 2, '\') into RootNode ;
	
	select count(*) into pExists
	from table_access
	where c_name = rootNode;
	
	if pExists = 0 then
		i2b2_add_root_node(rootNode, jobId);
	end if;
	
	select c_hlevel into root_level
	from i2b2
	where c_name = RootNode;
	
	-- Get study name from topNode
  
	PERFORM parse_nth_value(topNode, topLevel, '\') into study_name ;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,null),'(\\){2,}', '\');
	PERFORM length(tPath) - length(replace(tPath,'\',null)) into pCount ;

	if pCount > 2 then
		i2b2_fill_in_tree(null, tPath, jobId);
	end if;

	--	uppercase study_id in lt_src_mirna_subj_samp_map in case curator forgot
	
	update LT_SRC_MIRNA_SUBJ_SAMP_MAP
	set trial_name=upper(trial_name);
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in LT_SRC_MIRNA_SUBJ_SAMP_MAP',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd
	
	insert into patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    PERFORM nextval('seq_patient_num')
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,LOCALTIMESTAMP
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || s.site_id || ':' || s.subject_id,'(::){1,}', ':') as sourcesystem_cd
		 from LT_SRC_MIRNA_SUBJ_SAMP_MAP s
		     ,de_gpl_info g
		 where (s.subject_id IS NOT NULL AND s.subject_id::text <> '')
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = mirnaType
		   and not exists
			  (select 1 from patient_dimension x
			   where x.sourcesystem_cd = 
				 regexp_replace(TrialID || ':' || s.site_id || ':' || s.subject_id,'(::){1,}', ':'))
		) x;
	
	pCount := SQL%ROWCOUNT;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',pCount,stepCt,'Done');
	commit;
	
	i2b2_create_security_for_trial(TrialId, secureStudy, jobID);

	--	Delete existing observation_fact data, will be repopulated
	
	delete from observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and coalesce(x.source_cd,'STD') = sourceCD
		    and x.platform = mirna_type);

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	select count(*) into pExists
	from all_tables
	where table_name = 'DE_SUBJECT_MIRNA_DATA'
	  and partitioned = 'YES';
	
	if pExists = 0 then
		--	dataset is not partitioned so must delete
		
		delete from de_subject_mirna_data
		where trial_source = TrialId || ':' || sourceCd;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete data from de_subject_mirna_data',SQL%ROWCOUNT,stepCt,'Done');
		commit;
	else
		--	Create partition in de_subject_MIRNA_data if it doesn't exist else truncate partition
			
		select count(*)
			into pExists
			from all_tab_partitions
			where table_name = 'DE_SUBJECT_MIRNA_DATA'
			  and partition_name = TrialId || ':' || sourceCd;
			
		if pExists = 0 then
					
			--	needed to add partition to de_subject_MIRNA_data

			sqlText := 'alter table deapp.de_subject_mirna_data add PARTITION "' || TrialID || ':' || sourceCd || '"  VALUES (' || '''' || TrialID || ':' || sourceCd || '''' || ') ' ||
						   'NOLOGGING COMPRESS TABLESPACE "TRANSMART" ';
			EXECUTE(sqlText);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Adding partition to de_subject_mirna_data',0,stepCt,'Done');
				
		else
			sqlText := 'alter table deapp.de_subject_mirna_data truncate partition "' || TrialID || ':' || sourceCd || '"';
			EXECUTE(sqlText);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in de_subject_mirna_data',0,stepCt,'Done');
		end if;
		
	end if;
		
	--	Cleanup any existing data in de_subject_sample_mapping.  

	delete from DE_SUBJECT_SAMPLE_MAPPING 
	where trial_name = TrialID 
	  and coalesce(source_cd,'STD') = sourceCd
	  and platform = mirna_type; --Making sure only miRNA data is deleted
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');

	commit;

--	truncate tmp node table

	EXECUTE('truncate table tm_wz.WT_QPCR_MIRNA_NODES');
	
--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
--	from wt_subject_mirna_data

	EXECUTE('truncate table tm_wz.WT_QPCR_MIRNA_NODE_VALUES');
	
	insert into WT_QPCR_MIRNA_NODE_VALUES
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	PERFORM distinct a.category_cd
				   ,coalesce(a.platform,'GPL570')
				   ,coalesce(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from LT_SRC_MIRNA_SUBJ_SAMP_MAP a
	    ,de_gpl_info g 
	where a.trial_name = TrialID
	  and coalesce(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = mirnaType
	  and g.title = (select min(x.title) from de_gpl_info x where coalesce(a.platform,'GPL570') = x.platform)
      -- and upper(g.organism) = 'HOMO SAPIENS'
	  ;
        
	--  and decode(dataType,'R',sign(a.intensity_value),1) = 1;	--	take all values when dataType T, only >0 for dataType R
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP wt_qpcr_mirna_node_values',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	PERFORM distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       category_cd,'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\','(\\){2,}', '\') 
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  WT_QPCR_MIRNA_NODE_VALUES;
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_mirna_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert for platform node so platform concept can be populated
	
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	PERFORM distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  WT_QPCR_MIRNA_NODE_VALUES;
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in wt_qpcr_mirna_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd
	
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	PERFORM distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  WT_QPCR_MIRNA_NODE_VALUES
	where category_cd like '%ATTR1%'
	  and (attribute_1 IS NOT NULL AND attribute_1::text <> '');
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in WT_QPCR_MIRNA_NODES',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd
	
	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	PERFORM distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  WT_QPCR_MIRNA_NODE_VALUES
	where category_cd like '%ATTR2%'
	  and (attribute_2 IS NOT NULL AND attribute_2::text <> '');
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in WT_QPCR_MIRNA_NODES',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert for tissue_type node so sample_type_cd can be populated

	insert into WT_QPCR_MIRNA_NODES
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	PERFORM distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  WT_QPCR_MIRNA_NODE_VALUES
	where category_cd like '%TISSUETYPE%';
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_qpcr_mirna_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
				
	update WT_QPCR_MIRNA_NODES
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\',null)),'\');
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_mirna_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
		
--	add leaf nodes for miRNA data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)

		i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId);
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;
		
		cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');
		
		i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID);

	END LOOP;  
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
	
	update i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	  	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
		
--	update concept_cd for nodes, this is done to make the next insert easier
	
	update WT_QPCR_MIRNA_NODES t
	set concept_cd=(select c.concept_cd from concept_dimension c
	                where c.concept_path = t.leaf_node LIMIT 1 OFFSET 1
				   )
    where exists
         (select 1 from concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and coalesce(t.concept_cd::text, '') = '';
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update WT_QPCR_MIRNA_NODES with newly created concept_cds',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	 
	
  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_mirna_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in wt_mirna_nodes
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in wt_mirna_nodes
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in wt_mirna_nodes
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in wt_mirna_nodes
  --PLATFORM        = MIRNA_AFFYMETRIX - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in wt_qpcr_mirna_nodes
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_mirna_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd
  
  --ASSAY_ID        = generated by trigger

	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
    )
	PERFORM t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,deapp.nextval('seq_assay_id')
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,mirna_type as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || to_char(b.patient_num) as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,coalesce(a.category_cd,'Biomarker_Data+QPCR_MIRNA+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from lt_src_mirna_subj_samp_map a		
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join patient_dimension b
		  on regexp_replace(TrialID || ':' || a.site_id || ':' || a.subject_id,'(::){1,}', ':') = b.sourcesystem_cd
		inner join WT_QPCR_MIRNA_NODES ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and coalesce(a.attribute_1,'@') = coalesce(ln.attribute_1,'@')
			and coalesce(a.attribute_2,'@') = coalesce(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join WT_QPCR_MIRNA_NODES pn
			on a.platform = pn.platform
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(pn.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(pn.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'	  
		left outer join WT_QPCR_MIRNA_NODES ttp
			on a.tissue_type = ttp.tissue_type
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = coalesce(ttp.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(ttp.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'		  
		left outer join WT_QPCR_MIRNA_NODES a1
			on a.attribute_1 = a1.attribute_1
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a1.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a1.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = coalesce(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'		  
		left outer join WT_QPCR_MIRNA_NODES a2
			on a.attribute_2 = a1.attribute_2
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = coalesce(a2.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = coalesce(a2.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = coalesce(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'			  
		left outer join patient_dimension sid
			on  regexp_replace(TrialId || 'S:' || a.site_id || ':' || a.subject_id || ':' || a.sample_cd,
							  '(::){1,}', ':') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  (ln.concept_cd IS NOT NULL AND ln.concept_cd::text <> '')) t;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');

  commit;

--	recreate de_subject_sam
--	recreate de_subject_sample_mapping indexes

	--execute immediate('create index de_subject_smpl_mpng_idx1 on de_subject_sample_mapping(timepoint, patient_id, trial_name) parallel nologging'); 
	--execute immediate('create index de_subject_smpl_mpng_idx2 on de_subject_sample_mapping(patient_id, timepoint_cd, platform_cd, assay_id, trial_name) parallel nologging'); 
	--execute immediate('create bitmap index de_subject_smpl_mpng_idx3 on de_subject_sample_mapping(sample_type_cd) parallel nologging');
	--execute immediate('create index de_subject_smpl_mpng_idx4 on de_subject_sample_mapping(gpl_id) parallel nologging');
	--execute immediate('create index de_subject_smpl_mpng_idx4 on de_subject_sample_mapping(platform, gpl_id) parallel nologging');
    --stepCt := stepCt + 1;
	--cz_write_audit(jobId,databaseName,procedureName,'Recreate indexes on DEAPP de_subject_sample_mapping',0,stepCt,'Done');

--	Insert records for patients and samples into observation_fact

	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
        ,INSTANCE_NUM
    )
    PERFORM distinct m.patient_id
		  ,m.concept_code
		  ,'@'
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null	--	not numeric for qpcr_mirna
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
                  ,1
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCD
      and m.platform = mirna_type;
	  
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');

    commit;
    
	--	Insert sample facts 
	
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    PERFORM distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null	--	not numeric for miRNA
		  ,m.trial_name
		  ,LOCALTIMESTAMP
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCd
      and m.platform = mirna_type
	 and m.patient_id != m.sample_id;
	  
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');

    commit;
    
	--Update I2b2 for correct data type
	
	update i2b2 t
	set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
	where t.c_basecode in (select distinct x.concept_cd from WT_QPCR_MIRNA_NODES x);
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	update i2b2
	SET c_columndatatype = 'N',
      --Static XML String
		c_metadataxml = '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>10/21/2013 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
	where c_basecode IN (
		  SELECT xd.concept_cd
		  from WT_QPCR_MIRNA_NODES xd
			  ,observation_fact xf
		  where xf.concept_cd = xd.concept_cd
		  procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
	commit;
 
/*
	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	update i2b2 a
    set c_visualattributes = 'LA'
    where 1 = (
      select count(*)
      from i2b2 b
      where b.c_fullname like (a.c_fullname || '%'))
      and c_fullname like '%' || topNode || '%';
*/

	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	update i2b2 a
    set c_visualattributes = 'LAH'
	where a.c_basecode in (select distinct x.concept_code from de_subject_sample_mapping x
						   where x.trial_name = TrialId
						     and x.platform = mirna_type
							 and (x.concept_code IS NOT NULL AND x.concept_code::text <> ''));
	  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
  
	COMMIT;
  
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for miRNA data
  
    i2b2_create_concept_counts(topNode ,jobID );
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done');
	
	--	delete each node that is hidden
	
	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		i2b2_delete_1_node(r_delNodes.c_fullname);
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		
		cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');

	END LOOP;  	


  --Reload Security: Inserts one record for every I2B2 record into the security table

    i2b2_load_security_data(jobId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done');

--	tag data with probeset_id from reference.probeset_deapp
  
	EXECUTE ('truncate table tm_wz.WT_SUBJECT_MIRNA_PROBESET');
	
	--	note: assay_id represents a unique subject/site/sample
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'TrialId:'||TrialID,0,stepCt,'test');
  
	insert into WT_SUBJECT_MIRNA_PROBESET  --mod
	(probeset_id
--	,expr_id
	,intensity_value
	,patient_id
--	,sample_cd
--	,subject_id
	,trial_name
	,assay_id
	)
	PERFORM    p.probeset_id 
		  ,avg(md.intensity_value)
                  ,sd.patient_id
		  ,TrialId
		  ,sd.assay_id
	from deapp.de_subject_sample_mapping sd
		,LT_SRC_QPCR_MIRNA_DATA md   
                ,mirna_probeset_deapp p
	where sd.sample_cd = md.expr_id
	  and sd.platform = 'MIRNA_AFFYMETRIX'
	  and sd.trial_name =TrialId
	  and sd.source_cd = sourceCd
	 -- and sd.gpl_id = gs.id_ref
	  and md.probeset =p.probeset-- gs.mirna_id
	 and decode(dataType,'R',sign(md.intensity_value),1) = 1  
	group by  p.probeset_id 
		  ,sd.patient_id,sd.assay_id;
		  
	pExists := SQL%ROWCOUNT;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_mirna_probeset',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;		
	
	/*if pExists = 0 then
		raise no_probeset_recs;
	end if;*/
--mod

	--	insert into de_subject_mirna_data when dataType is T (transformed)
 
	if dataType = 'T' then
		insert into de_subject_mirna_data
		(trial_source
		,probeset_id
		,assay_id
		,patient_id
		--,sample_id
		--,subject_id
		,trial_name
		,zscore
		)
		PERFORM (TrialId || ':' || sourceCd)
			  ,probeset_id
			  ,assay_id
			  ,patient_id
			  --,sample_id
			  --,subject_id
			  ,trial_name
			  ,case when intensity_value < -2.5
			        then -2.5
					when intensity_value > 2.5
					then 2.5
					else intensity_value
			   end as zscore
		from WT_SUBJECT_MIRNA_PROBESET --mod
		where trial_name = TrialID;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Insert transformed into DEAPP de_subject_mirna_data',SQL%ROWCOUNT,stepCt,'Done');

		commit;	
	else
		
	--	Calculate ZScores and insert data into de_subject_mirna_data.  The 'L' parameter indicates that the gene expression data will be selected from
	--	wt_subject_mirna_probeset as part of a Load.  

		if dataType = 'R' or dataType = 'L' then
			i2b2_mirna_zscore_calc(TrialID,'L',jobId,dataType,logBase,sourceCD);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',0,stepCt,'Done');
			commit;
		end if;
	
	end if;

    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_QPCR_miRNA_DATA',0,stepCt,'Done');

	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;
	
	PERFORM 0 into rtn_code ;

	EXCEPTION
	--when unmapped_patients then
	--	cz_write_audit(jobId,databasename,procedurename,'No site_id/subject_id mapped to patient_dimension',1,stepCt,'ERROR');
	--	cz_error_handler(jobid,procedurename);
	--	cz_end_audit (jobId,'FAIL');
	when missing_platform then
		cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		cz_error_handler(jobid,procedurename);
		cz_end_audit (jobId,'FAIL');
		PERFORM 161 into rtn_code ;
	when missing_tissue then
		cz_write_audit(jobId,databasename,procedurename,'Tissue Type data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		cz_error_handler(jobid,procedurename);
		CZ_END_AUDIT (JOBID,'FAIL');
		PERFORM 162 into rtn_code ;
	when unmapped_platform then
		cz_write_audit(jobId,databasename,procedurename,'Platform not found in de_qpcr_mirna_annotation',1,stepCt,'ERROR');
		CZ_ERROR_HANDLER(JOBID,PROCEDURENAME);
		cz_end_audit (jobId,'FAIL');
		PERFORM 163 into rtn_code ;--mod
	when multiple_platform then
		cz_write_audit(jobId,databasename,procedurename,'Multiple platforms for sample_cd in LT_SRC_MIRNA_SUBJ_SAMP_MAP',1,stepCt,'ERROR');
		CZ_ERROR_HANDLER(JOBID,PROCEDURENAME);
		cz_end_audit (jobId,'FAIL');
		PERFORM 164 into rtn_code ;
	when no_probeset_recs then
		cz_write_audit(jobId,databasename,procedurename,'Unable to match probesets to platform in probeset_deapp',1,stepCt,'ERROR');
		CZ_ERROR_HANDLER(JOBID,PROCEDURENAME);
		cz_end_audit (jobId,'FAIL');
		PERFORM 165 into rtn_code ;
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		--End Proc
		cz_end_audit (jobID, 'FAIL');
		PERFORM 16  into rtn_code ;
END;
 
$_$;


ALTER FUNCTION tm_lz.i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, mirna_type character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, OUT rtn_code numeric) OWNER TO tm_lz;

--
-- Name: tf_trg_lz_src_analysis_meta_id(); Type: FUNCTION; Schema: tm_lz; Owner: tm_lz
--

CREATE FUNCTION tf_trg_lz_src_analysis_meta_id() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin     
      if NEW.ETL_ID is null then
        select nextval('tm_lz.seq_etl_id') into NEW.ETL_ID ;       
      end if;       
    RETURN NEW;
end;
$$;


ALTER FUNCTION tm_lz.tf_trg_lz_src_analysis_meta_id() OWNER TO tm_lz;

SET search_path = public, pg_catalog;

--
-- Name: array_accum(anyelement); Type: AGGREGATE; Schema: public; Owner: weymouth
--

CREATE AGGREGATE array_accum(anyelement) (
    SFUNC = array_append,
    STYPE = anyarray,
    INITCOND = '{}'
);


ALTER AGGREGATE public.array_accum(anyelement) OWNER TO weymouth;

SET search_path = tm_cz, pg_catalog;

--
-- Name: median(double precision); Type: AGGREGATE; Schema: tm_cz; Owner: tm_cz
--

CREATE AGGREGATE median(double precision) (
    SFUNC = array_append,
    STYPE = double precision[],
    INITCOND = '{}',
    FINALFUNC = tm_cz._final_median
);


ALTER AGGREGATE tm_cz.median(double precision) OWNER TO tm_cz;

SET search_path = tm_dataloader, pg_catalog;

--
-- Name: median(anyelement); Type: AGGREGATE; Schema: tm_dataloader; Owner: weymouth
--

CREATE AGGREGATE median(anyelement) (
    SFUNC = array_append,
    STYPE = anyarray,
    INITCOND = '{}',
    FINALFUNC = tm_dataloader._final_median
);


ALTER AGGREGATE tm_dataloader.median(anyelement) OWNER TO weymouth;

--
-- Name: median(double precision); Type: AGGREGATE; Schema: tm_dataloader; Owner: weymouth
--

CREATE AGGREGATE median(double precision) (
    SFUNC = array_append,
    STYPE = double precision[],
    INITCOND = '{}',
    FINALFUNC = tm_dataloader._final_median
);


ALTER AGGREGATE tm_dataloader.median(double precision) OWNER TO weymouth;

SET search_path = amapp, pg_catalog;

SET default_tablespace = transmart;

SET default_with_oids = false;

--
-- Name: am_data_uid; Type: TABLE; Schema: amapp; Owner: amapp; Tablespace: transmart
--

CREATE TABLE am_data_uid (
    am_data_id bigint NOT NULL,
    unique_id character varying(300) NOT NULL,
    am_data_type character varying(100) NOT NULL
);


ALTER TABLE amapp.am_data_uid OWNER TO amapp;

--
-- Name: am_tag_association; Type: TABLE; Schema: amapp; Owner: amapp; Tablespace: transmart
--

CREATE TABLE am_tag_association (
    subject_uid character varying(300) NOT NULL,
    object_uid character varying(300) NOT NULL,
    object_type character varying(50),
    tag_item_id bigint
);


ALTER TABLE amapp.am_tag_association OWNER TO amapp;

--
-- Name: am_tag_item; Type: TABLE; Schema: amapp; Owner: amapp; Tablespace: transmart
--

CREATE TABLE am_tag_item (
    tag_template_id bigint NOT NULL,
    tag_item_id bigint NOT NULL,
    required character varying(1),
    display_order bigint,
    display_name character varying(200) NOT NULL,
    gui_handler character varying(200) NOT NULL,
    max_values bigint,
    code_type_name character varying(200),
    editable character varying(1),
    active_ind boolean NOT NULL,
    tag_item_uid character varying(300) NOT NULL,
    tag_item_attr character varying(300),
    tag_item_type character varying(200),
    view_in_grid smallint,
    tag_item_subtype character varying(200),
    view_in_child_grid smallint
);


ALTER TABLE amapp.am_tag_item OWNER TO amapp;

--
-- Name: am_tag_value; Type: TABLE; Schema: amapp; Owner: amapp; Tablespace: transmart
--

CREATE TABLE am_tag_value (
    tag_value_id bigint NOT NULL,
    value character varying(2000)
);


ALTER TABLE amapp.am_tag_value OWNER TO amapp;

SET search_path = biomart, pg_catalog;

--
-- Name: bio_assay_platform; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_platform (
    bio_assay_platform_id bigint NOT NULL,
    platform_name character varying(200),
    platform_version character varying(200),
    platform_description character varying(2000),
    platform_array character varying(50),
    platform_accession character varying(20),
    platform_organism character varying(200),
    platform_vendor character varying(200),
    platform_type character varying(200),
    platform_technology character varying(200)
);


ALTER TABLE biomart.bio_assay_platform OWNER TO biomart;

--
-- Name: bio_compound; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_compound (
    bio_compound_id bigint NOT NULL,
    cnto_number character varying(200),
    jnj_number character varying(200),
    cas_registry character varying(400),
    code_name character varying(300),
    generic_name character varying(200),
    brand_name character varying(200),
    chemical_name character varying(1000),
    mechanism character varying(400),
    product_category character varying(200),
    description character varying(1000),
    etl_id_retired bigint,
    etl_id character varying(50),
    source_cd character varying(100)
);


ALTER TABLE biomart.bio_compound OWNER TO biomart;

--
-- Name: bio_concept_code; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_concept_code (
    bio_concept_code character varying(200),
    code_name character varying(200),
    code_description character varying(1000),
    code_type_name character varying(200),
    bio_concept_code_id bigint NOT NULL,
    filter_flag character(1) DEFAULT 0
);


ALTER TABLE biomart.bio_concept_code OWNER TO biomart;

--
-- Name: bio_data_uid; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_data_uid (
    bio_data_id bigint NOT NULL,
    unique_id character varying(300) NOT NULL,
    bio_data_type character varying(100) NOT NULL
);


ALTER TABLE biomart.bio_data_uid OWNER TO biomart;

--
-- Name: bio_disease; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_disease (
    bio_disease_id bigint NOT NULL,
    disease character varying(510) NOT NULL,
    ccs_category character varying(510),
    icd10_code character varying(510),
    mesh_code character varying(510),
    icd9_code character varying(510),
    prefered_name character varying(510),
    etl_id_retired bigint,
    primary_source_cd character varying(30),
    etl_id character varying(50)
);


ALTER TABLE biomart.bio_disease OWNER TO biomart;

--
-- Name: bio_marker; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_marker (
    bio_marker_id bigint NOT NULL,
    bio_marker_name character varying(200),
    bio_marker_description character varying(1000),
    organism character varying(200),
    primary_source_code character varying(200),
    primary_external_id character varying(200),
    bio_marker_type character varying(200) NOT NULL
);


ALTER TABLE biomart.bio_marker OWNER TO biomart;

--
-- Name: bio_observation; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_observation (
    bio_observation_id bigint NOT NULL,
    obs_name character varying(200),
    obs_code character varying(50),
    obs_descr character varying(1000),
    etl_id character varying(50),
    obs_type character varying(20),
    obs_code_source character varying(20)
);


ALTER TABLE biomart.bio_observation OWNER TO biomart;

SET search_path = amapp, pg_catalog;

--
-- Name: am_tag_display_vw; Type: VIEW; Schema: amapp; Owner: amapp
--

CREATE VIEW am_tag_display_vw AS
        (        (        (        (        (         SELECT DISTINCT tass.subject_uid, 
                                                    tass.tag_item_id, 
                                                    tval.value AS display_value, 
                                                    tass.object_type, 
                                                    tass.object_uid, 
                                                    obj_uid.am_data_id AS object_id
                                                   FROM ((am_tag_association tass
                                              JOIN am_data_uid obj_uid ON (((tass.object_uid)::text = (obj_uid.unique_id)::text)))
                                         JOIN am_tag_value tval ON ((obj_uid.am_data_id = tval.tag_value_id)))
                                        UNION 
                                                 SELECT DISTINCT tass.subject_uid, 
                                                    tass.tag_item_id, 
                                                    bio_val.code_name AS display_value, 
                                                    tass.object_type, 
                                                    tass.object_uid, 
                                                    obj_uid.bio_data_id AS object_id
                                                   FROM ((am_tag_association tass
                                              JOIN biomart.bio_data_uid obj_uid ON (((tass.object_uid)::text = (obj_uid.unique_id)::text)))
                                         JOIN biomart.bio_concept_code bio_val ON ((obj_uid.bio_data_id = bio_val.bio_concept_code_id))))
                                UNION 
                                         SELECT DISTINCT tass.subject_uid, 
                                            tass.tag_item_id, 
                                            bio_val.disease AS display_value, 
                                            tass.object_type, 
                                            tass.object_uid, 
                                            obj_uid.bio_data_id AS object_id
                                           FROM ((am_tag_association tass
                                      JOIN biomart.bio_data_uid obj_uid ON (((tass.object_uid)::text = (obj_uid.unique_id)::text)))
                                 JOIN biomart.bio_disease bio_val ON ((obj_uid.bio_data_id = bio_val.bio_disease_id))))
                        UNION 
                                 SELECT DISTINCT tass.subject_uid, 
                                    tass.tag_item_id, 
                                        CASE
                                            WHEN ((ati.code_type_name)::text = 'PLATFORM_NAME'::text) THEN (((((((bio_val.platform_type)::text || '/'::text) || (bio_val.platform_technology)::text) || '/'::text) || (bio_val.platform_vendor)::text) || '/'::text) || (bio_val.platform_name)::text)
                                            WHEN ((ati.code_type_name)::text = 'VENDOR'::text) THEN (bio_val.platform_vendor)::text
                                            WHEN ((ati.code_type_name)::text = 'MEASUREMENT_TYPE'::text) THEN (bio_val.platform_type)::text
                                            WHEN ((ati.code_type_name)::text = 'TECHNOLOGY'::text) THEN (bio_val.platform_technology)::text
                                            ELSE NULL::text
                                        END AS display_value, 
                                    tass.object_type, 
                                    tass.object_uid, 
                                    obj_uid.bio_data_id AS object_id
                                   FROM (((am_tag_association tass
                              JOIN biomart.bio_data_uid obj_uid ON (((tass.object_uid)::text = (obj_uid.unique_id)::text)))
                         JOIN biomart.bio_assay_platform bio_val ON ((obj_uid.bio_data_id = bio_val.bio_assay_platform_id)))
                    JOIN am_tag_item ati ON ((ati.tag_item_id = tass.tag_item_id))))
                UNION 
                         SELECT DISTINCT tass.subject_uid, 
                            tass.tag_item_id, 
                            bio_val.code_name AS display_value, 
                            tass.object_type, 
                            tass.object_uid, 
                            obj_uid.bio_data_id AS object_id
                           FROM ((am_tag_association tass
                      JOIN biomart.bio_data_uid obj_uid ON (((tass.object_uid)::text = (obj_uid.unique_id)::text)))
                 JOIN biomart.bio_compound bio_val ON ((obj_uid.bio_data_id = bio_val.bio_compound_id))))
        UNION 
                 SELECT DISTINCT tass.subject_uid, 
                    tass.tag_item_id, 
                    bio_val.bio_marker_name AS display_value, 
                    tass.object_type, 
                    tass.object_uid, 
                    obj_uid.bio_data_id AS object_id
                   FROM ((am_tag_association tass
              JOIN biomart.bio_data_uid obj_uid ON (((tass.object_uid)::text = (obj_uid.unique_id)::text)))
         JOIN biomart.bio_marker bio_val ON ((obj_uid.bio_data_id = bio_val.bio_marker_id))))
UNION 
         SELECT DISTINCT tass.subject_uid, 
            tass.tag_item_id, 
            bio_val.obs_name AS display_value, 
            tass.object_type, 
            tass.object_uid, 
            obj_uid.bio_data_id AS object_id
           FROM ((am_tag_association tass
      JOIN biomart.bio_data_uid obj_uid ON (((tass.object_uid)::text = (obj_uid.unique_id)::text)))
   JOIN biomart.bio_observation bio_val ON ((obj_uid.bio_data_id = bio_val.bio_observation_id)));


ALTER TABLE amapp.am_tag_display_vw OWNER TO amapp;

--
-- Name: am_tag_template; Type: TABLE; Schema: amapp; Owner: amapp; Tablespace: transmart
--

CREATE TABLE am_tag_template (
    tag_template_id bigint NOT NULL,
    tag_template_name character varying(200) NOT NULL,
    tag_template_type character varying(50) NOT NULL,
    tag_template_subtype character varying(50),
    active_ind boolean NOT NULL
);


ALTER TABLE amapp.am_tag_template OWNER TO amapp;

--
-- Name: am_tag_template_association; Type: TABLE; Schema: amapp; Owner: amapp; Tablespace: transmart
--

CREATE TABLE am_tag_template_association (
    tag_template_id bigint NOT NULL,
    object_uid character varying(300) NOT NULL,
    id bigint
);


ALTER TABLE amapp.am_tag_template_association OWNER TO amapp;

--
-- Name: seq_amapp_data_id; Type: SEQUENCE; Schema: amapp; Owner: amapp
--

CREATE SEQUENCE seq_amapp_data_id
    START WITH 1995735
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE amapp.seq_amapp_data_id OWNER TO amapp;

SET search_path = biomart, pg_catalog;

--
-- Name: annotation; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE annotation (
    platform character varying(50),
    probeset character varying(50),
    gene_descr character varying(4000),
    gene_symbol character varying(4000),
    gene_id character varying(50),
    organism character varying(200),
    id bigint NOT NULL
);


ALTER TABLE biomart.annotation OWNER TO biomart;

--
-- Name: assay_analysis_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE assay_analysis_data (
    bio_asy_analysis_data_id bigint NOT NULL,
    bio_experiment_id bigint,
    bio_assay_platform_id bigint,
    bio_assay_analysis_id bigint,
    bio_assay_feature_group_id bigint,
    feature_group_name character varying(100),
    tea_normalized_pvalue double precision,
    fold_change_ratio bigint,
    raw_pvalue double precision,
    adjusted_pvalue double precision,
    preferred_pvalue double precision
);


ALTER TABLE biomart.assay_analysis_data OWNER TO biomart;

--
-- Name: bio_ad_hoc_property; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_ad_hoc_property (
    ad_hoc_property_id bigint NOT NULL,
    bio_data_id bigint,
    property_key character varying(50),
    property_value character varying(2000)
);


ALTER TABLE biomart.bio_ad_hoc_property OWNER TO biomart;

--
-- Name: bio_analysis_attribute; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_analysis_attribute (
    study_id character varying(255),
    bio_assay_analysis_id bigint NOT NULL,
    term_id bigint,
    source_cd character varying(255),
    bio_analysis_attribute_id bigint NOT NULL
);


ALTER TABLE biomart.bio_analysis_attribute OWNER TO biomart;

--
-- Name: bio_analysis_attribute_lineage; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_analysis_attribute_lineage (
    bio_analysis_att_lineage_id bigint NOT NULL,
    bio_analysis_attribute_id bigint NOT NULL,
    ancestor_term_id bigint NOT NULL,
    ancestor_search_keyword_id bigint NOT NULL
);


ALTER TABLE biomart.bio_analysis_attribute_lineage OWNER TO biomart;

--
-- Name: bio_analysis_cohort_xref; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_analysis_cohort_xref (
    study_id character varying(255),
    cohort_id character varying(255),
    analysis_cd character varying(255),
    bio_assay_analysis_id bigint NOT NULL
);


ALTER TABLE biomart.bio_analysis_cohort_xref OWNER TO biomart;

--
-- Name: bio_assay; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay (
    bio_assay_id bigint NOT NULL,
    etl_id character varying(100) NOT NULL,
    study character varying(200),
    protocol character varying(200),
    description text,
    sample_type character varying(200),
    experiment_id bigint NOT NULL,
    test_date timestamp without time zone,
    sample_receive_date timestamp without time zone,
    requestor character varying(200),
    bio_assay_type character varying(200) NOT NULL,
    bio_assay_platform_id bigint,
    biosource character varying(200),
    measurement_type character varying(200),
    technology character varying(200),
    vendor character varying(200),
    platform_design character varying(200),
    biomarkers_studied character varying(200),
    biomarkers_type character varying(200)
);


ALTER TABLE biomart.bio_assay OWNER TO biomart;

--
-- Name: bio_assay_analysis; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_analysis (
    analysis_name character varying(500),
    short_description character varying(510),
    analysis_create_date timestamp without time zone,
    analyst_id character varying(510),
    bio_assay_analysis_id bigint NOT NULL,
    analysis_version character varying(200),
    fold_change_cutoff double precision,
    pvalue_cutoff double precision,
    rvalue_cutoff double precision,
    bio_asy_analysis_pltfm_id bigint,
    bio_source_import_id bigint,
    analysis_type character varying(200),
    analyst_name character varying(250),
    analysis_method_cd character varying(50),
    bio_assay_data_type character varying(50),
    etl_id character varying(100),
    long_description character varying(4000),
    qa_criteria character varying(4000),
    data_count bigint,
    tea_data_count bigint,
    analysis_update_date date,
    lsmean_cutoff double precision,
    etl_id_source bigint
);


ALTER TABLE biomart.bio_assay_analysis OWNER TO biomart;

--
-- Name: bio_assay_analysis_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_analysis_data (
    bio_asy_analysis_data_id bigint NOT NULL,
    fold_change_ratio bigint,
    raw_pvalue double precision,
    adjusted_pvalue double precision,
    r_value double precision,
    rho_value double precision,
    bio_assay_analysis_id bigint NOT NULL,
    adjusted_p_value_code character varying(100),
    feature_group_name character varying(100) NOT NULL,
    bio_experiment_id bigint,
    bio_assay_platform_id bigint,
    etl_id character varying(100),
    preferred_pvalue double precision,
    cut_value double precision,
    results_value character varying(100),
    numeric_value double precision,
    numeric_value_code character varying(50),
    tea_normalized_pvalue double precision,
    bio_assay_feature_group_id bigint,
    probeset_id bigint,
    lsmean1 double precision,
    lsmean2 double precision
);


ALTER TABLE biomart.bio_assay_analysis_data OWNER TO biomart;

--
-- Name: bio_assay_analysis_data_tea; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_analysis_data_tea (
    bio_asy_analysis_data_id bigint NOT NULL,
    fold_change_ratio bigint,
    raw_pvalue double precision,
    adjusted_pvalue double precision,
    r_value double precision,
    rho_value double precision,
    bio_assay_analysis_id bigint NOT NULL,
    adjusted_p_value_code character varying(100),
    feature_group_name character varying(100) NOT NULL,
    bio_experiment_id bigint,
    bio_assay_platform_id bigint,
    etl_id character varying(100),
    preferred_pvalue double precision,
    cut_value double precision,
    results_value character varying(100),
    numeric_value double precision,
    numeric_value_code character varying(50),
    tea_normalized_pvalue double precision,
    bio_experiment_type character varying(50),
    bio_assay_feature_group_id bigint,
    tea_rank bigint,
    probeset_id bigint
);


ALTER TABLE biomart.bio_assay_analysis_data_tea OWNER TO biomart;

--
-- Name: bio_assay_analysis_eqtl; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_analysis_eqtl (
    bio_asy_analysis_eqtl_id bigint NOT NULL,
    bio_assay_analysis_id bigint,
    rs_id character varying(50),
    gene character varying(50),
    p_value_char character varying(100),
    cis_trans character varying(10),
    distance_from_gene character varying(10),
    etl_id bigint,
    ext_data character varying(4000),
    p_value double precision,
    log_p_value double precision
);


ALTER TABLE biomart.bio_assay_analysis_eqtl OWNER TO biomart;

--
-- Name: bio_assay_analysis_ext; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_analysis_ext (
    bio_assay_analysis_ext_id bigint NOT NULL,
    bio_assay_analysis_id bigint NOT NULL,
    vendor character varying(500),
    vendor_type character varying(500),
    genome_version character varying(500),
    tissue character varying(500),
    cell_type character varying(500),
    population character varying(500),
    research_unit character varying(500),
    sample_size character varying(500),
    model_name character varying(100),
    model_desc character varying(500),
    sensitive_flag integer,
    sensitive_desc character varying(500)
);


ALTER TABLE biomart.bio_assay_analysis_ext OWNER TO biomart;

--
-- Name: bio_assay_analysis_gwas; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_analysis_gwas (
    bio_asy_analysis_gwas_id bigint,
    bio_assay_analysis_id bigint,
    rs_id character varying(50),
    p_value_char character varying(100),
    etl_id bigint,
    ext_data character varying(4000),
    p_value double precision,
    log_p_value double precision
);


ALTER TABLE biomart.bio_assay_analysis_gwas OWNER TO biomart;

--
-- Name: bio_assay_cohort; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_cohort (
    study_id character varying(500),
    cohort_id character varying(500),
    disease character varying(500),
    sample_type character varying(500),
    treatment character varying(500),
    organism character varying(500),
    pathology character varying(500),
    cohort_title character varying(500),
    short_desc character varying(500),
    long_desc character varying(500),
    import_date timestamp(6) without time zone NOT NULL,
    bio_assay_cohort_id bigint NOT NULL
);


ALTER TABLE biomart.bio_assay_cohort OWNER TO biomart;

--
-- Name: bio_assay_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_data (
    bio_sample_id bigint,
    bio_assay_data_id bigint NOT NULL,
    log2_value double precision,
    log10_value double precision,
    numeric_value bigint,
    text_value character varying(200),
    float_value double precision,
    feature_group_name character varying(100) NOT NULL,
    bio_experiment_id bigint,
    bio_assay_dataset_id bigint,
    bio_assay_id bigint,
    etl_id bigint
);


ALTER TABLE biomart.bio_assay_data OWNER TO biomart;

--
-- Name: bio_assay_data_annotation; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_data_annotation (
    bio_assay_feature_group_id bigint,
    bio_marker_id bigint NOT NULL,
    data_table character(5)
);


ALTER TABLE biomart.bio_assay_data_annotation OWNER TO biomart;

--
-- Name: bio_assay_data_stats; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_data_stats (
    bio_assay_data_stats_id bigint NOT NULL,
    bio_sample_count bigint,
    quartile_1 double precision,
    quartile_2 double precision,
    quartile_3 double precision,
    max_value double precision,
    min_value double precision,
    bio_sample_id bigint,
    feature_group_name character varying(120),
    value_normalize_method character varying(50),
    bio_experiment_id bigint,
    mean_value double precision,
    std_dev_value double precision,
    bio_assay_dataset_id bigint,
    bio_assay_feature_group_id bigint NOT NULL
);


ALTER TABLE biomart.bio_assay_data_stats OWNER TO biomart;

--
-- Name: bio_assay_data_stats_seq; Type: SEQUENCE; Schema: biomart; Owner: biomart
--

CREATE SEQUENCE bio_assay_data_stats_seq
    START WITH 34497441
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE biomart.bio_assay_data_stats_seq OWNER TO biomart;

--
-- Name: bio_assay_dataset; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_dataset (
    bio_assay_dataset_id bigint NOT NULL,
    dataset_name character varying(400),
    dataset_description character varying(1000),
    dataset_criteria character varying(1000),
    create_date timestamp without time zone,
    bio_experiment_id bigint NOT NULL,
    bio_assay_id bigint,
    etl_id character varying(100),
    accession character varying(50)
);


ALTER TABLE biomart.bio_assay_dataset OWNER TO biomart;

--
-- Name: bio_assay_feature_group; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_feature_group (
    bio_assay_feature_group_id bigint NOT NULL,
    feature_group_name character varying(100) NOT NULL,
    feature_group_type character varying(50) NOT NULL
);


ALTER TABLE biomart.bio_assay_feature_group OWNER TO biomart;

--
-- Name: bio_assay_sample; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_assay_sample (
    bio_assay_id bigint NOT NULL,
    bio_sample_id bigint NOT NULL,
    bio_clinic_trial_timepoint_id bigint NOT NULL
);


ALTER TABLE biomart.bio_assay_sample OWNER TO biomart;

--
-- Name: bio_asy_analysis_data_idx; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_asy_analysis_data_idx (
    bio_asy_analysis_data_idx_id bigint NOT NULL,
    ext_type character varying(255) NOT NULL,
    field_idx numeric(10,0) NOT NULL,
    field_name character varying(255) NOT NULL,
    display_idx numeric(10,0) NOT NULL,
    display_name character varying(255) NOT NULL
);


ALTER TABLE biomart.bio_asy_analysis_data_idx OWNER TO biomart;

--
-- Name: bio_asy_analysis_dataset; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_asy_analysis_dataset (
    bio_assay_dataset_id bigint NOT NULL,
    bio_assay_analysis_id bigint NOT NULL
);


ALTER TABLE biomart.bio_asy_analysis_dataset OWNER TO biomart;

--
-- Name: bio_asy_analysis_eqtl_top50; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_asy_analysis_eqtl_top50 (
    bio_assay_analysis_id bigint,
    analysis character varying(500),
    chrom character varying(4),
    pos numeric(10,0),
    rsgene character varying(200),
    rsid character varying(50),
    pvalue double precision,
    logpvalue double precision,
    extdata character varying(4000),
    rnum bigint
);


ALTER TABLE biomart.bio_asy_analysis_eqtl_top50 OWNER TO biomart;

--
-- Name: bio_asy_analysis_gwas_top50; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_asy_analysis_gwas_top50 (
    bio_assay_analysis_id bigint,
    analysis character varying(500),
    chrom character varying(4),
    pos numeric(10,0),
    rsgene character varying(200),
    rsid character varying(50),
    pvalue double precision,
    logpvalue double precision,
    extdata character varying(4000),
    rnum bigint
);


ALTER TABLE biomart.bio_asy_analysis_gwas_top50 OWNER TO biomart;

--
-- Name: bio_asy_analysis_pltfm; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_asy_analysis_pltfm (
    bio_asy_analysis_pltfm_id bigint NOT NULL,
    platform_name character varying(200),
    platform_version character varying(200),
    platform_description character varying(1000)
);


ALTER TABLE biomart.bio_asy_analysis_pltfm OWNER TO biomart;

--
-- Name: bio_asy_data_stats_all; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_asy_data_stats_all (
    bio_assay_data_stats_id bigint NOT NULL,
    bio_sample_count bigint,
    quartile_1 double precision,
    quartile_2 double precision,
    quartile_3 double precision,
    max_value double precision,
    min_value double precision,
    bio_sample_id bigint,
    feature_group_name character varying(120),
    value_normalize_method character varying(50),
    bio_experiment_id bigint,
    mean_value double precision,
    std_dev_value double precision,
    bio_assay_dataset_id bigint
);


ALTER TABLE biomart.bio_asy_data_stats_all OWNER TO biomart;

--
-- Name: bio_cell_line; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_cell_line (
    disease character varying(510),
    primary_site character varying(510),
    metastatic_site character varying(510),
    species character varying(510),
    attc_number character varying(510),
    cell_line_name character varying(510),
    bio_cell_line_id bigint NOT NULL,
    bio_disease_id bigint,
    origin character varying(200),
    description character varying(500),
    disease_stage character varying(100),
    disease_subtype character varying(200),
    etl_reference_link character varying(300)
);


ALTER TABLE biomart.bio_cell_line OWNER TO biomart;

--
-- Name: bio_cgdcp_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_cgdcp_data (
    evidence_code character varying(200),
    negation_indicator character(1),
    cell_line_id bigint,
    nci_disease_concept_code character varying(200),
    nci_role_code character varying(200),
    nci_drug_concept_code character varying(200),
    bio_data_id bigint NOT NULL
);


ALTER TABLE biomart.bio_cgdcp_data OWNER TO biomart;

--
-- Name: bio_clinc_trial_attr; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_clinc_trial_attr (
    bio_clinc_trial_attr_id bigint NOT NULL,
    property_code character varying(200) NOT NULL,
    property_value character varying(200),
    bio_experiment_id bigint NOT NULL
);


ALTER TABLE biomart.bio_clinc_trial_attr OWNER TO biomart;

--
-- Name: bio_clinc_trial_pt_group; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_clinc_trial_pt_group (
    bio_experiment_id bigint NOT NULL,
    bio_clinical_trial_p_group_id bigint NOT NULL,
    name character varying(510),
    description character varying(1000),
    number_of_patients integer,
    patient_group_type_code character varying(200)
);


ALTER TABLE biomart.bio_clinc_trial_pt_group OWNER TO biomart;

--
-- Name: bio_clinc_trial_time_pt; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_clinc_trial_time_pt (
    bio_clinc_trial_tm_pt_id bigint NOT NULL,
    time_point character varying(200),
    time_point_code character varying(200),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    bio_experiment_id bigint NOT NULL
);


ALTER TABLE biomart.bio_clinc_trial_time_pt OWNER TO biomart;

--
-- Name: bio_clinical_trial; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_clinical_trial (
    trial_number character varying(510),
    study_owner character varying(510),
    study_phase character varying(100),
    blinding_procedure character varying(1000),
    studytype character varying(510),
    duration_of_study_weeks integer,
    number_of_patients integer,
    number_of_sites integer,
    route_of_administration character varying(510),
    dosing_regimen character varying(3500),
    group_assignment character varying(510),
    type_of_control character varying(510),
    completion_date timestamp without time zone,
    primary_end_points character varying(2000),
    secondary_end_points character varying(3500),
    inclusion_criteria text,
    exclusion_criteria text,
    subjects character varying(2000),
    gender_restriction_mfb character varying(510),
    min_age integer,
    max_age integer,
    secondary_ids character varying(510),
    bio_experiment_id bigint NOT NULL,
    development_partner character varying(100),
    geo_platform character varying(30),
    main_findings character varying(2000),
    platform_name character varying(200),
    search_area character varying(100)
);


ALTER TABLE biomart.bio_clinical_trial OWNER TO biomart;

--
-- Name: bio_clinical_trial_design; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_clinical_trial_design (
    ref_id character varying(4000),
    ref_record_id character varying(4000),
    ref_back_reference character varying(4000),
    ref_article_pmid character varying(4000),
    ref_protocol_id character varying(4000),
    ref_title character varying(4000),
    study_type character varying(4000),
    common_name character varying(4000),
    icd10 character varying(4000),
    mesh character varying(4000),
    disease_type character varying(4000),
    physiology_name character varying(4000),
    trial_status character varying(4000),
    trial_phase character varying(4000),
    nature_of_trial character varying(4000),
    randomization character varying(4000),
    blinded_trial character varying(4000),
    trial_type character varying(4000),
    run_n_period character varying(4000),
    treatment_period character varying(4000),
    washout_period character varying(4000),
    open_label_extension character varying(4000),
    sponsor character varying(4000),
    trial_nbr_of_patients_studied character varying(4000),
    source_type character varying(4000),
    trial_age character varying(4000),
    disease_severity character varying(4000),
    difficult_to_treat character varying(4000),
    asthma_diagnosis character varying(4000),
    inhaled_steroid_dose character varying(4000),
    laba character varying(4000),
    ocs character varying(4000),
    xolair character varying(4000),
    ltra_inhibitors character varying(4000),
    asthma_phenotype character varying(4000),
    fev1 character varying(4000),
    fev1_reversibility character varying(4000),
    tlc character varying(4000),
    fev1_fvc character varying(4000),
    fvc character varying(4000),
    dlco character varying(4000),
    sgrq character varying(4000),
    hrct character varying(4000),
    biopsy character varying(4000),
    dyspnea_on_exertion character varying(4000),
    concomitant_med character varying(4000),
    trial_smokers_pct character varying(4000),
    trial_former_smokers_pct character varying(4000),
    trial_never_smokers_pct character varying(4000),
    trial_pack_years character varying(4000),
    exclusion_criteria character varying(4000),
    minimal_symptoms character varying(4000),
    rescue_medication_use character varying(4000),
    control_details character varying(4000),
    blinding_procedure character varying(4000),
    number_of_arms character varying(4000),
    description character varying(4000),
    arm character varying(4000),
    arm_nbr_of_patients_studied character varying(4000),
    arm_classification_type character varying(4000),
    arm_classification_value character varying(4000),
    arm_asthma_duration character varying(4000),
    arm_geographic_region character varying(4000),
    arm_age character varying(4000),
    arm_gender character varying(4000),
    arm_smokers_pct character varying(4000),
    arm_former_smokers_pct character varying(4000),
    arm_never_smokers_pct character varying(4000),
    arm_pack_years character varying(4000),
    minority_participation character varying(4000),
    baseline_symptom_score character varying(4000),
    baseline_rescue_medication_use character varying(4000),
    clinical_variable character varying(4000),
    clinical_variable_pct character varying(4000),
    clinical_variable_value character varying(4000),
    prior_med_drug_name character varying(4000),
    prior_med_pct character varying(4000),
    prior_med_value character varying(4000),
    biomarker_name character varying(4000),
    biomarker_pct character varying(4000),
    biomarkervalue character varying(4000),
    cellinfo_type character varying(4000),
    cellinfo_count character varying(4000),
    cellinfo_source character varying(4000),
    pulmonary_pathology_name character varying(4000),
    pulmpath_patient_pct character varying(4000),
    pulmpath_value_unit character varying(4000),
    pulmpath_method character varying(4000),
    runin_ocs character varying(4000),
    runin_ics character varying(4000),
    runin_laba character varying(4000),
    runin_ltra character varying(4000),
    runin_corticosteroids character varying(4000),
    runin_anti_fibrotics character varying(4000),
    runin_immunosuppressive character varying(4000),
    runin_cytotoxic character varying(4000),
    runin_description character varying(4000),
    trtmt_ocs character varying(4000),
    trtmt_ics character varying(4000),
    trtmt_laba character varying(4000),
    trtmt_ltra character varying(4000),
    trtmt_corticosteroids character varying(4000),
    trtmt_anti_fibrotics character varying(4000),
    trtmt_immunosuppressive character varying(4000),
    trtmt_cytotoxic character varying(4000),
    trtmt_description character varying(4000),
    drug_inhibitor_common_name character varying(4000),
    drug_inhibitor_standard_name character varying(4000),
    drug_inhibitor_cas_id character varying(4000),
    drug_inhibitor_dose character varying(4000),
    drug_inhibitor_route_of_admin character varying(4000),
    drug_inhibitor_trtmt_regime character varying(4000),
    comparator_name character varying(4000),
    comparator_dose character varying(4000),
    comparator_time_period character varying(4000),
    comparator_route_of_admin character varying(4000),
    treatment_regime character varying(4000),
    placebo character varying(4000),
    experiment_description character varying(4000),
    primary_endpoint_type character varying(4000),
    primary_endpoint_definition character varying(4000),
    primary_endpoint_time_period character varying(4000),
    primary_endpoint_change character varying(4000),
    primary_endpoint_p_value character varying(4000),
    primary_endpoint_stat_test character varying(4000),
    secondary_type character varying(4000),
    secondary_type_definition character varying(4000),
    secondary_type_time_period character varying(4000),
    secondary_type_change character varying(4000),
    secondary_type_p_value character varying(4000),
    secondary_type_stat_test character varying(4000),
    clinical_variable_name character varying(4000),
    pct_change_from_baseline character varying(4000),
    abs_change_from_baseline character varying(4000),
    rate_of_change_from_baseline character varying(4000),
    average_over_treatment_period character varying(4000),
    within_group_changes character varying(4000),
    stat_measure_p_value character varying(4000),
    definition_of_the_event character varying(4000),
    number_of_events character varying(4000),
    event_rate character varying(4000),
    time_to_event character varying(4000),
    event_pct_reduction character varying(4000),
    event_p_value character varying(4000),
    event_description character varying(4000),
    discontinuation_rate character varying(4000),
    response_rate character varying(4000),
    downstream_signaling_effects character varying(4000),
    beneficial_effects character varying(4000),
    adverse_effects character varying(4000),
    pk_pd_parameter character varying(4000),
    pk_pd_value character varying(4000),
    effect_description character varying(4000),
    biomolecule_name character varying(4000),
    biomolecule_id character varying(4000),
    biomolecule_type character varying(4000),
    biomarker character varying(4000),
    biomarker_type character varying(4000),
    baseline_expr_pct character varying(4000),
    baseline_expr_number character varying(4000),
    baseline_expr_value_fold_mean character varying(4000),
    baseline_expr_sd character varying(4000),
    baseline_expr_sem character varying(4000),
    baseline_expr_unit character varying(4000),
    expr_after_trtmt_pct character varying(4000),
    expr_after_trtmt_number character varying(4000),
    expr_aftertrtmt_valuefold_mean character varying(4000),
    expr_after_trtmt_sd character varying(4000),
    expr_after_trtmt_sem character varying(4000),
    expr_after_trtmt_unit character varying(4000),
    expr_chg_source_type character varying(4000),
    expr_chg_technique character varying(4000),
    expr_chg_description character varying(4000),
    clinical_correlation character varying(4000),
    statistical_test character varying(4000),
    statistical_coefficient_value character varying(4000),
    statistical_test_p_value character varying(4000),
    statistical_test_description character varying(4000)
);


ALTER TABLE biomart.bio_clinical_trial_design OWNER TO biomart;

--
-- Name: bio_cohort_exp_xref; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_cohort_exp_xref (
    study_id character varying(255),
    cohort_id character varying(255),
    exp_id character varying(255)
);


ALTER TABLE biomart.bio_cohort_exp_xref OWNER TO biomart;

--
-- Name: bio_content; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_content (
    bio_file_content_id bigint NOT NULL,
    file_name character varying(1000),
    repository_id bigint,
    location character varying(400),
    title character varying(1000),
    abstract character varying(2000),
    file_type character varying(200) NOT NULL,
    etl_id bigint,
    etl_id_c character varying(30),
    study_name character varying(30),
    cel_location character varying(300),
    cel_file_suffix character varying(30)
);


ALTER TABLE biomart.bio_content OWNER TO biomart;

--
-- Name: bio_content_reference; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_content_reference (
    bio_content_reference_id bigint NOT NULL,
    bio_content_id bigint NOT NULL,
    bio_data_id bigint NOT NULL,
    content_reference_type character varying(200) NOT NULL,
    etl_id bigint,
    etl_id_c character varying(30)
);


ALTER TABLE biomart.bio_content_reference OWNER TO biomart;

--
-- Name: bio_content_repository; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_content_repository (
    bio_content_repo_id bigint NOT NULL,
    location character varying(510),
    active_y_n character(1),
    repository_type character varying(200) NOT NULL,
    location_type character varying(200)
);


ALTER TABLE biomart.bio_content_repository OWNER TO biomart;

--
-- Name: bio_curated_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_curated_data (
    statement text,
    statement_status character varying(200),
    bio_data_id bigint NOT NULL,
    bio_curation_dataset_id bigint NOT NULL,
    reference_id bigint,
    data_type character varying(200)
);


ALTER TABLE biomart.bio_curated_data OWNER TO biomart;

--
-- Name: bio_curation_dataset; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_curation_dataset (
    bio_curation_dataset_id bigint NOT NULL,
    bio_asy_analysis_pltfm_id bigint,
    bio_source_import_id bigint,
    bio_curation_type character varying(200) NOT NULL,
    create_date timestamp without time zone,
    creator bigint,
    bio_curation_name character varying(500),
    data_type character varying(100)
);


ALTER TABLE biomart.bio_curation_dataset OWNER TO biomart;

--
-- Name: bio_data_attribute; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_data_attribute (
    bio_data_attribute_id bigint NOT NULL,
    property_code character varying(200) NOT NULL,
    property_value character varying(200),
    bio_data_id bigint NOT NULL,
    property_unit character varying(100)
);


ALTER TABLE biomart.bio_data_attribute OWNER TO biomart;

--
-- Name: bio_data_compound; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_data_compound (
    bio_data_id bigint NOT NULL,
    bio_compound_id bigint NOT NULL,
    etl_source character varying(100)
);


ALTER TABLE biomart.bio_data_compound OWNER TO biomart;

--
-- Name: bio_data_correl_descr; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_data_correl_descr (
    bio_data_correl_descr_id bigint NOT NULL,
    correlation character varying(510),
    description character varying(1000),
    type_name character varying(200),
    status character varying(200),
    source character varying(100),
    source_code character varying(200)
);


ALTER TABLE biomart.bio_data_correl_descr OWNER TO biomart;

--
-- Name: bio_data_correlation; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_data_correlation (
    bio_data_id bigint NOT NULL,
    asso_bio_data_id bigint NOT NULL,
    bio_data_correl_descr_id bigint NOT NULL,
    bio_data_correl_id bigint NOT NULL
);


ALTER TABLE biomart.bio_data_correlation OWNER TO biomart;

--
-- Name: bio_data_disease; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_data_disease (
    bio_data_id bigint NOT NULL,
    bio_disease_id bigint NOT NULL,
    etl_source character varying(100)
);


ALTER TABLE biomart.bio_data_disease OWNER TO biomart;

--
-- Name: bio_data_ext_code; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_data_ext_code (
    bio_data_id bigint NOT NULL,
    code character varying(500) NOT NULL,
    code_source character varying(200),
    code_type character varying(200),
    bio_data_type character varying(100),
    bio_data_ext_code_id bigint NOT NULL,
    etl_id character varying(50)
);


ALTER TABLE biomart.bio_data_ext_code OWNER TO biomart;

--
-- Name: bio_data_literature; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_data_literature (
    bio_data_id bigint NOT NULL,
    bio_lit_ref_data_id bigint,
    bio_curation_dataset_id bigint NOT NULL,
    statement text,
    statement_status character varying(200),
    data_type character varying(200)
);


ALTER TABLE biomart.bio_data_literature OWNER TO biomart;

--
-- Name: bio_data_observation; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_data_observation (
    bio_data_id bigint,
    bio_observation_id bigint,
    etl_source character varying(100)
);


ALTER TABLE biomart.bio_data_observation OWNER TO biomart;

--
-- Name: bio_data_omic_marker; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_data_omic_marker (
    bio_data_id bigint,
    bio_marker_id bigint NOT NULL,
    data_table character varying(5)
);


ALTER TABLE biomart.bio_data_omic_marker OWNER TO biomart;

--
-- Name: bio_data_platform; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_data_platform (
    bio_data_id bigint,
    bio_assay_platform_id bigint,
    etl_source character varying(100)
);


ALTER TABLE biomart.bio_data_platform OWNER TO biomart;

--
-- Name: bio_data_taxonomy; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_data_taxonomy (
    bio_taxonomy_id bigint NOT NULL,
    bio_data_id bigint NOT NULL,
    etl_source character varying(100)
);


ALTER TABLE biomart.bio_data_taxonomy OWNER TO biomart;

--
-- Name: bio_experiment; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_experiment (
    bio_experiment_id bigint NOT NULL,
    bio_experiment_type character varying(200),
    title character varying(1000),
    description character varying(4000),
    design character varying(2000),
    start_date timestamp without time zone,
    completion_date timestamp without time zone,
    primary_investigator character varying(400),
    contact_field character varying(400),
    etl_id character varying(100),
    status character varying(100),
    overall_design character varying(2000),
    accession character varying(100),
    entrydt timestamp without time zone,
    updated timestamp without time zone,
    institution character varying(400),
    country character varying(1000),
    biomarker_type character varying(255),
    target character varying(255),
    access_type character varying(100)
);


ALTER TABLE biomart.bio_experiment OWNER TO biomart;

--
-- Name: bio_lit_alt_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_lit_alt_data (
    bio_lit_alt_data_id bigint NOT NULL,
    bio_lit_ref_data_id bigint NOT NULL,
    in_vivo_model_id bigint,
    in_vitro_model_id bigint,
    etl_id character varying(50),
    alteration_type character varying(50),
    control character varying(1000),
    effect character varying(500),
    description character varying(1000),
    techniques character varying(1000),
    patients_percent character varying(500),
    patients_number character varying(500),
    pop_number character varying(250),
    pop_inclusion_criteria character varying(1000),
    pop_exclusion_criteria character varying(1000),
    pop_description character varying(1000),
    pop_type character varying(250),
    pop_value character varying(250),
    pop_phase character varying(250),
    pop_status character varying(250),
    pop_experimental_model character varying(250),
    pop_tissue character varying(250),
    pop_body_substance character varying(250),
    pop_localization character varying(1000),
    pop_cell_type character varying(250),
    clin_submucosa_marker_type character varying(250),
    clin_submucosa_unit character varying(250),
    clin_submucosa_value character varying(250),
    clin_asm_marker_type character varying(250),
    clin_asm_unit character varying(250),
    clin_asm_value character varying(250),
    clin_cellular_source character varying(250),
    clin_cellular_type character varying(250),
    clin_cellular_count character varying(250),
    clin_prior_med_percent character varying(250),
    clin_prior_med_dose character varying(250),
    clin_prior_med_name character varying(250),
    clin_baseline_variable character varying(250),
    clin_baseline_percent character varying(250),
    clin_baseline_value character varying(250),
    clin_smoker character varying(250),
    clin_atopy character varying(250),
    control_exp_percent character varying(50),
    control_exp_number character varying(50),
    control_exp_value character varying(50),
    control_exp_sd character varying(50),
    control_exp_unit character varying(100),
    over_exp_percent character varying(50),
    over_exp_number character varying(50),
    over_exp_value character varying(50),
    over_exp_sd character varying(50),
    over_exp_unit character varying(100),
    loss_exp_percent character varying(50),
    loss_exp_number character varying(50),
    loss_exp_value character varying(50),
    loss_exp_sd character varying(50),
    loss_exp_unit character varying(100),
    total_exp_percent character varying(50),
    total_exp_number character varying(50),
    total_exp_value character varying(50),
    total_exp_sd character varying(50),
    total_exp_unit character varying(100),
    glc_control_percent character varying(250),
    glc_molecular_change character varying(250),
    glc_type character varying(50),
    glc_percent character varying(100),
    glc_number character varying(100),
    ptm_region character varying(250),
    ptm_type character varying(250),
    ptm_change character varying(250),
    loh_loci character varying(250),
    mutation_type character varying(250),
    mutation_change character varying(250),
    mutation_sites character varying(250),
    epigenetic_region character varying(250),
    epigenetic_type character varying(250)
);


ALTER TABLE biomart.bio_lit_alt_data OWNER TO biomart;

--
-- Name: bio_lit_amd_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_lit_amd_data (
    bio_lit_amd_data_id bigint NOT NULL,
    bio_lit_alt_data_id bigint NOT NULL,
    etl_id character varying(50),
    molecule character varying(50),
    molecule_type character varying(50),
    total_exp_percent character varying(50),
    total_exp_number character varying(100),
    total_exp_value character varying(100),
    total_exp_sd character varying(50),
    total_exp_unit character varying(50),
    over_exp_percent character varying(50),
    over_exp_number character varying(100),
    over_exp_value character varying(100),
    over_exp_sd character varying(50),
    over_exp_unit character varying(50),
    co_exp_percent character varying(50),
    co_exp_number character varying(100),
    co_exp_value character varying(100),
    co_exp_sd character varying(50),
    co_exp_unit character varying(50),
    mutation_type character varying(50),
    mutation_sites character varying(50),
    mutation_change character varying(50),
    mutation_percent character varying(50),
    mutation_number character varying(100),
    target_exp_percent character varying(50),
    target_exp_number character varying(100),
    target_exp_value character varying(100),
    target_exp_sd character varying(50),
    target_exp_unit character varying(50),
    target_over_exp_percent character varying(50),
    target_over_exp_number character varying(100),
    target_over_exp_value character varying(100),
    target_over_exp_sd character varying(50),
    target_over_exp_unit character varying(50),
    techniques character varying(250),
    description character varying(1000)
);


ALTER TABLE biomart.bio_lit_amd_data OWNER TO biomart;

--
-- Name: bio_lit_inh_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_lit_inh_data (
    bio_lit_inh_data_id bigint NOT NULL,
    bio_lit_ref_data_id bigint,
    etl_id character varying(50),
    trial_type character varying(250),
    trial_phase character varying(250),
    trial_status character varying(250),
    trial_experimental_model character varying(250),
    trial_tissue character varying(250),
    trial_body_substance character varying(250),
    trial_description character varying(1000),
    trial_designs character varying(250),
    trial_cell_line character varying(250),
    trial_cell_type character varying(250),
    trial_patients_number character varying(100),
    trial_inclusion_criteria character varying(2000),
    inhibitor character varying(250),
    inhibitor_standard_name character varying(250),
    casid character varying(250),
    description character varying(1000),
    concentration character varying(250),
    time_exposure character varying(500),
    administration character varying(250),
    treatment character varying(2000),
    techniques character varying(1000),
    effect_molecular character varying(250),
    effect_percent character varying(250),
    effect_number character varying(50),
    effect_value character varying(250),
    effect_sd character varying(250),
    effect_unit character varying(250),
    effect_response_rate character varying(250),
    effect_downstream character varying(2000),
    effect_beneficial character varying(2000),
    effect_adverse character varying(2000),
    effect_description character varying(2000),
    effect_pharmacos character varying(2000),
    effect_potentials character varying(2000)
);


ALTER TABLE biomart.bio_lit_inh_data OWNER TO biomart;

--
-- Name: bio_lit_int_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_lit_int_data (
    bio_lit_int_data_id bigint NOT NULL,
    bio_lit_ref_data_id bigint NOT NULL,
    in_vivo_model_id bigint,
    in_vitro_model_id bigint,
    etl_id character varying(50),
    source_component character varying(100),
    source_gene_id character varying(50),
    target_component character varying(100),
    target_gene_id character varying(50),
    interaction_mode character varying(250),
    regulation character varying(1000),
    mechanism character varying(250),
    effect character varying(500),
    localization character varying(500),
    region character varying(250),
    techniques character varying(1000)
);


ALTER TABLE biomart.bio_lit_int_data OWNER TO biomart;

--
-- Name: bio_lit_int_model_mv; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_lit_int_model_mv (
    bio_lit_int_data_id bigint,
    experimental_model character varying(250)
);


ALTER TABLE biomart.bio_lit_int_model_mv OWNER TO biomart;

--
-- Name: bio_lit_model_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_lit_model_data (
    bio_lit_model_data_id bigint NOT NULL,
    etl_id character varying(50),
    model_type character varying(50),
    description character varying(1000),
    stimulation character varying(1000),
    control_challenge character varying(500),
    challenge character varying(1000),
    sentization character varying(1000),
    zygosity character varying(250),
    experimental_model character varying(250),
    animal_wild_type character varying(250),
    tissue character varying(250),
    cell_type character varying(250),
    cell_line character varying(250),
    body_substance character varying(250),
    component character varying(250),
    gene_id character varying(250)
);


ALTER TABLE biomart.bio_lit_model_data OWNER TO biomart;

--
-- Name: bio_lit_int_model_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW bio_lit_int_model_view AS
 SELECT DISTINCT s.bio_lit_int_data_id, 
    s.experimental_model
   FROM (         SELECT a.bio_lit_int_data_id, 
                    b.experimental_model
                   FROM (bio_lit_int_data a
              JOIN bio_lit_model_data b ON ((a.in_vivo_model_id = b.bio_lit_model_data_id)))
             WHERE (b.experimental_model IS NOT NULL)
        UNION 
                 SELECT a.bio_lit_int_data_id, 
                    b.experimental_model
                   FROM (bio_lit_int_data a
              JOIN bio_lit_model_data b ON ((a.in_vitro_model_id = b.bio_lit_model_data_id)))
             WHERE (b.experimental_model IS NOT NULL)) s;


ALTER TABLE biomart.bio_lit_int_model_view OWNER TO biomart;

--
-- Name: bio_lit_pe_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_lit_pe_data (
    bio_lit_pe_data_id bigint NOT NULL,
    bio_lit_ref_data_id bigint NOT NULL,
    in_vivo_model_id bigint,
    in_vitro_model_id bigint,
    etl_id character varying(50),
    description character varying(2000)
);


ALTER TABLE biomart.bio_lit_pe_data OWNER TO biomart;

--
-- Name: bio_lit_ref_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_lit_ref_data (
    bio_lit_ref_data_id bigint NOT NULL,
    etl_id character varying(50),
    component character varying(100),
    component_class character varying(250),
    gene_id character varying(50),
    molecule_type character varying(50),
    variant character varying(250),
    reference_type character varying(50),
    reference_id character varying(250),
    reference_title character varying(2000),
    back_references character varying(1000),
    study_type character varying(250),
    disease character varying(250),
    disease_icd10 character varying(250),
    disease_mesh character varying(250),
    disease_site character varying(250),
    disease_stage character varying(250),
    disease_grade character varying(250),
    disease_types character varying(250),
    disease_description character varying(1000),
    physiology character varying(250),
    stat_clinical character varying(500),
    stat_clinical_correlation character varying(250),
    stat_tests character varying(500),
    stat_coefficient character varying(500),
    stat_p_value character varying(100),
    stat_description character varying(1000)
);


ALTER TABLE biomart.bio_lit_ref_data OWNER TO biomart;

--
-- Name: bio_lit_sum_data; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_lit_sum_data (
    bio_lit_sum_data_id bigint NOT NULL,
    etl_id character varying(50),
    disease_site character varying(250),
    target character varying(50),
    variant character varying(50),
    data_type character varying(50),
    alteration_type character varying(100),
    total_frequency character varying(50),
    total_affected_cases character varying(50),
    summary character varying(1000)
);


ALTER TABLE biomart.bio_lit_sum_data OWNER TO biomart;

--
-- Name: bio_marker_correl_mv; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW bio_marker_correl_mv AS
        (        (        (        (        (        (         SELECT DISTINCT b.bio_marker_id, 
                                                            b.bio_marker_id AS asso_bio_marker_id, 
                                                            'GENE'::text AS correl_type, 
                                                            1 AS mv_id
                                                           FROM bio_marker b
                                                          WHERE ((b.bio_marker_type)::text = 'GENE'::text)
                                                UNION 
                                                         SELECT DISTINCT b.bio_marker_id, 
                                                            b.bio_marker_id AS asso_bio_marker_id, 
                                                            'PROTEIN'::text AS correl_type, 
                                                            4 AS mv_id
                                                           FROM bio_marker b
                                                          WHERE ((b.bio_marker_type)::text = 'PROTEIN'::text))
                                        UNION 
                                                 SELECT DISTINCT b.bio_marker_id, 
                                                    b.bio_marker_id AS asso_bio_marker_id, 
                                                    'MIRNA'::text AS correl_type, 
                                                    7 AS mv_id
                                                   FROM bio_marker b
                                                  WHERE ((b.bio_marker_type)::text = 'MIRNA'::text))
                                UNION 
                                         SELECT DISTINCT c.bio_data_id AS bio_marker_id, 
                                            c.asso_bio_data_id AS asso_bio_marker_id, 
                                            'PATHWAY GENE'::text AS correl_type, 
                                            2 AS mv_id
                                           FROM bio_marker b, 
                                            bio_data_correlation c, 
                                            bio_data_correl_descr d
                                          WHERE ((((b.bio_marker_id = c.bio_data_id) AND (c.bio_data_correl_descr_id = d.bio_data_correl_descr_id)) AND ((b.primary_source_code)::text <> 'ARIADNE'::text)) AND ((d.correlation)::text = 'PATHWAY GENE'::text)))
                        UNION 
                                 SELECT DISTINCT c.bio_data_id AS bio_marker_id, 
                                    c.asso_bio_data_id AS asso_bio_marker_id, 
                                    'HOMOLOGENE_GENE'::text AS correl_type, 
                                    3 AS mv_id
                                   FROM bio_marker b, 
                                    bio_data_correlation c, 
                                    bio_data_correl_descr d
                                  WHERE (((b.bio_marker_id = c.bio_data_id) AND (c.bio_data_correl_descr_id = d.bio_data_correl_descr_id)) AND ((d.correlation)::text = 'HOMOLOGENE GENE'::text)))
                UNION 
                         SELECT DISTINCT c.bio_data_id AS bio_marker_id, 
                            c.asso_bio_data_id AS asso_bio_marker_id, 
                            'PROTEIN TO GENE'::text AS correl_type, 
                            5 AS mv_id
                           FROM bio_marker b, 
                            bio_data_correlation c, 
                            bio_data_correl_descr d
                          WHERE (((b.bio_marker_id = c.bio_data_id) AND (c.bio_data_correl_descr_id = d.bio_data_correl_descr_id)) AND ((d.correlation)::text = 'PROTEIN TO GENE'::text)))
        UNION 
                 SELECT DISTINCT c.bio_data_id AS bio_marker_id, 
                    c.asso_bio_data_id AS asso_bio_marker_id, 
                    'GENE TO PROTEIN'::text AS correl_type, 
                    6 AS mv_id
                   FROM bio_marker b, 
                    bio_data_correlation c, 
                    bio_data_correl_descr d
                  WHERE (((b.bio_marker_id = c.bio_data_id) AND (c.bio_data_correl_descr_id = d.bio_data_correl_descr_id)) AND ((d.correlation)::text = 'GENE TO PROTEIN'::text)))
UNION 
         SELECT DISTINCT c1.bio_data_id AS bio_marker_id, 
            c2.asso_bio_data_id AS asso_bio_marker_id, 
            'PATHWAY TO PROTEIN'::text AS correl_type, 
            8 AS mv_id
           FROM (((bio_data_correlation c1
      JOIN bio_data_correlation c2 ON ((c1.asso_bio_data_id = c2.bio_data_id)))
   JOIN bio_data_correl_descr d1 ON ((c1.bio_data_correl_descr_id = d1.bio_data_correl_descr_id)))
   JOIN bio_data_correl_descr d2 ON ((c2.bio_data_correl_descr_id = d2.bio_data_correl_descr_id)))
  WHERE (((d1.correlation)::text = 'PATHWAY GENE'::text) AND ((d2.correlation)::text = 'GENE TO PROTEIN'::text));


ALTER TABLE biomart.bio_marker_correl_mv OWNER TO biomart;

--
-- Name: bio_marker_correl_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW bio_marker_correl_view AS
        (         SELECT DISTINCT b.bio_marker_id, 
                    b.bio_marker_id AS asso_bio_marker_id, 
                    'GENE'::text AS correl_type, 
                    1 AS mv_id
                   FROM bio_marker b
                  WHERE ((b.bio_marker_type)::text = 'GENE'::text)
        UNION 
                 SELECT DISTINCT c.bio_data_id AS bio_marker_id, 
                    c.asso_bio_data_id AS asso_bio_marker_id, 
                    'PATHWAY_GENE'::text AS correl_type, 
                    2 AS mv_id
                   FROM bio_marker b, 
                    bio_data_correlation c, 
                    bio_data_correl_descr d
                  WHERE ((((b.bio_marker_id = c.bio_data_id) AND (c.bio_data_correl_descr_id = d.bio_data_correl_descr_id)) AND ((b.primary_source_code)::text <> 'ARIADNE'::text)) AND ((d.correlation)::text = 'PATHWAY GENE'::text)))
UNION 
         SELECT DISTINCT c.bio_data_id AS bio_marker_id, 
            c.asso_bio_data_id AS asso_bio_marker_id, 
            'HOMOLOGENE_GENE'::text AS correl_type, 
            3 AS mv_id
           FROM bio_marker b, 
            bio_data_correlation c, 
            bio_data_correl_descr d
          WHERE (((b.bio_marker_id = c.bio_data_id) AND (c.bio_data_correl_descr_id = d.bio_data_correl_descr_id)) AND ((d.correlation)::text = 'HOMOLOGENE GENE'::text));


ALTER TABLE biomart.bio_marker_correl_view OWNER TO biomart;

--
-- Name: bio_marker_exp_analysis_mv; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW bio_marker_exp_analysis_mv AS
 SELECT DISTINCT t3.bio_marker_id, 
    t1.bio_experiment_id, 
    t1.bio_assay_analysis_id, 
    ((t1.bio_assay_analysis_id * 100) + t3.bio_marker_id) AS mv_id
   FROM bio_assay_analysis_data t1, 
    bio_experiment t2, 
    bio_marker t3, 
    bio_assay_data_annotation t4
  WHERE ((((t1.bio_experiment_id = t2.bio_experiment_id) AND ((t2.bio_experiment_type)::text = 'Experiment'::text)) AND (t3.bio_marker_id = t4.bio_marker_id)) AND (t1.bio_assay_feature_group_id = t4.bio_assay_feature_group_id));


ALTER TABLE biomart.bio_marker_exp_analysis_mv OWNER TO biomart;

SET search_path = deapp, pg_catalog;

--
-- Name: de_metabolite_annotation; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_metabolite_annotation (
    id bigint NOT NULL,
    gpl_id character varying(50) NOT NULL,
    biochemical_name character varying(200) NOT NULL,
    biomarker_id character varying(200),
    hmdb_id character varying(50)
);


ALTER TABLE deapp.de_metabolite_annotation OWNER TO deapp;

--
-- Name: de_metabolite_sub_pathways; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_metabolite_sub_pathways (
    id bigint NOT NULL,
    gpl_id character varying(50) NOT NULL,
    sub_pathway_name character varying(200) NOT NULL,
    super_pathway_id bigint
);


ALTER TABLE deapp.de_metabolite_sub_pathways OWNER TO deapp;

--
-- Name: de_metabolite_sub_pway_metab; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_metabolite_sub_pway_metab (
    metabolite_id bigint NOT NULL,
    sub_pathway_id bigint NOT NULL
);


ALTER TABLE deapp.de_metabolite_sub_pway_metab OWNER TO deapp;

SET search_path = biomart, pg_catalog;

--
-- Name: bio_metab_subpathway_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW bio_metab_subpathway_view AS
 SELECT sp.id AS subpathway_id, 
    b.bio_marker_id AS asso_bio_marker_id, 
    'SUBPATHWAY TO METABOLITE'::text AS correl_type
   FROM (((deapp.de_metabolite_sub_pathways sp
   JOIN deapp.de_metabolite_sub_pway_metab j ON ((sp.id = j.sub_pathway_id)))
   JOIN deapp.de_metabolite_annotation m ON ((m.id = j.metabolite_id)))
   JOIN bio_marker b ON ((((b.bio_marker_type)::text = 'METABOLITE'::text) AND ((b.primary_external_id)::text = (m.hmdb_id)::text))));


ALTER TABLE biomart.bio_metab_subpathway_view OWNER TO biomart;

SET search_path = deapp, pg_catalog;

--
-- Name: de_metabolite_super_pathways; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_metabolite_super_pathways (
    id bigint NOT NULL,
    gpl_id character varying(50) NOT NULL,
    super_pathway_name character varying(200)
);


ALTER TABLE deapp.de_metabolite_super_pathways OWNER TO deapp;

SET search_path = biomart, pg_catalog;

--
-- Name: bio_metab_superpathway_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW bio_metab_superpathway_view AS
 SELECT supp.id AS superpathway_id, 
    b.bio_marker_id AS asso_bio_marker_id, 
    'SUPERPATHWAY TO METABOLITE'::text AS correl_type
   FROM ((((deapp.de_metabolite_super_pathways supp
   JOIN deapp.de_metabolite_sub_pathways subp ON ((supp.id = subp.super_pathway_id)))
   JOIN deapp.de_metabolite_sub_pway_metab j ON ((subp.id = j.sub_pathway_id)))
   JOIN deapp.de_metabolite_annotation m ON ((m.id = j.metabolite_id)))
   JOIN bio_marker b ON ((((b.bio_marker_type)::text = 'METABOLITE'::text) AND ((b.primary_external_id)::text = (m.hmdb_id)::text))));


ALTER TABLE biomart.bio_metab_superpathway_view OWNER TO biomart;

--
-- Name: bio_patient; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_patient (
    bio_patient_id bigint NOT NULL,
    first_name character varying(200),
    last_name character varying(200),
    middle_name character varying(200),
    birth_date timestamp without time zone,
    birth_date_orig character varying(200),
    gender_code character varying(200),
    race_code character varying(200),
    ethnic_group_code character varying(200),
    address_zip_code character varying(200),
    country_code character varying(200),
    informed_consent_code character varying(200),
    bio_experiment_id bigint,
    bio_clinical_trial_p_group_id bigint
);


ALTER TABLE biomart.bio_patient OWNER TO biomart;

--
-- Name: bio_patient_event; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_patient_event (
    bio_patient_event_id bigint NOT NULL,
    bio_patient_id bigint NOT NULL,
    event_code character varying(200),
    event_type_code character varying(200),
    event_date timestamp without time zone,
    site character varying(400),
    bio_clinic_trial_timepoint_id bigint NOT NULL
);


ALTER TABLE biomart.bio_patient_event OWNER TO biomart;

--
-- Name: bio_patient_event_attr; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_patient_event_attr (
    bio_patient_attr_code character varying(200) NOT NULL,
    attribute_text_value character varying(200),
    attribute_numeric_value character varying(200),
    bio_clinic_trial_attr_id bigint NOT NULL,
    bio_patient_attribute_id bigint NOT NULL,
    bio_patient_event_id bigint NOT NULL
);


ALTER TABLE biomart.bio_patient_event_attr OWNER TO biomart;

--
-- Name: bio_recombination_rates; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_recombination_rates (
    chromosome character varying(20),
    "position" numeric(18,0),
    rate numeric(18,6),
    map numeric(18,6)
);


ALTER TABLE biomart.bio_recombination_rates OWNER TO biomart;

--
-- Name: bio_regulome_score; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_regulome_score (
    chromosome character varying(20),
    "position" numeric(18,0),
    rs_id character varying(100),
    score character varying(10)
);


ALTER TABLE biomart.bio_regulome_score OWNER TO biomart;

--
-- Name: bio_sample; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_sample (
    bio_sample_id bigint NOT NULL,
    bio_sample_type character varying(200) NOT NULL,
    characteristics character varying(1000),
    source_code character varying(200),
    experiment_id bigint,
    bio_subject_id bigint,
    source character varying(200),
    bio_bank_id bigint,
    bio_patient_event_id bigint,
    bio_cell_line_id bigint,
    bio_sample_name character varying(100)
);


ALTER TABLE biomart.bio_sample OWNER TO biomart;

--
-- Name: bio_species_organism; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_species_organism (
    id bigint,
    species character varying(200),
    organism character varying(200)
);


ALTER TABLE biomart.bio_species_organism OWNER TO biomart;

--
-- Name: bio_stats_exp_marker; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_stats_exp_marker (
    bio_marker_id bigint NOT NULL,
    bio_experiment_id bigint NOT NULL,
    bio_stats_exp_marker_id bigint
);


ALTER TABLE biomart.bio_stats_exp_marker OWNER TO biomart;

--
-- Name: bio_subject; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_subject (
    bio_subject_id bigint NOT NULL,
    site_subject_id bigint,
    source character varying(200),
    source_code character varying(200),
    status character varying(200),
    organism character varying(200),
    bio_subject_type character varying(200) NOT NULL
);


ALTER TABLE biomart.bio_subject OWNER TO biomart;

--
-- Name: bio_taxonomy; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE bio_taxonomy (
    bio_taxonomy_id bigint NOT NULL,
    taxon_name character varying(200) NOT NULL,
    taxon_label character varying(200) NOT NULL,
    ncbi_tax_id character varying(200)
);


ALTER TABLE biomart.bio_taxonomy OWNER TO biomart;

--
-- Name: biobank_sample; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE biobank_sample (
    sample_tube_id character varying(255) NOT NULL,
    accession_number character varying(255) NOT NULL,
    client_sample_tube_id character varying(255) NOT NULL,
    container_id character varying(255) NOT NULL,
    import_date timestamp without time zone,
    source_type character varying(255) NOT NULL
);


ALTER TABLE biomart.biobank_sample OWNER TO biomart;

--
-- Name: cta_results; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE cta_results (
    bio_assay_analysis_id bigint,
    search_keyword_id bigint,
    keyword character varying(400),
    bio_marker_id bigint,
    bio_marker_name character varying(200),
    gene_id character varying(200),
    probe_id character varying(100),
    fold_change double precision,
    preferred_pvalue double precision,
    organism character varying(100)
);


ALTER TABLE biomart.cta_results OWNER TO biomart;

--
-- Name: ctd2_clin_inhib_effect; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd2_clin_inhib_effect (
    ctd_cie_seq bigint,
    ctd_study_id bigint,
    event_description_name character varying(4000),
    event_definition_name character varying(4000),
    adverse_effect_name character varying(4000),
    signal_effect_name character varying(4000),
    pharmaco_parameter_name character varying(500),
    discontinuation_rate_value character varying(250),
    beneficial_effect_name character varying(4000),
    drug_effect character varying(4000),
    clinical_variable_name character varying(250),
    qp_sm_percentage_change character varying(250),
    qp_sm_absolute_change character varying(250),
    qp_sm_rate_of_change character varying(250),
    qp_sm_treatment_period character varying(250),
    qp_sm_group_change character varying(250),
    qp_sm_p_value character varying(250),
    ce_sm_no character varying(250),
    ce_sm_event_rate character varying(250),
    ce_time_to_event character varying(250),
    ce_reduction character varying(250),
    ce_p_value character varying(250),
    clinical_correlation character varying(2000),
    coefficient_value character varying(250),
    statistics_p_value character varying(250),
    statistics_description character varying(4000),
    primary_endpoint_type character varying(250),
    primary_endpoint_definition character varying(4000),
    primary_endpoint_test_name character varying(2000),
    primary_endpoint_time_period character varying(2000),
    primary_endpoint_change character varying(2000),
    primary_endpoint_p_value character varying(2000),
    secondary_endpoint_type character varying(2000),
    secondary_endpoint_definition character varying(4000),
    secondary_endpoint_test_name character varying(2000),
    secondary_endpoint_time_period character varying(4000),
    secondary_endpoint_change character varying(4000),
    secondary_endpoint_p_value character varying(4000)
);


ALTER TABLE biomart.ctd2_clin_inhib_effect OWNER TO biomart;

--
-- Name: ctd2_disease; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd2_disease (
    ctd_disease_seq bigint,
    ctd_study_id bigint,
    disease_type_name character varying(500),
    disease_common_name character varying(500),
    icd10_name character varying(250),
    mesh_name character varying(250),
    study_type_name character varying(2000),
    physiology_name character varying(500)
);


ALTER TABLE biomart.ctd2_disease OWNER TO biomart;

--
-- Name: ctd2_inhib_details; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd2_inhib_details (
    ctd_inhib_seq bigint,
    ctd_study_id bigint,
    common_name_name character varying(500),
    standard_name_name character varying(500),
    experimental_detail_dose character varying(4000),
    exp_detail_exposure_period character varying(4000),
    exp_detail_treatment_name character varying(4000),
    exp_detail_admin_route character varying(4000),
    exp_detail_description character varying(4000),
    exp_detail_placebo character varying(250),
    comparator_name_name character varying(250),
    comp_treatment_name character varying(4000),
    comp_admin_route character varying(4000),
    comp_dose character varying(2000),
    comp_exposure_period character varying(2000)
);


ALTER TABLE biomart.ctd2_inhib_details OWNER TO biomart;

--
-- Name: ctd2_study; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd2_study (
    ctd_study_id bigint,
    ref_article_protocol_id character varying(1000),
    reference_id integer NOT NULL,
    pubmed_id character varying(250),
    pubmed_title character varying(2000),
    protocol_id character varying(1000),
    protocol_title character varying(2000)
);


ALTER TABLE biomart.ctd2_study OWNER TO biomart;

--
-- Name: ctd2_trial_details; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd2_trial_details (
    ctd_td_seq bigint,
    ctd_study_id bigint,
    control character varying(2000),
    blinding_procedure character varying(2000),
    no_of_arms character varying(2000),
    sponsor character varying(2000),
    patient_studied character varying(2000),
    source_type character varying(2000),
    trial_description character varying(4000),
    arm_name character varying(250),
    patient_study character varying(250),
    class_type character varying(250),
    class_value character varying(250),
    asthma_duration character varying(250),
    region character varying(250),
    age character varying(100),
    gender character varying(100),
    minor_participation character varying(100),
    symptom_score character varying(100),
    rescue_medication character varying(2000),
    therapeutic_intervention character varying(255),
    smokers character varying(255),
    former_smokers character varying(255),
    never_smokers character varying(255),
    smoking_pack_years character varying(255),
    pulm_path_name character varying(255),
    pulm_path_pct character varying(50),
    pulm_path_value character varying(50),
    pulm_path_method character varying(255),
    allow_med_therapy_ocs character varying(1000),
    allow_med_therapy_ics character varying(1000),
    allow_med_therapy_laba character varying(1000),
    allow_med_therapy_ltra character varying(1000),
    allow_med_therapy_desc character varying(4000),
    allow_med_therapy_cortster character varying(1000),
    allow_med_therapy_immuno character varying(1000),
    allow_med_therapy_cyto character varying(1000),
    allow_med_treat_ocs character varying(1000),
    allow_med_treat_ics character varying(1000),
    allow_med_treat_laba character varying(1000),
    allow_med_treat_ltra character varying(1000),
    allow_med_treat_desc character varying(4000),
    allow_med_treat_cortster character varying(1000),
    allow_med_treat_immuno character varying(1000),
    allow_med_treat_cyto character varying(1000),
    pat_char_base_clin_var character varying(500),
    pat_char_base_clin_var_pct character varying(250),
    pat_char_base_clin_var_value character varying(250),
    biomarker_name_name character varying(250),
    pat_char_biomarker_pct character varying(250),
    pat_char_biomarker_value character varying(250),
    pat_char_cellinfo_name character varying(250),
    pat_char_cellinfo_type character varying(250),
    pat_char_cellinfo_count character varying(250),
    pat_char_priormed_name character varying(250),
    pat_char_priormed_pct character varying(500),
    pat_char_priormed_dose character varying(250),
    disease_phenotype_name character varying(1000),
    disease_severity_name character varying(500),
    incl_age character varying(2000),
    incl_difficult_to_treat character varying(2000),
    incl_disease_diagnosis character varying(2000),
    incl_steroid_dose character varying(2000),
    incl_laba character varying(2000),
    incl_ocs character varying(2000),
    incl_xolair character varying(2000),
    incl_ltra_inhibitor character varying(2000),
    incl_fev1 character varying(2000),
    incl_fev1_reversibility character varying(2000),
    incl_smoking character varying(2000),
    incl_tlc character varying(2000),
    incl_fvc character varying(2000),
    incl_dlco character varying(2000),
    incl_sgrq character varying(2000),
    incl_hrct character varying(2000),
    incl_biopsy character varying(2000),
    incl_dypsnea_on_exertion character varying(2000),
    incl_concomitant_med character varying(2000),
    incl_former_smokers character varying(2000),
    incl_never_smokers character varying(2000),
    incl_smoking_pack_years character varying(2000),
    incl_fev_fvc character varying(2000),
    trial_des_minimal_symptom character varying(2000),
    trial_des_rescue_med character varying(4000),
    trial_des_exclusion_criteria character varying(4000),
    trial_des_open_label_status character varying(250),
    trial_des_random_status character varying(250),
    trial_des_nature_of_trial character varying(250),
    trial_des_blinded_status character varying(250),
    trial_des_run_in_period character varying(2000),
    trial_des_treatment character varying(2000),
    trial_des_washout_period character varying(2000),
    trial_status_name character varying(2000),
    trial_phase_name character varying(2000)
);


ALTER TABLE biomart.ctd2_trial_details OWNER TO biomart;

--
-- Name: ctd_allowed_meds_treatment; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd_allowed_meds_treatment (
    ctd_study_id bigint,
    trtmt_ocs character varying(4000),
    trtmt_ics character varying(4000),
    trtmt_laba character varying(4000),
    trtmt_ltra character varying(4000),
    trtmt_corticosteroids character varying(4000),
    trtmt_anti_fibrotics character varying(4000),
    trtmt_immunosuppressive character varying(4000),
    trtmt_cytotoxic character varying(4000)
);


ALTER TABLE biomart.ctd_allowed_meds_treatment OWNER TO biomart;

--
-- Name: ctd_full; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd_full (
    clinical_trial_design_id bigint,
    ref_article_protocol_id character varying(4000),
    ref_record_id character varying(4000),
    ref_back_reference character varying(4000),
    ref_article_pmid character varying(4000),
    ref_protocol_id character varying(4000),
    ref_title character varying(4000),
    study_type character varying(4000),
    common_name character varying(4000),
    icd10 character varying(4000),
    mesh character varying(4000),
    disease_type character varying(4000),
    physiology_name character varying(4000),
    trial_status character varying(4000),
    trial_phase character varying(4000),
    nature_of_trial character varying(4000),
    randomization character varying(4000),
    blinded_trial character varying(4000),
    trial_type character varying(4000),
    run_in_period character varying(4000),
    treatment_period character varying(4000),
    washout_period character varying(4000),
    open_label_extension character varying(4000),
    sponsor character varying(4000),
    trial_nbr_of_patients_studied character varying(4000),
    source_type character varying(4000),
    trial_age character varying(4000),
    disease_severity character varying(4000),
    difficult_to_treat character varying(4000),
    asthma_diagnosis character varying(4000),
    inhaled_steroid_dose character varying(4000),
    laba character varying(4000),
    ocs character varying(4000),
    xolair character varying(4000),
    ltra_inhibitors character varying(4000),
    asthma_phenotype character varying(4000),
    fev1 character varying(4000),
    fev1_reversibility character varying(4000),
    tlc character varying(4000),
    fev1_fvc character varying(4000),
    fvc character varying(4000),
    dlco character varying(4000),
    sgrq character varying(4000),
    hrct character varying(4000),
    biopsy character varying(4000),
    dyspnea_on_exertion character varying(4000),
    concomitant_med character varying(4000),
    trial_smokers_pct character varying(4000),
    trial_former_smokers_pct character varying(4000),
    trial_never_smokers_pct character varying(4000),
    trial_pack_years character varying(4000),
    exclusion_criteria text,
    minimal_symptoms character varying(4000),
    rescue_medication_use character varying(4000),
    control_details character varying(4000),
    blinding_procedure character varying(4000),
    number_of_arms character varying(4000),
    description text,
    arm character varying(4000),
    arm_nbr_of_patients_studied character varying(4000),
    arm_classification_type character varying(4000),
    arm_classification_value character varying(4000),
    arm_asthma_duration character varying(4000),
    arm_geographic_region character varying(4000),
    arm_age character varying(4000),
    arm_gender character varying(4000),
    arm_smokers_pct character varying(4000),
    arm_former_smokers_pct character varying(4000),
    arm_never_smokers_pct character varying(4000),
    arm_pack_years character varying(4000),
    minority_participation character varying(4000),
    baseline_symptom_score character varying(4000),
    baseline_rescue_medication_use character varying(4000),
    clinical_variable character varying(4000),
    clinical_variable_pct character varying(4000),
    clinical_variable_value character varying(4000),
    prior_med_drug_name character varying(4000),
    prior_med_pct character varying(4000),
    prior_med_value character varying(4000),
    biomarker_name character varying(4000),
    biomarker_pct character varying(4000),
    biomarker_value character varying(4000),
    cellinfo_type character varying(4000),
    cellinfo_count character varying(4000),
    cellinfo_source character varying(4000),
    pulmonary_pathology_name character varying(4000),
    pulmpath_patient_pct character varying(4000),
    pulmpath_value_unit character varying(4000),
    pulmpath_method character varying(4000),
    runin_ocs character varying(4000),
    runin_ics character varying(4000),
    runin_laba character varying(4000),
    runin_ltra character varying(4000),
    runin_corticosteroids character varying(4000),
    runin_anti_fibrotics character varying(4000),
    runin_immunosuppressive character varying(4000),
    runin_cytotoxic character varying(4000),
    runin_description character varying(4000),
    trtmt_ocs character varying(4000),
    trtmt_ics character varying(4000),
    trtmt_laba character varying(4000),
    trtmt_ltra character varying(4000),
    trtmt_corticosteroids character varying(4000),
    trtmt_anti_fibrotics character varying(4000),
    trtmt_immunosuppressive character varying(4000),
    trtmt_cytotoxic character varying(4000),
    trtmt_description character varying(4000),
    drug_inhibitor_common_name character varying(4000),
    drug_inhibitor_standard_name character varying(4000),
    drug_inhibitor_cas_id character varying(4000),
    drug_inhibitor_dose character varying(4000),
    drug_inhibitor_route_of_admin character varying(4000),
    drug_inhibitor_trtmt_regime character varying(4000),
    comparator_name character varying(4000),
    comparator_dose character varying(4000),
    comparator_time_period character varying(4000),
    comparator_route_of_admin character varying(4000),
    treatment_regime character varying(4000),
    placebo character varying(4000),
    experiment_description character varying(4000),
    primary_endpoint_type character varying(4000),
    primary_endpoint_definition character varying(4000),
    primary_endpoint_change character varying(4000),
    primary_endpoint_time_period character varying(4000),
    primary_endpoint_stat_test character varying(4000),
    primary_endpoint_p_value character varying(4000),
    secondary_type character varying(4000),
    secondary_type_definition character varying(4000),
    secondary_type_change character varying(4000),
    secondary_type_time_period character varying(4000),
    secondary_type_p_value character varying(4000),
    secondary_type_stat_test character varying(4000),
    clinical_variable_name character varying(4000),
    pct_change_from_baseline character varying(4000),
    abs_change_from_baseline character varying(4000),
    rate_of_change_from_baseline character varying(4000),
    average_over_treatment_period character varying(4000),
    within_group_changes character varying(4000),
    stat_measure_p_value character varying(4000),
    definition_of_the_event character varying(4000),
    number_of_events character varying(4000),
    event_rate character varying(4000),
    time_to_event character varying(4000),
    event_pct_reduction character varying(4000),
    event_p_value character varying(4000),
    event_description character varying(4000),
    discontinuation_rate character varying(4000),
    response_rate character varying(4000),
    downstream_signaling_effects character varying(4000),
    beneficial_effects character varying(4000),
    adverse_effects character varying(4000),
    pk_pd_parameter character varying(4000),
    pk_pd_value character varying(4000),
    effect_description character varying(4000),
    biomolecule_name character varying(4000),
    biomolecule_id character varying(4000),
    biomolecule_type character varying(4000),
    biomarker character varying(4000),
    biomarker_type character varying(4000),
    baseline_expr_pct character varying(4000),
    baseline_expr_number character varying(4000),
    baseline_expr_value_fold_mean character varying(4000),
    baseline_expr_sd character varying(4000),
    baseline_expr_sem character varying(4000),
    baseline_expr_unit character varying(4000),
    expr_after_trtmt_pct character varying(4000),
    expr_after_trtmt_number character varying(4000),
    expr_aftertrtmt_valuefold_mean character varying(4000),
    expr_after_trtmt_sd character varying(4000),
    expr_after_trtmt_sem character varying(4000),
    expr_after_trtmt_unit character varying(4000),
    expr_chg_source_type character varying(4000),
    expr_chg_technique character varying(4000),
    expr_chg_description character varying(4000),
    clinical_correlation character varying(4000),
    statistical_test character varying(4000),
    statistical_coefficient_value character varying(4000),
    statistical_test_p_value character varying(4000),
    statistical_test_description character varying(4000),
    drug_inhibitor_time_period character varying(4000)
);


ALTER TABLE biomart.ctd_full OWNER TO biomart;

--
-- Name: ctd_arm_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_arm_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.arm, v.arm_nbr_of_patients_studied) AS id, 
    v.ref_article_protocol_id, 
    v.arm, 
    v.arm_nbr_of_patients_studied, 
    v.arm_classification_type, 
    v.arm_classification_value, 
    v.arm_asthma_duration, 
    v.arm_geographic_region, 
    v.arm_age, 
    v.arm_gender, 
    v.arm_smokers_pct, 
    v.arm_former_smokers_pct, 
    v.arm_never_smokers_pct, 
    v.arm_pack_years, 
    v.minority_participation, 
    v.baseline_symptom_score, 
    v.baseline_rescue_medication_use
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.arm, 
            to_number((ctd_full.arm_nbr_of_patients_studied)::text, '999999999999999'::text) AS arm_nbr_of_patients_studied, 
            ctd_full.arm_classification_type, 
            ctd_full.arm_classification_value, 
            ctd_full.arm_asthma_duration, 
            ctd_full.arm_geographic_region, 
            ctd_full.arm_age, 
            ctd_full.arm_gender, 
            ctd_full.arm_smokers_pct, 
            ctd_full.arm_former_smokers_pct, 
            ctd_full.arm_never_smokers_pct, 
            ctd_full.arm_pack_years, 
            ctd_full.minority_participation, 
            ctd_full.baseline_symptom_score, 
            ctd_full.baseline_rescue_medication_use
           FROM ctd_full
          WHERE ((ctd_full.arm IS NOT NULL) AND ((ctd_full.arm)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.arm, to_number((ctd_full.arm_nbr_of_patients_studied)::text, '999999999999999'::text)) v;


ALTER TABLE biomart.ctd_arm_view OWNER TO biomart;

--
-- Name: ctd_biomarker; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd_biomarker (
    ctd_study_id bigint,
    biomarker_name character varying(4000),
    biomarker_pct character varying(4000),
    biomarker_value character varying(4000)
);


ALTER TABLE biomart.ctd_biomarker OWNER TO biomart;

--
-- Name: ctd_biomarker_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_biomarker_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.biomarker_name) AS id, 
    v.ref_article_protocol_id, 
    v.biomarker_name, 
    v.biomarker_pct, 
    v.biomarker_value
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.biomarker_name, 
            ctd_full.biomarker_pct, 
            ctd_full.biomarker_value
           FROM ctd_full
          WHERE ((ctd_full.biomarker_name IS NOT NULL) AND ((ctd_full.biomarker_name)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.biomarker_name) v;


ALTER TABLE biomart.ctd_biomarker_view OWNER TO biomart;

--
-- Name: ctd_cell_info_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_cell_info_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.cellinfo_type) AS id, 
    v.ref_article_protocol_id, 
    v.cellinfo_type, 
    v.cellinfo_count, 
    v.cellinfo_source
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.cellinfo_type, 
            ctd_full.cellinfo_count, 
            ctd_full.cellinfo_source
           FROM ctd_full
          WHERE ((ctd_full.cellinfo_type IS NOT NULL) AND ((ctd_full.cellinfo_type)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.cellinfo_type) v;


ALTER TABLE biomart.ctd_cell_info_view OWNER TO biomart;

--
-- Name: ctd_clinical_chars_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_clinical_chars_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.clinical_variable) AS id, 
    v.ref_article_protocol_id, 
    v.clinical_variable, 
    v.clinical_variable_pct, 
    v.clinical_variable_value
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.clinical_variable, 
            ctd_full.clinical_variable_pct, 
            ctd_full.clinical_variable_value
           FROM ctd_full
          WHERE ((ctd_full.clinical_variable IS NOT NULL) AND ((ctd_full.clinical_variable)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.clinical_variable) v;


ALTER TABLE biomart.ctd_clinical_chars_view OWNER TO biomart;

--
-- Name: ctd_disease; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd_disease (
    ctd_study_id bigint,
    common_name character varying(4000),
    icd10 character varying(4000),
    mesh character varying(4000),
    disease_severity character varying(4000)
);


ALTER TABLE biomart.ctd_disease OWNER TO biomart;

--
-- Name: ctd_drug_effects_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_drug_effects_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.beneficial_effects, v.adverse_effects) AS id, 
    v.ref_article_protocol_id, 
    v.discontinuation_rate, 
    v.response_rate, 
    v.downstream_signaling_effects, 
    v.beneficial_effects, 
    v.adverse_effects, 
    v.pk_pd_parameter, 
    v.pk_pd_value, 
    v.effect_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.discontinuation_rate, 
            ctd_full.response_rate, 
            ctd_full.downstream_signaling_effects, 
            ctd_full.beneficial_effects, 
            ctd_full.adverse_effects, 
            ctd_full.pk_pd_parameter, 
            ctd_full.pk_pd_value, 
            ctd_full.effect_description
           FROM ctd_full
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.beneficial_effects, ctd_full.adverse_effects) v;


ALTER TABLE biomart.ctd_drug_effects_view OWNER TO biomart;

--
-- Name: ctd_drug_inhib; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd_drug_inhib (
    ctd_study_id bigint,
    drug_inhibitor_common_name character varying(4000),
    drug_inhibitor_standard_name character varying(4000),
    drug_inhibitor_cas_id character varying(4000)
);


ALTER TABLE biomart.ctd_drug_inhib OWNER TO biomart;

--
-- Name: ctd_drug_inhibitor_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_drug_inhibitor_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.drug_inhibitor_common_name) AS id, 
    v.ref_article_protocol_id, 
    v.drug_inhibitor_common_name, 
    v.drug_inhibitor_standard_name, 
    v.drug_inhibitor_cas_id
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.drug_inhibitor_common_name, 
            ctd_full.drug_inhibitor_standard_name, 
            ctd_full.drug_inhibitor_cas_id
           FROM ctd_full
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.drug_inhibitor_common_name) v;


ALTER TABLE biomart.ctd_drug_inhibitor_view OWNER TO biomart;

--
-- Name: ctd_events_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_events_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.definition_of_the_event) AS id, 
    v.ref_article_protocol_id, 
    v.definition_of_the_event, 
    v.number_of_events, 
    v.event_rate, 
    v.time_to_event, 
    v.event_pct_reduction, 
    v.event_p_value, 
    v.event_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.definition_of_the_event, 
            ctd_full.number_of_events, 
            ctd_full.event_rate, 
            ctd_full.time_to_event, 
            ctd_full.event_pct_reduction, 
            ctd_full.event_p_value, 
            ctd_full.event_description
           FROM ctd_full
          WHERE (((ctd_full.definition_of_the_event IS NOT NULL) AND ((ctd_full.definition_of_the_event)::text <> ''::text)) OR ((ctd_full.event_description IS NOT NULL) AND ((ctd_full.event_description)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.definition_of_the_event) v;


ALTER TABLE biomart.ctd_events_view OWNER TO biomart;

--
-- Name: ctd_experiments_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_experiments_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.drug_inhibitor_common_name, v.drug_inhibitor_trtmt_regime) AS id, 
    v.ref_article_protocol_id, 
    v.drug_inhibitor_common_name, 
    v.drug_inhibitor_dose, 
    v.drug_inhibitor_time_period, 
    v.drug_inhibitor_route_of_admin, 
    v.drug_inhibitor_trtmt_regime, 
    v.comparator_name, 
    v.comparator_dose, 
    v.comparator_time_period, 
    v.comparator_route_of_admin, 
    v.treatment_regime, 
    v.placebo, 
    v.experiment_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.drug_inhibitor_common_name, 
            ctd_full.drug_inhibitor_time_period, 
            ctd_full.drug_inhibitor_dose, 
            ctd_full.drug_inhibitor_route_of_admin, 
            ctd_full.drug_inhibitor_trtmt_regime, 
            ctd_full.comparator_name, 
            ctd_full.comparator_dose, 
            ctd_full.comparator_time_period, 
            ctd_full.comparator_route_of_admin, 
            ctd_full.treatment_regime, 
            ctd_full.placebo, 
            ctd_full.experiment_description
           FROM ctd_full
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.drug_inhibitor_common_name, ctd_full.drug_inhibitor_trtmt_regime) v;


ALTER TABLE biomart.ctd_experiments_view OWNER TO biomart;

--
-- Name: ctd_expr_after_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_expr_after_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.biomolecule_name) AS id, 
    v.ref_article_protocol_id, 
    v.biomolecule_name, 
    v.expr_after_trtmt_pct, 
    v.expr_after_trtmt_number, 
    v.expr_aftertrtmt_valuefold_mean, 
    v.expr_after_trtmt_sd, 
    v.expr_after_trtmt_sem, 
    v.expr_after_trtmt_unit
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.biomolecule_name, 
            ctd_full.expr_after_trtmt_pct, 
            ctd_full.expr_after_trtmt_number, 
            ctd_full.expr_aftertrtmt_valuefold_mean, 
            ctd_full.expr_after_trtmt_sd, 
            ctd_full.expr_after_trtmt_sem, 
            ctd_full.expr_after_trtmt_unit
           FROM ctd_full
          WHERE (((ctd_full.biomolecule_name IS NOT NULL) AND ((ctd_full.biomolecule_name)::text <> ''::text)) OR ((ctd_full.expr_aftertrtmt_valuefold_mean IS NOT NULL) AND ((ctd_full.expr_aftertrtmt_valuefold_mean)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.biomolecule_name) v;


ALTER TABLE biomart.ctd_expr_after_view OWNER TO biomart;

--
-- Name: ctd_expr_baseline_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_expr_baseline_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.biomolecule_name) AS id, 
    v.ref_article_protocol_id, 
    v.biomolecule_name, 
    v.baseline_expr_pct, 
    v.baseline_expr_number, 
    v.baseline_expr_value_fold_mean, 
    v.baseline_expr_sd, 
    v.baseline_expr_sem, 
    v.baseline_expr_unit
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.biomolecule_name, 
            ctd_full.baseline_expr_pct, 
            ctd_full.baseline_expr_number, 
            ctd_full.baseline_expr_value_fold_mean, 
            ctd_full.baseline_expr_sd, 
            ctd_full.baseline_expr_sem, 
            ctd_full.baseline_expr_unit
           FROM ctd_full
          WHERE (((ctd_full.biomolecule_name IS NOT NULL) AND ((ctd_full.biomolecule_name)::text <> ''::text)) OR ((ctd_full.baseline_expr_value_fold_mean IS NOT NULL) AND ((ctd_full.baseline_expr_value_fold_mean)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.biomolecule_name) v;


ALTER TABLE biomart.ctd_expr_baseline_view OWNER TO biomart;

--
-- Name: ctd_expr_bio_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_expr_bio_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.biomolecule_name) AS id, 
    v.ref_article_protocol_id, 
    v.biomolecule_name, 
    v.biomolecule_id, 
    v.biomolecule_type, 
    v.biomarker, 
    v.biomarker_type
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.biomolecule_name, 
            ctd_full.biomolecule_id, 
            ctd_full.biomolecule_type, 
            ctd_full.biomarker, 
            ctd_full.biomarker_type
           FROM ctd_full
          WHERE (((ctd_full.biomolecule_name IS NOT NULL) AND ((ctd_full.biomolecule_name)::text <> ''::text)) OR ((ctd_full.biomolecule_id IS NOT NULL) AND ((ctd_full.biomolecule_id)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.biomolecule_name) v;


ALTER TABLE biomart.ctd_expr_bio_view OWNER TO biomart;

--
-- Name: ctd_expr_source_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_expr_source_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.expr_chg_source_type) AS id, 
    v.ref_article_protocol_id, 
    v.expr_chg_source_type, 
    v.expr_chg_technique, 
    v.expr_chg_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.expr_chg_source_type, 
            ctd_full.expr_chg_technique, 
            ctd_full.expr_chg_description
           FROM ctd_full
          WHERE (((ctd_full.expr_chg_source_type IS NOT NULL) AND ((ctd_full.expr_chg_source_type)::text <> ''::text)) OR ((ctd_full.expr_chg_description IS NOT NULL) AND ((ctd_full.expr_chg_description)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.expr_chg_source_type) v;


ALTER TABLE biomart.ctd_expr_source_view OWNER TO biomart;

--
-- Name: ctd_full_clinical_endpts_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_full_clinical_endpts_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id) AS id, 
    v.ref_article_protocol_id, 
    v.primary_endpoint_type, 
    v.primary_endpoint_definition, 
    v.primary_endpoint_change, 
    v.primary_endpoint_time_period, 
    v.primary_endpoint_p_value, 
    v.primary_endpoint_stat_test, 
    v.secondary_type, 
    v.secondary_type_definition, 
    v.secondary_type_change, 
    v.secondary_type_time_period, 
    v.secondary_type_p_value, 
    v.secondary_type_stat_test
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.primary_endpoint_type, 
            ctd_full.primary_endpoint_definition, 
            ctd_full.primary_endpoint_change, 
            ctd_full.primary_endpoint_time_period, 
            ctd_full.primary_endpoint_p_value, 
            ctd_full.primary_endpoint_stat_test, 
            ctd_full.secondary_type, 
            ctd_full.secondary_type_definition, 
            ctd_full.secondary_type_change, 
            ctd_full.secondary_type_time_period, 
            ctd_full.secondary_type_p_value, 
            ctd_full.secondary_type_stat_test
           FROM ctd_full
          ORDER BY ctd_full.ref_article_protocol_id) v;


ALTER TABLE biomart.ctd_full_clinical_endpts_view OWNER TO biomart;

--
-- Name: ctd_full_search_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_full_search_view AS
 SELECT row_number() OVER (ORDER BY t.ref_article_protocol_id) AS fact_id, 
    t.ref_article_protocol_id, 
    t.mesh, 
    t.common_name, 
    t.drug_inhibitor_standard_name, 
    t.primary_endpoint_type, 
    t.secondary_type, 
    t.biomarker_name, 
    t.disease_severity, 
    t.inhaled_steroid_dose, 
    t.fev1, 
    t.primary_endpoint_time_period, 
    t.primary_endpoint_change, 
    t.primary_endpoint_p_value
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.mesh, 
            ctd_full.common_name, 
            ctd_full.drug_inhibitor_standard_name, 
            ctd_full.primary_endpoint_type, 
            ctd_full.secondary_type, 
            ctd_full.biomarker_name, 
            ctd_full.disease_severity, 
            ctd_full.inhaled_steroid_dose, 
            ctd_full.fev1, 
            ctd_full.primary_endpoint_time_period, 
            ctd_full.primary_endpoint_change, 
            ctd_full.primary_endpoint_p_value
           FROM ctd_full) t;


ALTER TABLE biomart.ctd_full_search_view OWNER TO biomart;

--
-- Name: ctd_inclusion_criteria; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd_inclusion_criteria (
    ctd_study_id bigint,
    inhaled_steroid_dose character varying(4000),
    laba character varying(4000),
    ocs character varying(4000),
    xolair character varying(4000),
    ltra_inhibitors character varying(4000),
    asthma_phenotype character varying(4000),
    fev1 character varying(4000)
);


ALTER TABLE biomart.ctd_inclusion_criteria OWNER TO biomart;

--
-- Name: ctd_primary_endpts; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd_primary_endpts (
    ctd_study_id bigint,
    primary_type character varying(4000),
    primary_type_definition character varying(4000),
    primary_type_time_period character varying(4000),
    primary_type_change character varying(4000),
    primary_type_p_value character varying(4000),
    id bigint
);


ALTER TABLE biomart.ctd_primary_endpts OWNER TO biomart;

--
-- Name: ctd_primary_endpts_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_primary_endpts_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.primary_endpoint_type) AS id, 
    v.ref_article_protocol_id, 
    v.primary_endpoint_type, 
    v.primary_endpoint_definition, 
    v.primary_endpoint_change, 
    v.primary_endpoint_time_period, 
    v.primary_endpoint_p_value, 
    v.primary_endpoint_stat_test
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.primary_endpoint_type, 
            ctd_full.primary_endpoint_definition, 
            ctd_full.primary_endpoint_change, 
            ctd_full.primary_endpoint_time_period, 
            ctd_full.primary_endpoint_p_value, 
            ctd_full.primary_endpoint_stat_test
           FROM ctd_full
          WHERE (((ctd_full.primary_endpoint_type IS NOT NULL) AND ((ctd_full.primary_endpoint_type)::text <> ''::text)) OR ((ctd_full.primary_endpoint_definition IS NOT NULL) AND ((ctd_full.primary_endpoint_definition)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.primary_endpoint_type) v;


ALTER TABLE biomart.ctd_primary_endpts_view OWNER TO biomart;

--
-- Name: ctd_prior_med_use_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_prior_med_use_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.prior_med_drug_name) AS id, 
    v.ref_article_protocol_id, 
    v.prior_med_drug_name, 
    v.prior_med_pct, 
    v.prior_med_value
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.prior_med_drug_name, 
            ctd_full.prior_med_pct, 
            ctd_full.prior_med_value
           FROM ctd_full
          WHERE ((ctd_full.prior_med_drug_name IS NOT NULL) AND ((ctd_full.prior_med_drug_name)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.prior_med_drug_name) v;


ALTER TABLE biomart.ctd_prior_med_use_view OWNER TO biomart;

--
-- Name: ctd_pulmonary_path_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_pulmonary_path_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.pulmonary_pathology_name) AS id, 
    v.ref_article_protocol_id, 
    v.pulmonary_pathology_name, 
    v.pulmpath_patient_pct, 
    v.pulmpath_value_unit, 
    v.pulmpath_method
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.pulmonary_pathology_name, 
            ctd_full.pulmpath_patient_pct, 
            ctd_full.pulmpath_value_unit, 
            ctd_full.pulmpath_method
           FROM ctd_full
          WHERE ((ctd_full.pulmonary_pathology_name IS NOT NULL) AND ((ctd_full.pulmonary_pathology_name)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.pulmonary_pathology_name) v;


ALTER TABLE biomart.ctd_pulmonary_path_view OWNER TO biomart;

--
-- Name: ctd_quant_params_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_quant_params_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id) AS id, 
    v.ref_article_protocol_id, 
    v.clinical_variable_name, 
    v.pct_change_from_baseline, 
    v.abs_change_from_baseline, 
    v.rate_of_change_from_baseline, 
    v.average_over_treatment_period, 
    v.within_group_changes, 
    v.stat_measure_p_value
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.clinical_variable_name, 
            ctd_full.pct_change_from_baseline, 
            ctd_full.abs_change_from_baseline, 
            ctd_full.rate_of_change_from_baseline, 
            ctd_full.average_over_treatment_period, 
            ctd_full.within_group_changes, 
            ctd_full.stat_measure_p_value
           FROM ctd_full
          WHERE ((ctd_full.clinical_variable_name IS NOT NULL) AND ((ctd_full.clinical_variable_name)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id) v;


ALTER TABLE biomart.ctd_quant_params_view OWNER TO biomart;

--
-- Name: ctd_reference_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_reference_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.ref_record_id) AS id, 
    v.ref_article_protocol_id, 
    v.ref_article_pmid, 
    v.ref_protocol_id, 
    v.ref_title, 
    v.ref_record_id, 
    v.ref_back_reference
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.ref_article_pmid, 
            ctd_full.ref_protocol_id, 
            ctd_full.ref_title, 
            ctd_full.ref_record_id, 
            ctd_full.ref_back_reference
           FROM ctd_full
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.ref_record_id) v;


ALTER TABLE biomart.ctd_reference_view OWNER TO biomart;

--
-- Name: ctd_runin_therapies_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_runin_therapies_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.runin_description) AS id, 
    v.ref_article_protocol_id, 
    v.runin_ocs, 
    v.runin_ics, 
    v.runin_laba, 
    v.runin_ltra, 
    v.runin_corticosteroids, 
    v.runin_anti_fibrotics, 
    v.runin_immunosuppressive, 
    v.runin_cytotoxic, 
    v.runin_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.runin_ocs, 
            ctd_full.runin_ics, 
            ctd_full.runin_laba, 
            ctd_full.runin_ltra, 
            ctd_full.runin_corticosteroids, 
            ctd_full.runin_anti_fibrotics, 
            ctd_full.runin_immunosuppressive, 
            ctd_full.runin_cytotoxic, 
            ctd_full.runin_description
           FROM ctd_full
          WHERE ((((ctd_full.runin_ocs IS NOT NULL) AND ((ctd_full.runin_ocs)::text <> ''::text)) OR ((ctd_full.runin_description IS NOT NULL) AND ((ctd_full.runin_description)::text <> ''::text))) OR ((ctd_full.runin_immunosuppressive IS NOT NULL) AND ((ctd_full.runin_immunosuppressive)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.runin_description) v;


ALTER TABLE biomart.ctd_runin_therapies_view OWNER TO biomart;

--
-- Name: ctd_sec_endpts; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd_sec_endpts (
    ctd_study_id bigint,
    secondary_type character varying(4000),
    secondary_type_definition character varying(4000),
    secondary_type_time_period character varying(4000),
    secondary_type_change character varying(4000),
    secondary_type_p_value character varying(4000),
    id bigint
);


ALTER TABLE biomart.ctd_sec_endpts OWNER TO biomart;

--
-- Name: ctd_secondary_endpts_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_secondary_endpts_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.secondary_type) AS id, 
    v.ref_article_protocol_id, 
    v.secondary_type, 
    v.secondary_type_definition, 
    v.secondary_type_change, 
    v.secondary_type_time_period, 
    v.secondary_type_p_value, 
    v.secondary_type_stat_test
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.secondary_type, 
            ctd_full.secondary_type_definition, 
            ctd_full.secondary_type_change, 
            ctd_full.secondary_type_time_period, 
            ctd_full.secondary_type_p_value, 
            ctd_full.secondary_type_stat_test
           FROM ctd_full
          WHERE (((ctd_full.secondary_type IS NOT NULL) AND ((ctd_full.secondary_type)::text <> ''::text)) OR ((ctd_full.secondary_type_definition IS NOT NULL) AND ((ctd_full.secondary_type_definition)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.secondary_type) v;


ALTER TABLE biomart.ctd_secondary_endpts_view OWNER TO biomart;

--
-- Name: ctd_stats_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_stats_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.statistical_test) AS id, 
    v.ref_article_protocol_id, 
    v.clinical_correlation, 
    v.statistical_test, 
    v.statistical_coefficient_value, 
    v.statistical_test_p_value, 
    v.statistical_test_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.clinical_correlation, 
            ctd_full.statistical_test, 
            ctd_full.statistical_coefficient_value, 
            ctd_full.statistical_test_p_value, 
            ctd_full.statistical_test_description
           FROM ctd_full
          WHERE (((ctd_full.statistical_test_description IS NOT NULL) AND ((ctd_full.statistical_test_description)::text <> ''::text)) OR ((ctd_full.statistical_test IS NOT NULL) AND ((ctd_full.statistical_test)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.statistical_test) v;


ALTER TABLE biomart.ctd_stats_view OWNER TO biomart;

--
-- Name: ctd_study; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE ctd_study (
    ctd_study_id bigint,
    ref_article_protocol_id character varying(4000),
    ref_article_pmid character varying(4000),
    ref_protocol_id character varying(4000)
);


ALTER TABLE biomart.ctd_study OWNER TO biomart;

--
-- Name: ctd_study_details_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_study_details_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.common_name) AS id, 
    v.ref_article_protocol_id, 
    v.study_type, 
    v.common_name, 
    v.icd10, 
    v.mesh, 
    v.disease_type, 
    v.physiology_name
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.study_type, 
            ctd_full.common_name, 
            ctd_full.icd10, 
            ctd_full.mesh, 
            ctd_full.disease_type, 
            ctd_full.physiology_name
           FROM ctd_full
          WHERE ((ctd_full.common_name IS NOT NULL) AND ((ctd_full.common_name)::text <> ''::text))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.common_name) v;


ALTER TABLE biomart.ctd_study_details_view OWNER TO biomart;

--
-- Name: ctd_td_design_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_td_design_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.nature_of_trial, v.trial_type) AS id, 
    v.ref_article_protocol_id, 
    v.nature_of_trial, 
    v.randomization, 
    v.blinded_trial, 
    v.trial_type, 
    v.run_in_period, 
    v.treatment_period, 
    v.washout_period, 
    v.open_label_extension
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.nature_of_trial, 
            ctd_full.randomization, 
            ctd_full.blinded_trial, 
            ctd_full.trial_type, 
            ctd_full.run_in_period, 
            ctd_full.treatment_period, 
            ctd_full.washout_period, 
            ctd_full.open_label_extension
           FROM ctd_full
          WHERE (((ctd_full.trial_type IS NOT NULL) AND ((ctd_full.trial_type)::text <> ''::text)) OR ((ctd_full.nature_of_trial IS NOT NULL) AND ((ctd_full.nature_of_trial)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.nature_of_trial, ctd_full.trial_type) v;


ALTER TABLE biomart.ctd_td_design_view OWNER TO biomart;

--
-- Name: ctd_td_excl_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_td_excl_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id) AS id, 
    v.ref_article_protocol_id, 
    v.exclusion_criteria1, 
    v.exclusion_criteria2, 
    v.minimal_symptoms, 
    v.rescue_medication_use, 
    v.control_details, 
    v.blinding_procedure, 
    v.number_of_arms, 
    v.description1, 
    v.description2
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            "substring"(ctd_full.exclusion_criteria, 1, 4000) AS exclusion_criteria1, 
            "substring"(ctd_full.exclusion_criteria, 4001, 2000) AS exclusion_criteria2, 
            ctd_full.minimal_symptoms, 
            ctd_full.rescue_medication_use, 
            ctd_full.control_details, 
            ctd_full.blinding_procedure, 
            ctd_full.number_of_arms, 
            "substring"(ctd_full.description, 1, 4000) AS description1, 
            "substring"(ctd_full.description, 4001, 2000) AS description2
           FROM ctd_full
          WHERE (((ctd_full.blinding_procedure IS NOT NULL) AND ((ctd_full.blinding_procedure)::text <> ''::text)) OR ((ctd_full.number_of_arms IS NOT NULL) AND ((ctd_full.number_of_arms)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id) v;


ALTER TABLE biomart.ctd_td_excl_view OWNER TO biomart;

--
-- Name: ctd_td_inclusion_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_td_inclusion_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.disease_severity, v.fev1) AS id, 
    v.ref_article_protocol_id, 
    v.trial_age, 
    v.disease_severity, 
    v.difficult_to_treat, 
    v.asthma_diagnosis, 
    v.inhaled_steroid_dose, 
    v.laba, 
    v.ocs, 
    v.xolair, 
    v.ltra_inhibitors, 
    v.asthma_phenotype, 
    v.fev1, 
    v.fev1_reversibility, 
    v.tlc, 
    v.fev1_fvc, 
    v.fvc, 
    v.dlco, 
    v.sgrq, 
    v.hrct, 
    v.biopsy, 
    v.dyspnea_on_exertion, 
    v.concomitant_med
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.trial_age, 
            ctd_full.disease_severity, 
            ctd_full.difficult_to_treat, 
            ctd_full.asthma_diagnosis, 
            ctd_full.inhaled_steroid_dose, 
            ctd_full.laba, 
            ctd_full.ocs, 
            ctd_full.xolair, 
            ctd_full.ltra_inhibitors, 
            ctd_full.asthma_phenotype, 
            ctd_full.fev1, 
            ctd_full.fev1_reversibility, 
            ctd_full.tlc, 
            ctd_full.fev1_fvc, 
            ctd_full.fvc, 
            ctd_full.dlco, 
            ctd_full.sgrq, 
            ctd_full.hrct, 
            ctd_full.biopsy, 
            ctd_full.dyspnea_on_exertion, 
            ctd_full.concomitant_med
           FROM ctd_full
          WHERE ((((ctd_full.fev1 IS NOT NULL) AND ((ctd_full.fev1)::text <> ''::text)) OR ((ctd_full.disease_severity IS NOT NULL) AND ((ctd_full.disease_severity)::text <> ''::text))) OR ((ctd_full.trial_age IS NOT NULL) AND ((ctd_full.trial_age)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.disease_severity, ctd_full.fev1) v;


ALTER TABLE biomart.ctd_td_inclusion_view OWNER TO biomart;

--
-- Name: ctd_td_smoker_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_td_smoker_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.trial_smokers_pct) AS id, 
    v.ref_article_protocol_id, 
    v.trial_smokers_pct, 
    v.trial_former_smokers_pct, 
    v.trial_never_smokers_pct, 
    v.trial_pack_years
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.trial_smokers_pct, 
            ctd_full.trial_former_smokers_pct, 
            ctd_full.trial_never_smokers_pct, 
            ctd_full.trial_pack_years
           FROM ctd_full
          WHERE (((ctd_full.trial_smokers_pct IS NOT NULL) AND ((ctd_full.trial_smokers_pct)::text <> ''::text)) OR ((ctd_full.trial_never_smokers_pct IS NOT NULL) AND ((ctd_full.trial_never_smokers_pct)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.trial_smokers_pct) v;


ALTER TABLE biomart.ctd_td_smoker_view OWNER TO biomart;

--
-- Name: ctd_td_sponsor_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_td_sponsor_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.sponsor, v.trial_nbr_of_patients_studied) AS id, 
    v.ref_article_protocol_id, 
    v.sponsor, 
    v.trial_nbr_of_patients_studied, 
    v.source_type
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.sponsor, 
            ctd_full.trial_nbr_of_patients_studied, 
            ctd_full.source_type
           FROM ctd_full
          WHERE (((ctd_full.sponsor IS NOT NULL) AND ((ctd_full.sponsor)::text <> ''::text)) OR ((ctd_full.trial_nbr_of_patients_studied IS NOT NULL) AND ((ctd_full.trial_nbr_of_patients_studied)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.sponsor, ctd_full.trial_nbr_of_patients_studied) v;


ALTER TABLE biomart.ctd_td_sponsor_view OWNER TO biomart;

--
-- Name: ctd_td_status_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_td_status_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id) AS id, 
    v.ref_article_protocol_id, 
    v.trial_status, 
    v.trial_phase
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.trial_status, 
            ctd_full.trial_phase
           FROM ctd_full
          WHERE (((ctd_full.trial_status IS NOT NULL) AND ((ctd_full.trial_status)::text <> ''::text)) OR ((ctd_full.trial_phase IS NOT NULL) AND ((ctd_full.trial_phase)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id) v;


ALTER TABLE biomart.ctd_td_status_view OWNER TO biomart;

--
-- Name: ctd_treatment_phases_view; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW ctd_treatment_phases_view AS
 SELECT row_number() OVER (ORDER BY v.ref_article_protocol_id, v.trtmt_description, v.trtmt_ocs) AS id, 
    v.ref_article_protocol_id, 
    v.trtmt_ocs, 
    v.trtmt_ics, 
    v.trtmt_laba, 
    v.trtmt_ltra, 
    v.trtmt_corticosteroids, 
    v.trtmt_anti_fibrotics, 
    v.trtmt_immunosuppressive, 
    v.trtmt_cytotoxic, 
    v.trtmt_description
   FROM ( SELECT DISTINCT ctd_full.ref_article_protocol_id, 
            ctd_full.trtmt_ocs, 
            ctd_full.trtmt_ics, 
            ctd_full.trtmt_laba, 
            ctd_full.trtmt_ltra, 
            ctd_full.trtmt_corticosteroids, 
            ctd_full.trtmt_anti_fibrotics, 
            ctd_full.trtmt_immunosuppressive, 
            ctd_full.trtmt_cytotoxic, 
            ctd_full.trtmt_description
           FROM ctd_full
          WHERE ((((ctd_full.trtmt_ocs IS NOT NULL) AND ((ctd_full.trtmt_ocs)::text <> ''::text)) OR ((ctd_full.trtmt_description IS NOT NULL) AND ((ctd_full.trtmt_description)::text <> ''::text))) OR ((ctd_full.trtmt_immunosuppressive IS NOT NULL) AND ((ctd_full.trtmt_immunosuppressive)::text <> ''::text)))
          ORDER BY ctd_full.ref_article_protocol_id, ctd_full.trtmt_description, ctd_full.trtmt_ocs) v;


ALTER TABLE biomart.ctd_treatment_phases_view OWNER TO biomart;

--
-- Name: dd; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE dd (
    drn character varying(20),
    drug character varying(100)
);


ALTER TABLE biomart.dd OWNER TO biomart;

--
-- Name: gene_info_test; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE gene_info_test (
    tax_id bigint,
    gene_id bigint,
    gene_symbol character varying(200),
    gene_descr character varying(4000)
);


ALTER TABLE biomart.gene_info_test OWNER TO biomart;

--
-- Name: gene_synonym_test; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE gene_synonym_test (
    tax_id bigint,
    gene_id bigint,
    gene_symbol character varying(200),
    gene_synonym character varying(200)
);


ALTER TABLE biomart.gene_synonym_test OWNER TO biomart;

--
-- Name: genego_gene_map; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE genego_gene_map (
    gene_symbol character varying(20),
    gene_id character varying(10),
    bio_marker_id bigint NOT NULL
);


ALTER TABLE biomart.genego_gene_map OWNER TO biomart;

--
-- Name: gse_analysis; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE gse_analysis (
    name character varying(100),
    platform character varying(100),
    test character varying(1000),
    data_ct bigint,
    fc_mean bigint,
    fc_stddev bigint,
    bio_experiment_id bigint,
    bio_assay_platform_id bigint,
    bio_assay_analysis_id bigint,
    analysis1 character varying(300),
    analysis2 character varying(300)
);


ALTER TABLE biomart.gse_analysis OWNER TO biomart;

--
-- Name: gse_probeset; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE gse_probeset (
    name character varying(100),
    platform character varying(100),
    probeset character varying(100)
);


ALTER TABLE biomart.gse_probeset OWNER TO biomart;

--
-- Name: heat_map_results; Type: TABLE; Schema: biomart; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE heat_map_results (
    subject_id character varying(50),
    log_intensity double precision,
    cohort_id character varying(255),
    probe_id character varying(100),
    bio_assay_feature_group_id bigint,
    fold_change_ratio double precision,
    tea_normalized_pvalue double precision,
    bio_marker_name character varying(400),
    bio_marker_id bigint,
    search_keyword_id bigint,
    bio_assay_analysis_id bigint,
    trial_name character varying(50),
    significant smallint,
    gene_id character varying(200),
    assay_id bigint,
    preferred_pvalue double precision
);


ALTER TABLE biomart.heat_map_results OWNER TO tm_cz;

--
-- Name: hibernate_sequence; Type: SEQUENCE; Schema: biomart; Owner: biomart
--

CREATE SEQUENCE hibernate_sequence
    START WITH 21270
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE biomart.hibernate_sequence OWNER TO biomart;

--
-- Name: mesh; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE mesh (
    ui character varying(20) NOT NULL,
    mh character varying(200),
    mn character varying(200),
    ui_path character varying(500)
);


ALTER TABLE biomart.mesh OWNER TO biomart;

--
-- Name: mesh_copy; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE mesh_copy (
    ui character varying(20) NOT NULL,
    mh character varying(200),
    mn character varying(200)
);


ALTER TABLE biomart.mesh_copy OWNER TO biomart;

--
-- Name: mesh_descriptor; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE mesh_descriptor (
    mesh_descriptor_id character varying(15) NOT NULL,
    mesh_heading character varying(256),
    mesh_annotation character varying(2000)
);


ALTER TABLE biomart.mesh_descriptor OWNER TO biomart;

--
-- Name: mesh_entry; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE mesh_entry (
    mh character varying(200),
    entry character varying(200)
);


ALTER TABLE biomart.mesh_entry OWNER TO biomart;

--
-- Name: mesh_path; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE mesh_path (
    unique_id character varying(20) NOT NULL,
    mesh_name character varying(200),
    child_number character varying(200),
    parent_number character varying(200),
    id_path character varying(500)
);


ALTER TABLE biomart.mesh_path OWNER TO biomart;

--
-- Name: mesh_temp; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE mesh_temp (
    ui character varying(20),
    mh character varying(200),
    mn character varying(200)
);


ALTER TABLE biomart.mesh_temp OWNER TO biomart;

--
-- Name: mesh_with_parent; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW mesh_with_parent AS
 SELECT mesh.mn, 
    mesh.ui, 
    mesh.mh, 
        CASE
            WHEN (biomart_user.instr(mesh.mn, '.'::character varying) = 0) THEN NULL::text
            ELSE substr((mesh.mn)::text, 1, (biomart_user.instr(mesh.mn, '.'::character varying, (-1)) - 1))
        END AS pn
   FROM mesh
  ORDER BY mesh.mn;


ALTER TABLE biomart.mesh_with_parent OWNER TO biomart;

--
-- Name: VIEW mesh_with_parent; Type: COMMENT; Schema: biomart; Owner: biomart
--

COMMENT ON VIEW mesh_with_parent IS '-- mesh terms with parent term relation';


--
-- Name: mirna_bio_assay_data_annot; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE mirna_bio_assay_data_annot (
    bio_assay_feature_group_id numeric(18,0),
    bio_marker_id numeric(18,0) NOT NULL,
    data_table character(5)
);


ALTER TABLE biomart.mirna_bio_assay_data_annot OWNER TO biomart;

--
-- Name: seq_bio_data_id; Type: SEQUENCE; Schema: biomart; Owner: biomart
--

CREATE SEQUENCE seq_bio_data_id
    START WITH 391523268
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biomart.seq_bio_data_id OWNER TO biomart;

--
-- Name: mirna_bio_assay_feature_group; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE mirna_bio_assay_feature_group (
    bio_assay_feature_group_id numeric(18,0) DEFAULT nextval('seq_bio_data_id'::regclass) NOT NULL,
    feature_group_name character varying(100) NOT NULL,
    feature_group_type character varying(50) NOT NULL
);


ALTER TABLE biomart.mirna_bio_assay_feature_group OWNER TO biomart;

--
-- Name: mirna_bio_marker; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE mirna_bio_marker (
    bio_marker_id bigint NOT NULL,
    bio_marker_name character varying(200),
    bio_marker_description character varying(1000),
    organism character varying(200),
    primary_source_code character varying(200),
    primary_external_id character varying(200),
    bio_marker_type character varying(200) NOT NULL
);


ALTER TABLE biomart.mirna_bio_marker OWNER TO biomart;

--
-- Name: project_info; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE project_info (
    file_id integer NOT NULL,
    id character varying(100),
    name character varying(100),
    file_name character varying(100),
    activedataname character varying(400),
    project_accession character varying(100),
    project_category text,
    project_contactaddress character varying(4000),
    project_contactcompany character varying(400),
    project_contactdepartment character varying(400),
    project_contactemail character varying(400),
    project_contactlaboratory character varying(400),
    project_contactname character varying(400),
    project_contactphone character varying(100),
    project_contactweblink character varying(1000),
    project_contributors character varying(4000),
    project_description text,
    project_design text,
    project_id character varying(100),
    project_keywords character varying(1000),
    project_organism character varying(400),
    project_tissue character varying(400),
    project_compound character varying(400),
    project_platform character varying(400),
    project_platformdescription character varying(4000),
    project_platformorganism character varying(400),
    project_platformprovider character varying(400),
    project_platformtechnology character varying(400),
    project_platformtype character varying(400),
    project_pubmed character varying(400),
    project_studytype character varying(1000),
    project_supplementaryfile character varying(400),
    project_title character varying(500),
    project_weblink character varying(1000),
    project_extractedfromcelfiles character varying(1000),
    project_contactorganization character varying(1000),
    project_contactfax character varying(100),
    project_outputfile character varying(500),
    project_datasource character varying(100),
    project_editors character varying(100),
    project_isprivate character varying(100),
    project_publishdate character varying(100),
    entrydt timestamp without time zone
);


ALTER TABLE biomart.project_info OWNER TO biomart;

--
-- Name: seq_bio_data_fact_id; Type: SEQUENCE; Schema: biomart; Owner: biomart
--

CREATE SEQUENCE seq_bio_data_fact_id
    START WITH 26518741
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE biomart.seq_bio_data_fact_id OWNER TO biomart;

--
-- Name: seq_clinical_trial_design_id; Type: SEQUENCE; Schema: biomart; Owner: biomart
--

CREATE SEQUENCE seq_clinical_trial_design_id
    START WITH 24181
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE biomart.seq_clinical_trial_design_id OWNER TO biomart;

--
-- Name: tests; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE tests (
    name character varying(100),
    platform character varying(100),
    id bigint,
    test character varying(1000),
    probeset character varying(100),
    raw_pvalue double precision,
    adjusted_pvalue double precision,
    estimate double precision,
    fold_change double precision,
    max_ls_mean double precision
);


ALTER TABLE biomart.tests OWNER TO biomart;

--
-- Name: tmp_bio_marker; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE tmp_bio_marker (
    id bigint,
    gene_id character varying(50),
    organism character varying(200)
);


ALTER TABLE biomart.tmp_bio_marker OWNER TO biomart;

--
-- Name: tmp_omicsoft_compound; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE tmp_omicsoft_compound (
    accession character varying(100),
    bio_compound_id bigint NOT NULL,
    cas_registry character varying(400),
    compound character varying(4000),
    bio_experiment_id bigint
);


ALTER TABLE biomart.tmp_omicsoft_compound OWNER TO biomart;

--
-- Name: tmp_omicsoft_disease_m1; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE tmp_omicsoft_disease_m1 (
    accession character varying(100),
    mesh_heading character varying(256),
    mesh_descriptor_id character varying(15) NOT NULL
);


ALTER TABLE biomart.tmp_omicsoft_disease_m1 OWNER TO biomart;

--
-- Name: tmp_project_category; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE tmp_project_category (
    file_id character varying(100),
    accession character varying(100),
    category character varying(4000)
);


ALTER TABLE biomart.tmp_project_category OWNER TO biomart;

--
-- Name: tmp_project_compound; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE tmp_project_compound (
    file_id character varying(100),
    accession character varying(100),
    compound character varying(4000)
);


ALTER TABLE biomart.tmp_project_compound OWNER TO biomart;

--
-- Name: tmp_project_disease; Type: TABLE; Schema: biomart; Owner: biomart; Tablespace: transmart
--

CREATE TABLE tmp_project_disease (
    file_id character varying(100),
    accession character varying(100),
    disease character varying(4000)
);


ALTER TABLE biomart.tmp_project_disease OWNER TO biomart;

--
-- Name: vw_faceted_search; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW vw_faceted_search AS
 SELECT ba.bio_assay_analysis_id AS analysis_id, 
    be.bio_experiment_id AS study, 
    be.bio_experiment_id AS study_id, 
    ba.analysis_type AS analyses, 
    ba.bio_assay_data_type AS data_type, 
    bplat.platform_accession AS platform, 
    bplat.platform_description, 
    bplat.platform_vendor, 
    baap.platform_name, 
    ('OBS:'::text || (bpobs.obs_code)::text) AS observation, 
    be.title AS study_title, 
    be.description AS study_description, 
    be.design AS study_design, 
    be.primary_investigator AS study_primary_inv, 
    be.contact_field AS study_contact_field, 
    be.overall_design AS study_overall_design, 
    be.institution AS study_institution, 
    be.accession AS study_accession, 
    be.country AS study_country, 
    be.biomarker_type AS study_biomarker_type, 
    be.target AS study_target, 
    be.access_type AS study_access_type, 
    ba.analysis_name, 
    ba.short_description AS analysis_description_s, 
    ba.long_description AS analysis_description_l, 
    ba.analysis_type, 
    ba.analyst_name AS analysis_analyst_name, 
    ba.analysis_method_cd AS analysis_method, 
    ba.bio_assay_data_type AS analysis_data_type, 
    ba.qa_criteria AS analysis_qa_criteria, 
    bae.model_name, 
    bae.model_desc AS model_description, 
    bae.research_unit, 
    row_number() OVER (ORDER BY ba.bio_assay_analysis_id) AS facet_id
   FROM (((((((bio_assay_analysis ba
   JOIN bio_experiment be ON (((ba.etl_id)::text = (be.accession)::text)))
   LEFT JOIN bio_assay_analysis_ext bae ON ((bae.bio_assay_analysis_id = ba.bio_assay_analysis_id)))
   LEFT JOIN bio_data_platform bdplat ON ((ba.bio_assay_analysis_id = bdplat.bio_data_id)))
   LEFT JOIN bio_assay_platform bplat ON ((bdplat.bio_assay_platform_id = bplat.bio_assay_platform_id)))
   LEFT JOIN bio_data_observation bdpobs ON ((ba.bio_assay_analysis_id = bdpobs.bio_data_id)))
   LEFT JOIN bio_observation bpobs ON ((bdpobs.bio_observation_id = bpobs.bio_observation_id)))
   LEFT JOIN bio_asy_analysis_pltfm baap ON ((baap.bio_asy_analysis_pltfm_id = ba.bio_asy_analysis_pltfm_id)))
  WHERE (lower((be.bio_experiment_type)::text) = 'experiment'::text);


ALTER TABLE biomart.vw_faceted_search OWNER TO biomart;

--
-- Name: vw_faceted_search_disease; Type: VIEW; Schema: biomart; Owner: biomart
--

CREATE VIEW vw_faceted_search_disease AS
 SELECT (-1) AS bio_assay_analysis_id, 
    'TODO: Translate from ora https://raw.githubusercontent.com/transmart/transmart-gwas-plugin/pfizer/External%20Dep/Database/VW_FACETED_SEARCH_DISEASE.sql'::text AS solr_hierarchy;


ALTER TABLE biomart.vw_faceted_search_disease OWNER TO biomart;

SET search_path = fmapp, pg_catalog;

--
-- Name: fm_data_uid; Type: TABLE; Schema: fmapp; Owner: fmapp; Tablespace: transmart
--

CREATE TABLE fm_data_uid (
    fm_data_id bigint NOT NULL,
    unique_id character varying(300) NOT NULL,
    fm_data_type character varying(100) NOT NULL
);


ALTER TABLE fmapp.fm_data_uid OWNER TO fmapp;

--
-- Name: fm_folder; Type: TABLE; Schema: fmapp; Owner: fmapp; Tablespace: transmart
--

CREATE TABLE fm_folder (
    folder_id bigint NOT NULL,
    folder_name character varying(1000) NOT NULL,
    folder_full_name character varying(1000) NOT NULL,
    folder_level bigint NOT NULL,
    folder_type character varying(100) NOT NULL,
    folder_tag character varying(50),
    active_ind boolean NOT NULL,
    parent_id bigint,
    description character varying(2000)
);


ALTER TABLE fmapp.fm_folder OWNER TO fmapp;

--
-- Name: fm_folder_association; Type: TABLE; Schema: fmapp; Owner: fmapp; Tablespace: transmart
--

CREATE TABLE fm_folder_association (
    folder_id bigint NOT NULL,
    object_uid character varying(300) NOT NULL,
    object_type character varying(100) NOT NULL
);


ALTER TABLE fmapp.fm_folder_association OWNER TO fmapp;

SET search_path = biomart_user, pg_catalog;

--
-- Name: browse_analyses_view; Type: VIEW; Schema: biomart_user; Owner: biomart_user
--

CREATE VIEW browse_analyses_view AS
 SELECT fd.unique_id AS id, 
    baa.analysis_name AS title, 
    baa.long_description AS description, 
    string_agg((bap.platform_type)::text, '|'::text ORDER BY (bap.platform_type)::text) AS measurement_type, 
    string_agg((bap.platform_name)::text, '|'::text ORDER BY (bap.platform_name)::text) AS platform_name, 
    string_agg((bap.platform_vendor)::text, '|'::text ORDER BY (bap.platform_vendor)::text) AS vendor, 
    string_agg((bap.platform_technology)::text, '|'::text ORDER BY (bap.platform_technology)::text) AS technology
   FROM (((((((biomart.bio_assay_analysis baa
   JOIN biomart.bio_data_uid bd ON ((baa.bio_assay_analysis_id = bd.bio_data_id)))
   JOIN fmapp.fm_folder_association fa ON (((fa.object_uid)::text = (bd.unique_id)::text)))
   JOIN fmapp.fm_data_uid fd ON ((fa.folder_id = fd.fm_data_id)))
   JOIN fmapp.fm_folder ff ON ((ff.folder_id = fa.folder_id)))
   LEFT JOIN amapp.am_tag_association ata ON (((fd.unique_id)::text = (ata.subject_uid)::text)))
   LEFT JOIN biomart.bio_data_uid bdu ON (((bdu.unique_id)::text = (ata.object_uid)::text)))
   LEFT JOIN biomart.bio_assay_platform bap ON ((bap.bio_assay_platform_id = bdu.bio_data_id)))
  WHERE (((ata.object_type)::text = 'BIO_ASSAY_PLATFORM'::text) AND ff.active_ind)
  GROUP BY fd.unique_id, baa.analysis_name, baa.long_description;


ALTER TABLE biomart_user.browse_analyses_view OWNER TO biomart_user;

--
-- Name: browse_assays_view; Type: VIEW; Schema: biomart_user; Owner: biomart_user
--

CREATE VIEW browse_assays_view AS
 SELECT DISTINCT fd.unique_id AS id, 
    f.folder_name AS title, 
    f.description, 
    string_agg((bap.platform_type)::text, '|'::text ORDER BY (bap.platform_type)::text) AS measurement_type, 
    string_agg((bap.platform_name)::text, '|'::text ORDER BY (bap.platform_name)::text) AS platform_name, 
    string_agg((bap.platform_vendor)::text, '|'::text ORDER BY (bap.platform_vendor)::text) AS vendor, 
    string_agg((bap.platform_technology)::text, '|'::text ORDER BY (bap.platform_technology)::text) AS technology, 
    bio_markers.object_uids AS gene, 
    bio_markers.object_uids AS mirna, 
    biomarker_types.object_uids AS biomarker_type
   FROM ((((((fmapp.fm_folder f
   JOIN fmapp.fm_data_uid fd ON ((f.folder_id = fd.fm_data_id)))
   LEFT JOIN amapp.am_tag_association ata ON ((((fd.unique_id)::text = (ata.subject_uid)::text) AND ((ata.object_type)::text = 'BIO_ASSAY_PLATFORM'::text))))
   LEFT JOIN biomart.bio_data_uid bdu ON (((bdu.unique_id)::text = (ata.object_uid)::text)))
   LEFT JOIN biomart.bio_assay_platform bap ON ((bap.bio_assay_platform_id = bdu.bio_data_id)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata_1.object_uid)::text, '|'::text ORDER BY (ata_1.object_uid)::text) AS object_uids
   FROM ((fmapp.fm_folder ff
   JOIN fmapp.fm_data_uid fdu ON ((ff.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata_1 ON (((fdu.unique_id)::text = (ata_1.subject_uid)::text)))
  WHERE (((ata_1.object_type)::text = 'BIO_MARKER'::text) AND ((ff.folder_type)::text = 'ASSAY'::text))
  GROUP BY fdu.unique_id) bio_markers ON (((bio_markers.id)::text = (fd.unique_id)::text)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata_1.object_uid)::text, '|'::text ORDER BY (ata_1.object_uid)::text) AS object_uids
   FROM (((fmapp.fm_folder ff
   JOIN fmapp.fm_data_uid fdu ON ((ff.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata_1 ON (((fdu.unique_id)::text = (ata_1.subject_uid)::text)))
   JOIN amapp.am_tag_item ati ON ((ata_1.tag_item_id = ati.tag_item_id)))
  WHERE ((((ata_1.object_type)::text = 'BIO_CONCEPT_CODE'::text) AND ((ati.code_type_name)::text = 'ASSAY_TYPE_OF_BM_STUDIED'::text)) AND ((ff.folder_type)::text = 'ASSAY'::text))
  GROUP BY fdu.unique_id) biomarker_types ON (((biomarker_types.id)::text = (fd.unique_id)::text)))
  WHERE (((f.folder_type)::text = 'ASSAY'::text) AND f.active_ind)
  GROUP BY fd.unique_id, f.folder_name, f.description, bio_markers.object_uids, biomarker_types.object_uids;


ALTER TABLE biomart_user.browse_assays_view OWNER TO biomart_user;

--
-- Name: browse_folders_view; Type: VIEW; Schema: biomart_user; Owner: biomart_user
--

CREATE VIEW browse_folders_view AS
 SELECT fd.unique_id AS id, 
    f.folder_name AS title, 
    f.description, 
    string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS file_type
   FROM ((fmapp.fm_folder f
   JOIN fmapp.fm_data_uid fd ON ((f.folder_id = fd.fm_data_id)))
   LEFT JOIN amapp.am_tag_association ata ON (((fd.unique_id)::text = (ata.subject_uid)::text)))
  WHERE (((((f.folder_type)::text = 'FOLDER'::text) AND f.active_ind) AND ((ata.object_type)::text = 'BIO_CONCEPT_CODE'::text)) AND ((ata.object_uid)::text ~~ 'FILE_TYPE%'::text))
  GROUP BY fd.unique_id, f.folder_name, f.description;


ALTER TABLE biomart_user.browse_folders_view OWNER TO biomart_user;

--
-- Name: browse_programs_view; Type: VIEW; Schema: biomart_user; Owner: biomart_user
--

CREATE VIEW browse_programs_view AS
 SELECT fd.unique_id AS id, 
    f.folder_name AS title, 
    f.description, 
    diseases.object_uids AS disease, 
    observations.object_uids AS observation, 
    pathways.object_uids AS pathway, 
    genes.object_uids AS gene, 
    therapeutic_domains.object_uids AS therapeutic_domain, 
    institutions.object_uids AS institution, 
    targets.object_uids AS target
   FROM ((((((((fmapp.fm_folder f
   JOIN fmapp.fm_data_uid fd ON ((f.folder_id = fd.fm_data_id)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
       string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS object_uids
      FROM ((((fmapp.fm_folder ff
   JOIN fmapp.fm_data_uid fdu ON ((ff.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata ON (((fdu.unique_id)::text = (ata.subject_uid)::text)))
   JOIN biomart.bio_data_uid bdu ON (((bdu.unique_id)::text = (ata.object_uid)::text)))
   JOIN biomart.bio_disease bd ON ((bd.bio_disease_id = bdu.bio_data_id)))
  WHERE (((ata.object_type)::text = ANY (ARRAY[('BIO_DISEASE'::character varying)::text, ('PROGRAM_TARGET'::character varying)::text])) AND ((ff.folder_type)::text = 'PROGRAM'::text))
  GROUP BY fdu.unique_id) diseases ON (((diseases.id)::text = (fd.unique_id)::text)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS object_uids
   FROM ((((fmapp.fm_folder ff
   JOIN fmapp.fm_data_uid fdu ON ((ff.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata ON (((fdu.unique_id)::text = (ata.subject_uid)::text)))
   JOIN biomart.bio_data_uid bdu ON (((bdu.unique_id)::text = (ata.object_uid)::text)))
   JOIN biomart.bio_observation bo ON ((bo.bio_observation_id = bdu.bio_data_id)))
  WHERE (((ata.object_type)::text = ANY (ARRAY[('BIO_OBSERVATION'::character varying)::text, ('PROGRAM_TARGET'::character varying)::text])) AND ((ff.folder_type)::text = 'PROGRAM'::text))
  GROUP BY fdu.unique_id) observations ON (((observations.id)::text = (fd.unique_id)::text)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS object_uids
   FROM ((((fmapp.fm_folder ff
   JOIN fmapp.fm_data_uid fdu ON ((ff.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata ON (((fdu.unique_id)::text = (ata.subject_uid)::text)))
   JOIN biomart.bio_data_uid bdu ON (((bdu.unique_id)::text = (ata.object_uid)::text)))
   JOIN biomart.bio_marker bm ON ((bm.bio_marker_id = bdu.bio_data_id)))
  WHERE ((((bm.bio_marker_type)::text = 'PATHWAY'::text) AND (((ata.object_type)::text = 'BIO_MARKER'::text) OR ((ata.object_type)::text = 'PROGRAM_TARGET'::text))) AND ((ff.folder_type)::text = 'PROGRAM'::text))
  GROUP BY fdu.unique_id) pathways ON (((pathways.id)::text = (fd.unique_id)::text)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS object_uids
   FROM ((((fmapp.fm_folder ff
   JOIN fmapp.fm_data_uid fdu ON ((ff.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata ON (((fdu.unique_id)::text = (ata.subject_uid)::text)))
   JOIN biomart.bio_data_uid bdu ON (((bdu.unique_id)::text = (ata.object_uid)::text)))
   JOIN biomart.bio_marker bm ON ((bm.bio_marker_id = bdu.bio_data_id)))
  WHERE ((((bm.bio_marker_type)::text = 'GENE'::text) AND (((ata.object_type)::text = 'BIO_MARKER'::text) OR ((ata.object_type)::text = 'PROGRAM_TARGET'::text))) AND ((ff.folder_type)::text = 'PROGRAM'::text))
  GROUP BY fdu.unique_id) genes ON (((genes.id)::text = (fd.unique_id)::text)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS object_uids
   FROM (((((fmapp.fm_folder ff
   JOIN fmapp.fm_data_uid fdu ON ((ff.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata ON (((fdu.unique_id)::text = (ata.subject_uid)::text)))
   JOIN amapp.am_tag_item ati ON ((ata.tag_item_id = ati.tag_item_id)))
   JOIN biomart.bio_data_uid bdu ON (((bdu.unique_id)::text = (ata.object_uid)::text)))
   JOIN biomart.bio_concept_code bcc ON ((bcc.bio_concept_code_id = bdu.bio_data_id)))
  WHERE ((((ata.object_type)::text = ANY (ARRAY[('BIO_CONCEPT_CODE'::character varying)::text, ('PROGRAM_TARGET'::character varying)::text])) AND ((ff.folder_type)::text = 'PROGRAM'::text)) AND ((ati.code_type_name)::text = 'THERAPEUTIC_DOMAIN'::text))
  GROUP BY fdu.unique_id) therapeutic_domains ON (((therapeutic_domains.id)::text = (fd.unique_id)::text)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS object_uids
   FROM (((((fmapp.fm_folder ff
   JOIN fmapp.fm_data_uid fdu ON ((ff.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata ON (((fdu.unique_id)::text = (ata.subject_uid)::text)))
   JOIN amapp.am_tag_item ati ON ((ata.tag_item_id = ati.tag_item_id)))
   JOIN biomart.bio_data_uid bdu ON (((bdu.unique_id)::text = (ata.object_uid)::text)))
   JOIN biomart.bio_concept_code bcc ON ((bcc.bio_concept_code_id = bdu.bio_data_id)))
  WHERE ((((ata.object_type)::text = ANY (ARRAY[('BIO_CONCEPT_CODE'::character varying)::text, ('PROGRAM_TARGET'::character varying)::text])) AND ((ff.folder_type)::text = 'PROGRAM'::text)) AND ((ati.code_type_name)::text = 'PROGRAM_INSTITUTION'::text))
  GROUP BY fdu.unique_id) institutions ON (((institutions.id)::text = (fd.unique_id)::text)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS object_uids
   FROM (((((fmapp.fm_folder ff
   JOIN fmapp.fm_data_uid fdu ON ((ff.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata ON (((fdu.unique_id)::text = (ata.subject_uid)::text)))
   JOIN amapp.am_tag_item ati ON ((ata.tag_item_id = ati.tag_item_id)))
   JOIN biomart.bio_data_uid bdu ON (((bdu.unique_id)::text = (ata.object_uid)::text)))
   JOIN biomart.bio_concept_code bcc ON ((bcc.bio_concept_code_id = bdu.bio_data_id)))
  WHERE ((((ata.object_type)::text = ANY (ARRAY[('BIO_CONCEPT_CODE'::character varying)::text, ('PROGRAM_TARGET'::character varying)::text])) AND ((ff.folder_type)::text = 'PROGRAM'::text)) AND ((ati.code_type_name)::text = 'PROGRAM_TARGET_PATHWAY_PHENOTYPE'::text))
  GROUP BY fdu.unique_id) targets ON (((targets.id)::text = (fd.unique_id)::text)))
  WHERE (((f.folder_type)::text = 'PROGRAM'::text) AND f.active_ind);


ALTER TABLE biomart_user.browse_programs_view OWNER TO biomart_user;

--
-- Name: browse_studies_view; Type: VIEW; Schema: biomart_user; Owner: biomart_user
--

CREATE VIEW browse_studies_view AS
 SELECT fd.unique_id AS id, 
    exp.title, 
    exp.description, 
    exp.design, 
    exp.biomarker_type, 
    exp.access_type, 
    exp.accession, 
    exp.institution, 
    exp.country, 
    diseases.object_uids AS disease, 
    compounds.object_uids AS compound, 
    study_objectives.object_uids AS study_objective, 
    species.object_uids AS organism, 
    phases.object_uids AS study_phase
   FROM (((((((((biomart.bio_experiment exp
   JOIN biomart.bio_data_uid bd ON ((exp.bio_experiment_id = bd.bio_data_id)))
   JOIN fmapp.fm_folder_association fa ON (((fa.object_uid)::text = (bd.unique_id)::text)))
   JOIN fmapp.fm_data_uid fd ON ((fa.folder_id = fd.fm_data_id)))
   JOIN fmapp.fm_folder ff ON ((ff.folder_id = fa.folder_id)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS object_uids
   FROM ((fmapp.fm_folder_association ffa
   JOIN fmapp.fm_data_uid fdu ON ((ffa.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata ON (((fdu.unique_id)::text = (ata.subject_uid)::text)))
  WHERE ((ata.object_type)::text = 'BIO_DISEASE'::text)
  GROUP BY fdu.unique_id) diseases ON (((diseases.id)::text = (fd.unique_id)::text)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS object_uids
   FROM ((fmapp.fm_folder_association ffa
   JOIN fmapp.fm_data_uid fdu ON ((ffa.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata ON (((fdu.unique_id)::text = (ata.subject_uid)::text)))
  WHERE ((ata.object_type)::text = 'BIO_COMPOUND'::text)
  GROUP BY fdu.unique_id) compounds ON (((compounds.id)::text = (fd.unique_id)::text)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS object_uids
   FROM (((fmapp.fm_folder_association ffa
   JOIN fmapp.fm_data_uid fdu ON ((ffa.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata ON (((fdu.unique_id)::text = (ata.subject_uid)::text)))
   JOIN amapp.am_tag_item ati ON ((ata.tag_item_id = ati.tag_item_id)))
  WHERE (((ata.object_type)::text = 'BIO_CONCEPT_CODE'::text) AND ((ati.code_type_name)::text = 'STUDY_OBJECTIVE'::text))
  GROUP BY fdu.unique_id) study_objectives ON (((study_objectives.id)::text = (fd.unique_id)::text)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS object_uids
   FROM (((fmapp.fm_folder_association ffa
   JOIN fmapp.fm_data_uid fdu ON ((ffa.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata ON (((fdu.unique_id)::text = (ata.subject_uid)::text)))
   JOIN amapp.am_tag_item ati ON ((ata.tag_item_id = ati.tag_item_id)))
  WHERE (((ata.object_type)::text = 'BIO_CONCEPT_CODE'::text) AND ((ati.code_type_name)::text = 'SPECIES'::text))
  GROUP BY fdu.unique_id) species ON (((species.id)::text = (fd.unique_id)::text)))
   LEFT JOIN ( SELECT fdu.unique_id AS id, 
    string_agg((ata.object_uid)::text, '|'::text ORDER BY (ata.object_uid)::text) AS object_uids
   FROM (((fmapp.fm_folder_association ffa
   JOIN fmapp.fm_data_uid fdu ON ((ffa.folder_id = fdu.fm_data_id)))
   JOIN amapp.am_tag_association ata ON (((fdu.unique_id)::text = (ata.subject_uid)::text)))
   JOIN amapp.am_tag_item ati ON ((ata.tag_item_id = ati.tag_item_id)))
  WHERE (((ata.object_type)::text = 'BIO_CONCEPT_CODE'::text) AND ((ati.code_type_name)::text = 'STUDY_PHASE'::text))
  GROUP BY fdu.unique_id) phases ON (((phases.id)::text = (fd.unique_id)::text)))
  WHERE ff.active_ind;


ALTER TABLE biomart_user.browse_studies_view OWNER TO biomart_user;

SET default_tablespace = '';

--
-- Name: gene_ontology; Type: TABLE; Schema: biomart_user; Owner: biomart_user; Tablespace: 
--

CREATE TABLE gene_ontology (
    pathway character varying(100),
    descr character varying(500)
);


ALTER TABLE biomart_user.gene_ontology OWNER TO biomart_user;

--
-- Name: gene_ontology_data; Type: TABLE; Schema: biomart_user; Owner: biomart_user; Tablespace: 
--

CREATE TABLE gene_ontology_data (
    pathway character varying(100),
    gene_id character varying(20),
    gene_symbol character varying(200),
    organism character varying(100)
);


ALTER TABLE biomart_user.gene_ontology_data OWNER TO biomart_user;

--
-- Name: ioe_temp_obj_reg2; Type: TABLE; Schema: biomart_user; Owner: biomart_user; Tablespace: 
--

CREATE TABLE ioe_temp_obj_reg2 (
    object_schema character varying(32),
    object_name character varying(32),
    object_type character varying(64),
    kde_username character varying(64),
    kde_session character varying(255),
    object_created_timestamp timestamp(0) without time zone
);


ALTER TABLE biomart_user.ioe_temp_obj_reg2 OWNER TO biomart_user;

--
-- Name: kde_temp_obj_reg3; Type: TABLE; Schema: biomart_user; Owner: biomart_user; Tablespace: 
--

CREATE TABLE kde_temp_obj_reg3 (
    object_schema character varying(32),
    object_name character varying(32),
    object_type character varying(64),
    kde_username character varying(64),
    kde_session character varying(255),
    object_created_timestamp character(15)
);


ALTER TABLE biomart_user.kde_temp_obj_reg3 OWNER TO biomart_user;

SET search_path = deapp, pg_catalog;

--
-- Name: de_chromo_region_id_seq; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE de_chromo_region_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.de_chromo_region_id_seq OWNER TO deapp;

SET default_tablespace = transmart;

--
-- Name: de_chromosomal_region; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_chromosomal_region (
    region_id bigint DEFAULT nextval('de_chromo_region_id_seq'::regclass) NOT NULL,
    gpl_id character varying(50),
    chromosome character varying(2),
    start_bp bigint,
    end_bp bigint,
    num_probes integer,
    region_name character varying(100),
    cytoband character varying(100),
    gene_symbol character varying(100),
    gene_id bigint,
    organism character varying(200)
);


ALTER TABLE deapp.de_chromosomal_region OWNER TO deapp;

--
-- Name: de_concept_visit; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_concept_visit (
    concept_cd character varying(50) NOT NULL,
    visit_name character varying(100) NOT NULL,
    sourcesystem_cd character varying(50)
);


ALTER TABLE deapp.de_concept_visit OWNER TO deapp;

--
-- Name: de_encounter_level; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_encounter_level (
    study_id character varying(50),
    concept_id character varying(500),
    link_type character varying(50)
);


ALTER TABLE deapp.de_encounter_level OWNER TO deapp;

--
-- Name: de_encounter_type; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_encounter_type (
    study_id character varying(200),
    link_type character varying(50),
    link_value character varying(200),
    encounter_num numeric(38,0)
);


ALTER TABLE deapp.de_encounter_type OWNER TO deapp;

--
-- Name: de_gpl_info; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_gpl_info (
    platform character varying(50) NOT NULL,
    title character varying(500),
    organism character varying(100),
    annotation_date timestamp without time zone,
    marker_type character varying(100),
    genome_build character varying(20),
    release_nbr character varying(50)
);


ALTER TABLE deapp.de_gpl_info OWNER TO deapp;

--
-- Name: de_mrna_annotation; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_mrna_annotation (
    gpl_id character varying(100),
    probe_id character varying(100),
    gene_symbol character varying(100),
    probeset_id bigint,
    gene_id bigint,
    organism character varying(200),
    de_mrna_annotation_id bigint NOT NULL
);


ALTER TABLE deapp.de_mrna_annotation OWNER TO deapp;

--
-- Name: de_obs_enroll_days; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_obs_enroll_days (
    encounter_num bigint,
    days_since_enroll double precision,
    study_id character varying(200)
);


ALTER TABLE deapp.de_obs_enroll_days OWNER TO deapp;

--
-- Name: de_parent_cd_seq; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE de_parent_cd_seq
    START WITH 3801
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE deapp.de_parent_cd_seq OWNER TO deapp;

--
-- Name: de_pathway; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_pathway (
    name character varying(300),
    description character varying(510),
    id bigint NOT NULL,
    type character varying(100),
    source character varying(100),
    externalid character varying(100),
    pathway_uid character varying(200),
    user_id bigint
);


ALTER TABLE deapp.de_pathway OWNER TO deapp;

--
-- Name: de_pathway_gene; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_pathway_gene (
    id bigint NOT NULL,
    pathway_id numeric,
    gene_symbol character varying(200),
    gene_id character varying(200)
);


ALTER TABLE deapp.de_pathway_gene OWNER TO deapp;

--
-- Name: protein_annotation_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE protein_annotation_id
    START WITH 4742232
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.protein_annotation_id OWNER TO deapp;

--
-- Name: de_protein_annotation; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_protein_annotation (
    id bigint DEFAULT nextval('protein_annotation_id'::regclass) NOT NULL,
    gpl_id character varying(50) NOT NULL,
    peptide character varying(200) NOT NULL,
    uniprot_id character varying(200),
    biomarker_id character varying(200),
    organism character varying(200),
    uniprot_name character varying(200)
);


ALTER TABLE deapp.de_protein_annotation OWNER TO deapp;

--
-- Name: de_qpcr_mirna_annotation; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_qpcr_mirna_annotation (
    id_ref character varying(100),
    probe_id character varying(100),
    mirna_symbol character varying(100),
    mirna_id character varying(100),
    probeset_id numeric(38,0),
    organism character varying(200),
    gpl_id character varying(20)
);


ALTER TABLE deapp.de_qpcr_mirna_annotation OWNER TO deapp;

--
-- Name: de_rbm_annotation; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_rbm_annotation (
    id bigint NOT NULL,
    gpl_id character varying(50) NOT NULL,
    antigen_name character varying(200) NOT NULL,
    uniprot_id character varying(50),
    gene_symbol character varying(50),
    gene_id character varying(200),
    uniprot_name character varying(200)
);


ALTER TABLE deapp.de_rbm_annotation OWNER TO deapp;

--
-- Name: de_rbm_data_annotation_join; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_rbm_data_annotation_join (
    data_id bigint NOT NULL,
    annotation_id bigint NOT NULL
);


ALTER TABLE deapp.de_rbm_data_annotation_join OWNER TO deapp;

--
-- Name: de_rc_snp_info_seq; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE de_rc_snp_info_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.de_rc_snp_info_seq OWNER TO deapp;

--
-- Name: de_rc_snp_info; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_rc_snp_info (
    snp_info_id bigint DEFAULT nextval('de_rc_snp_info_seq'::regclass) NOT NULL,
    rs_id character varying(50),
    chrom character varying(4),
    pos bigint,
    ref character varying(1000),
    alt character varying(1000),
    gene_info character varying(1000),
    variation_class character varying(10),
    strand character varying(1),
    clinsig character varying(100),
    disease character varying(500),
    gmaf character varying(10),
    gene_biotype character varying(100),
    impact character varying(50),
    transcript_id character varying(100),
    functional_class character varying(100),
    effect character varying(100),
    exon_id character varying(100),
    amino_acid_change character varying(100),
    codon_change character varying(1000),
    hg_version character varying(10),
    gene_name character varying(50),
    entrez_id character varying(50),
    recombination_rate numeric(18,6),
    recombination_map numeric(18,6),
    regulome_score character varying(10),
    exon_intron character varying(50)
);


ALTER TABLE deapp.de_rc_snp_info OWNER TO deapp;

--
-- Name: de_rc_snp_info1; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_rc_snp_info1 (
    snp_info_id bigint DEFAULT nextval('de_rc_snp_info_seq'::regclass) NOT NULL,
    rs_id character varying(50),
    chrom character varying(4),
    pos bigint,
    hg_version character varying(10),
    exon_intron character varying(10),
    recombination_rate numeric(18,6),
    recombination_map numeric(18,6),
    regulome_score character varying(10),
    gene_name character varying(50),
    entrez_id character varying(50)
);


ALTER TABLE deapp.de_rc_snp_info1 OWNER TO deapp;

--
-- Name: de_rnaseq_annotation; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_rnaseq_annotation (
    gpl_id character varying(50),
    transcript_id character varying(50),
    gene_symbol character varying(50),
    gene_id character varying(50),
    organism character varying(30),
    probeset_id bigint
);


ALTER TABLE deapp.de_rnaseq_annotation OWNER TO deapp;

--
-- Name: de_sample_snp_data; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_sample_snp_data (
    sample_id character varying(50),
    snp_name character varying(100),
    snp_calls character varying(4),
    copy_number double precision
);


ALTER TABLE deapp.de_sample_snp_data OWNER TO deapp;

--
-- Name: de_saved_comparison; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_saved_comparison (
    comparison_id bigint NOT NULL,
    query_id1 bigint,
    query_id2 bigint
);


ALTER TABLE deapp.de_saved_comparison OWNER TO deapp;

--
-- Name: de_snp_calls_by_gsm; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_snp_calls_by_gsm (
    gsm_num character varying(100),
    trial_name character varying(20),
    patient_num bigint,
    snp_name character varying(100),
    snp_calls character varying(4)
);


ALTER TABLE deapp.de_snp_calls_by_gsm OWNER TO deapp;

--
-- Name: de_snp_copy_number; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_snp_copy_number (
    patient_num bigint,
    trial_name character varying(20),
    snp_name character varying(50),
    chrom character varying(2),
    chrom_pos bigint,
    copy_number smallint
);


ALTER TABLE deapp.de_snp_copy_number OWNER TO deapp;

--
-- Name: de_snp_data_by_patient; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_snp_data_by_patient (
    snp_data_by_patient_id bigint NOT NULL,
    snp_dataset_id bigint,
    trial_name character varying(255),
    patient_num bigint,
    chrom character varying(16),
    data_by_patient_chr text,
    ped_by_patient_chr text
);


ALTER TABLE deapp.de_snp_data_by_patient OWNER TO deapp;

--
-- Name: de_snp_data_by_probe; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_snp_data_by_probe (
    snp_data_by_probe_id bigint NOT NULL,
    probe_id bigint,
    probe_name character varying(255),
    snp_id bigint,
    snp_name character varying(255),
    trial_name character varying(255),
    data_by_probe text
);


ALTER TABLE deapp.de_snp_data_by_probe OWNER TO deapp;

--
-- Name: de_snp_data_dataset_loc; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_snp_data_dataset_loc (
    snp_data_dataset_loc_id bigint NOT NULL,
    trial_name character varying(255),
    snp_dataset_id bigint,
    location bigint
);


ALTER TABLE deapp.de_snp_data_dataset_loc OWNER TO deapp;

--
-- Name: de_snp_gene_map; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_snp_gene_map (
    snp_id bigint,
    snp_name character varying(255),
    entrez_gene_id bigint
);


ALTER TABLE deapp.de_snp_gene_map OWNER TO deapp;

--
-- Name: de_snp_info; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_snp_info (
    snp_info_id bigint NOT NULL,
    name character varying(255),
    chrom character varying(16),
    chrom_pos bigint
);


ALTER TABLE deapp.de_snp_info OWNER TO deapp;

--
-- Name: de_snp_probe; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_snp_probe (
    snp_probe_id bigint NOT NULL,
    probe_name character varying(255),
    snp_id bigint,
    snp_name character varying(255),
    vendor_name character varying(255)
);


ALTER TABLE deapp.de_snp_probe OWNER TO deapp;

--
-- Name: de_snp_probe_sorted_def; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_snp_probe_sorted_def (
    snp_probe_sorted_def_id bigint NOT NULL,
    platform_name character varying(255),
    num_probe bigint,
    chrom character varying(16),
    probe_def text,
    snp_id_def text
);


ALTER TABLE deapp.de_snp_probe_sorted_def OWNER TO deapp;

--
-- Name: de_snp_subject_sorted_def; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_snp_subject_sorted_def (
    snp_subject_sorted_def_id bigint NOT NULL,
    trial_name character varying(255),
    patient_position integer,
    patient_num bigint,
    subject_id character varying(255)
);


ALTER TABLE deapp.de_snp_subject_sorted_def OWNER TO deapp;

--
-- Name: de_subject_acgh_data; Type: TABLE; Schema: deapp; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_subject_acgh_data (
    trial_name character varying(50),
    region_id bigint NOT NULL,
    assay_id bigint NOT NULL,
    patient_id bigint,
    chip double precision,
    segmented double precision,
    flag smallint,
    probloss double precision,
    probnorm double precision,
    probgain double precision,
    probamp double precision,
    partition_id numeric
);


ALTER TABLE deapp.de_subject_acgh_data OWNER TO tm_cz;

--
-- Name: COLUMN de_subject_acgh_data.chip; Type: COMMENT; Schema: deapp; Owner: tm_cz
--

COMMENT ON COLUMN de_subject_acgh_data.chip IS 'log2ratio';


--
-- Name: COLUMN de_subject_acgh_data.segmented; Type: COMMENT; Schema: deapp; Owner: tm_cz
--

COMMENT ON COLUMN de_subject_acgh_data.segmented IS 'segmented log2ratio';


--
-- Name: COLUMN de_subject_acgh_data.flag; Type: COMMENT; Schema: deapp; Owner: tm_cz
--

COMMENT ON COLUMN de_subject_acgh_data.flag IS 'call  -1:loss, 0:normal, 1:gain, 2:amplification';


--
-- Name: de_subject_metabolomics_data; Type: TABLE; Schema: deapp; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_subject_metabolomics_data (
    trial_source character varying(200),
    trial_name character varying(200),
    metabolite_annotation_id bigint,
    assay_id bigint,
    subject_id character varying(100),
    patient_id bigint,
    raw_intensity bigint,
    log_intensity bigint,
    zscore bigint NOT NULL,
    partition_id numeric
);


ALTER TABLE deapp.de_subject_metabolomics_data OWNER TO tm_cz;

--
-- Name: de_subject_microarray_data; Type: TABLE; Schema: deapp; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_subject_microarray_data (
    trial_name character varying(50),
    probeset_id bigint,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(50),
    raw_intensity double precision,
    log_intensity double precision,
    zscore double precision,
    new_raw double precision,
    new_log double precision,
    new_zscore double precision,
    trial_source character varying(200),
    partition_id numeric
);


ALTER TABLE deapp.de_subject_microarray_data OWNER TO tm_cz;

--
-- Name: de_subject_microarray_data_new; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_subject_microarray_data_new (
    trial_source character varying(200),
    trial_name character varying(50),
    probeset_id bigint,
    assay_id bigint,
    patient_id bigint,
    raw_intensity double precision,
    log_intensity double precision,
    zscore double precision
);


ALTER TABLE deapp.de_subject_microarray_data_new OWNER TO deapp;

--
-- Name: de_subject_microarray_logs; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_subject_microarray_logs (
    probeset character varying(50),
    raw_intensity numeric,
    pvalue double precision,
    refseq character varying(50),
    gene_symbol character varying(50),
    assay_id bigint,
    patient_id bigint,
    subject_id character varying(20),
    trial_name character varying(15),
    timepoint character varying(30),
    log_intensity numeric
);


ALTER TABLE deapp.de_subject_microarray_logs OWNER TO deapp;

--
-- Name: de_subject_microarray_med; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_subject_microarray_med (
    probeset character varying(50),
    raw_intensity numeric,
    log_intensity numeric,
    gene_symbol character varying(50),
    assay_id bigint,
    patient_id bigint,
    subject_id character varying(20),
    trial_name character varying(15),
    timepoint character varying(30),
    pvalue double precision,
    refseq character varying(50),
    mean_intensity numeric,
    stddev_intensity numeric,
    median_intensity numeric,
    zscore double precision
);


ALTER TABLE deapp.de_subject_microarray_med OWNER TO deapp;

--
-- Name: de_subject_mirna_data; Type: TABLE; Schema: deapp; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_subject_mirna_data (
    trial_source character varying(200),
    trial_name character varying(50),
    assay_id numeric(18,0),
    patient_id numeric(18,0),
    raw_intensity numeric,
    log_intensity numeric,
    probeset_id numeric(38,0),
    zscore numeric(18,9),
    partition_id numeric
);


ALTER TABLE deapp.de_subject_mirna_data OWNER TO tm_cz;

--
-- Name: de_subject_protein_data; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_subject_protein_data (
    trial_name character varying(50),
    protein_annotation_id bigint,
    component character varying(100),
    patient_id numeric(38,0),
    gene_symbol character varying(100),
    gene_id character varying(200),
    assay_id numeric,
    subject_id character varying(100),
    intensity numeric,
    zscore numeric,
    log_intensity numeric,
    partition_id numeric
);


ALTER TABLE deapp.de_subject_protein_data OWNER TO deapp;

--
-- Name: de_subject_proteomics_data; Type: TABLE; Schema: deapp; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_subject_proteomics_data (
    trial_name character varying(15),
    protein_annotation_id bigint,
    component character varying(100),
    patient_id bigint,
    gene_symbol character varying(100),
    gene_id bigint,
    assay_id bigint,
    subject_id character varying(100),
    intensity bigint,
    zscore bigint,
    partition_id numeric
);


ALTER TABLE deapp.de_subject_proteomics_data OWNER TO tm_cz;

--
-- Name: de_subject_rbm_data; Type: TABLE; Schema: deapp; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_subject_rbm_data (
    trial_name character varying(100),
    antigen_name character varying(100),
    n_value bigint,
    patient_id bigint,
    gene_symbol character varying(100),
    gene_id integer,
    assay_id bigint,
    normalized_value double precision,
    concept_cd character varying(100),
    timepoint character varying(100),
    data_uid character varying(100),
    value double precision,
    log_intensity numeric,
    mean_intensity numeric,
    stddev_intensity numeric,
    median_intensity numeric,
    zscore double precision,
    rbm_panel character varying(50),
    unit character varying(50),
    id bigint NOT NULL,
    partition_id numeric
);


ALTER TABLE deapp.de_subject_rbm_data OWNER TO tm_cz;

--
-- Name: de_subject_rbm_data_seq; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE de_subject_rbm_data_seq
    START WITH 1272564
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.de_subject_rbm_data_seq OWNER TO deapp;

--
-- Name: de_subject_rna_data; Type: TABLE; Schema: deapp; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_subject_rna_data (
    trial_source character varying(200),
    trial_name character varying(50),
    probeset_id character varying(200),
    assay_id bigint,
    patient_id bigint,
    raw_intensity double precision,
    log_intensity double precision,
    zscore double precision,
    partition_id numeric
);


ALTER TABLE deapp.de_subject_rna_data OWNER TO tm_cz;

--
-- Name: de_subject_rnaseq_data; Type: TABLE; Schema: deapp; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_subject_rnaseq_data (
    trial_name character varying(50),
    region_id bigint NOT NULL,
    assay_id bigint NOT NULL,
    patient_id bigint,
    readcount bigint,
    partition_id bigint
);


ALTER TABLE deapp.de_subject_rnaseq_data OWNER TO tm_cz;

--
-- Name: de_subject_sample_mapping; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_subject_sample_mapping (
    patient_id bigint,
    site_id character varying(100),
    subject_id character varying(100),
    subject_type character varying(100),
    concept_code character varying(1000),
    assay_id bigint NOT NULL,
    patient_uid character varying(50),
    sample_type character varying(100),
    assay_uid character varying(100),
    trial_name character varying(30),
    timepoint character varying(100),
    timepoint_cd character varying(50),
    sample_type_cd character varying(50),
    tissue_type_cd character varying(50),
    platform character varying(50),
    platform_cd character varying(50),
    tissue_type character varying(100),
    data_uid character varying(100),
    gpl_id character varying(50),
    rbm_panel character varying(50),
    sample_id bigint,
    sample_cd character varying(200),
    category_cd character varying(1000),
    source_cd character varying(200),
    omic_source_study character varying(200),
    omic_patient_num bigint,
    omic_patient_id bigint,
    partition_id numeric
);


ALTER TABLE deapp.de_subject_sample_mapping OWNER TO deapp;

--
-- Name: de_subject_snp_dataset; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_subject_snp_dataset (
    subject_snp_dataset_id bigint NOT NULL,
    dataset_name character varying(255),
    concept_cd character varying(255),
    platform_name character varying(255),
    trial_name character varying(255),
    patient_num bigint,
    timepoint character varying(255),
    subject_id character varying(255),
    sample_type character varying(255),
    paired_dataset_id bigint,
    patient_gender character varying(1)
);


ALTER TABLE deapp.de_subject_snp_dataset OWNER TO deapp;

--
-- Name: de_variant_dataset; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_variant_dataset (
    dataset_id character varying(50) NOT NULL,
    datasource_id character varying(200),
    etl_id character varying(20),
    etl_date date,
    genome character varying(50) NOT NULL,
    metadata_comment text,
    variant_dataset_type character varying(50),
    gpl_id character varying(50)
);


ALTER TABLE deapp.de_variant_dataset OWNER TO deapp;

--
-- Name: de_variant_metadata_seq; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE de_variant_metadata_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.de_variant_metadata_seq OWNER TO deapp;

--
-- Name: de_variant_metadata; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_variant_metadata (
    de_variant_metadata_id integer DEFAULT nextval('de_variant_metadata_seq'::regclass) NOT NULL,
    dataset_id character varying(50),
    key character varying(255),
    value text
);


ALTER TABLE deapp.de_variant_metadata OWNER TO deapp;

--
-- Name: de_variant_population_data_seq; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE de_variant_population_data_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.de_variant_population_data_seq OWNER TO deapp;

--
-- Name: de_variant_population_data; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_variant_population_data (
    variant_population_data_id bigint DEFAULT nextval('de_variant_population_data_seq'::regclass) NOT NULL,
    dataset_id character varying(50),
    chr character varying(50),
    pos bigint,
    info_name character varying(100),
    info_index integer DEFAULT 0,
    integer_value bigint,
    float_value double precision,
    text_value character varying(4000)
);


ALTER TABLE deapp.de_variant_population_data OWNER TO deapp;

--
-- Name: de_variant_population_info_seq; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE de_variant_population_info_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.de_variant_population_info_seq OWNER TO deapp;

--
-- Name: de_variant_population_info; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_variant_population_info (
    variant_population_info_id bigint DEFAULT nextval('de_variant_population_info_seq'::regclass) NOT NULL,
    dataset_id character varying(50),
    info_name character varying(100),
    description text,
    type character varying(30),
    number character varying(10)
);


ALTER TABLE deapp.de_variant_population_info OWNER TO deapp;

--
-- Name: de_variant_subject_detail_seq; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE de_variant_subject_detail_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.de_variant_subject_detail_seq OWNER TO deapp;

--
-- Name: de_variant_subject_detail; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_variant_subject_detail (
    variant_subject_detail_id bigint DEFAULT nextval('de_variant_subject_detail_seq'::regclass) NOT NULL,
    dataset_id character varying(50),
    chr character varying(50),
    pos bigint,
    rs_id character varying(50),
    ref character varying(500),
    alt character varying(500),
    qual character varying(100),
    filter character varying(50),
    info character varying(10000),
    format character varying(500),
    variant_value text
);


ALTER TABLE deapp.de_variant_subject_detail OWNER TO deapp;

--
-- Name: de_variant_subject_idx_seq; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE de_variant_subject_idx_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.de_variant_subject_idx_seq OWNER TO deapp;

--
-- Name: de_variant_subject_idx; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_variant_subject_idx (
    dataset_id character varying(50),
    subject_id character varying(50),
    "position" bigint,
    variant_subject_idx_id bigint DEFAULT nextval('de_variant_subject_idx_seq'::regclass) NOT NULL
);


ALTER TABLE deapp.de_variant_subject_idx OWNER TO deapp;

--
-- Name: de_variant_subject_summary_seq; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE de_variant_subject_summary_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.de_variant_subject_summary_seq OWNER TO deapp;

--
-- Name: de_variant_subject_summary; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_variant_subject_summary (
    variant_subject_summary_id bigint DEFAULT nextval('de_variant_subject_summary_seq'::regclass) NOT NULL,
    chr character varying(50),
    pos bigint,
    dataset_id character varying(50) NOT NULL,
    subject_id character varying(50) NOT NULL,
    rs_id character varying(50),
    variant character varying(1000),
    variant_format character varying(100),
    variant_type character varying(100),
    reference boolean,
    allele1 integer,
    allele2 integer,
    assay_id bigint
);


ALTER TABLE deapp.de_variant_subject_summary OWNER TO deapp;

--
-- Name: COLUMN de_variant_subject_summary.reference; Type: COMMENT; Schema: deapp; Owner: deapp
--

COMMENT ON COLUMN de_variant_subject_summary.reference IS 'This column contains a flag whether this subject has a reference value on this variant, or not.';


--
-- Name: COLUMN de_variant_subject_summary.assay_id; Type: COMMENT; Schema: deapp; Owner: deapp
--

COMMENT ON COLUMN de_variant_subject_summary.assay_id IS 'Reference to de_subject_sample_mapping';


--
-- Name: de_xtrial_child_map; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_xtrial_child_map (
    concept_cd character varying(50) NOT NULL,
    parent_cd bigint NOT NULL,
    manually_mapped bigint,
    study_id character varying(50)
);


ALTER TABLE deapp.de_xtrial_child_map OWNER TO deapp;

--
-- Name: de_xtrial_parent_names; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE de_xtrial_parent_names (
    parent_cd bigint NOT NULL,
    across_path character varying(500),
    manually_created bigint
);


ALTER TABLE deapp.de_xtrial_parent_names OWNER TO deapp;

--
-- Name: deapp_annotation; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE deapp_annotation (
    annotation_type character varying(50),
    annotation_value character varying(100),
    gene_id bigint,
    gene_symbol character varying(200)
);


ALTER TABLE deapp.deapp_annotation OWNER TO deapp;

--
-- Name: haploview_data; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE haploview_data (
    i2b2_id bigint,
    jnj_id character varying(30),
    father_id integer,
    mother_id integer,
    sex smallint,
    affection_status smallint,
    chromosome character varying(10),
    gene character varying(50),
    release smallint,
    release_date timestamp without time zone,
    trial_name character varying(50),
    snp_data text
);


ALTER TABLE deapp.haploview_data OWNER TO deapp;

--
-- Name: kegg; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE kegg (
    pathway character varying(20),
    gene_id character varying(20),
    gene_symbol character varying(20)
);


ALTER TABLE deapp.kegg OWNER TO deapp;

--
-- Name: kegg_data; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE kegg_data (
    pathway character varying(100),
    gene_id character varying(20),
    gene character varying(200)
);


ALTER TABLE deapp.kegg_data OWNER TO deapp;

--
-- Name: kegg_def; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE kegg_def (
    pathway character varying(100),
    descr character varying(500)
);


ALTER TABLE deapp.kegg_def OWNER TO deapp;

--
-- Name: metabolite_sub_pth_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE metabolite_sub_pth_id
    START WITH 1095
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.metabolite_sub_pth_id OWNER TO deapp;

--
-- Name: metabolite_sup_pth_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE metabolite_sup_pth_id
    START WITH 152
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.metabolite_sup_pth_id OWNER TO deapp;

--
-- Name: metabolomics_annot_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE metabolomics_annot_id
    START WITH 4479
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.metabolomics_annot_id OWNER TO deapp;

--
-- Name: rbm_annotation_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE rbm_annotation_id
    START WITH 105393
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.rbm_annotation_id OWNER TO deapp;

--
-- Name: ricerca; Type: TABLE; Schema: deapp; Owner: deapp; Tablespace: transmart
--

CREATE TABLE ricerca (
    subject_id character varying(20),
    sample_id character varying(100)
);


ALTER TABLE deapp.ricerca OWNER TO deapp;

--
-- Name: seq_assay_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE seq_assay_id
    START WITH 45741
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE deapp.seq_assay_id OWNER TO deapp;

--
-- Name: seq_data_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE seq_data_id
    START WITH 11594011
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE deapp.seq_data_id OWNER TO deapp;

--
-- Name: seq_de_mrna_annotation_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE seq_de_mrna_annotation_id
    START WITH 263161
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.seq_de_mrna_annotation_id OWNER TO deapp;

--
-- Name: seq_metabolomics_partition_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE seq_metabolomics_partition_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.seq_metabolomics_partition_id OWNER TO deapp;

--
-- Name: seq_mrna_partition_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE seq_mrna_partition_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.seq_mrna_partition_id OWNER TO deapp;

--
-- Name: seq_rbm_partition_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE seq_rbm_partition_id
    START WITH 29
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.seq_rbm_partition_id OWNER TO deapp;

--
-- Name: seq_rna_partition_id; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE seq_rna_partition_id
    START WITH 107
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.seq_rna_partition_id OWNER TO deapp;

--
-- Name: tt; Type: SEQUENCE; Schema: deapp; Owner: deapp
--

CREATE SEQUENCE tt
    START WITH 241
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE deapp.tt OWNER TO deapp;

SET search_path = fmapp, pg_catalog;

--
-- Name: fm_file; Type: TABLE; Schema: fmapp; Owner: fmapp; Tablespace: transmart
--

CREATE TABLE fm_file (
    file_id bigint NOT NULL,
    display_name character varying(1000) NOT NULL,
    original_name character varying(1000) NOT NULL,
    file_version numeric,
    file_type character varying(100),
    file_size numeric,
    filestore_location character varying(1000),
    filestore_name character varying(1000),
    link_url character varying(1000),
    active_ind boolean NOT NULL,
    create_date timestamp without time zone NOT NULL,
    update_date timestamp without time zone NOT NULL
);


ALTER TABLE fmapp.fm_file OWNER TO fmapp;

--
-- Name: fm_folder_file_association; Type: TABLE; Schema: fmapp; Owner: fmapp; Tablespace: transmart
--

CREATE TABLE fm_folder_file_association (
    folder_id bigint NOT NULL,
    file_id bigint NOT NULL
);


ALTER TABLE fmapp.fm_folder_file_association OWNER TO fmapp;

--
-- Name: seq_fm_id; Type: SEQUENCE; Schema: fmapp; Owner: fmapp
--

CREATE SEQUENCE seq_fm_id
    START WITH 1992447
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fmapp.seq_fm_id OWNER TO fmapp;

SET search_path = galaxy, pg_catalog;

--
-- Name: status_of_export_job; Type: TABLE; Schema: galaxy; Owner: galaxy; Tablespace: transmart
--

CREATE TABLE status_of_export_job (
    job_status character varying(200),
    last_export_name character varying(200),
    last_export_time date,
    job_name_id character varying(200),
    id bigint NOT NULL
);


ALTER TABLE galaxy.status_of_export_job OWNER TO galaxy;

--
-- Name: users_details_for_export_gal; Type: TABLE; Schema: galaxy; Owner: galaxy; Tablespace: transmart
--

CREATE TABLE users_details_for_export_gal (
    id bigint NOT NULL,
    galaxy_key character varying(100) NOT NULL,
    mail_address character varying(200) NOT NULL,
    username character varying(200) NOT NULL
);


ALTER TABLE galaxy.users_details_for_export_gal OWNER TO galaxy;

SET search_path = i2b2demodata, pg_catalog;

--
-- Name: archive_observation_fact; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE archive_observation_fact (
    encounter_num numeric(38,0),
    patient_num numeric(38,0),
    concept_cd character varying(50),
    provider_id character varying(50),
    start_date timestamp without time zone,
    modifier_cd character varying(100),
    instance_num numeric(18,0),
    valtype_cd character varying(50),
    tval_char character varying(255),
    nval_num numeric(18,5),
    valueflag_cd character varying(50),
    quantity_num numeric(18,5),
    units_cd character varying(50),
    end_date timestamp without time zone,
    location_cd character varying(50),
    observation_blob text,
    confidence_num numeric(18,5),
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0),
    archive_upload_id numeric(22,0)
);


ALTER TABLE i2b2demodata.archive_observation_fact OWNER TO i2b2demodata;

--
-- Name: async_job; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE async_job (
    id integer NOT NULL,
    job_name character varying(200),
    job_status character varying(200),
    run_time character varying(200),
    job_status_time timestamp(6) without time zone,
    last_run_on timestamp(6) without time zone,
    viewer_url character varying(4000),
    alt_viewer_url character varying(600),
    job_results text,
    job_inputs_json text,
    job_type character varying(20)
);


ALTER TABLE i2b2demodata.async_job OWNER TO i2b2demodata;

--
-- Name: async_job_seq; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE async_job_seq
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.async_job_seq OWNER TO i2b2demodata;

--
-- Name: cd; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE cd (
    concept_path character varying(500),
    parent_concept_path character varying(500),
    patient_count bigint
);


ALTER TABLE i2b2demodata.cd OWNER TO i2b2demodata;

--
-- Name: code_lookup; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE code_lookup (
    table_cd character varying(100) NOT NULL,
    column_cd character varying(100) NOT NULL,
    code_cd character varying(50) NOT NULL,
    name_char character varying(650),
    lookup_blob text,
    upload_date timestamp without time zone,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.code_lookup OWNER TO i2b2demodata;

--
-- Name: concept_counts; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE concept_counts (
    concept_path character varying(500),
    parent_concept_path character varying(500),
    patient_count bigint
);


ALTER TABLE i2b2demodata.concept_counts OWNER TO i2b2demodata;

--
-- Name: concept_dimension; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE concept_dimension (
    concept_cd character varying(50) NOT NULL,
    concept_path character varying(700) NOT NULL,
    name_char character varying(2000),
    concept_blob text,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id bigint,
    table_name character varying(255)
);


ALTER TABLE i2b2demodata.concept_dimension OWNER TO i2b2demodata;

--
-- Name: concept_id; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE concept_id
    START WITH 1340964
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.concept_id OWNER TO i2b2demodata;

--
-- Name: counter; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE counter (
    concept_cd character varying(50) NOT NULL,
    counts bigint
);


ALTER TABLE i2b2demodata.counter OWNER TO i2b2demodata;

--
-- Name: crc_db_lookup; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE crc_db_lookup (
    c_domain_id character varying(255),
    c_project_path character varying(255),
    c_owner_id character varying(255),
    c_db_fullschema character varying(255),
    c_db_datasource character varying(255),
    c_db_servertype character varying(255),
    c_db_nicename character varying(255),
    c_db_tooltip character varying(255),
    c_comment text,
    c_entry_date timestamp without time zone,
    c_change_date timestamp without time zone,
    c_status_cd character(1)
);


ALTER TABLE i2b2demodata.crc_db_lookup OWNER TO i2b2demodata;

--
-- Name: datamart_report; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE datamart_report (
    total_patient numeric(38,0),
    total_observationfact numeric(38,0),
    total_event numeric(38,0),
    report_date timestamp without time zone
);


ALTER TABLE i2b2demodata.datamart_report OWNER TO i2b2demodata;

--
-- Name: dimloader; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE dimloader (
    c_hlevel bigint,
    c_fullname character varying(900),
    c_name character varying(2000),
    c_synonym_cd character(1),
    c_visualattributes character(3),
    c_totalnum bigint,
    c_basecode character varying(50),
    c_metadataxml text,
    c_facttablecolumn character varying(50),
    c_tablename character varying(50),
    c_columnname character varying(50),
    c_columndatatype character varying(50),
    c_operator character varying(10),
    c_dimcode character varying(900),
    c_comment text,
    c_tooltip character varying(900),
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    valuetype_cd character varying(50)
);


ALTER TABLE i2b2demodata.dimloader OWNER TO i2b2demodata;

--
-- Name: encounter_mapping; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE encounter_mapping (
    encounter_ide character varying(200) NOT NULL,
    encounter_ide_source character varying(50) NOT NULL,
    encounter_num numeric(38,0) NOT NULL,
    patient_ide character varying(200),
    patient_ide_source character varying(50),
    encounter_ide_status character varying(50),
    upload_date timestamp without time zone,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.encounter_mapping OWNER TO i2b2demodata;

--
-- Name: hilosequences; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE hilosequences (
    sequencename character varying(50) NOT NULL,
    highvalues bigint NOT NULL
);


ALTER TABLE i2b2demodata.hilosequences OWNER TO i2b2demodata;

--
-- Name: jms_messages; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE jms_messages (
    messageid bigint NOT NULL,
    destination character varying(255) NOT NULL,
    txid bigint,
    txop character(1),
    messageblob text
);


ALTER TABLE i2b2demodata.jms_messages OWNER TO i2b2demodata;

--
-- Name: jms_roles; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE jms_roles (
    roleid character varying(32) NOT NULL,
    userid character varying(32) NOT NULL
);


ALTER TABLE i2b2demodata.jms_roles OWNER TO i2b2demodata;

--
-- Name: jms_subscriptions; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE jms_subscriptions (
    clientid character varying(128) NOT NULL,
    subname character varying(128) NOT NULL,
    topic character varying(255) NOT NULL,
    selector character varying(255)
);


ALTER TABLE i2b2demodata.jms_subscriptions OWNER TO i2b2demodata;

--
-- Name: jms_transactions; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE jms_transactions (
    txid bigint
);


ALTER TABLE i2b2demodata.jms_transactions OWNER TO i2b2demodata;

--
-- Name: jms_users; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE jms_users (
    userid character varying(32) NOT NULL,
    passwd character varying(32) NOT NULL,
    clientid character varying(128)
);


ALTER TABLE i2b2demodata.jms_users OWNER TO i2b2demodata;

--
-- Name: map; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE map (
    subject_id character varying(100),
    smaple_id character varying(100)
);


ALTER TABLE i2b2demodata.map OWNER TO i2b2demodata;

--
-- Name: modifier_dimension; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE modifier_dimension (
    modifier_path character varying(700) NOT NULL,
    modifier_cd character varying(50),
    name_char character varying(2000),
    modifier_blob text,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id bigint,
    modifier_level bigint,
    modifier_node_type character varying(10)
);


ALTER TABLE i2b2demodata.modifier_dimension OWNER TO i2b2demodata;

--
-- Name: modifier_metadata; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE modifier_metadata (
    modifier_cd character varying(50),
    valtype_cd character varying(10),
    std_units character varying(50),
    visit_ind character(1)
);


ALTER TABLE i2b2demodata.modifier_metadata OWNER TO i2b2demodata;

--
-- Name: modifier_dimension_view; Type: VIEW; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE VIEW modifier_dimension_view AS
 SELECT md.modifier_path, 
    md.modifier_cd, 
    md.name_char, 
    md.modifier_blob, 
    md.update_date, 
    md.download_date, 
    md.import_date, 
    md.sourcesystem_cd, 
    md.upload_id, 
    md.modifier_level, 
    md.modifier_node_type, 
    mm.valtype_cd, 
    mm.std_units, 
    mm.visit_ind
   FROM (modifier_dimension md
   LEFT JOIN modifier_metadata mm ON (((md.modifier_cd)::text = (mm.modifier_cd)::text)));


ALTER TABLE i2b2demodata.modifier_dimension_view OWNER TO i2b2demodata;

--
-- Name: news_updates; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE news_updates (
    newsid integer,
    ranbyuser character varying(200),
    rowsaffected integer,
    operation character varying(200),
    datasetname character varying(200),
    updatedate timestamp(6) without time zone,
    commentfield character varying(200)
);


ALTER TABLE i2b2demodata.news_updates OWNER TO i2b2demodata;

--
-- Name: observation_fact; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE observation_fact (
    encounter_num numeric(38,0),
    patient_num numeric(38,0) NOT NULL,
    concept_cd character varying(50) NOT NULL,
    provider_id character varying(50) NOT NULL,
    start_date timestamp without time zone,
    modifier_cd character varying(100) NOT NULL,
    instance_num numeric(18,0),
    valtype_cd character varying(50),
    tval_char character varying(255),
    nval_num numeric(18,5),
    valueflag_cd character varying(50),
    quantity_num numeric(18,5),
    units_cd character varying(50),
    end_date timestamp without time zone,
    location_cd character varying(50),
    observation_blob text,
    confidence_num numeric(18,5),
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0),
    sample_cd character varying(200)
);


ALTER TABLE i2b2demodata.observation_fact OWNER TO i2b2demodata;

--
-- Name: patient_dimension; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE patient_dimension (
    patient_num numeric(38,0) NOT NULL,
    vital_status_cd character varying(50),
    birth_date timestamp without time zone,
    death_date timestamp without time zone,
    sex_cd character varying(50),
    age_in_years_num numeric(38,0),
    language_cd character varying(50),
    race_cd character varying(50),
    marital_status_cd character varying(50),
    religion_cd character varying(50),
    zip_cd character varying(50),
    statecityzip_path character varying(700),
    income_cd character varying(50),
    patient_blob text,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(107),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.patient_dimension OWNER TO i2b2demodata;

--
-- Name: patient_mapping; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE patient_mapping (
    patient_ide character varying(200) NOT NULL,
    patient_ide_source character varying(50) NOT NULL,
    patient_num numeric(38,0) NOT NULL,
    patient_ide_status character varying(50),
    upload_date timestamp without time zone,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.patient_mapping OWNER TO i2b2demodata;

--
-- Name: patient_trial; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE patient_trial (
    patient_num numeric,
    trial character varying(30),
    secure_obj_token character varying(50)
);


ALTER TABLE i2b2demodata.patient_trial OWNER TO i2b2demodata;

--
-- Name: protocol_id_seq; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE protocol_id_seq
    START WITH 215
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.protocol_id_seq OWNER TO i2b2demodata;

--
-- Name: provider_dimension; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE provider_dimension (
    provider_id character varying(50) NOT NULL,
    provider_path character varying(700) NOT NULL,
    name_char character varying(850),
    provider_blob text,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.provider_dimension OWNER TO i2b2demodata;

--
-- Name: qt_analysis_plugin; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_analysis_plugin (
    plugin_id numeric(10,0) NOT NULL,
    plugin_name character varying(2000),
    description character varying(2000),
    version_cd character varying(50),
    parameter_info text,
    parameter_info_xsd text,
    command_line text,
    working_folder text,
    commandoption_cd text,
    plugin_icon text,
    status_cd character varying(50),
    user_id character varying(50),
    group_id character varying(50),
    create_date timestamp without time zone,
    update_date timestamp without time zone
);


ALTER TABLE i2b2demodata.qt_analysis_plugin OWNER TO i2b2demodata;

--
-- Name: qt_analysis_plugin_result_type; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_analysis_plugin_result_type (
    plugin_id numeric(10,0) NOT NULL,
    result_type_id numeric(10,0) NOT NULL
);


ALTER TABLE i2b2demodata.qt_analysis_plugin_result_type OWNER TO i2b2demodata;

--
-- Name: qt_breakdown_path; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_breakdown_path (
    name character varying(100),
    value character varying(2000),
    create_date timestamp without time zone,
    update_date timestamp without time zone,
    user_id character varying(50)
);


ALTER TABLE i2b2demodata.qt_breakdown_path OWNER TO i2b2demodata;

--
-- Name: qt_sq_qper_pecid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qper_pecid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qper_pecid OWNER TO i2b2demodata;

--
-- Name: qt_patient_enc_collection; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_patient_enc_collection (
    patient_enc_coll_id numeric(10,0) DEFAULT nextval('qt_sq_qper_pecid'::regclass) NOT NULL,
    result_instance_id numeric(5,0),
    set_index numeric(10,0),
    patient_num numeric(10,0),
    encounter_num numeric(10,0)
);


ALTER TABLE i2b2demodata.qt_patient_enc_collection OWNER TO i2b2demodata;

--
-- Name: qt_sq_qpr_pcid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qpr_pcid
    START WITH 4430157
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qpr_pcid OWNER TO i2b2demodata;

--
-- Name: qt_patient_set_collection; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_patient_set_collection (
    patient_set_coll_id numeric(10,0) DEFAULT nextval('qt_sq_qpr_pcid'::regclass) NOT NULL,
    result_instance_id numeric(5,0),
    set_index numeric(10,0),
    patient_num numeric(10,0)
);


ALTER TABLE i2b2demodata.qt_patient_set_collection OWNER TO i2b2demodata;

--
-- Name: qt_sq_pqm_qmid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_pqm_qmid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_pqm_qmid OWNER TO i2b2demodata;

--
-- Name: qt_pdo_query_master; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_pdo_query_master (
    query_master_id numeric(5,0) DEFAULT nextval('qt_sq_pqm_qmid'::regclass) NOT NULL,
    user_id character varying(50) NOT NULL,
    group_id character varying(50) NOT NULL,
    create_date timestamp without time zone NOT NULL,
    request_xml text,
    i2b2_request_xml text
);


ALTER TABLE i2b2demodata.qt_pdo_query_master OWNER TO i2b2demodata;

--
-- Name: qt_privilege; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_privilege (
    protection_label_cd character varying(1500),
    dataprot_cd character varying(1000),
    hivemgmt_cd character varying(1000),
    plugin_id numeric(10,0)
);


ALTER TABLE i2b2demodata.qt_privilege OWNER TO i2b2demodata;

--
-- Name: qt_sq_qi_qiid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qi_qiid
    START WITH 28714
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qi_qiid OWNER TO i2b2demodata;

--
-- Name: qt_query_instance; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_query_instance (
    query_instance_id numeric(5,0) DEFAULT nextval('qt_sq_qi_qiid'::regclass) NOT NULL,
    query_master_id numeric(5,0),
    user_id character varying(50) NOT NULL,
    group_id character varying(50) NOT NULL,
    batch_mode character varying(50),
    start_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone,
    delete_flag character varying(3),
    status_type_id numeric(5,0),
    message text
);


ALTER TABLE i2b2demodata.qt_query_instance OWNER TO i2b2demodata;

--
-- Name: qt_sq_qm_qmid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qm_qmid
    START WITH 28736
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qm_qmid OWNER TO i2b2demodata;

--
-- Name: qt_query_master; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_query_master (
    query_master_id numeric(5,0) DEFAULT nextval('qt_sq_qm_qmid'::regclass) NOT NULL,
    name character varying(250) NOT NULL,
    user_id character varying(50) NOT NULL,
    group_id character varying(50) NOT NULL,
    master_type_cd character varying(2000),
    plugin_id numeric(10,0),
    create_date timestamp without time zone NOT NULL,
    delete_date timestamp without time zone,
    delete_flag character varying(3),
    generated_sql text,
    request_xml text,
    i2b2_request_xml text
);


ALTER TABLE i2b2demodata.qt_query_master OWNER TO i2b2demodata;

--
-- Name: qt_sq_qri_qriid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qri_qriid
    START WITH 28694
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qri_qriid OWNER TO i2b2demodata;

--
-- Name: qt_query_result_instance; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_query_result_instance (
    result_instance_id numeric(5,0) DEFAULT nextval('qt_sq_qri_qriid'::regclass) NOT NULL,
    query_instance_id numeric(5,0),
    result_type_id numeric(3,0) NOT NULL,
    set_size numeric(10,0),
    start_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone,
    delete_flag character varying(3),
    status_type_id numeric(3,0) NOT NULL,
    message text,
    description character varying(200),
    real_set_size numeric(10,0),
    obfusc_method character varying(500)
);


ALTER TABLE i2b2demodata.qt_query_result_instance OWNER TO i2b2demodata;

--
-- Name: qt_sq_qr_qrid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qr_qrid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qr_qrid OWNER TO i2b2demodata;

--
-- Name: qt_query_result_type; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_query_result_type (
    result_type_id numeric(3,0) DEFAULT nextval('qt_sq_qr_qrid'::regclass) NOT NULL,
    name character varying(100),
    description character varying(200),
    display_type_id character varying(500),
    visual_attribute_type_id character varying(3)
);


ALTER TABLE i2b2demodata.qt_query_result_type OWNER TO i2b2demodata;

--
-- Name: qt_sq_qs_qsid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qs_qsid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qs_qsid OWNER TO i2b2demodata;

--
-- Name: qt_query_status_type; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_query_status_type (
    status_type_id numeric(3,0) DEFAULT nextval('qt_sq_qs_qsid'::regclass) NOT NULL,
    name character varying(100),
    description character varying(200)
);


ALTER TABLE i2b2demodata.qt_query_status_type OWNER TO i2b2demodata;

--
-- Name: qt_sq_qxr_xrid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE qt_sq_qxr_xrid
    START WITH 655
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.qt_sq_qxr_xrid OWNER TO i2b2demodata;

--
-- Name: qt_xml_result; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE qt_xml_result (
    xml_result_id numeric(5,0) DEFAULT nextval('qt_sq_qxr_xrid'::regclass) NOT NULL,
    result_instance_id numeric(5,0),
    xml_value character varying(4000)
);


ALTER TABLE i2b2demodata.qt_xml_result OWNER TO i2b2demodata;

--
-- Name: ricerca; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE ricerca (
    concept_cd character varying(50) NOT NULL,
    concept_path character varying(700) NOT NULL
);


ALTER TABLE i2b2demodata.ricerca OWNER TO i2b2demodata;

--
-- Name: sample_categories; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE sample_categories (
    trial_cd character varying(200),
    sample_id character varying(250),
    trial_name character varying(100),
    sample_cd character varying(200),
    field1 character varying(200),
    field2 character varying(200),
    field3 character varying(200),
    field4 character varying(200),
    field5 character varying(200),
    field6 character varying(200),
    field7 character varying(200),
    field8 character varying(200),
    field9 character varying(200),
    field10 character varying(200),
    field11 character varying(200),
    field12 character varying(200),
    field13 character varying(200),
    field14 character varying(200),
    field15 character varying(200),
    tissue_type character varying(2000),
    data_types character varying(2000),
    disease character varying(2000),
    tissue_state character varying(2000),
    biobank character varying(3),
    source_organism character varying(255),
    treatment character varying(255),
    sample_treatment character varying(2000),
    subject_treatment character varying(2000),
    timepoint character varying(250)
);


ALTER TABLE i2b2demodata.sample_categories OWNER TO i2b2demodata;

--
-- Name: sample_dimension; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE sample_dimension (
    sample_cd character varying(200) NOT NULL
);


ALTER TABLE i2b2demodata.sample_dimension OWNER TO i2b2demodata;

--
-- Name: seq_encounter_num; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE seq_encounter_num
    START WITH 49814595
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.seq_encounter_num OWNER TO i2b2demodata;

--
-- Name: seq_patient_num; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE seq_patient_num
    START WITH 1000384597
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.seq_patient_num OWNER TO i2b2demodata;

--
-- Name: seq_subject_reference; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE seq_subject_reference
    START WITH 743
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.seq_subject_reference OWNER TO i2b2demodata;

--
-- Name: sq_up_patdim_patientnum; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE sq_up_patdim_patientnum
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.sq_up_patdim_patientnum OWNER TO i2b2demodata;

--
-- Name: set_type; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE set_type (
    id integer DEFAULT nextval('sq_up_patdim_patientnum'::regclass) NOT NULL,
    name character varying(500),
    create_date timestamp without time zone
);


ALTER TABLE i2b2demodata.set_type OWNER TO i2b2demodata;

--
-- Name: set_upload_status; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE set_upload_status (
    upload_id numeric NOT NULL,
    set_type_id integer NOT NULL,
    source_cd character varying(50) NOT NULL,
    no_of_record numeric,
    loaded_record numeric,
    deleted_record numeric,
    load_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone,
    load_status character varying(100),
    message text,
    input_file_name text,
    log_file_name text,
    transform_name character varying(500)
);


ALTER TABLE i2b2demodata.set_upload_status OWNER TO i2b2demodata;

--
-- Name: source_master; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE source_master (
    source_cd character varying(50) NOT NULL,
    description character varying(300),
    create_date timestamp without time zone
);


ALTER TABLE i2b2demodata.source_master OWNER TO i2b2demodata;

--
-- Name: sq_up_encdim_encounternum; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE sq_up_encdim_encounternum
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.sq_up_encdim_encounternum OWNER TO i2b2demodata;

--
-- Name: sq_uploadstatus_uploadid; Type: SEQUENCE; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE SEQUENCE sq_uploadstatus_uploadid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2demodata.sq_uploadstatus_uploadid OWNER TO i2b2demodata;

--
-- Name: timers; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE timers (
    timerid character varying(80) NOT NULL,
    targetid character varying(250) NOT NULL,
    initialdate timestamp(6) without time zone NOT NULL,
    timerinterval bigint,
    instancepk text,
    info text
);


ALTER TABLE i2b2demodata.timers OWNER TO i2b2demodata;

--
-- Name: upload_status; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE upload_status (
    upload_id numeric(38,0) DEFAULT nextval('sq_uploadstatus_uploadid'::regclass) NOT NULL,
    upload_label character varying(500) NOT NULL,
    user_id character varying(100) NOT NULL,
    source_cd character varying(50) NOT NULL,
    no_of_record numeric,
    loaded_record numeric,
    deleted_record numeric,
    load_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone,
    load_status character varying(100),
    message text,
    input_file_name text,
    log_file_name text,
    transform_name character varying(500)
);


ALTER TABLE i2b2demodata.upload_status OWNER TO i2b2demodata;

--
-- Name: visit_dimension; Type: TABLE; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: transmart
--

CREATE TABLE visit_dimension (
    encounter_num numeric(38,0) NOT NULL,
    patient_num numeric(38,0) NOT NULL,
    active_status_cd character varying(50),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    inout_cd character varying(50),
    location_cd character varying(50),
    location_path character varying(900),
    length_of_stay numeric(38,0),
    visit_blob text,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id numeric(38,0)
);


ALTER TABLE i2b2demodata.visit_dimension OWNER TO i2b2demodata;

SET search_path = i2b2metadata, pg_catalog;

--
-- Name: custom_meta; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: transmart
--

CREATE TABLE custom_meta (
    c_hlevel bigint NOT NULL,
    c_fullname character varying(700) NOT NULL,
    c_name character varying(2000) NOT NULL,
    c_synonym_cd character(1) NOT NULL,
    c_visualattributes character(3) NOT NULL,
    c_totalnum bigint,
    c_basecode character varying(50),
    c_metadataxml text,
    c_facttablecolumn character varying(50) NOT NULL,
    c_tablename character varying(50) NOT NULL,
    c_columnname character varying(50) NOT NULL,
    c_columndatatype character varying(50) NOT NULL,
    c_operator character varying(10) NOT NULL,
    c_dimcode character varying(900) NOT NULL,
    c_comment text,
    c_tooltip character varying(900),
    update_date timestamp without time zone NOT NULL,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    valuetype_cd character varying(50),
    m_applied_path character varying(700) NOT NULL,
    m_exclusion_cd character varying(25),
    c_path character varying(700),
    c_symbol character varying(50)
);


ALTER TABLE i2b2metadata.custom_meta OWNER TO i2b2metadata;

--
-- Name: i2b2_record_id_seq; Type: SEQUENCE; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE SEQUENCE i2b2_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2metadata.i2b2_record_id_seq OWNER TO i2b2metadata;

--
-- Name: i2b2; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: transmart
--

CREATE TABLE i2b2 (
    c_hlevel numeric(22,0) NOT NULL,
    c_fullname character varying(700) NOT NULL,
    c_name character varying(2000) NOT NULL,
    c_synonym_cd character(1) NOT NULL,
    c_visualattributes character(3) NOT NULL,
    c_totalnum numeric(22,0),
    c_basecode character varying(50),
    c_metadataxml text,
    c_facttablecolumn character varying(50) NOT NULL,
    c_tablename character varying(150) NOT NULL,
    c_columnname character varying(50) NOT NULL,
    c_columndatatype character varying(50) NOT NULL,
    c_operator character varying(10) NOT NULL,
    c_dimcode character varying(700) NOT NULL,
    c_comment text,
    c_tooltip character varying(900),
    m_applied_path character varying(700) NOT NULL,
    update_date timestamp without time zone NOT NULL,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    valuetype_cd character varying(50),
    m_exclusion_cd character varying(25),
    c_path character varying(700),
    c_symbol character varying(50),
    i2b2_id bigint,
    record_id integer DEFAULT nextval('i2b2_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE i2b2metadata.i2b2 OWNER TO i2b2metadata;

--
-- Name: i2b2_id_seq; Type: SEQUENCE; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE SEQUENCE i2b2_id_seq
    START WITH 496244
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2metadata.i2b2_id_seq OWNER TO i2b2metadata;

--
-- Name: i2b2_secure; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: transmart
--

CREATE TABLE i2b2_secure (
    c_hlevel numeric(22,0),
    c_fullname character varying(900) NOT NULL,
    c_name character varying(2000),
    c_synonym_cd character(1),
    c_visualattributes character(3),
    c_totalnum numeric(22,0),
    c_basecode character varying(450),
    c_metadataxml text,
    c_facttablecolumn character varying(50),
    c_tablename character varying(150),
    c_columnname character varying(50),
    c_columndatatype character varying(50),
    c_operator character varying(10),
    c_dimcode character varying(900),
    c_comment text,
    c_tooltip character varying(900),
    m_applied_path character varying(700),
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    valuetype_cd character varying(50),
    m_exclusion_cd character varying(25),
    c_path character varying(900),
    c_symbol character varying(50),
    i2b2_id numeric(18,0),
    secure_obj_token character varying(50)
);


ALTER TABLE i2b2metadata.i2b2_secure OWNER TO i2b2metadata;

--
-- Name: i2b2_tags; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: transmart
--

CREATE TABLE i2b2_tags (
    tag_id integer NOT NULL,
    path character varying(400),
    tag character varying(1000),
    tag_type character varying(400),
    tags_idx integer NOT NULL
);


ALTER TABLE i2b2metadata.i2b2_tags OWNER TO i2b2metadata;

--
-- Name: i2b2_trial_nodes; Type: VIEW; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE VIEW i2b2_trial_nodes AS
 SELECT DISTINCT ON (i2b2.c_comment) i2b2.c_fullname, 
    "substring"(i2b2.c_comment, 7) AS trial
   FROM i2b2
  WHERE (i2b2.c_comment IS NOT NULL)
  ORDER BY i2b2.c_comment, char_length((i2b2.c_fullname)::text);


ALTER TABLE i2b2metadata.i2b2_trial_nodes OWNER TO i2b2metadata;

--
-- Name: ont_db_lookup; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: transmart
--

CREATE TABLE ont_db_lookup (
    c_domain_id character varying(255),
    c_project_path character varying(255),
    c_owner_id character varying(255),
    c_db_fullschema character varying(255),
    c_db_datasource character varying(255),
    c_db_servertype character varying(255),
    c_db_nicename character varying(255),
    c_db_tooltip character varying(255),
    c_comment text,
    c_entry_date timestamp without time zone,
    c_change_date timestamp without time zone,
    c_status_cd character(1)
);


ALTER TABLE i2b2metadata.ont_db_lookup OWNER TO i2b2metadata;

--
-- Name: ont_sq_ps_prid; Type: SEQUENCE; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE SEQUENCE ont_sq_ps_prid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2metadata.ont_sq_ps_prid OWNER TO i2b2metadata;

--
-- Name: ont_process_status; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: transmart
--

CREATE TABLE ont_process_status (
    process_id numeric(5,0) DEFAULT nextval('ont_sq_ps_prid'::regclass) NOT NULL,
    process_type_cd character varying(50),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    process_step_cd character varying(50),
    process_status_cd character varying(50),
    crc_upload_id character varying(5),
    status_cd character varying(50),
    message character varying(2000),
    entry_date timestamp without time zone,
    change_date timestamp without time zone,
    changedby_char character(50)
);


ALTER TABLE i2b2metadata.ont_process_status OWNER TO i2b2metadata;

--
-- Name: schemes; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: transmart
--

CREATE TABLE schemes (
    c_key character varying(50) NOT NULL,
    c_name character varying(50) NOT NULL,
    c_description character varying(100)
);


ALTER TABLE i2b2metadata.schemes OWNER TO i2b2metadata;

--
-- Name: seq_concept_code; Type: SEQUENCE; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE SEQUENCE seq_concept_code
    START WITH 1000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2metadata.seq_concept_code OWNER TO i2b2metadata;

--
-- Name: seq_i2b2_data_id; Type: SEQUENCE; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE SEQUENCE seq_i2b2_data_id
    START WITH 1789
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2metadata.seq_i2b2_data_id OWNER TO i2b2metadata;

--
-- Name: seq_i2b2_tags_tag_id; Type: SEQUENCE; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE SEQUENCE seq_i2b2_tags_tag_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE i2b2metadata.seq_i2b2_tags_tag_id OWNER TO i2b2metadata;

--
-- Name: sq_i2b2_id; Type: SEQUENCE; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE SEQUENCE sq_i2b2_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2metadata.sq_i2b2_id OWNER TO i2b2metadata;

--
-- Name: sq_i2b2_tag_id; Type: SEQUENCE; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE SEQUENCE sq_i2b2_tag_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE i2b2metadata.sq_i2b2_tag_id OWNER TO i2b2metadata;

--
-- Name: table_access; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: transmart
--

CREATE TABLE table_access (
    c_table_cd character varying(65) NOT NULL,
    c_table_name character varying(50) NOT NULL,
    c_protected_access character(1),
    c_hlevel numeric(22,0) NOT NULL,
    c_fullname character varying(700) NOT NULL,
    c_name character varying(2000) NOT NULL,
    c_synonym_cd character(1) NOT NULL,
    c_visualattributes character(3) NOT NULL,
    c_totalnum numeric(22,0),
    c_basecode character varying(50),
    c_metadataxml text,
    c_facttablecolumn character varying(50) NOT NULL,
    c_dimtablename character varying(50) NOT NULL,
    c_columnname character varying(50) NOT NULL,
    c_columndatatype character varying(50) NOT NULL,
    c_operator character varying(10) NOT NULL,
    c_dimcode character varying(700) NOT NULL,
    c_comment text,
    c_tooltip character varying(900),
    c_entry_date timestamp without time zone,
    c_change_date timestamp without time zone,
    c_status_cd character(1),
    valuetype_cd character varying(50)
);


ALTER TABLE i2b2metadata.table_access OWNER TO i2b2metadata;

--
-- Name: tmp_secure_token; Type: TABLE; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: transmart
--

CREATE TABLE tmp_secure_token (
    sourcesystem_cd character varying(50),
    secure_obj_token character varying(50)
);


ALTER TABLE i2b2metadata.tmp_secure_token OWNER TO i2b2metadata;

SET search_path = public, pg_catalog;

SET default_tablespace = '';

--
-- Name: biomart_write_tables; Type: TABLE; Schema: public; Owner: weymouth; Tablespace: 
--

CREATE TABLE biomart_write_tables (
    nschema text,
    ntable text
);


ALTER TABLE public.biomart_write_tables OWNER TO weymouth;

--
-- Name: schemas_tables_funcs; Type: VIEW; Schema: public; Owner: weymouth
--

CREATE VIEW schemas_tables_funcs AS
        (        (        ( SELECT quote_ident((c.relname)::text) AS name, 
                            c.relkind AS kind, 
                            r.rolname AS owner, 
                            c.relacl AS acl, 
                            n.nspname, 
                            (EXISTS ( SELECT 1
                                   FROM pg_depend
                                  WHERE (((pg_depend.refobjsubid <> 0) AND (pg_depend.deptype = 'a'::"char")) AND (pg_depend.objid = c.oid))
                                 LIMIT 1)) AS change_owner_skip
                           FROM ((pg_class c
                      JOIN pg_namespace n ON ((c.relnamespace = n.oid)))
                 JOIN pg_roles r ON ((c.relowner = r.oid)))
                WHERE (c.relkind = ANY (ARRAY['r'::"char", 'S'::"char", 'v'::"char"]))
                ORDER BY (c.relkind = 'S'::"char"))
                UNION 
                         SELECT n.nspname AS name, 
                            's'::"char" AS kind, 
                            r.rolname AS owner, 
                            n.nspacl AS acl, 
                            n.nspname, 
                            false AS change_owner_skip
                           FROM (pg_namespace n
                      JOIN pg_roles r ON ((n.nspowner = r.oid))))
        UNION 
                 SELECT quote_ident((pg_tablespace.spcname)::text) AS name, 
                    'T'::"char" AS kind, 
                    NULL::name AS owner, 
                    pg_tablespace.spcacl AS acl, 
                    NULL::name AS nspname, 
                    false AS change_owner_skip
                   FROM pg_tablespace
                  WHERE (pg_tablespace.spcname !~~ 'pg\_%'::text))
UNION 
         SELECT (((quote_ident((p.proname)::text) || '('::text) || array_to_string(( SELECT array_accum(y.typname) AS array_accum
                   FROM ( SELECT t.typname
                           FROM (( SELECT z.id, 
                                    p.proargtypes[z.id] AS proargtypes
                                   FROM generate_subscripts(p.proargtypes, 1) z(id)) a(id, oid)
                      JOIN pg_type t ON ((t.oid = a.oid)))
                     GROUP BY a.id, t.typname
                     ORDER BY a.id) y), ', '::text)) || ')'::text) AS name, 
            (
                CASE p.proisagg
                    WHEN false THEN 'f'::text
                    ELSE 'a'::text
                END)::"char" AS kind, 
            r.rolname AS owner, 
            p.proacl AS acl, 
            n.nspname, 
            false AS change_owner_skip
           FROM ((pg_proc p
      JOIN pg_namespace n ON ((p.pronamespace = n.oid)))
   JOIN pg_roles r ON ((p.proowner = r.oid)));


ALTER TABLE public.schemas_tables_funcs OWNER TO weymouth;

--
-- Name: ts_default_permissions; Type: TABLE; Schema: public; Owner: weymouth; Tablespace: 
--

CREATE TABLE ts_default_permissions (
    nschema text,
    nuser text,
    ntype text,
    nperm text
);


ALTER TABLE public.ts_default_permissions OWNER TO weymouth;

--
-- Name: ts_misc_permissions; Type: TABLE; Schema: public; Owner: weymouth; Tablespace: 
--

CREATE TABLE ts_misc_permissions (
    nschema text,
    nname text,
    ntype text,
    nuser text,
    nperm text
);


ALTER TABLE public.ts_misc_permissions OWNER TO weymouth;

SET search_path = searchapp, pg_catalog;

--
-- Name: hibernate_sequence; Type: SEQUENCE; Schema: searchapp; Owner: searchapp
--

CREATE SEQUENCE hibernate_sequence
    START WITH 100042
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE searchapp.hibernate_sequence OWNER TO searchapp;

SET default_tablespace = transmart;

--
-- Name: search_gene_signature; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_gene_signature (
    search_gene_signature_id bigint NOT NULL,
    name character varying(100) NOT NULL,
    description character varying(1000),
    unique_id character varying(50),
    create_date timestamp without time zone NOT NULL,
    created_by_auth_user_id bigint NOT NULL,
    last_modified_date timestamp without time zone,
    modified_by_auth_user_id bigint,
    version_number character varying(50),
    public_flag boolean DEFAULT false,
    deleted_flag boolean DEFAULT false,
    parent_gene_signature_id bigint,
    source_concept_id bigint,
    source_other character varying(255),
    owner_concept_id bigint,
    stimulus_description character varying(1000),
    stimulus_dosing character varying(255),
    treatment_description character varying(1000),
    treatment_dosing character varying(255),
    treatment_bio_compound_id bigint,
    treatment_protocol_number character varying(50),
    pmid_list character varying(255),
    species_concept_id bigint NOT NULL,
    species_mouse_src_concept_id bigint,
    species_mouse_detail character varying(255),
    tissue_type_concept_id bigint,
    experiment_type_concept_id bigint,
    experiment_type_in_vivo_descr character varying(255),
    experiment_type_atcc_ref character varying(255),
    analytic_cat_concept_id bigint,
    analytic_cat_other character varying(255),
    bio_assay_platform_id bigint NOT NULL,
    analyst_name character varying(100),
    norm_method_concept_id bigint,
    norm_method_other character varying(255),
    analysis_method_concept_id bigint,
    analysis_method_other character varying(255),
    multiple_testing_correction boolean,
    p_value_cutoff_concept_id bigint NOT NULL,
    upload_file character varying(255) NOT NULL,
    search_gene_sig_file_schema_id bigint DEFAULT 1 NOT NULL,
    fold_chg_metric_concept_id bigint NOT NULL,
    experiment_type_cell_line_id bigint,
    qc_performed numeric(1,0),
    qc_date date,
    qc_info character varying(255),
    data_source character varying(255),
    custom_value1 character varying(255),
    custom_name1 character varying(255),
    custom_value2 character varying(255),
    custom_name2 character varying(255),
    custom_value3 character varying(255),
    custom_name3 character varying(255),
    custom_value4 character varying(255),
    custom_name4 character varying(255),
    custom_value5 character varying(255),
    custom_name5 character varying(255),
    version character varying(255)
);


ALTER TABLE searchapp.search_gene_signature OWNER TO searchapp;

--
-- Name: search_gene_signature_item; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_gene_signature_item (
    search_gene_signature_id bigint NOT NULL,
    bio_marker_id bigint,
    fold_chg_metric bigint,
    bio_data_unique_id character varying(200),
    id bigint NOT NULL,
    bio_assay_feature_group_id bigint,
    probeset_id bigint
);


ALTER TABLE searchapp.search_gene_signature_item OWNER TO searchapp;

--
-- Name: search_keyword; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_keyword (
    keyword character varying(400),
    bio_data_id bigint,
    unique_id character varying(500) NOT NULL,
    search_keyword_id bigint NOT NULL,
    data_category character varying(200) NOT NULL,
    source_code character varying(100),
    display_data_category character varying(200),
    owner_auth_user_id bigint
);


ALTER TABLE searchapp.search_keyword OWNER TO searchapp;

--
-- Name: listsig_genes; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW listsig_genes AS
 SELECT k_gsi.search_keyword_id AS gene_keyword_id, 
    k_gs.search_keyword_id AS list_keyword_id
   FROM search_keyword k_gs, 
    search_gene_signature gs, 
    search_gene_signature_item gsi, 
    search_keyword k_gsi
  WHERE (((k_gs.bio_data_id = gs.search_gene_signature_id) AND (gs.search_gene_signature_id = gsi.search_gene_signature_id)) AND (gsi.bio_marker_id = k_gsi.bio_data_id));


ALTER TABLE searchapp.listsig_genes OWNER TO searchapp;

--
-- Name: pathway_genes; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW pathway_genes AS
 SELECT k_gene.search_keyword_id AS gene_keyword_id, 
    k_pathway.search_keyword_id AS pathway_keyword_id, 
    b.asso_bio_marker_id AS gene_biomarker_id
   FROM search_keyword k_pathway, 
    biomart.bio_marker_correl_mv b, 
    search_keyword k_gene
  WHERE (((((b.correl_type = 'PATHWAY_GENE'::text) AND (b.bio_marker_id = k_pathway.bio_data_id)) AND ((k_pathway.data_category)::text = 'PATHWAY'::text)) AND (b.asso_bio_marker_id = k_gene.bio_data_id)) AND ((k_gene.data_category)::text = 'GENE'::text));


ALTER TABLE searchapp.pathway_genes OWNER TO searchapp;

--
-- Name: plugin; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE plugin (
    plugin_seq bigint NOT NULL,
    name character varying(200) NOT NULL,
    plugin_name character varying(90) NOT NULL,
    has_modules character(1) DEFAULT 'N'::bpchar NOT NULL,
    has_form character(1) DEFAULT 'N'::bpchar NOT NULL,
    default_link character varying(70) NOT NULL,
    form_link character varying(70),
    form_page character varying(100),
    active character(1)
);


ALTER TABLE searchapp.plugin OWNER TO searchapp;

--
-- Name: plugin_module; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE plugin_module (
    module_seq bigint NOT NULL,
    plugin_seq bigint NOT NULL,
    name character varying(70) NOT NULL,
    params text NOT NULL,
    version character varying(10) DEFAULT 0.1 NOT NULL,
    active character(1) DEFAULT 'Y'::bpchar NOT NULL,
    has_form character(1) DEFAULT 'N'::bpchar NOT NULL,
    form_link character varying(90),
    form_page character varying(90),
    module_name character varying(50) NOT NULL,
    category character varying(50)
);


ALTER TABLE searchapp.plugin_module OWNER TO searchapp;

--
-- Name: plugin_module_backup; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE plugin_module_backup (
    module_seq bigint NOT NULL,
    plugin_seq bigint NOT NULL,
    name character varying(70) NOT NULL,
    params text NOT NULL,
    version character varying(10) NOT NULL,
    active character(1) NOT NULL,
    has_form character(1) NOT NULL,
    form_link character varying(90),
    form_page character varying(90),
    module_name character varying(50) NOT NULL,
    category character varying(50)
);


ALTER TABLE searchapp.plugin_module_backup OWNER TO searchapp;

--
-- Name: plugin_module_seq; Type: SEQUENCE; Schema: searchapp; Owner: searchapp
--

CREATE SEQUENCE plugin_module_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE searchapp.plugin_module_seq OWNER TO searchapp;

--
-- Name: plugin_seq; Type: SEQUENCE; Schema: searchapp; Owner: searchapp
--

CREATE SEQUENCE plugin_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE searchapp.plugin_seq OWNER TO searchapp;

--
-- Name: report; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE report (
    report_id bigint,
    name character varying(200),
    description character varying(1000),
    creatinguser character varying(200),
    public_flag character varying(20),
    create_date timestamp(6) without time zone,
    study character varying(200)
);


ALTER TABLE searchapp.report OWNER TO searchapp;

--
-- Name: report_item; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE report_item (
    report_item_id bigint,
    report_id bigint,
    code character varying(200)
);


ALTER TABLE searchapp.report_item OWNER TO searchapp;

--
-- Name: saved_faceted_search; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE saved_faceted_search (
    saved_faceted_search_id bigint NOT NULL,
    user_id bigint NOT NULL,
    name character varying(100) NOT NULL,
    keywords character varying(4000) NOT NULL,
    create_dt date DEFAULT now(),
    modified_dt date,
    search_type character varying(50) DEFAULT 'FACETED_SEARCH'::character varying NOT NULL,
    analysis_ids character varying(4000)
);


ALTER TABLE searchapp.saved_faceted_search OWNER TO searchapp;

--
-- Name: search_app_access_log; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_app_access_log (
    id bigint,
    access_time timestamp without time zone,
    event character varying(255),
    request_url character varying(255),
    user_name character varying(255),
    event_message text
);


ALTER TABLE searchapp.search_app_access_log OWNER TO searchapp;

--
-- Name: search_auth_group; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_auth_group (
    id bigint NOT NULL,
    group_category character varying(255)
);


ALTER TABLE searchapp.search_auth_group OWNER TO searchapp;

--
-- Name: search_auth_group_member; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_auth_group_member (
    auth_user_id bigint,
    auth_group_id bigint
);


ALTER TABLE searchapp.search_auth_group_member OWNER TO searchapp;

--
-- Name: search_auth_principal; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_auth_principal (
    id bigint NOT NULL,
    principal_type character varying(255),
    date_created timestamp without time zone NOT NULL,
    description character varying(255),
    last_updated timestamp without time zone NOT NULL,
    name character varying(255),
    unique_id character varying(255),
    enabled boolean
);


ALTER TABLE searchapp.search_auth_principal OWNER TO searchapp;

--
-- Name: search_auth_sec_object_access; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_auth_sec_object_access (
    auth_sec_obj_access_id bigint NOT NULL,
    auth_principal_id bigint,
    secure_object_id bigint,
    secure_access_level_id bigint
);


ALTER TABLE searchapp.search_auth_sec_object_access OWNER TO searchapp;

--
-- Name: search_auth_user; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_auth_user (
    id bigint NOT NULL,
    email character varying(255),
    email_show boolean,
    passwd character varying(255),
    user_real_name character varying(255),
    username character varying(255),
    federated_id character varying(255)
);


ALTER TABLE searchapp.search_auth_user OWNER TO searchapp;

--
-- Name: search_auth_user_sec_access; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_auth_user_sec_access (
    search_auth_user_sec_access_id bigint NOT NULL,
    search_auth_user_id bigint,
    search_secure_object_id bigint,
    search_sec_access_level_id bigint
);


ALTER TABLE searchapp.search_auth_user_sec_access OWNER TO searchapp;

--
-- Name: search_auth_user_sec_access_v; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_auth_user_sec_access_v AS
        (         SELECT sasoa.auth_sec_obj_access_id AS search_auth_user_sec_access_id, 
                    sasoa.auth_principal_id AS search_auth_user_id, 
                    sasoa.secure_object_id AS search_secure_object_id, 
                    sasoa.secure_access_level_id AS search_sec_access_level_id
                   FROM search_auth_user sau, 
                    search_auth_sec_object_access sasoa
                  WHERE (sau.id = sasoa.auth_principal_id)
        UNION 
                 SELECT sasoa.auth_sec_obj_access_id AS search_auth_user_sec_access_id, 
                    sagm.auth_user_id AS search_auth_user_id, 
                    sasoa.secure_object_id AS search_secure_object_id, 
                    sasoa.secure_access_level_id AS search_sec_access_level_id
                   FROM search_auth_group sag, 
                    search_auth_group_member sagm, 
                    search_auth_sec_object_access sasoa
                  WHERE ((sag.id = sagm.auth_group_id) AND (sag.id = sasoa.auth_principal_id)))
UNION 
         SELECT sasoa.auth_sec_obj_access_id AS search_auth_user_sec_access_id, 
            NULL::bigint AS search_auth_user_id, 
            sasoa.secure_object_id AS search_secure_object_id, 
            sasoa.secure_access_level_id AS search_sec_access_level_id
           FROM search_auth_group sag, 
            search_auth_sec_object_access sasoa
          WHERE (((sag.group_category)::text = 'EVERYONE_GROUP'::text) AND (sag.id = sasoa.auth_principal_id));


ALTER TABLE searchapp.search_auth_user_sec_access_v OWNER TO searchapp;

--
-- Name: search_bio_mkr_correl_fast_mv; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_bio_mkr_correl_fast_mv (
    domain_object_id bigint NOT NULL,
    asso_bio_marker_id bigint,
    correl_type character varying(19),
    value_metric bigint,
    mv_id bigint
);


ALTER TABLE searchapp.search_bio_mkr_correl_fast_mv OWNER TO searchapp;

--
-- Name: search_bio_mkr_correl_fast_view; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_bio_mkr_correl_fast_view AS
 SELECT i.search_gene_signature_id AS domain_object_id, 
    i.bio_marker_id AS asso_bio_marker_id, 
    'GENE_SIGNATURE_ITEM'::character varying(40) AS correl_type, 
        CASE
            WHEN (i.fold_chg_metric IS NULL) THEN (1)::bigint
            ELSE i.fold_chg_metric
        END AS value_metric, 
    3 AS mv_id
   FROM search_gene_signature_item i, 
    search_gene_signature gs
  WHERE ((i.search_gene_signature_id = gs.search_gene_signature_id) AND (gs.deleted_flag = false));


ALTER TABLE searchapp.search_bio_mkr_correl_fast_view OWNER TO searchapp;

--
-- Name: search_bio_mkr_correl_view; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_bio_mkr_correl_view AS
 SELECT a.domain_object_id, 
    a.asso_bio_marker_id, 
    a.correl_type, 
    a.value_metric, 
    a.mv_id
   FROM (         SELECT i.search_gene_signature_id AS domain_object_id, 
                    i.bio_marker_id AS asso_bio_marker_id, 
                    'GENE_SIGNATURE_ITEM'::text AS correl_type, 
                        CASE
                            WHEN (i.fold_chg_metric IS NULL) THEN (1)::bigint
                            ELSE i.fold_chg_metric
                        END AS value_metric, 
                    1 AS mv_id
                   FROM search_gene_signature_item i, 
                    search_gene_signature gs
                  WHERE (((i.search_gene_signature_id = gs.search_gene_signature_id) AND (gs.deleted_flag IS FALSE)) AND (i.bio_marker_id IS NOT NULL))
        UNION ALL 
                 SELECT i.search_gene_signature_id AS domain_object_id, 
                    bada.bio_marker_id AS asso_bio_marker_id, 
                    'GENE_SIGNATURE_ITEM'::text AS correl_type, 
                        CASE
                            WHEN (i.fold_chg_metric IS NULL) THEN (1)::bigint
                            ELSE i.fold_chg_metric
                        END AS value_metric, 
                    2 AS mv_id
                   FROM search_gene_signature_item i, 
                    search_gene_signature gs, 
                    biomart.bio_assay_data_annotation bada
                  WHERE ((((i.search_gene_signature_id = gs.search_gene_signature_id) AND (gs.deleted_flag IS FALSE)) AND (bada.bio_assay_feature_group_id = i.bio_assay_feature_group_id)) AND (i.bio_assay_feature_group_id IS NOT NULL))) a;


ALTER TABLE searchapp.search_bio_mkr_correl_view OWNER TO searchapp;

--
-- Name: search_taxonomy; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_taxonomy (
    term_id bigint NOT NULL,
    term_name character varying(900) NOT NULL,
    source_cd character varying(900),
    import_date timestamp(1) without time zone DEFAULT now(),
    search_keyword_id bigint
);


ALTER TABLE searchapp.search_taxonomy OWNER TO searchapp;

--
-- Name: search_taxonomy_rels; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_taxonomy_rels (
    search_taxonomy_rels_id bigint NOT NULL,
    child_id bigint NOT NULL,
    parent_id bigint
);


ALTER TABLE searchapp.search_taxonomy_rels OWNER TO searchapp;

--
-- Name: search_categories; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_categories AS
 SELECT str.child_id AS category_id, 
    st.term_name AS category_name
   FROM search_taxonomy_rels str, 
    search_taxonomy st
  WHERE ((str.parent_id = ( SELECT search_taxonomy_rels.child_id
           FROM search_taxonomy_rels
          WHERE (search_taxonomy_rels.parent_id IS NULL))) AND (str.child_id = st.term_id));


ALTER TABLE searchapp.search_categories OWNER TO searchapp;

--
-- Name: search_custom_filter; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_custom_filter (
    search_custom_filter_id bigint NOT NULL,
    search_user_id bigint NOT NULL,
    name character varying(200) NOT NULL,
    description character varying(2000),
    private character(1) DEFAULT 'N'::bpchar NOT NULL
);


ALTER TABLE searchapp.search_custom_filter OWNER TO searchapp;

--
-- Name: search_custom_filter_item; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_custom_filter_item (
    search_custom_filter_item_id bigint NOT NULL,
    search_custom_filter_id bigint NOT NULL,
    unique_id character varying(200) NOT NULL,
    bio_data_type character varying(100) NOT NULL
);


ALTER TABLE searchapp.search_custom_filter_item OWNER TO searchapp;

--
-- Name: search_gene_sig_file_schema; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_gene_sig_file_schema (
    search_gene_sig_file_schema_id bigint NOT NULL,
    name character varying(100) NOT NULL,
    description character varying(255),
    number_columns bigint DEFAULT 2 NOT NULL,
    supported boolean DEFAULT false
);


ALTER TABLE searchapp.search_gene_sig_file_schema OWNER TO searchapp;

--
-- Name: search_keyword_term; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_keyword_term (
    keyword_term character varying(200),
    search_keyword_id bigint,
    rank bigint,
    search_keyword_term_id bigint NOT NULL,
    term_length bigint,
    owner_auth_user_id bigint
);


ALTER TABLE searchapp.search_keyword_term OWNER TO searchapp;

--
-- Name: search_request_map; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_request_map (
    id bigint,
    version bigint,
    config_attribute character varying(255),
    url character varying(255)
);


ALTER TABLE searchapp.search_request_map OWNER TO searchapp;

--
-- Name: search_role; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_role (
    id bigint NOT NULL,
    version bigint,
    authority character varying(255),
    description character varying(255)
);


ALTER TABLE searchapp.search_role OWNER TO searchapp;

--
-- Name: search_role_auth_user; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_role_auth_user (
    people_id bigint,
    authorities_id bigint
);


ALTER TABLE searchapp.search_role_auth_user OWNER TO searchapp;

--
-- Name: search_sec_access_level; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_sec_access_level (
    search_sec_access_level_id bigint NOT NULL,
    access_level_name character varying(200),
    access_level_value bigint
);


ALTER TABLE searchapp.search_sec_access_level OWNER TO searchapp;

--
-- Name: search_secure_object; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_secure_object (
    search_secure_object_id bigint NOT NULL,
    bio_data_id bigint,
    display_name character varying(100),
    data_type character varying(200),
    bio_data_unique_id character varying(200)
);


ALTER TABLE searchapp.search_secure_object OWNER TO searchapp;

--
-- Name: search_secure_object_path; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_secure_object_path (
    search_secure_object_id bigint,
    i2b2_concept_path character varying(2000),
    search_secure_obj_path_id bigint NOT NULL
);


ALTER TABLE searchapp.search_secure_object_path OWNER TO searchapp;

--
-- Name: search_taxonomy_level1; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_taxonomy_level1 AS
 SELECT st.term_id, 
    st.term_name, 
    sc.category_name
   FROM search_taxonomy_rels str, 
    search_taxonomy st, 
    search_categories sc
  WHERE ((str.parent_id = sc.category_id) AND (str.child_id = st.term_id));


ALTER TABLE searchapp.search_taxonomy_level1 OWNER TO searchapp;

--
-- Name: search_taxonomy_level2; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_taxonomy_level2 AS
 SELECT st.term_id, 
    st.term_name, 
    stl1.category_name
   FROM search_taxonomy_rels str, 
    search_taxonomy st, 
    search_taxonomy_level1 stl1
  WHERE ((str.parent_id = stl1.term_id) AND (str.child_id = st.term_id));


ALTER TABLE searchapp.search_taxonomy_level2 OWNER TO searchapp;

--
-- Name: search_taxonomy_level3; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_taxonomy_level3 AS
 SELECT st.term_id, 
    st.term_name, 
    stl2.category_name
   FROM search_taxonomy_rels str, 
    search_taxonomy st, 
    search_taxonomy_level2 stl2
  WHERE ((str.parent_id = stl2.term_id) AND (str.child_id = st.term_id));


ALTER TABLE searchapp.search_taxonomy_level3 OWNER TO searchapp;

--
-- Name: search_taxonomy_level4; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_taxonomy_level4 AS
 SELECT st.term_id, 
    st.term_name, 
    stl3.category_name
   FROM search_taxonomy_rels str, 
    search_taxonomy st, 
    search_taxonomy_level3 stl3
  WHERE ((str.parent_id = stl3.term_id) AND (str.child_id = st.term_id));


ALTER TABLE searchapp.search_taxonomy_level4 OWNER TO searchapp;

--
-- Name: search_taxonomy_level5; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_taxonomy_level5 AS
 SELECT st.term_id, 
    st.term_name, 
    stl4.category_name
   FROM search_taxonomy_rels str, 
    search_taxonomy st, 
    search_taxonomy_level4 stl4
  WHERE ((str.parent_id = stl4.term_id) AND (str.child_id = st.term_id));


ALTER TABLE searchapp.search_taxonomy_level5 OWNER TO searchapp;

--
-- Name: search_taxonomy_lineage; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_taxonomy_lineage AS
 SELECT s1.child_id, 
    s2.child_id AS parent1, 
    s3.child_id AS parent2, 
    s4.child_id AS parent3, 
    s5.child_id AS parent4
   FROM search_taxonomy_rels s1, 
    search_taxonomy_rels s2, 
    search_taxonomy_rels s3, 
    search_taxonomy_rels s4, 
    search_taxonomy_rels s5
  WHERE ((((s1.parent_id = s2.child_id) AND (s2.parent_id = s3.child_id)) AND (s3.parent_id = s4.child_id)) AND (s4.parent_id = s5.child_id));


ALTER TABLE searchapp.search_taxonomy_lineage OWNER TO searchapp;

--
-- Name: search_taxonomy_terms_cats; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW search_taxonomy_terms_cats AS
 SELECT DISTINCT unoin_results.term_id, 
    unoin_results.term_name, 
    unoin_results.category_name
   FROM (        (        (        (         SELECT search_taxonomy_level1.term_id, 
                                            search_taxonomy_level1.term_name, 
                                            search_taxonomy_level1.category_name
                                           FROM search_taxonomy_level1
                                UNION 
                                         SELECT search_taxonomy_level2.term_id, 
                                            search_taxonomy_level2.term_name, 
                                            search_taxonomy_level2.category_name
                                           FROM search_taxonomy_level2)
                        UNION 
                                 SELECT search_taxonomy_level3.term_id, 
                                    search_taxonomy_level3.term_name, 
                                    search_taxonomy_level3.category_name
                                   FROM search_taxonomy_level3)
                UNION 
                         SELECT search_taxonomy_level4.term_id, 
                            search_taxonomy_level4.term_name, 
                            search_taxonomy_level4.category_name
                           FROM search_taxonomy_level4)
        UNION 
                 SELECT search_taxonomy_level5.term_id, 
                    search_taxonomy_level5.term_name, 
                    search_taxonomy_level5.category_name
                   FROM search_taxonomy_level5) unoin_results;


ALTER TABLE searchapp.search_taxonomy_terms_cats OWNER TO searchapp;

--
-- Name: search_user_feedback; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_user_feedback (
    search_user_feedback_id bigint NOT NULL,
    search_user_id bigint,
    create_date timestamp without time zone,
    feedback_text character varying(2000),
    app_version character varying(100)
);


ALTER TABLE searchapp.search_user_feedback OWNER TO searchapp;

--
-- Name: search_user_settings; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE search_user_settings (
    id bigint NOT NULL,
    setting_name character varying(255) NOT NULL,
    user_id bigint NOT NULL,
    setting_value character varying(1024) NOT NULL
);


ALTER TABLE searchapp.search_user_settings OWNER TO searchapp;

--
-- Name: seq_saved_faceted_search_id; Type: SEQUENCE; Schema: searchapp; Owner: searchapp
--

CREATE SEQUENCE seq_saved_faceted_search_id
    START WITH 278
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE searchapp.seq_saved_faceted_search_id OWNER TO searchapp;

--
-- Name: seq_search_data_id; Type: SEQUENCE; Schema: searchapp; Owner: searchapp
--

CREATE SEQUENCE seq_search_data_id
    START WITH 3017276
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE searchapp.seq_search_data_id OWNER TO searchapp;

--
-- Name: solr_keywords_lineage; Type: VIEW; Schema: searchapp; Owner: searchapp
--

CREATE VIEW solr_keywords_lineage AS
 SELECT DISTINCT union_results.term_id, 
    union_results.ancestor_id, 
    union_results.search_keyword_id
   FROM (        (        (        (         SELECT DISTINCT l.child_id AS term_id, 
                                            l.child_id AS ancestor_id, 
                                            st.search_keyword_id
                                           FROM search_taxonomy_lineage l, 
                                            search_taxonomy st
                                          WHERE ((l.child_id = st.term_id) AND (l.child_id IS NOT NULL))
                                UNION 
                                         SELECT DISTINCT l.child_id AS term_id, 
                                            l.parent1 AS ancestor_id, 
                                            st.search_keyword_id
                                           FROM search_taxonomy_lineage l, 
                                            search_taxonomy st
                                          WHERE ((l.parent1 = st.term_id) AND (l.parent1 IS NOT NULL)))
                        UNION 
                                 SELECT DISTINCT l.child_id AS term_id, 
                                    l.parent2 AS ancestor_id, 
                                    st.search_keyword_id
                                   FROM search_taxonomy_lineage l, 
                                    search_taxonomy st
                                  WHERE ((l.parent2 = st.term_id) AND (l.parent2 IS NOT NULL)))
                UNION 
                         SELECT DISTINCT l.child_id AS term_id, 
                            l.parent3 AS ancestor_id, 
                            st.search_keyword_id
                           FROM search_taxonomy_lineage l, 
                            search_taxonomy st
                          WHERE ((l.parent3 = st.term_id) AND (l.parent3 IS NOT NULL)))
        UNION 
                 SELECT DISTINCT l.child_id AS term_id, 
                    l.parent4 AS ancestor_id, 
                    st.search_keyword_id
                   FROM search_taxonomy_lineage l, 
                    search_taxonomy st
                  WHERE ((l.parent4 = st.term_id) AND (l.parent4 IS NOT NULL))) union_results
  WHERE (union_results.search_keyword_id IS NOT NULL);


ALTER TABLE searchapp.solr_keywords_lineage OWNER TO searchapp;

--
-- Name: subset; Type: TABLE; Schema: searchapp; Owner: searchapp; Tablespace: transmart
--

CREATE TABLE subset (
    subset_id bigint NOT NULL,
    description character varying(1000) NOT NULL,
    create_date date NOT NULL,
    creating_user character varying(200) NOT NULL,
    query_master_id_1 bigint NOT NULL,
    query_master_id_2 bigint,
    study character varying(200),
    public_flag boolean NOT NULL,
    deleted_flag boolean NOT NULL
);


ALTER TABLE searchapp.subset OWNER TO searchapp;

SET search_path = tm_cz, pg_catalog;

--
-- Name: az_test_run; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE az_test_run (
    test_run_id bigint NOT NULL,
    dw_version_id bigint,
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    status character varying(20),
    return_code character varying(30),
    return_message character varying(4000),
    test_run_name character varying(200),
    param1 character varying(4000),
    test_category_id bigint
);


ALTER TABLE tm_cz.az_test_run OWNER TO tm_cz;

--
-- Name: az_test_step_act_result; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE az_test_step_act_result (
    test_step_act_result_id bigint NOT NULL,
    test_step_run_id bigint NOT NULL,
    act_record_cnt double precision,
    return_code character varying(30),
    return_message character varying(4000),
    return_error_stack character varying(4000),
    return_error_back_trace character varying(4000)
);


ALTER TABLE tm_cz.az_test_step_act_result OWNER TO tm_cz;

--
-- Name: az_test_step_run; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE az_test_step_run (
    test_step_run_id bigint NOT NULL,
    test_run_id bigint NOT NULL,
    test_id bigint NOT NULL,
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    status character varying(20),
    seq_id bigint,
    param1 character varying(4000)
);


ALTER TABLE tm_cz.az_test_step_run OWNER TO tm_cz;

--
-- Name: cz_test; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_test (
    test_id bigint NOT NULL,
    test_name character varying(200),
    test_desc character varying(1000),
    test_schema character varying(255),
    test_table character varying(255),
    test_column character varying(255),
    test_type character varying(255),
    test_sql character varying(2000),
    test_param1 character varying(2000),
    test_param2 character varying(2000),
    test_param3 character varying(2000),
    test_min_value double precision,
    test_max_value double precision,
    test_category_id bigint,
    test_severity_cd character varying(20),
    table_type character varying(100)
);


ALTER TABLE tm_cz.cz_test OWNER TO tm_cz;

--
-- Name: cz_test_category; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_test_category (
    test_category_id bigint NOT NULL,
    test_category character varying(255),
    test_sub_category1 character varying(255),
    test_sub_category2 character varying(255),
    person_id bigint
);


ALTER TABLE tm_cz.cz_test_category OWNER TO tm_cz;

--
-- Name: all_test_detail_view; Type: VIEW; Schema: tm_cz; Owner: tm_cz
--

CREATE VIEW all_test_detail_view AS
 SELECT a.test_run_id AS run_id, 
    c.test_id, 
    a.test_run_name AS run_name, 
    c.test_table AS vtable, 
    c.test_column AS vcolumn, 
    e.test_category AS category, 
    e.test_sub_category1 AS sub_category1, 
    e.test_sub_category2 AS sub_category2, 
    c.test_sql AS vsql, 
    to_char(b.start_date, 'DD/MM/YYYY HH24:MI:SS'::text) AS start_date, 
    to_char(b.end_date, 'DD/MM/YYYY HH24:MI:SS'::text) AS end_date, 
    b.status, 
    c.test_severity_cd, 
    d.act_record_cnt, 
    c.test_min_value AS min_value_allowed, 
    c.test_max_value AS max_value_allowed, 
    d.return_code AS error_code, 
    d.return_message AS error_message
   FROM ((((az_test_run a
   LEFT JOIN az_test_step_run b ON ((a.test_run_id = b.test_run_id)))
   JOIN cz_test c ON ((c.test_id = b.test_id)))
   LEFT JOIN az_test_step_act_result d ON ((d.test_step_run_id = b.test_step_run_id)))
   JOIN cz_test_category e ON ((e.test_category_id = c.test_category_id)))
  ORDER BY a.test_run_id, c.test_table, c.test_column;


ALTER TABLE tm_cz.all_test_detail_view OWNER TO tm_cz;

--
-- Name: cz_dw_version; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_dw_version (
    dw_version_id bigint NOT NULL,
    version_name character varying(200),
    release_date timestamp without time zone,
    create_date timestamp without time zone,
    created_by bigint,
    is_current character(1)
);


ALTER TABLE tm_cz.cz_dw_version OWNER TO tm_cz;

--
-- Name: all_test_summary_view; Type: VIEW; Schema: tm_cz; Owner: tm_cz
--

CREATE VIEW all_test_summary_view AS
 SELECT a.test_run_id, 
    a.test_run_name, 
    to_char(a.start_date, 'DD/MM/YYYY HH24:MI:SS'::text) AS start_date, 
    to_char(a.end_date, 'DD/MM/YYYY HH24:MI:SS'::text) AS end_date, 
    a.status, 
    d.test_category, 
    d.test_sub_category1, 
    d.test_sub_category2, 
    sum(
        CASE
            WHEN ((b.status)::text = 'PASS'::text) THEN 1
            ELSE 0
        END) AS pass, 
    sum(
        CASE
            WHEN ((b.status)::text = 'WARNING'::text) THEN 1
            ELSE 0
        END) AS warning, 
    sum(
        CASE
            WHEN ((b.status)::text = 'FAIL'::text) THEN 1
            ELSE 0
        END) AS fail, 
    sum(
        CASE
            WHEN ((b.status)::text = 'ERROR'::text) THEN 1
            ELSE 0
        END) AS error, 
    count(b.status) AS total, 
    c.version_name AS db_version
   FROM (((az_test_run a
   JOIN az_test_step_run b ON ((a.test_run_id = b.test_run_id)))
   JOIN cz_dw_version c ON ((c.dw_version_id = a.dw_version_id)))
   JOIN cz_test_category d ON ((d.test_category_id = a.test_category_id)))
  GROUP BY a.test_run_id, a.test_run_name, to_char(a.start_date, 'DD/MM/YYYY HH24:MI:SS'::text), to_char(a.end_date, 'DD/MM/YYYY HH24:MI:SS'::text), a.status, d.test_category, d.test_sub_category1, d.test_sub_category2, c.version_name;


ALTER TABLE tm_cz.all_test_summary_view OWNER TO tm_cz;

--
-- Name: annotation_deapp; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE annotation_deapp (
    gpl_id character varying(100),
    probe_id character varying(100),
    gene_symbol character varying(100),
    gene_id character varying(100),
    probeset_id bigint,
    organism character varying(200)
);


ALTER TABLE tm_cz.annotation_deapp OWNER TO tm_cz;

--
-- Name: annotation_deapp_20120206; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE annotation_deapp_20120206 (
    gpl_id character varying(100),
    probe_id character varying(100),
    gene_symbol character varying(100),
    gene_id character varying(100),
    probeset_id bigint
);


ALTER TABLE tm_cz.annotation_deapp_20120206 OWNER TO tm_cz;

--
-- Name: antigen_deapp; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE antigen_deapp (
    antigen_id bigint NOT NULL,
    antigen_name character varying(100) NOT NULL,
    platform character varying(100) NOT NULL
);


ALTER TABLE tm_cz.antigen_deapp OWNER TO tm_cz;

--
-- Name: az_test_comparison_info; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE az_test_comparison_info (
    test_id bigint,
    param1 character varying(4000),
    prev_dw_version_id bigint,
    prev_test_step_run_id bigint,
    prev_act_record_cnt double precision,
    curr_dw_version_id bigint,
    curr_test_step_run_id bigint,
    curr_act_record_cnt double precision,
    curr_run_date timestamp without time zone,
    prev_run_date date
);


ALTER TABLE tm_cz.az_test_comparison_info OWNER TO tm_cz;

--
-- Name: bio_clinical_trial_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE bio_clinical_trial_release (
    trial_number character varying(510),
    study_owner character varying(510),
    study_phase character varying(100),
    blinding_procedure character varying(1000),
    studytype character varying(510),
    duration_of_study_weeks integer,
    number_of_patients integer,
    number_of_sites integer,
    route_of_administration character varying(510),
    dosing_regimen character varying(3500),
    group_assignment character varying(510),
    type_of_control character varying(510),
    completion_date timestamp without time zone,
    primary_end_points character varying(2000),
    secondary_end_points character varying(3500),
    inclusion_criteria text,
    exclusion_criteria text,
    subjects character varying(2000),
    gender_restriction_mfb character varying(510),
    min_age integer,
    max_age integer,
    secondary_ids character varying(510),
    bio_experiment_id bigint,
    development_partner character varying(100),
    geo_platform character varying(30),
    main_findings character varying(2000),
    platform_name character varying(200),
    search_area character varying(100),
    release_study character varying(510)
);


ALTER TABLE tm_cz.bio_clinical_trial_release OWNER TO tm_cz;

--
-- Name: bio_data_compound_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE bio_data_compound_release (
    bio_data_id bigint NOT NULL,
    bio_compound_id bigint NOT NULL,
    etl_source character varying(100),
    release_study character varying(100)
);


ALTER TABLE tm_cz.bio_data_compound_release OWNER TO tm_cz;

--
-- Name: bio_data_uid_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE bio_data_uid_release (
    bio_data_id bigint NOT NULL,
    unique_id character varying(200) NOT NULL,
    bio_data_type character varying(100) NOT NULL,
    release_study character varying(200) NOT NULL
);


ALTER TABLE tm_cz.bio_data_uid_release OWNER TO tm_cz;

--
-- Name: bio_experiment_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE bio_experiment_release (
    bio_experiment_id bigint,
    bio_experiment_type character varying(200),
    title character varying(1000),
    description character varying(2000),
    design character varying(2000),
    start_date timestamp without time zone,
    completion_date timestamp without time zone,
    primary_investigator character varying(400),
    contact_field character varying(400),
    etl_id character varying(100),
    status character varying(100),
    overall_design character varying(2000),
    accession character varying(100) NOT NULL,
    entrydt timestamp without time zone,
    updated timestamp without time zone,
    institution character varying(100),
    country character varying(50),
    biomarker_type character varying(255),
    target character varying(255),
    access_type character varying(100),
    release_study character varying(100) NOT NULL
);


ALTER TABLE tm_cz.bio_experiment_release OWNER TO tm_cz;

--
-- Name: category_path_excluded_words; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE category_path_excluded_words (
    excluded_text character varying(100)
);


ALTER TABLE tm_cz.category_path_excluded_words OWNER TO tm_cz;

--
-- Name: concept_dimension_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE concept_dimension_release (
    concept_cd character varying(50) NOT NULL,
    concept_path character varying(700) NOT NULL,
    name_char character varying(2000),
    concept_blob text,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id bigint,
    table_name character varying(255),
    release_study character varying(50)
);


ALTER TABLE tm_cz.concept_dimension_release OWNER TO tm_cz;

--
-- Name: currtime; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE currtime (
    clock_timestamp timestamp with time zone
);


ALTER TABLE tm_cz.currtime OWNER TO tm_cz;

--
-- Name: cz_data; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_data (
    data_id bigint NOT NULL,
    data_name character varying(200),
    technical_desc character varying(1000),
    business_desc character varying(1000),
    create_date timestamp without time zone,
    custodian_id bigint,
    owner_id bigint,
    load_freq character varying(20)
);


ALTER TABLE tm_cz.cz_data OWNER TO tm_cz;

--
-- Name: cz_data_file; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_data_file (
    file_name character varying(200),
    provider character varying(200),
    extraction_date timestamp without time zone,
    location character varying(500),
    data_id bigint NOT NULL,
    contact_id bigint,
    exp_record_cnt bigint,
    act_record_cnt bigint,
    url character varying(500),
    description character varying(2000),
    data_file_id bigint NOT NULL
);


ALTER TABLE tm_cz.cz_data_file OWNER TO tm_cz;

--
-- Name: cz_data_profile_column_exclusi; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_data_profile_column_exclusi (
    table_name character varying(500) NOT NULL,
    column_name character varying(500) NOT NULL,
    exclusion_reason character varying(2000),
    etl_date timestamp without time zone DEFAULT ('now'::text)::timestamp without time zone
);


ALTER TABLE tm_cz.cz_data_profile_column_exclusi OWNER TO tm_cz;

--
-- Name: cz_data_profile_column_sample; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_data_profile_column_sample (
    table_name character varying(500),
    column_name character varying(500),
    value character varying(4000),
    count bigint,
    etl_date timestamp without time zone DEFAULT ('now'::text)::timestamp without time zone
);


ALTER TABLE tm_cz.cz_data_profile_column_sample OWNER TO tm_cz;

--
-- Name: cz_data_profile_stats; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_data_profile_stats (
    table_name character varying(500) NOT NULL,
    column_name character varying(500) NOT NULL,
    data_type character varying(500),
    column_length integer,
    column_precision integer,
    column_scale integer NOT NULL,
    total_count bigint,
    percentage_null real,
    null_count bigint,
    non_null_count bigint,
    distinct_count bigint,
    max_length integer,
    min_length integer,
    first_value character varying(4000),
    last_value character varying(4000),
    max_length_value character varying(4000),
    min_length_value character varying(4000),
    etl_date timestamp without time zone DEFAULT ('now'::text)::timestamp without time zone
);


ALTER TABLE tm_cz.cz_data_profile_stats OWNER TO tm_cz;

--
-- Name: cz_form_layout; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_form_layout (
    form_layout_id bigint NOT NULL,
    form_key character varying(50),
    form_column character varying(50),
    display_name character varying(50),
    data_type character varying(50),
    sequence bigint,
    display character(1)
);


ALTER TABLE tm_cz.cz_form_layout OWNER TO tm_cz;

--
-- Name: cz_form_layout_seq; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE cz_form_layout_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tm_cz.cz_form_layout_seq OWNER TO tm_cz;

--
-- Name: cz_job_audit; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_job_audit (
    seq_id bigint NOT NULL,
    job_id bigint NOT NULL,
    database_name character varying(50),
    procedure_name character varying(100),
    step_desc character varying(1000),
    step_status character varying(50),
    records_manipulated bigint,
    step_number bigint,
    job_date timestamp without time zone,
    time_elapsed_secs double precision DEFAULT 0
);


ALTER TABLE tm_cz.cz_job_audit OWNER TO tm_cz;

--
-- Name: cz_job_error; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_job_error (
    job_id bigint NOT NULL,
    error_number character varying(300),
    error_message character varying(1000),
    error_stack character varying(2000),
    seq_id bigint NOT NULL,
    error_backtrace character varying(2000)
);


ALTER TABLE tm_cz.cz_job_error OWNER TO tm_cz;

--
-- Name: cz_job_master; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_job_master (
    job_id bigint NOT NULL,
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    active character varying(1),
    time_elapsed_secs double precision DEFAULT 0,
    build_id bigint,
    session_id bigint,
    database_name character varying(50),
    job_status character varying(50),
    job_name character varying(500)
);


ALTER TABLE tm_cz.cz_job_master OWNER TO tm_cz;

--
-- Name: cz_job_message; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_job_message (
    job_id bigint NOT NULL,
    message_id bigint,
    message_line bigint,
    message_procedure character varying(100),
    info_message character varying(2000),
    seq_id bigint NOT NULL
);


ALTER TABLE tm_cz.cz_job_message OWNER TO tm_cz;

--
-- Name: cz_person; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_person (
    person_id bigint NOT NULL,
    f_name character varying(200),
    l_name character varying(200),
    m_name character varying(200),
    user_name character varying(20),
    role_code character varying(20),
    email_address character varying(100),
    mail_address character varying(200),
    cell_phone character varying(20),
    work_phone character varying(20)
);


ALTER TABLE tm_cz.cz_person OWNER TO tm_cz;

--
-- Name: cz_rwg_invalid_terms; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_rwg_invalid_terms (
    study_id character varying(500),
    category_name character varying(500),
    term_name character varying(500),
    import_date timestamp without time zone DEFAULT now()
);


ALTER TABLE tm_cz.cz_rwg_invalid_terms OWNER TO tm_cz;

--
-- Name: cz_test_result; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_test_result (
    test_id bigint NOT NULL,
    test_result_id bigint NOT NULL,
    test_result_text character varying(2000),
    test_result_nbr bigint,
    test_run_id bigint,
    external_location character varying(2000),
    run_date timestamp without time zone,
    study_id character varying(2000)
);


ALTER TABLE tm_cz.cz_test_result OWNER TO tm_cz;

--
-- Name: cz_test_severity; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_test_severity (
    test_severity_cd character varying(10) NOT NULL,
    severity_name character varying(255),
    severity_level smallint
);


ALTER TABLE tm_cz.cz_test_severity OWNER TO tm_cz;

--
-- Name: cz_xtrial_ctrl_vocab; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_xtrial_ctrl_vocab (
    ctrl_vocab_code character varying(200) NOT NULL,
    ctrl_vocab_name character varying(200) NOT NULL,
    ctrl_vocab_category character varying(200),
    ctrl_vocab_id bigint NOT NULL
);


ALTER TABLE tm_cz.cz_xtrial_ctrl_vocab OWNER TO tm_cz;

--
-- Name: cz_xtrial_exclusion; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE cz_xtrial_exclusion (
    trial_id character varying(200)
);


ALTER TABLE tm_cz.cz_xtrial_exclusion OWNER TO tm_cz;

SET search_path = tm_lz, pg_catalog;

--
-- Name: lz_src_sample_categories; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lz_src_sample_categories (
    trial_cd character varying(200),
    site_cd character varying(200),
    subject_cd character varying(200),
    sample_cd character varying(200),
    category_cd character varying(200),
    category_value character varying(200)
);


ALTER TABLE tm_lz.lz_src_sample_categories OWNER TO tm_lz;

SET search_path = tm_cz, pg_catalog;

--
-- Name: czv_pivot_sample_categories; Type: VIEW; Schema: tm_cz; Owner: tm_cz
--

CREATE VIEW czv_pivot_sample_categories AS
 SELECT x.trial_cd, 
    x.sample_cd AS sample_id, 
    x.trial_name, 
    COALESCE(x.pathology, 'Not Applicable'::text) AS pathology, 
    COALESCE(x.race, 'Not Applicable'::text) AS race, 
    COALESCE(x.tissue_type, 'Not Applicable'::text) AS tissue_type, 
    COALESCE(x.gender, 'Not Applicable'::text) AS gender, 
    COALESCE(x.biomarker, 'Not Applicable'::text) AS biomarker, 
    COALESCE(x.access_type, 'Not Applicable'::text) AS access_type, 
    COALESCE(x.institution, 'Not Applicable'::text) AS institution, 
    COALESCE(x.program_initiative, 'Not Applicable'::text) AS program_initiative, 
    COALESCE(x.organism, 'Not Applicable'::text) AS organism
   FROM ( SELECT s.trial_cd, 
            s.sample_cd, 
            f.c_name AS trial_name, 
            max((
                CASE
                    WHEN ((s.category_cd)::text = 'PATHOLOGY'::text) THEN s.category_value
                    ELSE NULL::character varying
                END)::text) AS pathology, 
            max((
                CASE
                    WHEN ((s.category_cd)::text = 'RACE'::text) THEN s.category_value
                    ELSE NULL::character varying
                END)::text) AS race, 
            max((
                CASE
                    WHEN ((s.category_cd)::text = 'TISSUE_TYPE'::text) THEN s.category_value
                    ELSE NULL::character varying
                END)::text) AS tissue_type, 
            max((
                CASE
                    WHEN ((s.category_cd)::text = 'GENDER'::text) THEN s.category_value
                    ELSE NULL::character varying
                END)::text) AS gender, 
            max((
                CASE
                    WHEN ((s.category_cd)::text = 'BIOMARKER'::text) THEN s.category_value
                    ELSE NULL::character varying
                END)::text) AS biomarker, 
            max((
                CASE
                    WHEN ((s.category_cd)::text = 'ACCESS'::text) THEN s.category_value
                    ELSE NULL::character varying
                END)::text) AS access_type, 
            max((
                CASE
                    WHEN ((s.category_cd)::text = 'INSTITUTION'::text) THEN s.category_value
                    ELSE NULL::character varying
                END)::text) AS institution, 
            max((
                CASE
                    WHEN ((s.category_cd)::text = 'PROGRAM/INITIATIVE'::text) THEN s.category_value
                    ELSE NULL::character varying
                END)::text) AS program_initiative, 
            max((
                CASE
                    WHEN ((s.category_cd)::text = 'ORGANISM'::text) THEN s.category_value
                    ELSE NULL::character varying
                END)::text) AS organism
           FROM tm_lz.lz_src_sample_categories s, 
            i2b2metadata.i2b2 f
          WHERE (((s.trial_cd)::text = (f.sourcesystem_cd)::text) AND (f.c_hlevel = ( SELECT min(x_1.c_hlevel) AS min
                   FROM i2b2metadata.i2b2 x_1
                  WHERE ((f.sourcesystem_cd)::text = (x_1.sourcesystem_cd)::text))))
          GROUP BY s.trial_cd, s.sample_cd, f.c_name) x;


ALTER TABLE tm_cz.czv_pivot_sample_categories OWNER TO tm_cz;

--
-- Name: de_gpl_info_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_gpl_info_release (
    platform character varying(10),
    title character varying(500),
    organism character varying(100),
    annotation_date timestamp without time zone
);


ALTER TABLE tm_cz.de_gpl_info_release OWNER TO tm_cz;

--
-- Name: de_mrna_annotation_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_mrna_annotation_release (
    gpl_id character varying(100),
    probe_id character varying(100),
    gene_symbol character varying(100),
    gene_id character varying(100),
    probeset_id bigint
);


ALTER TABLE tm_cz.de_mrna_annotation_release OWNER TO tm_cz;

--
-- Name: de_snp_data_by_patient_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_snp_data_by_patient_release (
    snp_data_by_patient_id bigint,
    snp_dataset_id bigint,
    trial_name character varying(255),
    patient_num bigint,
    chrom character varying(16),
    data_by_patient_chr text,
    ped_by_patient_chr text,
    release_study character varying(255)
);


ALTER TABLE tm_cz.de_snp_data_by_patient_release OWNER TO tm_cz;

--
-- Name: de_snp_data_by_probe_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_snp_data_by_probe_release (
    snp_data_by_probe_id bigint,
    probe_id bigint,
    probe_name character varying(255),
    snp_id bigint,
    snp_name character varying(255),
    trial_name character varying(255),
    data_by_probe text,
    release_study character varying(200)
);


ALTER TABLE tm_cz.de_snp_data_by_probe_release OWNER TO tm_cz;

--
-- Name: de_snp_data_ds_loc_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_snp_data_ds_loc_release (
    snp_data_dataset_loc_id bigint,
    trial_name character varying(255),
    snp_dataset_id bigint,
    location bigint,
    release_study character varying(200)
);


ALTER TABLE tm_cz.de_snp_data_ds_loc_release OWNER TO tm_cz;

--
-- Name: de_snp_gene_map_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_snp_gene_map_release (
    snp_id bigint,
    snp_name character varying(255),
    entrez_gene_id bigint
);


ALTER TABLE tm_cz.de_snp_gene_map_release OWNER TO tm_cz;

--
-- Name: de_snp_info_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_snp_info_release (
    snp_info_id bigint,
    name character varying(255),
    chrom character varying(16),
    chrom_pos bigint
);


ALTER TABLE tm_cz.de_snp_info_release OWNER TO tm_cz;

--
-- Name: de_snp_probe_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_snp_probe_release (
    snp_probe_id bigint,
    probe_name character varying(255),
    snp_id bigint,
    snp_name character varying(255),
    vendor_name character varying(255)
);


ALTER TABLE tm_cz.de_snp_probe_release OWNER TO tm_cz;

--
-- Name: de_snp_probe_sort_def_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_snp_probe_sort_def_release (
    snp_probe_sorted_def_id bigint,
    platform_name character varying(255),
    num_probe bigint,
    chrom character varying(16),
    probe_def text,
    snp_id_def text
);


ALTER TABLE tm_cz.de_snp_probe_sort_def_release OWNER TO tm_cz;

--
-- Name: de_subj_protein_data_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_subj_protein_data_release (
    trial_name character varying(15),
    component character varying(15),
    intensity bigint,
    patient_id bigint,
    subject_id character varying(10),
    gene_symbol character varying(100),
    gene_id integer,
    assay_id bigint,
    timepoint character varying(20),
    n_value bigint,
    mean_intensity bigint,
    stddev_intensity bigint,
    median_intensity bigint,
    zscore bigint,
    release_study character varying(15)
);


ALTER TABLE tm_cz.de_subj_protein_data_release OWNER TO tm_cz;

--
-- Name: de_subj_sample_map_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_subj_sample_map_release (
    patient_id bigint,
    site_id character varying(100),
    subject_id character varying(100),
    subject_type character varying(100),
    concept_code character varying(1000),
    assay_id bigint,
    patient_uid character varying(50),
    sample_type character varying(100),
    assay_uid character varying(100),
    trial_name character varying(30),
    timepoint character varying(100),
    timepoint_cd character varying(50),
    sample_type_cd character varying(50),
    tissue_type_cd character varying(50),
    platform character varying(50),
    platform_cd character varying(50),
    tissue_type character varying(100),
    data_uid character varying(100),
    gpl_id character varying(20),
    rbm_panel character varying(50),
    sample_id bigint,
    sample_cd character varying(200),
    category_cd character varying(1000),
    release_study character varying(30)
);


ALTER TABLE tm_cz.de_subj_sample_map_release OWNER TO tm_cz;

--
-- Name: de_subject_mrna_data_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_subject_mrna_data_release (
    trial_name character varying(50),
    probeset_id bigint,
    assay_id bigint,
    patient_id bigint,
    timepoint character varying(100),
    pvalue double precision,
    refseq character varying(50),
    subject_id character varying(50),
    raw_intensity bigint,
    mean_intensity double precision,
    stddev_intensity double precision,
    median_intensity double precision,
    log_intensity double precision,
    zscore double precision,
    sample_id bigint,
    release_study character varying(50)
);


ALTER TABLE tm_cz.de_subject_mrna_data_release OWNER TO tm_cz;

--
-- Name: de_subject_rbm_data_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE de_subject_rbm_data_release (
    trial_name character varying(15),
    antigen_name character varying(100),
    n_value bigint,
    patient_id bigint,
    gene_symbol character varying(100),
    gene_id integer,
    assay_id bigint,
    normalized_value double precision,
    concept_cd character varying(100),
    timepoint character varying(100),
    data_uid character varying(100),
    value bigint,
    log_intensity bigint,
    mean_intensity bigint,
    stddev_intensity bigint,
    median_intensity bigint,
    zscore bigint,
    rbm_panel character varying(50),
    release_study character varying(15)
);


ALTER TABLE tm_cz.de_subject_rbm_data_release OWNER TO tm_cz;

--
-- Name: dk1; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE dk1 (
    c1 character varying(10)
);


ALTER TABLE tm_cz.dk1 OWNER TO tm_cz;

--
-- Name: emt_temp_seq; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE emt_temp_seq
    START WITH 11621
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.emt_temp_seq OWNER TO tm_cz;

--
-- Name: gplid; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE gplid (
    gpl_id character varying(50)
);


ALTER TABLE tm_cz.gplid OWNER TO tm_cz;

--
-- Name: haploview_data_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE haploview_data_release (
    i2b2_id bigint,
    jnj_id character varying(30),
    father_id integer,
    mother_id integer,
    sex smallint,
    affection_status smallint,
    chromosome character varying(10),
    gene character varying(50),
    release smallint,
    release_date timestamp without time zone,
    trial_name character varying(50),
    snp_data text,
    release_study character varying(30)
);


ALTER TABLE tm_cz.haploview_data_release OWNER TO tm_cz;

--
-- Name: i2b2_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE i2b2_release (
    c_hlevel bigint,
    c_fullname character varying(900) NOT NULL,
    c_name character varying(2000),
    c_synonym_cd character(1),
    c_visualattributes character(3),
    c_totalnum bigint,
    c_basecode character varying(450),
    c_metadataxml text,
    c_facttablecolumn character varying(50),
    c_tablename character varying(50),
    c_columnname character varying(50),
    c_columndatatype character varying(50),
    c_operator character varying(10),
    c_dimcode character varying(900),
    c_comment text,
    c_tooltip character varying(900),
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    valuetype_cd character varying(50),
    i2b2_id bigint,
    release_study character varying(50)
);


ALTER TABLE tm_cz.i2b2_release OWNER TO tm_cz;

--
-- Name: i2b2_tags_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE i2b2_tags_release (
    tag_id bigint NOT NULL,
    path character varying(200),
    tag character varying(200),
    tag_type character varying(200),
    release_study character varying(200)
);


ALTER TABLE tm_cz.i2b2_tags_release OWNER TO tm_cz;

--
-- Name: last_test_detail_view; Type: VIEW; Schema: tm_cz; Owner: tm_cz
--

CREATE VIEW last_test_detail_view AS
 SELECT a.test_run_id AS run_id, 
    c.test_id, 
    a.test_run_name AS run_name, 
    c.test_table AS vtable, 
    c.test_column AS vcolumn, 
    e.test_category AS category, 
    e.test_sub_category1 AS sub_category1, 
    e.test_sub_category2 AS sub_category2, 
    c.test_sql AS vsql, 
    to_char(b.start_date, 'DD/MM/YYYY HH24:MI:SS'::text) AS start_date, 
    to_char(b.end_date, 'DD/MM/YYYY HH24:MI:SS'::text) AS end_date, 
    b.status, 
    c.test_severity_cd, 
    d.act_record_cnt, 
    c.test_min_value AS min_value_allowed, 
    c.test_max_value AS max_value_allowed, 
    d.return_code AS error_code, 
    d.return_message AS error_message
   FROM ((((az_test_run a
   LEFT JOIN az_test_step_run b ON ((a.test_run_id = b.test_run_id)))
   JOIN cz_test c ON ((c.test_id = b.test_id)))
   LEFT JOIN az_test_step_act_result d ON ((d.test_step_run_id = b.test_step_run_id)))
   JOIN cz_test_category e ON ((e.test_category_id = c.test_category_id)))
  WHERE (a.test_run_id = ( SELECT max(az_test_run.test_run_id) AS max
   FROM az_test_run))
  ORDER BY a.test_run_id, c.test_table, c.test_column;


ALTER TABLE tm_cz.last_test_detail_view OWNER TO tm_cz;

--
-- Name: last_test_summary_view; Type: VIEW; Schema: tm_cz; Owner: tm_cz
--

CREATE VIEW last_test_summary_view AS
 SELECT a.test_run_id, 
    a.test_run_name, 
    to_char(a.start_date, 'DD/MM/YYYY HH24:MI:SS'::text) AS start_date, 
    to_char(a.end_date, 'DD/MM/YYYY HH24:MI:SS'::text) AS end_date, 
    a.status, 
    d.test_category, 
    d.test_sub_category1, 
    d.test_sub_category2, 
    sum(
        CASE
            WHEN ((b.status)::text = 'PASS'::text) THEN 1
            ELSE 0
        END) AS pass, 
    sum(
        CASE
            WHEN ((b.status)::text = 'WARNING'::text) THEN 1
            ELSE 0
        END) AS warning, 
    sum(
        CASE
            WHEN ((b.status)::text = 'FAIL'::text) THEN 1
            ELSE 0
        END) AS fail, 
    sum(
        CASE
            WHEN ((b.status)::text = 'ERROR'::text) THEN 1
            ELSE 0
        END) AS error, 
    count(b.status) AS total, 
    c.version_name AS db_version
   FROM (((az_test_run a
   JOIN az_test_step_run b ON ((a.test_run_id = b.test_run_id)))
   JOIN cz_dw_version c ON ((c.dw_version_id = a.dw_version_id)))
   JOIN cz_test_category d ON ((d.test_category_id = a.test_category_id)))
  WHERE (a.test_run_id = ( SELECT max(az_test_run.test_run_id) AS max
   FROM az_test_run))
  GROUP BY a.test_run_id, a.test_run_name, to_char(a.start_date, 'DD/MM/YYYY HH24:MI:SS'::text), to_char(a.end_date, 'DD/MM/YYYY HH24:MI:SS'::text), a.status, d.test_category, d.test_sub_category1, d.test_sub_category2, c.version_name;


ALTER TABLE tm_cz.last_test_summary_view OWNER TO tm_cz;

--
-- Name: migrate_tables; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE migrate_tables (
    data_type character varying(50),
    table_owner character varying(50),
    table_name character varying(50),
    study_specific character(1),
    where_clause character varying(2000),
    insert_seq integer,
    stage_table_name character varying(100),
    rebuild_index character(1),
    delete_seq integer
);


ALTER TABLE tm_cz.migrate_tables OWNER TO tm_cz;

--
-- Name: mirna_annotation_deapp; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE mirna_annotation_deapp (
    id_ref character varying(100),
    probe_id character varying(100),
    mirna_symbol character varying(100),
    mirna_id character varying(100),
    probeset_id numeric(38,0),
    organism character varying(200),
    gpl_id character varying(20)
);


ALTER TABLE tm_cz.mirna_annotation_deapp OWNER TO tm_cz;

--
-- Name: seq_probeset_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_probeset_id
    START WITH 1112968
    INCREMENT BY 1
    MINVALUE 249739
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.seq_probeset_id OWNER TO tm_cz;

--
-- Name: mirna_probeset_deapp; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE mirna_probeset_deapp (
    probeset_id numeric(38,0) DEFAULT nextval('seq_probeset_id'::regclass) NOT NULL,
    probeset character varying(100),
    platform character varying(100),
    organism character varying(200)
);


ALTER TABLE tm_cz.mirna_probeset_deapp OWNER TO tm_cz;

--
-- Name: node_curation; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE node_curation (
    node_type character varying(25),
    node_name character varying(250),
    display_name character varying(250),
    display_in_ui character(1),
    data_type character(1),
    global_flag character(1),
    study_id character varying(30),
    curator_name character varying(250),
    curation_date timestamp without time zone,
    active_flag character(1)
);


ALTER TABLE tm_cz.node_curation OWNER TO tm_cz;

--
-- Name: observation_fact_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE observation_fact_release (
    encounter_num bigint,
    patient_num bigint,
    concept_cd character varying(50) NOT NULL,
    provider_id character varying(50) NOT NULL,
    start_date timestamp without time zone,
    modifier_cd character varying(100),
    valtype_cd character varying(50),
    tval_char character varying(255),
    nval_num double precision,
    valueflag_cd character varying(50),
    quantity_num double precision,
    units_cd character varying(50),
    end_date timestamp without time zone,
    location_cd character varying(50) NOT NULL,
    confidence_num bigint,
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id bigint,
    observation_blob text,
    release_study character varying(100)
);


ALTER TABLE tm_cz.observation_fact_release OWNER TO tm_cz;

--
-- Name: patient_dimension_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE patient_dimension_release (
    patient_num bigint,
    vital_status_cd character varying(50),
    birth_date timestamp without time zone,
    death_date timestamp without time zone,
    sex_cd character varying(50),
    age_in_years_num bigint,
    language_cd character varying(50),
    race_cd character varying(50),
    marital_status_cd character varying(50),
    religion_cd character varying(50),
    zip_cd character varying(50),
    statecityzip_path character varying(700),
    update_date timestamp without time zone,
    download_date timestamp without time zone,
    import_date timestamp without time zone,
    sourcesystem_cd character varying(50),
    upload_id bigint,
    patient_blob text,
    release_study character varying(50)
);


ALTER TABLE tm_cz.patient_dimension_release OWNER TO tm_cz;

--
-- Name: probeset_deapp; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE probeset_deapp (
    probeset_id bigint NOT NULL,
    probeset character varying(100) NOT NULL,
    platform character varying(100) NOT NULL,
    organism character varying(200)
);


ALTER TABLE tm_cz.probeset_deapp OWNER TO tm_cz;

--
-- Name: probeset_deapp_20120206; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE probeset_deapp_20120206 (
    probeset_id bigint NOT NULL,
    probeset character varying(100) NOT NULL,
    platform character varying(100) NOT NULL
);


ALTER TABLE tm_cz.probeset_deapp_20120206 OWNER TO tm_cz;

--
-- Name: rtqalimits_testid_seq; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE rtqalimits_testid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.rtqalimits_testid_seq OWNER TO tm_cz;

--
-- Name: rtqastatslist_testid_seq; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE rtqastatslist_testid_seq
    START WITH 80000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.rtqastatslist_testid_seq OWNER TO tm_cz;

--
-- Name: sample_categories_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE sample_categories_release (
    trial_cd character varying(200),
    site_cd character varying(200),
    subject_cd character varying(200),
    sample_cd character varying(200),
    category_cd character varying(200),
    category_value character varying(200),
    release_study character varying(50)
);


ALTER TABLE tm_cz.sample_categories_release OWNER TO tm_cz;

--
-- Name: search_secure_object_release; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE search_secure_object_release (
    search_secure_object_id bigint,
    bio_data_id bigint,
    display_name character varying(100),
    data_type character varying(200),
    bio_data_unique_id character varying(200),
    release_study character varying(100)
);


ALTER TABLE tm_cz.search_secure_object_release OWNER TO tm_cz;

--
-- Name: seq_antigen_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_antigen_id
    START WITH 46391
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.seq_antigen_id OWNER TO tm_cz;

--
-- Name: seq_child_rollup_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_child_rollup_id
    START WITH 1681
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.seq_child_rollup_id OWNER TO tm_cz;

--
-- Name: seq_cz; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz
    START WITH 141
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.seq_cz OWNER TO tm_cz;

--
-- Name: seq_cz_data; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_data
    START WITH 5
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_data OWNER TO tm_cz;

--
-- Name: seq_cz_data_file; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_data_file
    START WITH 6
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_data_file OWNER TO tm_cz;

--
-- Name: seq_cz_dw_version_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_dw_version_id
    START WITH 41
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_dw_version_id OWNER TO tm_cz;

--
-- Name: seq_cz_job_audit; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_job_audit
    START WITH 1686336
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_job_audit OWNER TO tm_cz;

--
-- Name: seq_cz_job_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_job_id
    START WITH 413
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.seq_cz_job_id OWNER TO tm_cz;

--
-- Name: seq_cz_job_master; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_job_master
    START WITH 18288
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_job_master OWNER TO tm_cz;

--
-- Name: seq_cz_job_message; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_job_message
    START WITH 988
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_job_message OWNER TO tm_cz;

--
-- Name: seq_cz_person_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_person_id
    START WITH 41
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_person_id OWNER TO tm_cz;

--
-- Name: seq_cz_test; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_test
    START WITH 8259
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_test OWNER TO tm_cz;

--
-- Name: seq_cz_test_category; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_cz_test_category
    START WITH 5
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 2;


ALTER TABLE tm_cz.seq_cz_test_category OWNER TO tm_cz;

--
-- Name: seq_form_layout_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_form_layout_id
    START WITH 41
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 20;


ALTER TABLE tm_cz.seq_form_layout_id OWNER TO tm_cz;

--
-- Name: seq_region_id; Type: SEQUENCE; Schema: tm_cz; Owner: tm_cz
--

CREATE SEQUENCE seq_region_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tm_cz.seq_region_id OWNER TO tm_cz;

--
-- Name: tmp_num_data_types; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE tmp_num_data_types (
    category_cd character varying(200),
    data_label character varying(500),
    period character varying(100),
    sample_type character varying(100),
    visit_name character varying(100)
);


ALTER TABLE tm_cz.tmp_num_data_types OWNER TO tm_cz;

--
-- Name: tmp_subject_info; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE tmp_subject_info (
    usubjid character varying(100),
    age_in_years_num smallint,
    sex_cd character varying(50),
    race_cd character varying(50)
);


ALTER TABLE tm_cz.tmp_subject_info OWNER TO tm_cz;

--
-- Name: tmp_trial_data; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE tmp_trial_data (
    usubjid character varying(50),
    study_id character varying(25),
    data_type character(1),
    visit_name character varying(100),
    data_label character varying(500),
    data_value character varying(500),
    unit_cd character varying(50),
    category_path character varying(250),
    sub_category_path_1 character varying(250),
    sub_category_path_2 character varying(250),
    patient_num bigint,
    sourcesystem_cd character varying(50),
    base_path character varying(1250)
);


ALTER TABLE tm_cz.tmp_trial_data OWNER TO tm_cz;

--
-- Name: tmp_trial_nodes; Type: TABLE; Schema: tm_cz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE tmp_trial_nodes (
    leaf_node character varying(4000),
    category_cd character varying(200),
    visit_name character varying(100),
    sample_type character varying(100),
    period character varying(100),
    data_label character varying(500),
    node_name character varying(500),
    data_value character varying(500)
);


ALTER TABLE tm_cz.tmp_trial_nodes OWNER TO tm_cz;

SET search_path = tm_dataloader, pg_catalog;

SET default_tablespace = '';

--
-- Name: i2b2_load_path; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE i2b2_load_path (
    path character varying(700) NOT NULL,
    path50 character varying(50),
    path100 character varying(100),
    path150 character varying(150),
    path200 character varying(200),
    path_len integer,
    record_id integer
);


ALTER TABLE tm_dataloader.i2b2_load_path OWNER TO weymouth;

--
-- Name: i2b2_load_path_with_count; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE i2b2_load_path_with_count (
    c_fullname character varying(700) NOT NULL,
    nbr_children integer
);


ALTER TABLE tm_dataloader.i2b2_load_path_with_count OWNER TO weymouth;

--
-- Name: i2b2_load_tree_full; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE i2b2_load_tree_full (
    idroot integer,
    idchild integer
);


ALTER TABLE tm_dataloader.i2b2_load_tree_full OWNER TO weymouth;

--
-- Name: lt_snp_calls_by_gsm; Type: TABLE; Schema: tm_dataloader; Owner: tm_dataloader; Tablespace: 
--

CREATE UNLOGGED TABLE lt_snp_calls_by_gsm (
    gsm_num character varying(10),
    snp_name character varying(100),
    snp_calls character varying(4)
);


ALTER TABLE tm_dataloader.lt_snp_calls_by_gsm OWNER TO tm_dataloader;

--
-- Name: lt_snp_copy_number; Type: TABLE; Schema: tm_dataloader; Owner: tm_dataloader; Tablespace: 
--

CREATE UNLOGGED TABLE lt_snp_copy_number (
    gsm_num character varying(10),
    snp_name character varying(50),
    chrom character varying(2),
    chrom_pos numeric(20,0),
    copy_number double precision
);


ALTER TABLE tm_dataloader.lt_snp_copy_number OWNER TO tm_dataloader;

--
-- Name: lt_snp_gene_map; Type: TABLE; Schema: tm_dataloader; Owner: tm_dataloader; Tablespace: 
--

CREATE UNLOGGED TABLE lt_snp_gene_map (
    snp_name character varying,
    entrez_gene_id bigint
);


ALTER TABLE tm_dataloader.lt_snp_gene_map OWNER TO tm_dataloader;

--
-- Name: lt_src_clinical_data; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE lt_src_clinical_data (
    study_id character varying(25),
    site_id character varying(50),
    subject_id character varying(20),
    visit_name character varying(100),
    sample_type character varying(100),
    data_label character varying(500),
    data_value character varying(500),
    category_cd character varying(250),
    data_label_ctrl_vocab_code character varying(200),
    data_value_ctrl_vocab_code character varying(500),
    data_label_components character varying(1000),
    units_cd character varying(50),
    visit_date character varying(200),
    link_type character varying(20),
    link_value character varying(200),
    end_date character varying(50),
    visit_reference character varying(100),
    date_ind character(1),
    obs_string character varying(100),
    valuetype_cd character varying(50),
    date_timestamp timestamp without time zone,
    ctrl_vocab_code character varying(200),
    modifier_cd character varying(100),
    sample_cd character varying(200)
);


ALTER TABLE tm_dataloader.lt_src_clinical_data OWNER TO weymouth;

--
-- Name: lt_src_deapp_annot; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE lt_src_deapp_annot (
    gpl_id character varying(100),
    probe_id character varying(100),
    gene_symbol character varying(100),
    gene_id character varying(250),
    organism character varying(200)
);


ALTER TABLE tm_dataloader.lt_src_deapp_annot OWNER TO weymouth;

--
-- Name: lt_src_mrna_data; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE lt_src_mrna_data (
    trial_name character varying(25),
    probeset character varying(100),
    expr_id character varying(100),
    intensity_value character varying(50)
);


ALTER TABLE tm_dataloader.lt_src_mrna_data OWNER TO weymouth;

--
-- Name: lt_src_mrna_subj_samp_map; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE lt_src_mrna_subj_samp_map (
    trial_name character varying(100),
    site_id character varying(100),
    subject_id character varying(100),
    sample_cd character varying(100),
    platform character varying(100),
    tissue_type character varying(100),
    attribute_1 character varying(256),
    attribute_2 character varying(200),
    category_cd character varying(200),
    source_cd character varying(200)
);


ALTER TABLE tm_dataloader.lt_src_mrna_subj_samp_map OWNER TO weymouth;

--
-- Name: wrk_clinical_data; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE wrk_clinical_data (
    study_id character varying(25),
    site_id character varying(50),
    subject_id character varying(20),
    visit_name character varying(100),
    data_label character varying(500),
    data_value character varying(500),
    category_cd character varying(250),
    etl_job_id numeric(22,0),
    etl_date timestamp without time zone,
    usubjid character varying(200),
    category_path character varying(1000),
    data_type character varying(10),
    data_label_ctrl_vocab_code character varying(200),
    data_value_ctrl_vocab_code character varying(500),
    data_label_components character varying(1000),
    units_cd character varying(50),
    visit_date character varying(200),
    node_name character varying(1000),
    link_type character varying(20),
    link_value character varying(200),
    end_date character varying(50),
    visit_reference character varying(100),
    date_ind character(1),
    obs_string character varying(100),
    rec_num numeric(18,0),
    valuetype_cd character varying(50),
    leaf_node character varying(2000),
    modifier_cd character varying(100),
    ctrl_vocab_code character varying(200),
    date_timestamp timestamp without time zone,
    sample_cd character varying(200)
);


ALTER TABLE tm_dataloader.wrk_clinical_data OWNER TO weymouth;

--
-- Name: wt_num_data_types; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE wt_num_data_types (
    category_cd character varying(250),
    data_label character varying(500),
    sample_type character varying(100),
    visit_name character varying(100)
);


ALTER TABLE tm_dataloader.wt_num_data_types OWNER TO weymouth;

--
-- Name: wt_subject_microarray_calcs; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE wt_subject_microarray_calcs (
    trial_name character varying(50),
    probeset_id bigint,
    mean_intensity double precision,
    median_intensity double precision,
    stddev_intensity double precision
);


ALTER TABLE tm_dataloader.wt_subject_microarray_calcs OWNER TO weymouth;

--
-- Name: wt_subject_microarray_logs; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE wt_subject_microarray_logs (
    probeset_id bigint,
    intensity_value numeric,
    pvalue numeric,
    num_calls numeric,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    log_intensity double precision,
    raw_intensity double precision
);


ALTER TABLE tm_dataloader.wt_subject_microarray_logs OWNER TO weymouth;

--
-- Name: wt_subject_mrna_probeset; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE wt_subject_mrna_probeset (
    probeset_id bigint,
    expr_id character varying(500),
    intensity_value double precision,
    num_calls bigint,
    pvalue numeric,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(100),
    trial_name character varying(200),
    timepoint character varying(200),
    sample_type character varying(200),
    platform character varying(200),
    tissue_type character varying(200)
);


ALTER TABLE tm_dataloader.wt_subject_mrna_probeset OWNER TO weymouth;

--
-- Name: wt_trial_nodes; Type: TABLE; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE UNLOGGED TABLE wt_trial_nodes (
    leaf_node character varying(4000),
    category_cd character varying(250),
    visit_name character varying(100),
    sample_type character varying(100),
    data_label character varying(500),
    node_name character varying(500),
    data_value character varying(500),
    data_type character varying(20),
    data_label_ctrl_vocab_code character varying(500),
    data_value_ctrl_vocab_code character varying(500),
    data_label_components character varying(1000),
    link_type character varying(50),
    obs_string character varying(100),
    valuetype_cd character varying(50),
    rec_num numeric
);


ALTER TABLE tm_dataloader.wt_trial_nodes OWNER TO weymouth;

SET search_path = tm_lz, pg_catalog;

SET default_tablespace = transmart;

--
-- Name: clinical_trial_metadata_ext; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE clinical_trial_metadata_ext (
    trial character varying(4000),
    title character varying(4000),
    description character varying(4000),
    condition character varying(4000),
    disease_subtype character varying(4000),
    drug_cnto character varying(4000),
    drug_name character varying(4000),
    descriptive_trial_name character varying(4000),
    study_owner character varying(4000),
    biomarker_data_owner character varying(4000),
    study_phase character varying(4000),
    blinding_procedure character varying(4000),
    study_type character varying(4000),
    duration_of_study character varying(4000),
    number_of_patients character varying(4000),
    number_of_sites character varying(4000),
    route_of_admin character varying(4000),
    dosing_regimen character varying(4000),
    group_assignment character varying(4000),
    type_of_control character varying(4000),
    study_design character varying(4000),
    completion_date character varying(4000),
    primary_endpoints character varying(4000),
    secondary_endpoints character varying(4000),
    inclusion_criteria character varying(4000),
    exclusion_criteria character varying(4000),
    subjects character varying(4000),
    gender_restriction character varying(4000),
    min_age character varying(4000),
    max_age character varying(4000),
    secondary_ids character varying(4000),
    pi character varying(4000),
    development_partner character varying(4000),
    geo_platform character varying(4000),
    main_findings character varying(4000),
    platform_name character varying(4000),
    study_id character varying(50),
    search_area character varying(100),
    experimental_design character varying(100),
    data_source character varying(100)
);


ALTER TABLE tm_lz.clinical_trial_metadata_ext OWNER TO tm_lz;

--
-- Name: lt_chromo_region_id_seq; Type: SEQUENCE; Schema: tm_lz; Owner: tm_lz
--

CREATE SEQUENCE lt_chromo_region_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tm_lz.lt_chromo_region_id_seq OWNER TO tm_lz;

--
-- Name: lt_chromosomal_region; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_chromosomal_region (
    region_id bigint DEFAULT nextval('lt_chromo_region_id_seq'::regclass) NOT NULL,
    gpl_id character varying(50),
    chromosome character varying(2),
    start_bp bigint,
    end_bp bigint,
    num_probes integer,
    region_name character varying(100),
    cytoband character varying(100),
    gene_symbol character varying(100),
    gene_id bigint,
    organism character varying(200)
);


ALTER TABLE tm_lz.lt_chromosomal_region OWNER TO tm_lz;

--
-- Name: lt_metabolomic_annotation; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_metabolomic_annotation (
    gpl_id character varying(20),
    biochemical_name character varying(200),
    hmdb_id character varying(20),
    super_pathway character varying(200),
    sub_pathway character varying(200)
);


ALTER TABLE tm_lz.lt_metabolomic_annotation OWNER TO tm_lz;

--
-- Name: lt_metabolomic_display_mapping; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_metabolomic_display_mapping (
    category_cd character varying(200) NOT NULL,
    display_value character varying(100),
    display_label character varying(200),
    display_unit character varying(20)
);


ALTER TABLE tm_lz.lt_metabolomic_display_mapping OWNER TO tm_lz;

--
-- Name: lt_protein_annotation; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_protein_annotation (
    gpl_id character varying(100),
    peptide character varying(200),
    uniprot_id character varying(200),
    biomarker_id numeric,
    organism character varying(100)
);


ALTER TABLE tm_lz.lt_protein_annotation OWNER TO tm_lz;

--
-- Name: lt_qpcr_mirna_annotation; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_qpcr_mirna_annotation (
    id_ref character varying(100),
    mirna_id character varying(100),
    sn_id character varying(100),
    organism character varying(1000),
    gpl_id character varying(20)
);


ALTER TABLE tm_lz.lt_qpcr_mirna_annotation OWNER TO tm_lz;

--
-- Name: lt_rnaseq_annotation; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_rnaseq_annotation (
    transcript_id character varying(50),
    gene_symbol character varying(50),
    organism character varying(30)
);


ALTER TABLE tm_lz.lt_rnaseq_annotation OWNER TO tm_lz;

--
-- Name: lt_snp_calls_by_gsm; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_snp_calls_by_gsm (
    gsm_num character varying(10),
    snp_name character varying(100),
    snp_calls character varying(4)
);


ALTER TABLE tm_lz.lt_snp_calls_by_gsm OWNER TO tm_lz;

--
-- Name: lt_snp_copy_number; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_snp_copy_number (
    gsm_num character varying(10),
    snp_name character varying(50),
    chrom character varying(2),
    chrom_pos numeric(20,0),
    copy_number double precision
);


ALTER TABLE tm_lz.lt_snp_copy_number OWNER TO tm_lz;

--
-- Name: lt_snp_gene_map; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_snp_gene_map (
    snp_name character varying,
    entrez_gene_id bigint
);


ALTER TABLE tm_lz.lt_snp_gene_map OWNER TO tm_lz;

--
-- Name: lt_src_acgh_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_acgh_data (
    trial_name character varying(25),
    region_name character varying(100),
    expr_id character varying(100),
    chip character varying(50),
    segmented character varying(50),
    flag character varying(50),
    probloss character varying(50),
    probnorm character varying(50),
    probgain character varying(50),
    probamp character varying(50)
);


ALTER TABLE tm_lz.lt_src_acgh_data OWNER TO tm_lz;

--
-- Name: lt_src_cel_files; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_cel_files (
    cel_file_name character varying(500)
);


ALTER TABLE tm_lz.lt_src_cel_files OWNER TO tm_lz;

--
-- Name: lt_src_clinical_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_clinical_data (
    study_id character varying(25),
    site_id character varying(50),
    subject_id character varying(20),
    visit_name character varying(100),
    sample_type character varying(100),
    data_label character varying(500),
    data_value character varying(500),
    category_cd character varying(250),
    data_label_ctrl_vocab_code character varying(200),
    data_value_ctrl_vocab_code character varying(500),
    data_label_components character varying(1000),
    units_cd character varying(50),
    visit_date character varying(200),
    link_type character varying(20),
    link_value character varying(200),
    end_date character varying(50),
    visit_reference character varying(100),
    date_ind character(1),
    obs_string character varying(100),
    valuetype_cd character varying(50),
    date_timestamp timestamp without time zone,
    ctrl_vocab_code character varying(200),
    modifier_cd character varying(100),
    sample_cd character varying(200)
);


ALTER TABLE tm_lz.lt_src_clinical_data OWNER TO tm_lz;

--
-- Name: lt_src_data_metadata; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_data_metadata (
    tag_path character varying(2000),
    tag_type character varying(200),
    tag_name character varying(200),
    tags_idx bigint
);


ALTER TABLE tm_lz.lt_src_data_metadata OWNER TO tm_lz;

--
-- Name: lt_src_deapp_annot; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_deapp_annot (
    gpl_id character varying(100),
    probe_id character varying(100),
    gene_symbol character varying(100),
    gene_id character varying(250),
    organism character varying(200)
);


ALTER TABLE tm_lz.lt_src_deapp_annot OWNER TO tm_lz;

--
-- Name: lt_src_display_mapping; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_display_mapping (
    category_cd character varying(200) NOT NULL,
    display_value character varying(100),
    display_label character varying(200),
    display_unit character varying(200)
);


ALTER TABLE tm_lz.lt_src_display_mapping OWNER TO tm_lz;

--
-- Name: lt_src_metabolomic_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_metabolomic_data (
    trial_name character varying(25),
    biochemical character varying(200),
    expr_id character varying(100),
    intensity_value character varying(50)
);


ALTER TABLE tm_lz.lt_src_metabolomic_data OWNER TO tm_lz;

--
-- Name: lt_src_metabolomic_map; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_metabolomic_map (
    trial_name character varying(100),
    site_id character varying(100),
    subject_id character varying(100),
    sample_cd character varying(100),
    platform character varying(100),
    tissue_type character varying(100),
    attribute_1 character varying(256),
    attribute_2 character varying(200),
    category_cd character varying(200),
    source_cd character varying(200)
);


ALTER TABLE tm_lz.lt_src_metabolomic_map OWNER TO tm_lz;

--
-- Name: lt_src_metabolomics_display_mapping; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_metabolomics_display_mapping (
    category_cd character varying(200) NOT NULL,
    display_value character varying(100),
    display_label character varying(200),
    display_unit character varying(20)
);


ALTER TABLE tm_lz.lt_src_metabolomics_display_mapping OWNER TO tm_lz;

--
-- Name: lt_src_mirna_deapp_annot; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_mirna_deapp_annot (
    id_ref character varying(100),
    probe_id character varying(100),
    mirna_symbol character varying(100),
    mirna_id character varying(250),
    organism character varying(200)
);


ALTER TABLE tm_lz.lt_src_mirna_deapp_annot OWNER TO tm_lz;

--
-- Name: lt_src_mirna_display_mapping; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_mirna_display_mapping (
    category_cd character varying(200) NOT NULL,
    display_value character varying(100),
    display_label character varying(200),
    display_unit character varying(20)
);


ALTER TABLE tm_lz.lt_src_mirna_display_mapping OWNER TO tm_lz;

--
-- Name: lt_src_mirna_subj_samp_map; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_mirna_subj_samp_map (
    trial_name character varying(100),
    site_id character varying(100),
    subject_id character varying(100),
    sample_cd character varying(100),
    platform character varying(100),
    tissue_type character varying(100),
    attribute_1 character varying(256),
    attribute_2 character varying(200),
    category_cd character varying(200),
    source_cd character varying(200)
);


ALTER TABLE tm_lz.lt_src_mirna_subj_samp_map OWNER TO tm_lz;

--
-- Name: lt_src_mrna_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_mrna_data (
    trial_name character varying(25),
    probeset character varying(100),
    expr_id character varying(100),
    intensity_value character varying(50)
);


ALTER TABLE tm_lz.lt_src_mrna_data OWNER TO tm_lz;

--
-- Name: lt_src_mrna_subj_samp_map; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_mrna_subj_samp_map (
    trial_name character varying(100),
    site_id character varying(100),
    subject_id character varying(100),
    sample_cd character varying(100),
    platform character varying(100),
    tissue_type character varying(100),
    attribute_1 character varying(256),
    attribute_2 character varying(200),
    category_cd character varying(200),
    source_cd character varying(200)
);


ALTER TABLE tm_lz.lt_src_mrna_subj_samp_map OWNER TO tm_lz;

--
-- Name: lt_src_nextbio; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_nextbio (
    bio_concept_code character varying(1000),
    code_name character varying(1000),
    code_description character varying(1000),
    code_type_name character varying(1000)
);


ALTER TABLE tm_lz.lt_src_nextbio OWNER TO tm_lz;

--
-- Name: lt_src_omicsoft_annot; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_omicsoft_annot (
    gpl_id character varying(100),
    probe_id character varying(100),
    gene_symbol character varying(1000),
    gene_id character varying(250),
    organism character varying(200),
    etl_id character varying(200)
);


ALTER TABLE tm_lz.lt_src_omicsoft_annot OWNER TO tm_lz;

--
-- Name: lt_src_omicsoft_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_omicsoft_data (
    id character varying(1000),
    contrast_name character varying(1000),
    probe_id character varying(1000),
    raw_p_value character varying(200),
    adj_p_value character varying(200),
    estimate double precision,
    fold_change double precision,
    max_l_s_mean double precision,
    bio_assay_analysis_id bigint,
    mean_fold_change double precision,
    std_dev_fold_change double precision,
    tea_normal_pvalue double precision,
    etl_id character varying(200)
);


ALTER TABLE tm_lz.lt_src_omicsoft_data OWNER TO tm_lz;

--
-- Name: lt_src_pathway; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_pathway (
    name character varying(1000),
    gene character varying(1000),
    organism character varying(200)
);


ALTER TABLE tm_lz.lt_src_pathway OWNER TO tm_lz;

--
-- Name: lt_src_pathway_org; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_pathway_org (
    name character varying(1000),
    gene character varying(1000),
    organism character varying(200),
    id character varying(20)
);


ALTER TABLE tm_lz.lt_src_pathway_org OWNER TO tm_lz;

--
-- Name: lt_src_protein_display_mapping; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_protein_display_mapping (
    category_cd character varying(200) NOT NULL,
    display_value character varying(100),
    display_label character varying(200),
    display_unit character varying(20)
);


ALTER TABLE tm_lz.lt_src_protein_display_mapping OWNER TO tm_lz;

--
-- Name: lt_src_proteomics_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_proteomics_data (
    trial_name character varying(25),
    peptide character varying(100),
    m_p_id character varying(100),
    intensity_value character varying(50)
);


ALTER TABLE tm_lz.lt_src_proteomics_data OWNER TO tm_lz;

--
-- Name: lt_src_proteomics_sub_sam_map; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_proteomics_sub_sam_map (
    trial_name character varying(100),
    site_id character varying(100),
    subject_id character varying(100),
    sample_cd character varying(100),
    platform character varying(100),
    tissue_type character varying(100),
    attribute_1 character varying(256),
    attribute_2 character varying(200),
    category_cd character varying(200),
    source_cd character varying(200)
);


ALTER TABLE tm_lz.lt_src_proteomics_sub_sam_map OWNER TO tm_lz;

--
-- Name: lt_src_qpcr_mirna_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_qpcr_mirna_data (
    trial_name character varying(25),
    probeset character varying(100),
    expr_id character varying(100),
    intensity_value character varying(50)
);


ALTER TABLE tm_lz.lt_src_qpcr_mirna_data OWNER TO tm_lz;

--
-- Name: lt_src_rbm_annotation; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_rbm_annotation (
    gpl_id character varying(50),
    antigen_name character varying(200),
    uniprotid character varying(50),
    gene_symbol character varying(200),
    gene_id character varying(50)
);


ALTER TABLE tm_lz.lt_src_rbm_annotation OWNER TO tm_lz;

--
-- Name: lt_src_rbm_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_rbm_data (
    sample_id character varying(200),
    analyte character varying(200),
    avalue character varying(200),
    trial_id character varying(20)
);


ALTER TABLE tm_lz.lt_src_rbm_data OWNER TO tm_lz;

--
-- Name: lt_src_rbm_display_mapping; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_rbm_display_mapping (
    category_cd character varying(200) NOT NULL,
    display_value character varying(100),
    display_label character varying(200),
    display_unit character varying(20)
);


ALTER TABLE tm_lz.lt_src_rbm_display_mapping OWNER TO tm_lz;

--
-- Name: lt_src_rbm_subj_samp_map; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_rbm_subj_samp_map (
    trial_name character varying(100),
    site_id character varying(100),
    subject_id character varying(100),
    sample_cd character varying(100),
    platform character varying(100),
    tissue_type character varying(100),
    attribute_1 character varying(256),
    attribute_2 character varying(200),
    category_cd character varying(200),
    source_cd character varying(200)
);


ALTER TABLE tm_lz.lt_src_rbm_subj_samp_map OWNER TO tm_lz;

--
-- Name: lt_src_rna_display_mapping; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_rna_display_mapping (
    category_cd character varying(200) NOT NULL,
    display_value character varying(100),
    display_label character varying(200),
    display_unit character varying(20)
);


ALTER TABLE tm_lz.lt_src_rna_display_mapping OWNER TO tm_lz;

--
-- Name: lt_src_rna_seq_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_rna_seq_data (
    trial_name character varying(25),
    probeset character varying(100),
    expr_id character varying(100),
    intensity_value character varying(50)
);


ALTER TABLE tm_lz.lt_src_rna_seq_data OWNER TO tm_lz;

--
-- Name: lt_src_rna_seq_subj_samp_map; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_rna_seq_subj_samp_map (
    trial_name character varying(100),
    site_id character varying(100),
    subject_id character varying(100),
    sample_cd character varying(100),
    platform character varying(100),
    tissue_type character varying(100),
    attribute_1 character varying(256),
    attribute_2 character varying(200),
    category_cd character varying(200),
    source_cd character varying(200)
);


ALTER TABLE tm_lz.lt_src_rna_seq_subj_samp_map OWNER TO tm_lz;

--
-- Name: lt_src_rnaseq_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_rnaseq_data (
    trial_name character varying(25),
    region_name character varying(100),
    expr_id character varying(100),
    readcount character varying(50)
);


ALTER TABLE tm_lz.lt_src_rnaseq_data OWNER TO tm_lz;

--
-- Name: lt_src_sample_categories; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_sample_categories (
    trial_cd character varying(200),
    site_cd character varying(200),
    subject_cd character varying(200),
    sample_cd character varying(200),
    category_cd character varying(200),
    category_value character varying(200)
);


ALTER TABLE tm_lz.lt_src_sample_categories OWNER TO tm_lz;

--
-- Name: lt_src_search_keyword; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_search_keyword (
    keyword character varying(300),
    display_category character varying(300),
    data_category character varying(200),
    source_cd character varying(200),
    uid_prefix character varying(20),
    unique_id character varying(300),
    parent_term character varying(300),
    bio_data_id character varying(300)
);


ALTER TABLE tm_lz.lt_src_search_keyword OWNER TO tm_lz;

SET default_tablespace = '';

--
-- Name: lt_src_study_metadata; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: 
--

CREATE TABLE lt_src_study_metadata (
    study_owner character varying(510),
    study_phase character varying(100),
    study_id character varying(100),
    design character varying(2000),
    overall_design character varying(2000),
    contact_field character varying(400),
    institution character varying(100),
    duration_of_study_weeks character varying(200),
    access_type character varying(100),
    type_of_control character varying(510),
    number_of_sites character varying(200),
    max_age character varying(100),
    secondary_ids character varying(510),
    status character varying(100),
    blinding_procedure character varying(1000),
    subjects character varying(2000),
    gender_restriction_mfb character varying(510),
    min_age character varying(100),
    search_area character varying(100),
    dosing_regimen character varying(3500),
    target character varying(255),
    primary_end_points character varying(2000),
    number_of_patients character varying(200),
    group_assignment character varying(510),
    studytype character varying(510),
    disease character varying(1000),
    route_of_administration character varying(510),
    biomarker_type character varying(255),
    compound character varying(1000),
    exclusion_criteria character varying(4000),
    secondary_end_points character varying(3500),
    description character varying(2000),
    organism character varying(200),
    country character varying(50),
    main_findings character varying(2000),
    geo_platform character varying(100),
    development_partner character varying(100),
    start_date character varying(50),
    completion_date character varying(50),
    primary_investigator character varying(400),
    inclusion_criteria character varying(4000),
    title character varying(1000),
    pubmed_ids character varying(1000)
);


ALTER TABLE tm_lz.lt_src_study_metadata OWNER TO tm_lz;

SET default_tablespace = transmart;

--
-- Name: lt_src_study_metadata_ad_hoc; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_study_metadata_ad_hoc (
    study_id character varying(100),
    ad_hoc_property_key character varying(500),
    ad_hoc_property_value character varying(4000),
    ad_hoc_property_link character varying(500)
);


ALTER TABLE tm_lz.lt_src_study_metadata_ad_hoc OWNER TO tm_lz;

--
-- Name: lt_src_subj_enroll_date; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lt_src_subj_enroll_date (
    study_id character varying(25),
    site_id character varying(50),
    subject_id character varying(20),
    enroll_date character varying(25)
);


ALTER TABLE tm_lz.lt_src_subj_enroll_date OWNER TO tm_lz;

--
-- Name: lz_src_analysis_metadata; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lz_src_analysis_metadata (
    study_id character varying(50),
    data_type character varying(50),
    analysis_name character varying(500),
    description character varying(500),
    phenotype_ids character varying(250),
    population character varying(500),
    tissue character varying(500),
    genome_version character varying(50),
    genotype_platform_ids character varying(500),
    expression_platform_ids character varying(500),
    statistical_test character varying(500),
    research_unit character varying(500),
    sample_size character varying(500),
    cell_type character varying(500),
    pvalue_cutoff character varying(50),
    etl_date timestamp without time zone,
    filename character varying(500),
    status character varying(50),
    process_date timestamp without time zone,
    etl_id numeric(38,0),
    analysis_name_archived character varying(500),
    model_name character varying(500),
    model_desc character varying(500),
    sensitive_flag numeric(18,0),
    sensitive_desc character varying(500)
);


ALTER TABLE tm_lz.lz_src_analysis_metadata OWNER TO tm_lz;

--
-- Name: lz_src_clinical_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lz_src_clinical_data (
    study_id character varying(25),
    site_id character varying(50),
    subject_id character varying(20),
    visit_name character varying(100),
    data_label character varying(500),
    data_value character varying(500),
    category_cd character varying(250),
    etl_job_id numeric(22,0),
    etl_date timestamp without time zone,
    data_label_ctrl_vocab_code character varying(200),
    data_value_ctrl_vocab_code character varying(500),
    data_label_components character varying(1000),
    units_cd character varying(50),
    visit_date character varying(50),
    link_type character varying(20),
    link_value character varying(200),
    end_date character varying(50),
    visit_reference character varying(100),
    date_ind character(1),
    obs_string character varying(100),
    valuetype_cd character varying(50),
    modifier_cd character varying(100),
    date_timestamp timestamp without time zone,
    ctrl_vocab_code character varying(200),
    sample_type character varying(100)
);


ALTER TABLE tm_lz.lz_src_clinical_data OWNER TO tm_lz;

--
-- Name: lz_src_mrna_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lz_src_mrna_data (
    trial_name character varying(25),
    probeset character varying(100),
    expr_id character varying(100),
    intensity_value character varying(50),
    source_cd character varying(200)
);


ALTER TABLE tm_lz.lz_src_mrna_data OWNER TO tm_lz;

--
-- Name: lz_src_mrna_subj_samp_map; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lz_src_mrna_subj_samp_map (
    trial_name character varying(100),
    site_id character varying(100),
    subject_id character varying(100),
    sample_cd character varying(100),
    platform character varying(100),
    tissue_type character varying(100),
    attribute_1 character varying(256),
    attribute_2 character varying(200),
    category_cd character varying(200),
    source_cd character varying(200)
);


ALTER TABLE tm_lz.lz_src_mrna_subj_samp_map OWNER TO tm_lz;

--
-- Name: lz_src_sample_categories_bkup; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lz_src_sample_categories_bkup (
    trial_cd character varying(200),
    site_cd character varying(200),
    subject_cd character varying(200),
    sample_cd character varying(200),
    category_cd character varying(200),
    category_value character varying(200)
);


ALTER TABLE tm_lz.lz_src_sample_categories_bkup OWNER TO tm_lz;

--
-- Name: lz_src_study_metadata; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lz_src_study_metadata (
    study_title character varying(500),
    study_date character varying(50),
    study_owner character varying(500),
    study_institution character varying(500),
    study_country character varying(500),
    study_related_publication character varying(500),
    study_description character varying(2000),
    study_access_type character varying(500),
    study_phase character varying(500),
    study_objective character varying(2000),
    study_biomarker_type character varying(500),
    study_compound character varying(500),
    study_design_factors character varying(2000),
    study_nbr_subjects character varying(20),
    study_organism character varying(500),
    study_id character varying(50)
);


ALTER TABLE tm_lz.lz_src_study_metadata OWNER TO tm_lz;

--
-- Name: lz_src_study_metadata_ad_hoc; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lz_src_study_metadata_ad_hoc (
    study_id character varying(100),
    ad_hoc_property_key character varying(500),
    ad_hoc_property_value character varying(4000),
    ad_hoc_property_link character varying(500),
    upload_date timestamp without time zone
);


ALTER TABLE tm_lz.lz_src_study_metadata_ad_hoc OWNER TO tm_lz;

--
-- Name: lz_src_subj_enroll_date; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE lz_src_subj_enroll_date (
    study_id character varying(25),
    site_id character varying(50),
    subject_id character varying(20),
    enroll_date character varying(25)
);


ALTER TABLE tm_lz.lz_src_subj_enroll_date OWNER TO tm_lz;

--
-- Name: rwg_analysis; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE rwg_analysis (
    study_id character varying(500),
    cohorts character varying(500),
    analysis_id character varying(500),
    pvalue_cutoff double precision,
    foldchange_cutoff double precision,
    lsmean_cutoff double precision,
    analysis_type character varying(500),
    data_type character varying(500),
    platform character varying(500),
    long_desc character varying(500),
    short_desc character varying(500),
    import_date timestamp(6) without time zone DEFAULT now() NOT NULL,
    bio_assay_analysis_id bigint
);


ALTER TABLE tm_lz.rwg_analysis OWNER TO tm_lz;

--
-- Name: rwg_analysis_data; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE rwg_analysis_data (
    study_id character varying(200),
    probeset character varying(200),
    fold_change double precision,
    pvalue double precision,
    raw_pvalue double precision,
    min_lsmean double precision,
    max_lsmean double precision,
    analysis_cd character varying(100),
    bio_assay_analysis_id bigint,
    adjusted_pvalue double precision
);


ALTER TABLE tm_lz.rwg_analysis_data OWNER TO tm_lz;

--
-- Name: rwg_analysis_data_ext; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE rwg_analysis_data_ext (
    analysis_id character varying(100),
    probeset character varying(100),
    preferred_pvalue character varying(100),
    raw_pvalue character varying(100),
    adjusted_pvalue character varying(100),
    fold_change character varying(100),
    lsmean_1 character varying(100),
    lsmean_2 character varying(100)
);


ALTER TABLE tm_lz.rwg_analysis_data_ext OWNER TO tm_lz;

--
-- Name: rwg_analysis_ext; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE rwg_analysis_ext (
    study_id character varying(500),
    cohorts character varying(500),
    analysis_id character varying(500),
    pvalue_cutoff character varying(500),
    foldchange_cutoff character varying(500),
    lsmean_cutoff character varying(500),
    analysis_type character varying(500),
    data_type character varying(500),
    platform character varying(500),
    long_desc character varying(500),
    short_desc character varying(500)
);


ALTER TABLE tm_lz.rwg_analysis_ext OWNER TO tm_lz;

--
-- Name: rwg_cohorts; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE rwg_cohorts (
    study_id character varying(500),
    cohort_id character varying(500),
    disease character varying(500),
    sample_type character varying(500),
    treatment character varying(500),
    organism character varying(500),
    pathology character varying(500),
    cohort_title character varying(500),
    short_desc character varying(500),
    long_desc character varying(500),
    import_date timestamp(6) without time zone DEFAULT now() NOT NULL
);


ALTER TABLE tm_lz.rwg_cohorts OWNER TO tm_lz;

--
-- Name: rwg_cohorts_ext; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE rwg_cohorts_ext (
    study_id character varying(500),
    cohort_id character varying(500),
    disease character varying(500),
    sample_type character varying(500),
    treatment character varying(500),
    organism character varying(500),
    pathology character varying(500),
    cohort_title character varying(500),
    short_desc character varying(500),
    long_desc character varying(500)
);


ALTER TABLE tm_lz.rwg_cohorts_ext OWNER TO tm_lz;

--
-- Name: rwg_samples; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE rwg_samples (
    study_id character varying(500),
    expr_id character varying(500),
    cohorts character varying(500),
    import_date timestamp(6) without time zone DEFAULT now() NOT NULL
);


ALTER TABLE tm_lz.rwg_samples OWNER TO tm_lz;

--
-- Name: rwg_samples_ext; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE rwg_samples_ext (
    study_id character varying(500),
    expr_id character varying(500),
    cohorts character varying(500)
);


ALTER TABLE tm_lz.rwg_samples_ext OWNER TO tm_lz;

--
-- Name: seq_etl_id; Type: SEQUENCE; Schema: tm_lz; Owner: tm_lz
--

CREATE SEQUENCE seq_etl_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tm_lz.seq_etl_id OWNER TO tm_lz;

--
-- Name: wt_snp_node_values; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE wt_snp_node_values (
    category_cd character varying(500),
    sample_type character varying(200),
    timepoint character varying(200),
    title character varying(500)
);


ALTER TABLE tm_lz.wt_snp_node_values OWNER TO tm_lz;

--
-- Name: wt_snp_nodes; Type: TABLE; Schema: tm_lz; Owner: tm_lz; Tablespace: transmart
--

CREATE TABLE wt_snp_nodes (
    leaf_node character varying(2000),
    category_cd character varying(500),
    platform character varying(500),
    sample_type character varying(200),
    timepoint character varying(200),
    node_type character varying(100)
);


ALTER TABLE tm_lz.wt_snp_nodes OWNER TO tm_lz;

SET search_path = tm_wz, pg_catalog;

--
-- Name: bio_assay_analysis_data_new; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE bio_assay_analysis_data_new (
    bio_asy_analysis_data_id bigint,
    fold_change_ratio bigint,
    raw_pvalue double precision,
    adjusted_pvalue double precision,
    r_value double precision,
    rho_value double precision,
    bio_assay_analysis_id bigint,
    adjusted_p_value_code character varying(100),
    feature_group_name character varying(100),
    bio_experiment_id bigint,
    bio_assay_platform_id bigint,
    etl_id character varying(100),
    preferred_pvalue double precision,
    cut_value double precision,
    results_value character varying(100),
    numeric_value double precision,
    numeric_value_code character varying(50),
    tea_normalized_pvalue double precision,
    bio_assay_feature_group_id bigint,
    lsmean1 double precision,
    lsmean2 double precision
);


ALTER TABLE tm_wz.bio_assay_analysis_data_new OWNER TO tm_wz;

--
-- Name: tmp_assay_analysis_metrics; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE tmp_assay_analysis_metrics (
    bio_assay_analysis_id bigint NOT NULL,
    data_ct bigint,
    fc_mean bigint,
    fc_stddev bigint
);


ALTER TABLE tm_wz.tmp_assay_analysis_metrics OWNER TO tm_wz;

--
-- Name: wrk_clinical_data; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wrk_clinical_data (
    study_id character varying(25),
    site_id character varying(50),
    subject_id character varying(20),
    visit_name character varying(100),
    data_label character varying(500),
    data_value character varying(500),
    category_cd character varying(250),
    etl_job_id numeric(22,0),
    etl_date timestamp without time zone,
    usubjid character varying(200),
    category_path character varying(1000),
    data_type character varying(10),
    data_label_ctrl_vocab_code character varying(200),
    data_value_ctrl_vocab_code character varying(500),
    data_label_components character varying(1000),
    units_cd character varying(50),
    visit_date character varying(200),
    node_name character varying(1000),
    link_type character varying(20),
    link_value character varying(200),
    end_date character varying(50),
    visit_reference character varying(100),
    date_ind character(1),
    obs_string character varying(100),
    rec_num numeric(18,0),
    valuetype_cd character varying(50),
    leaf_node character varying(2000),
    modifier_cd character varying(100),
    ctrl_vocab_code character varying(200),
    date_timestamp timestamp without time zone,
    sample_cd character varying(200)
);


ALTER TABLE tm_wz.wrk_clinical_data OWNER TO tm_wz;

--
-- Name: wrk_mrna_data; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wrk_mrna_data (
    probeset character varying(100),
    expr_id character varying(100),
    raw_intensity character varying(50)
);


ALTER TABLE tm_wz.wrk_mrna_data OWNER TO tm_wz;

--
-- Name: wt_clinical_data_dups; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_clinical_data_dups (
    site_id character varying(50),
    subject_id character varying(20),
    visit_name character varying(100),
    data_label character varying(500),
    category_cd character varying(250),
    modifier_cd character varying(100),
    link_value character varying(500)
);


ALTER TABLE tm_wz.wt_clinical_data_dups OWNER TO tm_wz;

--
-- Name: wt_clinical_encounter; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_clinical_encounter (
    link_type character varying(20),
    link_value character varying(500),
    encounter_num numeric
);


ALTER TABLE tm_wz.wt_clinical_encounter OWNER TO tm_wz;

--
-- Name: wt_del_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_del_nodes (
    c_fullname character varying(1000),
    c_basecode character varying(500)
);


ALTER TABLE tm_wz.wt_del_nodes OWNER TO tm_wz;

--
-- Name: wt_folder_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_folder_nodes (
    folder_path character varying(700),
    folder_name character varying(2000)
);


ALTER TABLE tm_wz.wt_folder_nodes OWNER TO tm_wz;

--
-- Name: wt_metabolomic_node_values; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_metabolomic_node_values (
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    transform_method character varying(2000)
);


ALTER TABLE tm_wz.wt_metabolomic_node_values OWNER TO tm_wz;

--
-- Name: wt_metabolomic_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_metabolomic_nodes (
    leaf_node character varying(2000),
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    node_name character varying(2000),
    concept_cd character varying(100),
    transform_method character varying(2000),
    node_type character varying(50)
);


ALTER TABLE tm_wz.wt_metabolomic_nodes OWNER TO tm_wz;

--
-- Name: wt_mixed_types; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_mixed_types (
    category_cd character varying(250),
    data_label character varying(500),
    visit_name character varying(100)
);


ALTER TABLE tm_wz.wt_mixed_types OWNER TO tm_wz;

--
-- Name: wt_mrna_data; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_mrna_data (
    probeset character varying(100),
    expr_id character varying(100),
    intensity_value character varying(50)
);


ALTER TABLE tm_wz.wt_mrna_data OWNER TO tm_wz;

--
-- Name: wt_mrna_node_values; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_mrna_node_values (
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    transform_method character varying(2000)
);


ALTER TABLE tm_wz.wt_mrna_node_values OWNER TO tm_wz;

--
-- Name: wt_mrna_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_mrna_nodes (
    leaf_node character varying(2000),
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    node_name character varying(2000),
    concept_cd character varying(100),
    transform_method character varying(2000),
    node_type character varying(50),
    orig_category_cd character varying(2000)
);


ALTER TABLE tm_wz.wt_mrna_nodes OWNER TO tm_wz;

--
-- Name: wt_mrna_subj_sample_map; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_mrna_subj_sample_map (
    trial_name character varying(100),
    site_id character varying(100),
    subject_id character varying(100),
    sample_cd character varying(100),
    platform character varying(100),
    tissue_type character varying(100),
    attribute_1 character varying(256),
    attribute_2 character varying(200),
    category_cd character varying(200)
);


ALTER TABLE tm_wz.wt_mrna_subj_sample_map OWNER TO tm_wz;

--
-- Name: wt_num_data_types; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_num_data_types (
    category_cd character varying(200),
    data_label character varying(500),
    sample_type character varying(100),
    visit_name character varying(100)
);


ALTER TABLE tm_wz.wt_num_data_types OWNER TO tm_wz;

--
-- Name: wt_proteomics_node_values; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_proteomics_node_values (
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    transform_method character varying(2000)
);


ALTER TABLE tm_wz.wt_proteomics_node_values OWNER TO tm_wz;

--
-- Name: wt_proteomics_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_proteomics_nodes (
    leaf_node character varying(2000),
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    node_name character varying(2000),
    concept_cd character varying(100),
    transform_method character varying(2000),
    node_type character varying(50)
);


ALTER TABLE tm_wz.wt_proteomics_nodes OWNER TO tm_wz;

--
-- Name: wt_qpcr_mirna_node_values; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_qpcr_mirna_node_values (
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    transform_method character varying(2000)
);


ALTER TABLE tm_wz.wt_qpcr_mirna_node_values OWNER TO tm_wz;

--
-- Name: wt_qpcr_mirna_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_qpcr_mirna_nodes (
    leaf_node character varying(2000),
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    node_name character varying(2000),
    concept_cd character varying(100),
    transform_method character varying(2000),
    node_type character varying(50)
);


ALTER TABLE tm_wz.wt_qpcr_mirna_nodes OWNER TO tm_wz;

--
-- Name: wt_rbm_node_values; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_rbm_node_values (
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    transform_method character varying(2000)
);


ALTER TABLE tm_wz.wt_rbm_node_values OWNER TO tm_wz;

--
-- Name: wt_rbm_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_rbm_nodes (
    leaf_node character varying(2000),
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    node_name character varying(2000),
    concept_cd character varying(100),
    transform_method character varying(2000),
    node_type character varying(50)
);


ALTER TABLE tm_wz.wt_rbm_nodes OWNER TO tm_wz;

--
-- Name: wt_rna_seq_node_values; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_rna_seq_node_values (
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    transform_method character varying(2000)
);


ALTER TABLE tm_wz.wt_rna_seq_node_values OWNER TO tm_wz;

--
-- Name: wt_rna_seq_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_rna_seq_nodes (
    leaf_node character varying(2000),
    category_cd character varying(2000),
    platform character varying(2000),
    tissue_type character varying(2000),
    attribute_1 character varying(2000),
    attribute_2 character varying(2000),
    title character varying(2000),
    node_name character varying(2000),
    concept_cd character varying(100),
    transform_method character varying(2000),
    node_type character varying(50)
);


ALTER TABLE tm_wz.wt_rna_seq_nodes OWNER TO tm_wz;

--
-- Name: wt_subject_acgh_region; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_acgh_region (
    region_id bigint,
    expr_id character varying(500),
    chip double precision,
    segmented double precision,
    flag smallint,
    probloss double precision,
    probnorm double precision,
    probgain double precision,
    probamp double precision,
    num_calls bigint,
    pvalue double precision,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(100),
    trial_name character varying(200),
    timepoint character varying(200),
    sample_type character varying(200),
    platform character varying(200),
    tissue_type character varying(200)
);


ALTER TABLE tm_wz.wt_subject_acgh_region OWNER TO tm_wz;

--
-- Name: wt_subject_info; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_info (
    usubjid character varying(107),
    age_in_years_num smallint,
    sex_cd character varying(50),
    race_cd character varying(50)
);


ALTER TABLE tm_wz.wt_subject_info OWNER TO tm_wz;

--
-- Name: wt_subject_mbolomics_probeset; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_mbolomics_probeset (
    probeset character varying(500),
    expr_id character varying(500),
    intensity_value bigint,
    num_calls bigint,
    pvalue bigint,
    assay_id bigint,
    patient_id bigint,
    sample_id character varying(100),
    subject_id character varying(100),
    trial_name character varying(200),
    timepoint character varying(200),
    sample_type character varying(200),
    platform character varying(200),
    tissue_type character varying(200)
);


ALTER TABLE tm_wz.wt_subject_mbolomics_probeset OWNER TO tm_wz;

--
-- Name: wt_subject_metabolomics_calcs; Type: TABLE; Schema: tm_wz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE wt_subject_metabolomics_calcs (
    trial_name character varying(50),
    probeset character varying(500),
    mean_intensity bigint,
    median_intensity bigint,
    stddev_intensity bigint
);


ALTER TABLE tm_wz.wt_subject_metabolomics_calcs OWNER TO tm_cz;

--
-- Name: wt_subject_metabolomics_logs; Type: TABLE; Schema: tm_wz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE wt_subject_metabolomics_logs (
    probeset character varying(500),
    intensity_value bigint,
    pvalue double precision,
    num_calls bigint,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    log_intensity bigint
);


ALTER TABLE tm_wz.wt_subject_metabolomics_logs OWNER TO tm_cz;

--
-- Name: wt_subject_metabolomics_med; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_metabolomics_med (
    probeset character varying(500),
    intensity_value bigint,
    log_intensity bigint,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    pvalue double precision,
    num_calls bigint,
    mean_intensity bigint,
    stddev_intensity bigint,
    median_intensity bigint,
    zscore bigint
);


ALTER TABLE tm_wz.wt_subject_metabolomics_med OWNER TO tm_wz;

SET default_tablespace = '';

--
-- Name: wt_subject_microarray_calcs; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_subject_microarray_calcs (
    trial_name character varying(50),
    probeset_id bigint,
    mean_intensity numeric,
    median_intensity numeric,
    stddev_intensity numeric
);


ALTER TABLE tm_wz.wt_subject_microarray_calcs OWNER TO tm_wz;

--
-- Name: wt_subject_microarray_logs; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_subject_microarray_logs (
    probeset_id bigint,
    intensity_value numeric,
    pvalue numeric,
    num_calls numeric,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    log_intensity numeric,
    raw_intensity numeric
);


ALTER TABLE tm_wz.wt_subject_microarray_logs OWNER TO tm_wz;

--
-- Name: wt_subject_microarray_med; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_subject_microarray_med (
    probeset_id bigint,
    intensity_value numeric,
    log_intensity numeric,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    pvalue numeric,
    num_calls numeric,
    mean_intensity numeric,
    stddev_intensity numeric,
    median_intensity numeric,
    zscore numeric
);


ALTER TABLE tm_wz.wt_subject_microarray_med OWNER TO tm_wz;

SET default_tablespace = transmart;

--
-- Name: wt_subject_mirna_calcs; Type: TABLE; Schema: tm_wz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE wt_subject_mirna_calcs (
    trial_name character varying(50),
    probeset_id character varying(1000),
    mean_intensity numeric,
    median_intensity numeric,
    stddev_intensity numeric
);


ALTER TABLE tm_wz.wt_subject_mirna_calcs OWNER TO tm_cz;

--
-- Name: wt_subject_mirna_logs; Type: TABLE; Schema: tm_wz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE wt_subject_mirna_logs (
    probeset_id character varying(1000),
    intensity_value numeric,
    pvalue double precision,
    num_calls numeric,
    assay_id numeric(18,0),
    patient_id numeric(18,0),
    sample_id numeric(18,0),
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    log_intensity numeric
);


ALTER TABLE tm_wz.wt_subject_mirna_logs OWNER TO tm_cz;

--
-- Name: wt_subject_mirna_med; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_mirna_med (
    probeset_id character varying(1000),
    intensity_value numeric,
    log_intensity numeric,
    assay_id numeric(18,0),
    patient_id numeric(18,0),
    sample_id numeric(18,0),
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    pvalue double precision,
    num_calls numeric,
    mean_intensity numeric,
    stddev_intensity numeric,
    median_intensity numeric,
    zscore numeric
);


ALTER TABLE tm_wz.wt_subject_mirna_med OWNER TO tm_wz;

--
-- Name: wt_subject_mirna_probeset; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_mirna_probeset (
    probeset_id numeric(38,0),
    expr_id character varying(500),
    intensity_value numeric,
    num_calls numeric,
    pvalue numeric,
    assay_id numeric(18,0),
    patient_id numeric(22,0),
    sample_id numeric(18,0),
    subject_id character varying(100),
    trial_name character varying(200),
    timepoint character varying(200),
    sample_type character varying(200),
    platform character varying(200),
    tissue_type character varying(200)
);


ALTER TABLE tm_wz.wt_subject_mirna_probeset OWNER TO tm_wz;

SET default_tablespace = '';

--
-- Name: wt_subject_mrna_data; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE TABLE wt_subject_mrna_data (
    probeset character varying(500),
    expr_id character varying(500),
    intensity_value numeric,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(100),
    trial_name character varying(200),
    timepoint character varying(200),
    sample_type character varying(200),
    platform character varying(200),
    tissue_type character varying(200)
);


ALTER TABLE tm_wz.wt_subject_mrna_data OWNER TO tm_wz;

SET default_tablespace = transmart;

--
-- Name: wt_subject_mrna_probeset; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_mrna_probeset (
    probeset_id bigint,
    expr_id character varying(500),
    intensity_value double precision,
    num_calls bigint,
    pvalue numeric,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(100),
    trial_name character varying(200),
    timepoint character varying(200),
    sample_type character varying(200),
    platform character varying(200),
    tissue_type character varying(200)
);


ALTER TABLE tm_wz.wt_subject_mrna_probeset OWNER TO tm_wz;

--
-- Name: wt_subject_proteomics_calcs; Type: TABLE; Schema: tm_wz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE wt_subject_proteomics_calcs (
    trial_name character varying(50),
    probeset_id character varying(500),
    mean_intensity numeric,
    median_intensity numeric,
    stddev_intensity numeric
);


ALTER TABLE tm_wz.wt_subject_proteomics_calcs OWNER TO tm_cz;

--
-- Name: wt_subject_proteomics_logs; Type: TABLE; Schema: tm_wz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE wt_subject_proteomics_logs (
    probeset_id character varying(500),
    intensity_value numeric,
    pvalue double precision,
    num_calls numeric,
    assay_id numeric(18,0),
    patient_id numeric(18,0),
    sample_id numeric(18,0),
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    log_intensity numeric
);


ALTER TABLE tm_wz.wt_subject_proteomics_logs OWNER TO tm_cz;

--
-- Name: wt_subject_proteomics_med; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_proteomics_med (
    probeset_id character varying(500),
    intensity_value numeric,
    log_intensity numeric,
    assay_id numeric(18,0),
    patient_id numeric(18,0),
    sample_id numeric(18,0),
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    pvalue double precision,
    num_calls numeric,
    mean_intensity numeric,
    stddev_intensity numeric,
    median_intensity numeric,
    zscore numeric
);


ALTER TABLE tm_wz.wt_subject_proteomics_med OWNER TO tm_wz;

--
-- Name: wt_subject_proteomics_probeset; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_proteomics_probeset (
    probeset character varying(500),
    expr_id character varying(500),
    intensity_value numeric,
    num_calls numeric,
    pvalue numeric,
    assay_id numeric(18,0),
    patient_id numeric(22,0),
    sample_id character varying(100),
    subject_id character varying(100),
    trial_name character varying(200),
    timepoint character varying(200),
    sample_type character varying(200),
    platform character varying(200),
    tissue_type character varying(200)
);


ALTER TABLE tm_wz.wt_subject_proteomics_probeset OWNER TO tm_wz;

--
-- Name: wt_subject_rbm_calcs; Type: TABLE; Schema: tm_wz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE wt_subject_rbm_calcs (
    trial_name character varying(50),
    probeset_id character varying(1000),
    mean_intensity bigint,
    median_intensity bigint,
    stddev_intensity bigint
);


ALTER TABLE tm_wz.wt_subject_rbm_calcs OWNER TO tm_cz;

--
-- Name: wt_subject_rbm_logs; Type: TABLE; Schema: tm_wz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE wt_subject_rbm_logs (
    probeset_id character varying(1000),
    intensity_value bigint,
    pvalue double precision,
    num_calls bigint,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    log_intensity bigint
);


ALTER TABLE tm_wz.wt_subject_rbm_logs OWNER TO tm_cz;

--
-- Name: wt_subject_rbm_med; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_rbm_med (
    probeset_id character varying(1000),
    intensity_value bigint,
    log_intensity bigint,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    pvalue double precision,
    num_calls bigint,
    mean_intensity bigint,
    stddev_intensity bigint,
    median_intensity bigint,
    zscore bigint
);


ALTER TABLE tm_wz.wt_subject_rbm_med OWNER TO tm_wz;

--
-- Name: wt_subject_rbm_probeset; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_rbm_probeset (
    probeset character varying(1000),
    expr_id character varying(500),
    intensity_value bigint,
    num_calls bigint,
    pvalue bigint,
    assay_id bigint,
    patient_id bigint,
    sample_id character varying(100),
    subject_id character varying(100),
    trial_name character varying(200),
    timepoint character varying(200),
    sample_type character varying(200),
    platform character varying(200),
    tissue_type character varying(200)
);


ALTER TABLE tm_wz.wt_subject_rbm_probeset OWNER TO tm_wz;

--
-- Name: wt_subject_rna_calcs; Type: TABLE; Schema: tm_wz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE wt_subject_rna_calcs (
    trial_name character varying(50),
    probeset_id character varying(200),
    mean_intensity bigint,
    median_intensity bigint,
    stddev_intensity bigint
);


ALTER TABLE tm_wz.wt_subject_rna_calcs OWNER TO tm_cz;

--
-- Name: wt_subject_rna_logs; Type: TABLE; Schema: tm_wz; Owner: tm_cz; Tablespace: transmart
--

CREATE TABLE wt_subject_rna_logs (
    probeset_id character varying(200),
    intensity_value bigint,
    pvalue double precision,
    num_calls bigint,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    log_intensity bigint
);


ALTER TABLE tm_wz.wt_subject_rna_logs OWNER TO tm_cz;

--
-- Name: wt_subject_rna_med; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_rna_med (
    probeset_id character varying(200),
    intensity_value bigint,
    log_intensity bigint,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(50),
    trial_name character varying(50),
    timepoint character varying(100),
    pvalue double precision,
    num_calls bigint,
    mean_intensity bigint,
    stddev_intensity bigint,
    median_intensity bigint,
    zscore bigint
);


ALTER TABLE tm_wz.wt_subject_rna_med OWNER TO tm_wz;

--
-- Name: wt_subject_rna_probeset; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_rna_probeset (
    probeset_id character varying(200),
    expr_id character varying(500),
    intensity_value bigint,
    num_calls bigint,
    pvalue bigint,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(100),
    trial_name character varying(200),
    timepoint character varying(200),
    sample_type character varying(200),
    platform character varying(200),
    tissue_type character varying(200)
);


ALTER TABLE tm_wz.wt_subject_rna_probeset OWNER TO tm_wz;

--
-- Name: wt_subject_rnaseq_region; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_rnaseq_region (
    region_id bigint,
    expr_id character varying(500),
    readcount bigint,
    assay_id bigint,
    patient_id bigint,
    sample_id bigint,
    subject_id character varying(100),
    trial_name character varying(200),
    timepoint character varying(200),
    sample_type character varying(200),
    platform character varying(200),
    tissue_type character varying(200)
);


ALTER TABLE tm_wz.wt_subject_rnaseq_region OWNER TO tm_wz;

--
-- Name: wt_subject_sample_mapping; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_subject_sample_mapping (
    patient_num numeric(38,0),
    site_id character varying(100),
    subject_id character varying(100),
    concept_code character varying(50),
    sample_type character varying(100),
    sample_type_cd character varying(100),
    timepoint character varying(100),
    timepoint_cd character varying(50),
    tissue_type character varying(100),
    tissue_type_cd character varying(50),
    platform character varying(50),
    platform_cd character varying(50),
    data_uid character varying(100),
    gpl_id character varying(20),
    sample_cd character varying(200),
    category_cd character varying(1000)
);


ALTER TABLE tm_wz.wt_subject_sample_mapping OWNER TO tm_wz;

--
-- Name: wt_trial_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_trial_nodes (
    leaf_node character varying(4000),
    category_cd character varying(250),
    visit_name character varying(100),
    sample_type character varying(100),
    data_label character varying(500),
    node_name character varying(500),
    data_value character varying(500),
    data_type character varying(20),
    data_label_ctrl_vocab_code character varying(500),
    data_value_ctrl_vocab_code character varying(500),
    data_label_components character varying(1000),
    link_type character varying(50),
    obs_string character varying(100),
    valuetype_cd character varying(50),
    rec_num numeric
);


ALTER TABLE tm_wz.wt_trial_nodes OWNER TO tm_wz;

--
-- Name: wt_vocab_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_vocab_nodes (
    leaf_node character varying(1000),
    modifier_cd character varying(100),
    label_node character varying(1000),
    value_instance numeric(18,0),
    label_instance numeric(18,0)
);


ALTER TABLE tm_wz.wt_vocab_nodes OWNER TO tm_wz;

--
-- Name: wt_xtrial_nodes; Type: TABLE; Schema: tm_wz; Owner: tm_wz; Tablespace: transmart
--

CREATE TABLE wt_xtrial_nodes (
    xtrial_cd character varying(200),
    trial_name character varying(200),
    leaf_name character varying(200),
    data_type character varying(10),
    concept_cd character varying(200),
    leaf_node character varying(2000)
);


ALTER TABLE tm_wz.wt_xtrial_nodes OWNER TO tm_wz;

SET search_path = amapp, pg_catalog;

SET default_tablespace = indx;

--
-- Name: am_data_uid_pk; Type: CONSTRAINT; Schema: amapp; Owner: amapp; Tablespace: indx
--

ALTER TABLE ONLY am_data_uid
    ADD CONSTRAINT am_data_uid_pk PRIMARY KEY (am_data_id);


--
-- Name: am_data_uid_uk; Type: CONSTRAINT; Schema: amapp; Owner: amapp; Tablespace: indx
--

ALTER TABLE ONLY am_data_uid
    ADD CONSTRAINT am_data_uid_uk UNIQUE (unique_id);


--
-- Name: am_tag_association_pkey; Type: CONSTRAINT; Schema: amapp; Owner: amapp; Tablespace: indx
--

ALTER TABLE ONLY am_tag_association
    ADD CONSTRAINT am_tag_association_pkey PRIMARY KEY (subject_uid, object_uid);


--
-- Name: am_tag_item_pkey; Type: CONSTRAINT; Schema: amapp; Owner: amapp; Tablespace: indx
--

ALTER TABLE ONLY am_tag_item
    ADD CONSTRAINT am_tag_item_pkey PRIMARY KEY (tag_template_id, tag_item_id);


--
-- Name: am_tag_template_association_pkey; Type: CONSTRAINT; Schema: amapp; Owner: amapp; Tablespace: indx
--

ALTER TABLE ONLY am_tag_template_association
    ADD CONSTRAINT am_tag_template_association_pkey PRIMARY KEY (tag_template_id, object_uid);


--
-- Name: am_tag_template_pkey; Type: CONSTRAINT; Schema: amapp; Owner: amapp; Tablespace: indx
--

ALTER TABLE ONLY am_tag_template
    ADD CONSTRAINT am_tag_template_pkey PRIMARY KEY (tag_template_id);


--
-- Name: am_tag_value_pk; Type: CONSTRAINT; Schema: amapp; Owner: amapp; Tablespace: indx
--

ALTER TABLE ONLY am_tag_value
    ADD CONSTRAINT am_tag_value_pk PRIMARY KEY (tag_value_id);


SET search_path = biomart, pg_catalog;

--
-- Name: annotation_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY annotation
    ADD CONSTRAINT annotation_pk PRIMARY KEY (id);


--
-- Name: assay_analysis_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY assay_analysis_data
    ADD CONSTRAINT assay_analysis_data_pk PRIMARY KEY (bio_asy_analysis_data_id);


--
-- Name: bio_aa_data_t_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_assay_analysis_data_tea
    ADD CONSTRAINT bio_aa_data_t_pk PRIMARY KEY (bio_asy_analysis_data_id);


--
-- Name: bio_ad_hoc_property_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_ad_hoc_property
    ADD CONSTRAINT bio_ad_hoc_property_pk PRIMARY KEY (ad_hoc_property_id);


--
-- Name: bio_analysis_cohort_xref_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_analysis_cohort_xref
    ADD CONSTRAINT bio_analysis_cohort_xref_pk PRIMARY KEY (bio_assay_analysis_id);


--
-- Name: bio_assay_analysis_eqtl_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_assay_analysis_eqtl
    ADD CONSTRAINT bio_assay_analysis_eqtl_pk PRIMARY KEY (bio_asy_analysis_eqtl_id);


--
-- Name: bio_assay_analysis_platform_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_asy_analysis_pltfm
    ADD CONSTRAINT bio_assay_analysis_platform_pk PRIMARY KEY (bio_asy_analysis_pltfm_id);


--
-- Name: bio_assay_platform_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_assay_platform
    ADD CONSTRAINT bio_assay_platform_pk PRIMARY KEY (bio_assay_platform_id);


--
-- Name: bio_assay_sample_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_assay_sample
    ADD CONSTRAINT bio_assay_sample_pk PRIMARY KEY (bio_assay_id, bio_sample_id, bio_clinic_trial_timepoint_id);


--
-- Name: bio_asy_dt_stats_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_asy_data_stats_all
    ADD CONSTRAINT bio_asy_dt_stats_pk PRIMARY KEY (bio_assay_data_stats_id);


--
-- Name: bio_asy_dt_stats_s_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_assay_data_stats
    ADD CONSTRAINT bio_asy_dt_stats_s_pk PRIMARY KEY (bio_assay_data_stats_id);


--
-- Name: bio_asy_feature_grp_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_assay_feature_group
    ADD CONSTRAINT bio_asy_feature_grp_pk PRIMARY KEY (bio_assay_feature_group_id);


--
-- Name: bio_cancer_gene_curation_fact_; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_cgdcp_data
    ADD CONSTRAINT bio_cancer_gene_curation_fact_ PRIMARY KEY (bio_data_id);


--
-- Name: bio_clinical_trial_patient_grp; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_clinc_trial_attr
    ADD CONSTRAINT bio_clinical_trial_patient_grp PRIMARY KEY (bio_clinc_trial_attr_id);


--
-- Name: bio_clinical_trial_pt_group; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_clinc_trial_pt_group
    ADD CONSTRAINT bio_clinical_trial_pt_group PRIMARY KEY (bio_clinical_trial_p_group_id);


--
-- Name: bio_clinical_trial_time_point_; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_clinc_trial_time_pt
    ADD CONSTRAINT bio_clinical_trial_time_point_ PRIMARY KEY (bio_clinc_trial_tm_pt_id);


--
-- Name: bio_concept_code_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_concept_code
    ADD CONSTRAINT bio_concept_code_pk PRIMARY KEY (bio_concept_code_id);


--
-- Name: bio_concept_code_uk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_concept_code
    ADD CONSTRAINT bio_concept_code_uk UNIQUE (bio_concept_code, code_type_name);


--
-- Name: bio_content_ref_n_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_content_reference
    ADD CONSTRAINT bio_content_ref_n_pk PRIMARY KEY (bio_content_reference_id);


--
-- Name: bio_data_analysis_dataset_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_asy_analysis_dataset
    ADD CONSTRAINT bio_data_analysis_dataset_pk PRIMARY KEY (bio_assay_dataset_id, bio_assay_analysis_id);


--
-- Name: bio_data_anl_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_assay_analysis
    ADD CONSTRAINT bio_data_anl_pk PRIMARY KEY (bio_assay_analysis_id);


--
-- Name: bio_data_attr_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_data_attribute
    ADD CONSTRAINT bio_data_attr_pk PRIMARY KEY (bio_data_attribute_id);


--
-- Name: bio_data_compound_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_data_compound
    ADD CONSTRAINT bio_data_compound_pk PRIMARY KEY (bio_data_id, bio_compound_id);


--
-- Name: bio_data_correlation_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_data_correlation
    ADD CONSTRAINT bio_data_correlation_pk PRIMARY KEY (bio_data_correl_id);


--
-- Name: bio_data_disease_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_data_disease
    ADD CONSTRAINT bio_data_disease_pk PRIMARY KEY (bio_data_id, bio_disease_id);


--
-- Name: bio_data_ext_code_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_data_ext_code
    ADD CONSTRAINT bio_data_ext_code_pk PRIMARY KEY (bio_data_ext_code_id);


--
-- Name: bio_data_literature_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_data_literature
    ADD CONSTRAINT bio_data_literature_pk PRIMARY KEY (bio_data_id);


--
-- Name: bio_data_uid_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_data_uid
    ADD CONSTRAINT bio_data_uid_pk PRIMARY KEY (bio_data_id);


--
-- Name: bio_data_uid_uk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_data_uid
    ADD CONSTRAINT bio_data_uid_uk UNIQUE (unique_id);


--
-- Name: bio_dataset_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_assay_dataset
    ADD CONSTRAINT bio_dataset_pk PRIMARY KEY (bio_assay_dataset_id);


--
-- Name: bio_experiment_data_fact_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_assay_data
    ADD CONSTRAINT bio_experiment_data_fact_pk PRIMARY KEY (bio_assay_data_id);


--
-- Name: bio_external_analysis_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_curation_dataset
    ADD CONSTRAINT bio_external_analysis_pk PRIMARY KEY (bio_curation_dataset_id);


--
-- Name: bio_externalanalysis_fact_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_curated_data
    ADD CONSTRAINT bio_externalanalysis_fact_pk PRIMARY KEY (bio_data_id);


--
-- Name: bio_lit_alt_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_lit_alt_data
    ADD CONSTRAINT bio_lit_alt_data_pk PRIMARY KEY (bio_lit_alt_data_id);


--
-- Name: bio_lit_amd_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_lit_amd_data
    ADD CONSTRAINT bio_lit_amd_data_pk PRIMARY KEY (bio_lit_amd_data_id);


--
-- Name: bio_lit_inh_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_lit_inh_data
    ADD CONSTRAINT bio_lit_inh_data_pk PRIMARY KEY (bio_lit_inh_data_id);


--
-- Name: bio_lit_int_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_lit_int_data
    ADD CONSTRAINT bio_lit_int_data_pk PRIMARY KEY (bio_lit_int_data_id);


--
-- Name: bio_lit_model_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_lit_model_data
    ADD CONSTRAINT bio_lit_model_data_pk PRIMARY KEY (bio_lit_model_data_id);


--
-- Name: bio_lit_pe_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_lit_pe_data
    ADD CONSTRAINT bio_lit_pe_data_pk PRIMARY KEY (bio_lit_pe_data_id);


--
-- Name: bio_lit_ref_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_lit_ref_data
    ADD CONSTRAINT bio_lit_ref_data_pk PRIMARY KEY (bio_lit_ref_data_id);


--
-- Name: bio_lit_sum_data_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_lit_sum_data
    ADD CONSTRAINT bio_lit_sum_data_pk PRIMARY KEY (bio_lit_sum_data_id);


--
-- Name: bio_marker_relationship_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_data_correl_descr
    ADD CONSTRAINT bio_marker_relationship_pk PRIMARY KEY (bio_data_correl_descr_id);


--
-- Name: bio_patient_attribute_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_patient_event_attr
    ADD CONSTRAINT bio_patient_attribute_pk PRIMARY KEY (bio_patient_attribute_id);


--
-- Name: bio_patient_event_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_patient_event
    ADD CONSTRAINT bio_patient_event_pk PRIMARY KEY (bio_patient_event_id);


--
-- Name: bio_patient_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_patient
    ADD CONSTRAINT bio_patient_pk PRIMARY KEY (bio_patient_id);


--
-- Name: bio_s_e_m_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_stats_exp_marker
    ADD CONSTRAINT bio_s_e_m_pk PRIMARY KEY (bio_marker_id, bio_experiment_id);


--
-- Name: bio_subject_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_subject
    ADD CONSTRAINT bio_subject_pk PRIMARY KEY (bio_subject_id);


--
-- Name: bio_taxon_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_taxonomy
    ADD CONSTRAINT bio_taxon_pk PRIMARY KEY (bio_taxonomy_id);


--
-- Name: biobank_sample_pkey; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY biobank_sample
    ADD CONSTRAINT biobank_sample_pkey PRIMARY KEY (sample_tube_id);


--
-- Name: biomarker_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_marker
    ADD CONSTRAINT biomarker_pk PRIMARY KEY (bio_marker_id);


--
-- Name: biomarker_uk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_marker
    ADD CONSTRAINT biomarker_uk UNIQUE (organism, primary_external_id);


--
-- Name: biosample_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_sample
    ADD CONSTRAINT biosample_pk PRIMARY KEY (bio_sample_id);


--
-- Name: celllinedictionary_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_cell_line
    ADD CONSTRAINT celllinedictionary_pk PRIMARY KEY (bio_cell_line_id);


--
-- Name: clinicaltrialdim_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_clinical_trial
    ADD CONSTRAINT clinicaltrialdim_pk PRIMARY KEY (bio_experiment_id);


--
-- Name: compounddim_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_compound
    ADD CONSTRAINT compounddim_pk PRIMARY KEY (bio_compound_id);


--
-- Name: diseasedim_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_disease
    ADD CONSTRAINT diseasedim_pk PRIMARY KEY (bio_disease_id);


--
-- Name: experimentdim_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_experiment
    ADD CONSTRAINT experimentdim_pk PRIMARY KEY (bio_experiment_id);


--
-- Name: external_file_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_content
    ADD CONSTRAINT external_file_pk PRIMARY KEY (bio_file_content_id);


--
-- Name: external_file_repository_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_content_repository
    ADD CONSTRAINT external_file_repository_pk PRIMARY KEY (bio_content_repo_id);


--
-- Name: mesh_copy_pkey; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY mesh_copy
    ADD CONSTRAINT mesh_copy_pkey PRIMARY KEY (ui);


--
-- Name: mesh_path_pkey; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY mesh_path
    ADD CONSTRAINT mesh_path_pkey PRIMARY KEY (unique_id);


--
-- Name: mesh_pkey; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY mesh
    ADD CONSTRAINT mesh_pkey PRIMARY KEY (ui);


--
-- Name: mirna_bio_asy_feature_grp_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY mirna_bio_assay_feature_group
    ADD CONSTRAINT mirna_bio_asy_feature_grp_pk PRIMARY KEY (bio_assay_feature_group_id);


--
-- Name: mirna_bm_org_pri_eid_key; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY mirna_bio_marker
    ADD CONSTRAINT mirna_bm_org_pri_eid_key UNIQUE (organism, primary_external_id);


--
-- Name: observationdim_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_observation
    ADD CONSTRAINT observationdim_pk PRIMARY KEY (bio_observation_id);


--
-- Name: pk_baa_id; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_analysis_attribute
    ADD CONSTRAINT pk_baa_id PRIMARY KEY (bio_analysis_attribute_id);


--
-- Name: pk_baal_id; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_analysis_attribute_lineage
    ADD CONSTRAINT pk_baal_id PRIMARY KEY (bio_analysis_att_lineage_id);


--
-- Name: pk_bio_assay_cohort; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_assay_cohort
    ADD CONSTRAINT pk_bio_assay_cohort PRIMARY KEY (bio_assay_cohort_id);


--
-- Name: project_info_file_name_key; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY project_info
    ADD CONSTRAINT project_info_file_name_key UNIQUE (file_name);


--
-- Name: project_info_id_key; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY project_info
    ADD CONSTRAINT project_info_id_key UNIQUE (id);


--
-- Name: project_info_name_key; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY project_info
    ADD CONSTRAINT project_info_name_key UNIQUE (name);


--
-- Name: project_info_pkey; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY project_info
    ADD CONSTRAINT project_info_pkey PRIMARY KEY (file_id);


--
-- Name: rbmorderdim_pk; Type: CONSTRAINT; Schema: biomart; Owner: biomart; Tablespace: indx
--

ALTER TABLE ONLY bio_assay
    ADD CONSTRAINT rbmorderdim_pk PRIMARY KEY (bio_assay_id);


SET search_path = deapp, pg_catalog;

--
-- Name: dataset_id; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_variant_dataset
    ADD CONSTRAINT dataset_id PRIMARY KEY (dataset_id);


--
-- Name: de_chromosomal_region_pkey; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_chromosomal_region
    ADD CONSTRAINT de_chromosomal_region_pkey PRIMARY KEY (region_id);


--
-- Name: de_gpl_info_pkey; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_gpl_info
    ADD CONSTRAINT de_gpl_info_pkey PRIMARY KEY (platform);


--
-- Name: de_metabolite_annotation_pk; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_metabolite_annotation
    ADD CONSTRAINT de_metabolite_annotation_pk PRIMARY KEY (id);


--
-- Name: de_metabolite_sub_pathway_pk; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_metabolite_sub_pathways
    ADD CONSTRAINT de_metabolite_sub_pathway_pk PRIMARY KEY (id);


--
-- Name: de_metabolite_super_pathway_pk; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_metabolite_super_pathways
    ADD CONSTRAINT de_metabolite_super_pathway_pk PRIMARY KEY (id);


--
-- Name: de_mrna_annotation_pkey; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_mrna_annotation
    ADD CONSTRAINT de_mrna_annotation_pkey PRIMARY KEY (de_mrna_annotation_id);


--
-- Name: de_pathway_gene_pkey; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_pathway_gene
    ADD CONSTRAINT de_pathway_gene_pkey PRIMARY KEY (id);


--
-- Name: de_pathway_pkey; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_pathway
    ADD CONSTRAINT de_pathway_pkey PRIMARY KEY (id);


--
-- Name: de_protein_annotation_pkey; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_protein_annotation
    ADD CONSTRAINT de_protein_annotation_pkey PRIMARY KEY (id);


--
-- Name: de_rbm_annotation_pkey; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_rbm_annotation
    ADD CONSTRAINT de_rbm_annotation_pkey PRIMARY KEY (id);


--
-- Name: de_snp_data_dataset_loc_pkey; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_snp_data_dataset_loc
    ADD CONSTRAINT de_snp_data_dataset_loc_pkey PRIMARY KEY (snp_data_dataset_loc_id);


--
-- Name: de_snp_info_id_pk; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_snp_info
    ADD CONSTRAINT de_snp_info_id_pk PRIMARY KEY (snp_info_id);


--
-- Name: de_subject_acgh_data_pkey; Type: CONSTRAINT; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY de_subject_acgh_data
    ADD CONSTRAINT de_subject_acgh_data_pkey PRIMARY KEY (assay_id, region_id);


--
-- Name: de_subject_rnaseq_data_pkey; Type: CONSTRAINT; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY de_subject_rnaseq_data
    ADD CONSTRAINT de_subject_rnaseq_data_pkey PRIMARY KEY (assay_id, region_id);


--
-- Name: de_variant_metadata_pk; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_variant_metadata
    ADD CONSTRAINT de_variant_metadata_pk PRIMARY KEY (de_variant_metadata_id);


--
-- Name: de_variant_population_data_id_idx; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_variant_population_data
    ADD CONSTRAINT de_variant_population_data_id_idx PRIMARY KEY (variant_population_data_id);


--
-- Name: de_variant_population_info_id_idx; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_variant_population_info
    ADD CONSTRAINT de_variant_population_info_id_idx PRIMARY KEY (variant_population_info_id);


--
-- Name: dextpn_parent_node_u; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_xtrial_parent_names
    ADD CONSTRAINT dextpn_parent_node_u UNIQUE (across_path);


--
-- Name: pk_de_rbm_data_annotation_join; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_rbm_data_annotation_join
    ADD CONSTRAINT pk_de_rbm_data_annotation_join PRIMARY KEY (data_id, annotation_id);


--
-- Name: pk_de_subject_rbm_data; Type: CONSTRAINT; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY de_subject_rbm_data
    ADD CONSTRAINT pk_de_subject_rbm_data PRIMARY KEY (id);


--
-- Name: sys_c0020600; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_snp_probe_sorted_def
    ADD CONSTRAINT sys_c0020600 PRIMARY KEY (snp_probe_sorted_def_id);


--
-- Name: sys_c0020601; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_snp_data_by_probe
    ADD CONSTRAINT sys_c0020601 PRIMARY KEY (snp_data_by_probe_id);


--
-- Name: sys_c0020602; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_snp_data_by_patient
    ADD CONSTRAINT sys_c0020602 PRIMARY KEY (snp_data_by_patient_id);


--
-- Name: sys_c0020604; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_xtrial_parent_names
    ADD CONSTRAINT sys_c0020604 PRIMARY KEY (parent_cd);


--
-- Name: sys_c0020605; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_xtrial_child_map
    ADD CONSTRAINT sys_c0020605 PRIMARY KEY (concept_cd);


--
-- Name: sys_c0020606; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_subject_snp_dataset
    ADD CONSTRAINT sys_c0020606 PRIMARY KEY (subject_snp_dataset_id);


--
-- Name: sys_c0020607; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_snp_subject_sorted_def
    ADD CONSTRAINT sys_c0020607 PRIMARY KEY (snp_subject_sorted_def_id);


--
-- Name: sys_c0020609; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_snp_probe
    ADD CONSTRAINT sys_c0020609 PRIMARY KEY (snp_probe_id);


--
-- Name: u_snp_info_name; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_snp_info
    ADD CONSTRAINT u_snp_info_name UNIQUE (name);


--
-- Name: u_snp_probe_name; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_snp_probe
    ADD CONSTRAINT u_snp_probe_name UNIQUE (probe_name);


--
-- Name: variant_subject_detail_id; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_variant_subject_detail
    ADD CONSTRAINT variant_subject_detail_id PRIMARY KEY (variant_subject_detail_id);


--
-- Name: variant_subject_summary_id; Type: CONSTRAINT; Schema: deapp; Owner: deapp; Tablespace: indx
--

ALTER TABLE ONLY de_variant_subject_summary
    ADD CONSTRAINT variant_subject_summary_id PRIMARY KEY (variant_subject_summary_id);


SET search_path = fmapp, pg_catalog;

--
-- Name: fm_data_uid_pk_1; Type: CONSTRAINT; Schema: fmapp; Owner: fmapp; Tablespace: indx
--

ALTER TABLE ONLY fm_data_uid
    ADD CONSTRAINT fm_data_uid_pk_1 PRIMARY KEY (fm_data_id);


--
-- Name: fm_data_uid_uk_1; Type: CONSTRAINT; Schema: fmapp; Owner: fmapp; Tablespace: indx
--

ALTER TABLE ONLY fm_data_uid
    ADD CONSTRAINT fm_data_uid_uk_1 UNIQUE (unique_id);


--
-- Name: fm_file_pkey; Type: CONSTRAINT; Schema: fmapp; Owner: fmapp; Tablespace: indx
--

ALTER TABLE ONLY fm_file
    ADD CONSTRAINT fm_file_pkey PRIMARY KEY (file_id);


--
-- Name: fm_folder_pkey; Type: CONSTRAINT; Schema: fmapp; Owner: fmapp; Tablespace: indx
--

ALTER TABLE ONLY fm_folder
    ADD CONSTRAINT fm_folder_pkey PRIMARY KEY (folder_id);


--
-- Name: pk_folder_assoc; Type: CONSTRAINT; Schema: fmapp; Owner: fmapp; Tablespace: indx
--

ALTER TABLE ONLY fm_folder_association
    ADD CONSTRAINT pk_folder_assoc PRIMARY KEY (folder_id, object_uid);


--
-- Name: pk_folder_file_assoc; Type: CONSTRAINT; Schema: fmapp; Owner: fmapp; Tablespace: indx
--

ALTER TABLE ONLY fm_folder_file_association
    ADD CONSTRAINT pk_folder_file_assoc PRIMARY KEY (folder_id, file_id);


SET search_path = galaxy, pg_catalog;

--
-- Name: status_of_export_job_pk; Type: CONSTRAINT; Schema: galaxy; Owner: galaxy; Tablespace: indx
--

ALTER TABLE ONLY status_of_export_job
    ADD CONSTRAINT status_of_export_job_pk PRIMARY KEY (id);


--
-- Name: users_details_for_export_g_pk; Type: CONSTRAINT; Schema: galaxy; Owner: galaxy; Tablespace: indx
--

ALTER TABLE ONLY users_details_for_export_gal
    ADD CONSTRAINT users_details_for_export_g_pk PRIMARY KEY (id);


SET search_path = i2b2demodata, pg_catalog;

--
-- Name: analysis_plugin_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY qt_analysis_plugin
    ADD CONSTRAINT analysis_plugin_pk PRIMARY KEY (plugin_id);


--
-- Name: analysis_plugin_result_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY qt_analysis_plugin_result_type
    ADD CONSTRAINT analysis_plugin_result_pk PRIMARY KEY (plugin_id, result_type_id);


--
-- Name: async_job_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY async_job
    ADD CONSTRAINT async_job_pkey PRIMARY KEY (id);


--
-- Name: code_lookup_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY code_lookup
    ADD CONSTRAINT code_lookup_pk PRIMARY KEY (table_cd, column_cd, code_cd);


--
-- Name: concept_dimension_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY concept_dimension
    ADD CONSTRAINT concept_dimension_pk PRIMARY KEY (concept_path);


--
-- Name: encounter_mapping_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY encounter_mapping
    ADD CONSTRAINT encounter_mapping_pk PRIMARY KEY (encounter_ide, encounter_ide_source);


--
-- Name: jms_messages_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY jms_messages
    ADD CONSTRAINT jms_messages_pkey PRIMARY KEY (messageid, destination);


--
-- Name: jms_roles_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY jms_roles
    ADD CONSTRAINT jms_roles_pkey PRIMARY KEY (userid, roleid);


--
-- Name: jms_subscriptions_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY jms_subscriptions
    ADD CONSTRAINT jms_subscriptions_pkey PRIMARY KEY (clientid, subname);


--
-- Name: jms_users_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY jms_users
    ADD CONSTRAINT jms_users_pkey PRIMARY KEY (userid);


--
-- Name: modifier_dimension_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY modifier_dimension
    ADD CONSTRAINT modifier_dimension_pk PRIMARY KEY (modifier_path);


--
-- Name: observation_fact_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY observation_fact
    ADD CONSTRAINT observation_fact_pkey PRIMARY KEY (patient_num, concept_cd, provider_id, modifier_cd);


--
-- Name: patient_dimension_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY patient_dimension
    ADD CONSTRAINT patient_dimension_pk PRIMARY KEY (patient_num);


--
-- Name: patient_mapping_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY patient_mapping
    ADD CONSTRAINT patient_mapping_pk PRIMARY KEY (patient_ide, patient_ide_source);


--
-- Name: pk_sourcemaster_sourcecd; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY source_master
    ADD CONSTRAINT pk_sourcemaster_sourcecd PRIMARY KEY (source_cd);


--
-- Name: pk_st_id; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY set_type
    ADD CONSTRAINT pk_st_id PRIMARY KEY (id);


--
-- Name: pk_up_upstatus_idsettypeid; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY set_upload_status
    ADD CONSTRAINT pk_up_upstatus_idsettypeid PRIMARY KEY (upload_id, set_type_id);


--
-- Name: pk_up_upstatus_uploadid; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY upload_status
    ADD CONSTRAINT pk_up_upstatus_uploadid PRIMARY KEY (upload_id);


--
-- Name: provider_dimension_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY provider_dimension
    ADD CONSTRAINT provider_dimension_pk PRIMARY KEY (provider_path, provider_id);


--
-- Name: qt_patient_enc_coll_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY qt_patient_enc_collection
    ADD CONSTRAINT qt_patient_enc_coll_pk PRIMARY KEY (patient_enc_coll_id);


--
-- Name: qt_patient_set_collection_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY qt_patient_set_collection
    ADD CONSTRAINT qt_patient_set_collection_pkey PRIMARY KEY (patient_set_coll_id);


--
-- Name: qt_pdo_query_master_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY qt_pdo_query_master
    ADD CONSTRAINT qt_pdo_query_master_pkey PRIMARY KEY (query_master_id);


--
-- Name: qt_query_instance_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY qt_query_instance
    ADD CONSTRAINT qt_query_instance_pkey PRIMARY KEY (query_instance_id);


--
-- Name: qt_query_master_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY qt_query_master
    ADD CONSTRAINT qt_query_master_pkey PRIMARY KEY (query_master_id);


--
-- Name: qt_query_result_instance_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY qt_query_result_instance
    ADD CONSTRAINT qt_query_result_instance_pkey PRIMARY KEY (result_instance_id);


--
-- Name: qt_query_result_type_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY qt_query_result_type
    ADD CONSTRAINT qt_query_result_type_pkey PRIMARY KEY (result_type_id);


--
-- Name: qt_query_status_type_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY qt_query_status_type
    ADD CONSTRAINT qt_query_status_type_pkey PRIMARY KEY (status_type_id);


--
-- Name: qt_xml_result_pkey; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY qt_xml_result
    ADD CONSTRAINT qt_xml_result_pkey PRIMARY KEY (xml_result_id);


--
-- Name: sample_dimension_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY sample_dimension
    ADD CONSTRAINT sample_dimension_pk PRIMARY KEY (sample_cd);


--
-- Name: timers_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY timers
    ADD CONSTRAINT timers_pk PRIMARY KEY (timerid, targetid);


--
-- Name: visit_dimension_pk; Type: CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

ALTER TABLE ONLY visit_dimension
    ADD CONSTRAINT visit_dimension_pk PRIMARY KEY (encounter_num, patient_num);


SET search_path = i2b2metadata, pg_catalog;

--
-- Name: ont_process_status_pkey; Type: CONSTRAINT; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: indx
--

ALTER TABLE ONLY ont_process_status
    ADD CONSTRAINT ont_process_status_pkey PRIMARY KEY (process_id);


--
-- Name: schemes_pk; Type: CONSTRAINT; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: indx
--

ALTER TABLE ONLY schemes
    ADD CONSTRAINT schemes_pk PRIMARY KEY (c_key);


--
-- Name: table_access_pk; Type: CONSTRAINT; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: indx
--

ALTER TABLE ONLY table_access
    ADD CONSTRAINT table_access_pk PRIMARY KEY (c_table_cd);


SET search_path = searchapp, pg_catalog;

--
-- Name: pk_auth_usr_group; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_auth_group
    ADD CONSTRAINT pk_auth_usr_group PRIMARY KEY (id);


--
-- Name: pk_search_principal; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_auth_principal
    ADD CONSTRAINT pk_search_principal PRIMARY KEY (id);


--
-- Name: plugin_module_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY plugin_module
    ADD CONSTRAINT plugin_module_pk PRIMARY KEY (module_seq);


--
-- Name: plugin_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY plugin
    ADD CONSTRAINT plugin_pk PRIMARY KEY (plugin_seq);


--
-- Name: rdt_search_user_fdbk_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_user_feedback
    ADD CONSTRAINT rdt_search_user_fdbk_pk PRIMARY KEY (search_user_feedback_id);


--
-- Name: sau_fed_id_key; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_auth_user
    ADD CONSTRAINT sau_fed_id_key UNIQUE (federated_id);


--
-- Name: saved_faceted_search_pkey; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY saved_faceted_search
    ADD CONSTRAINT saved_faceted_search_pkey PRIMARY KEY (saved_faceted_search_id);


--
-- Name: sch_sec_a_a_s_a_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_auth_sec_object_access
    ADD CONSTRAINT sch_sec_a_a_s_a_pk PRIMARY KEY (auth_sec_obj_access_id);


--
-- Name: search_cust_fil_item_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_custom_filter_item
    ADD CONSTRAINT search_cust_fil_item_pk PRIMARY KEY (search_custom_filter_item_id);


--
-- Name: search_custom_filter_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_custom_filter
    ADD CONSTRAINT search_custom_filter_pk PRIMARY KEY (search_custom_filter_id);


--
-- Name: search_gene_sig_descr_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_gene_signature
    ADD CONSTRAINT search_gene_sig_descr_pk PRIMARY KEY (search_gene_signature_id);


--
-- Name: search_gene_sig_file_sche_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_gene_sig_file_schema
    ADD CONSTRAINT search_gene_sig_file_sche_pk PRIMARY KEY (search_gene_sig_file_schema_id);


--
-- Name: search_gene_signature_ite_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_gene_signature_item
    ADD CONSTRAINT search_gene_signature_ite_pk PRIMARY KEY (id);


--
-- Name: search_keyword_uk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_keyword
    ADD CONSTRAINT search_keyword_uk UNIQUE (unique_id, data_category);


--
-- Name: search_kw_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_keyword
    ADD CONSTRAINT search_kw_pk PRIMARY KEY (search_keyword_id);


--
-- Name: search_kw_term_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_keyword_term
    ADD CONSTRAINT search_kw_term_pk PRIMARY KEY (search_keyword_term_id);


--
-- Name: search_sec_a_u_s_a_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_auth_user_sec_access
    ADD CONSTRAINT search_sec_a_u_s_a_pk PRIMARY KEY (search_auth_user_sec_access_id);


--
-- Name: search_sec_ac_level_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_sec_access_level
    ADD CONSTRAINT search_sec_ac_level_pk PRIMARY KEY (search_sec_access_level_id);


--
-- Name: search_sec_obj__path_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_secure_object_path
    ADD CONSTRAINT search_sec_obj__path_pk PRIMARY KEY (search_secure_obj_path_id);


--
-- Name: search_sec_obj_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_secure_object
    ADD CONSTRAINT search_sec_obj_pk PRIMARY KEY (search_secure_object_id);


--
-- Name: search_taxonomy_pk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_taxonomy
    ADD CONSTRAINT search_taxonomy_pk PRIMARY KEY (term_id);


--
-- Name: search_taxonomy_rels_pkey; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_taxonomy_rels
    ADD CONSTRAINT search_taxonomy_rels_pkey PRIMARY KEY (search_taxonomy_rels_id);


--
-- Name: search_user_settings_pkey; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_user_settings
    ADD CONSTRAINT search_user_settings_pkey PRIMARY KEY (id);


--
-- Name: search_user_settings_uk; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_user_settings
    ADD CONSTRAINT search_user_settings_uk UNIQUE (user_id, setting_name, setting_value);


--
-- Name: sys_c0011119; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_auth_user
    ADD CONSTRAINT sys_c0011119 PRIMARY KEY (id);


--
-- Name: sys_c0011120; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_role
    ADD CONSTRAINT sys_c0011120 PRIMARY KEY (id);


--
-- Name: u_child_id_parent_id; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY search_taxonomy_rels
    ADD CONSTRAINT u_child_id_parent_id UNIQUE (child_id, parent_id);


--
-- Name: u_saved_search__user_id_name; Type: CONSTRAINT; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

ALTER TABLE ONLY saved_faceted_search
    ADD CONSTRAINT u_saved_search__user_id_name UNIQUE (user_id, name);


SET search_path = tm_cz, pg_catalog;

--
-- Name: az_test_run_pk; Type: CONSTRAINT; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY az_test_run
    ADD CONSTRAINT az_test_run_pk PRIMARY KEY (test_run_id);


--
-- Name: az_test_step_act_result_pk; Type: CONSTRAINT; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY az_test_step_act_result
    ADD CONSTRAINT az_test_step_act_result_pk PRIMARY KEY (test_step_act_result_id);


--
-- Name: az_test_step_run_pk; Type: CONSTRAINT; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY az_test_step_run
    ADD CONSTRAINT az_test_step_run_pk PRIMARY KEY (test_step_run_id);


--
-- Name: cz_data_file_pk; Type: CONSTRAINT; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY cz_data_file
    ADD CONSTRAINT cz_data_file_pk PRIMARY KEY (data_file_id);


--
-- Name: cz_data_pk; Type: CONSTRAINT; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY cz_data
    ADD CONSTRAINT cz_data_pk PRIMARY KEY (data_id);


--
-- Name: cz_dw_version_pk; Type: CONSTRAINT; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY cz_dw_version
    ADD CONSTRAINT cz_dw_version_pk PRIMARY KEY (dw_version_id);


--
-- Name: cz_form_layout_pk; Type: CONSTRAINT; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY cz_form_layout
    ADD CONSTRAINT cz_form_layout_pk PRIMARY KEY (form_layout_id);


--
-- Name: cz_job_audit_pk; Type: CONSTRAINT; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY cz_job_audit
    ADD CONSTRAINT cz_job_audit_pk PRIMARY KEY (seq_id);


--
-- Name: cz_job_master_pk; Type: CONSTRAINT; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY cz_job_master
    ADD CONSTRAINT cz_job_master_pk PRIMARY KEY (job_id);


--
-- Name: cz_person_pk; Type: CONSTRAINT; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY cz_person
    ADD CONSTRAINT cz_person_pk PRIMARY KEY (person_id);


--
-- Name: cz_test_category_pk; Type: CONSTRAINT; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY cz_test_category
    ADD CONSTRAINT cz_test_category_pk PRIMARY KEY (test_category_id);


--
-- Name: cz_test_pk; Type: CONSTRAINT; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

ALTER TABLE ONLY cz_test
    ADD CONSTRAINT cz_test_pk PRIMARY KEY (test_id);


SET search_path = tm_dataloader, pg_catalog;

SET default_tablespace = '';

--
-- Name: i2b2_load_path_pkey; Type: CONSTRAINT; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

ALTER TABLE ONLY i2b2_load_path
    ADD CONSTRAINT i2b2_load_path_pkey PRIMARY KEY (path);


--
-- Name: i2b2_load_path_with_count_pkey; Type: CONSTRAINT; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

ALTER TABLE ONLY i2b2_load_path_with_count
    ADD CONSTRAINT i2b2_load_path_with_count_pkey PRIMARY KEY (c_fullname);


SET search_path = tm_lz, pg_catalog;

SET default_tablespace = indx;

--
-- Name: lt_chromosomal_region_pkey; Type: CONSTRAINT; Schema: tm_lz; Owner: tm_lz; Tablespace: indx
--

ALTER TABLE ONLY lt_chromosomal_region
    ADD CONSTRAINT lt_chromosomal_region_pkey PRIMARY KEY (region_id);


SET search_path = tm_wz, pg_catalog;

--
-- Name: tmp_assay_analysis_metrics_pk; Type: CONSTRAINT; Schema: tm_wz; Owner: tm_wz; Tablespace: indx
--

ALTER TABLE ONLY tmp_assay_analysis_metrics
    ADD CONSTRAINT tmp_assay_analysis_metrics_pk PRIMARY KEY (bio_assay_analysis_id);


SET search_path = biomart, pg_catalog;

--
-- Name: baad_fgn_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_fgn_idx ON bio_assay_analysis_data USING btree (feature_group_name);


--
-- Name: baad_idx1; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx1 ON bio_assay_analysis_data USING btree (bio_assay_feature_group_id, bio_experiment_id);


--
-- Name: baad_idx11; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx11 ON bio_assay_analysis_data USING btree (bio_experiment_id, bio_assay_analysis_id, bio_asy_analysis_data_id);


--
-- Name: baad_idx12; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx12 ON bio_assay_analysis_data USING btree (bio_experiment_id, bio_assay_analysis_id, bio_assay_feature_group_id);


--
-- Name: baad_idx14; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx14 ON bio_assay_analysis_data USING btree (bio_assay_feature_group_id, bio_asy_analysis_data_id);


--
-- Name: baad_idx4; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx4 ON bio_assay_analysis_data USING btree (bio_assay_platform_id);


--
-- Name: baad_idx6; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx6 ON bio_assay_analysis_data USING btree (bio_experiment_id, bio_assay_analysis_id);


--
-- Name: baad_idx7; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx7 ON bio_assay_analysis_data USING btree (bio_assay_analysis_id, bio_asy_analysis_data_id);


--
-- Name: baad_idx_tea_enalysis; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx_tea_enalysis ON bio_assay_analysis_data_tea USING btree (bio_assay_analysis_id, bio_asy_analysis_data_id);


--
-- Name: baad_idx_tea_exp_analysis; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx_tea_exp_analysis ON bio_assay_analysis_data_tea USING btree (bio_experiment_id, bio_assay_analysis_id);


--
-- Name: baad_idx_tea_exp_analysis1; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx_tea_exp_analysis1 ON bio_assay_analysis_data_tea USING btree (bio_experiment_id, bio_assay_analysis_id, bio_asy_analysis_data_id);


--
-- Name: baad_idx_tea_fg_experiment; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx_tea_fg_experiment ON bio_assay_analysis_data_tea USING btree (bio_assay_feature_group_id, bio_experiment_id);


--
-- Name: baad_idx_tea_probe_id; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx_tea_probe_id ON bio_assay_analysis_data_tea USING btree (bio_assay_feature_group_id, bio_asy_analysis_data_id);


--
-- Name: baad_idx_tea_probe_name; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx_tea_probe_name ON bio_assay_analysis_data_tea USING btree (feature_group_name, bio_asy_analysis_data_id);


--
-- Name: baad_idx_tea_rank; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX baad_idx_tea_rank ON bio_assay_analysis_data_tea USING btree (bio_assay_analysis_id, tea_rank);


--
-- Name: bacx_idx1; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bacx_idx1 ON bio_analysis_cohort_xref USING btree (bio_assay_analysis_id);


--
-- Name: bad_idx13; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bad_idx13 ON bio_assay_analysis_data USING btree (bio_assay_analysis_id, bio_assay_feature_group_id);


--
-- Name: bdc_index1; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bdc_index1 ON bio_data_correlation USING btree (asso_bio_data_id);


--
-- Name: bio_a__d_s_ds_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_a__d_s_ds_idx ON bio_asy_data_stats_all USING btree (bio_assay_dataset_id);


--
-- Name: bio_a__d_s_exp_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_a__d_s_exp_idx ON bio_asy_data_stats_all USING btree (bio_experiment_id);


--
-- Name: bio_a__d_s_f_g_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_a__d_s_f_g_idx ON bio_asy_data_stats_all USING btree (feature_group_name);


--
-- Name: bio_a_d_s_ds__s_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_a_d_s_ds__s_idx ON bio_assay_data_stats USING btree (bio_assay_dataset_id);


--
-- Name: bio_a_d_s_exp__s_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_a_d_s_exp__s_idx ON bio_assay_data_stats USING btree (bio_experiment_id);


--
-- Name: bio_a_d_s_f_g_s_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_a_d_s_f_g_s_idx ON bio_assay_data_stats USING btree (feature_group_name, bio_assay_data_stats_id);


--
-- Name: bio_a_d_s_fgi_s_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_a_d_s_fgi_s_idx ON bio_assay_data_stats USING btree (bio_assay_feature_group_id, bio_assay_data_stats_id);


--
-- Name: bio_a_o_an_idx2; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_a_o_an_idx2 ON bio_assay_data_annotation USING btree (bio_assay_feature_group_id, bio_marker_id);


--
-- Name: bio_a_o_fg_id_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_a_o_fg_id_idx ON bio_assay_data_annotation USING btree (bio_assay_feature_group_id);


--
-- Name: bio_assay_analysis_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_assay_analysis_pk ON bio_assay_analysis USING btree (bio_assay_analysis_id);


--
-- Name: bio_assay_data_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_assay_data_pk ON bio_assay_data USING btree (bio_assay_data_id);


--
-- Name: bio_assay_dataset_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_assay_dataset_pk ON bio_assay_dataset USING btree (bio_assay_dataset_id);


--
-- Name: bio_assay_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_assay_pk ON bio_assay USING btree (bio_assay_id);


--
-- Name: bio_asy_analysis_dataset_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_asy_analysis_dataset_pk ON bio_asy_analysis_dataset USING btree (bio_assay_dataset_id, bio_assay_analysis_id);


--
-- Name: bio_asy_analysis_pltfm_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_asy_analysis_pltfm_pk ON bio_asy_analysis_pltfm USING btree (bio_asy_analysis_pltfm_id);


--
-- Name: bio_asy_feature_grp_name_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_asy_feature_grp_name_idx ON bio_assay_feature_group USING btree (feature_group_name, bio_assay_feature_group_id);


--
-- Name: bio_cell_line_dict_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_cell_line_dict_pk ON bio_cell_line USING btree (bio_cell_line_id);


--
-- Name: bio_cell_line_name_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_cell_line_name_idx ON bio_cell_line USING btree (cell_line_name, bio_cell_line_id);


--
-- Name: bio_cgdcp_data_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_cgdcp_data_pk ON bio_cgdcp_data USING btree (bio_data_id);


--
-- Name: bio_clinc_trial_attr_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_clinc_trial_attr_pk ON bio_clinc_trial_attr USING btree (bio_clinc_trial_attr_id);


--
-- Name: bio_clinc_trial_pt_group_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_clinc_trial_pt_group_pk ON bio_clinc_trial_pt_group USING btree (bio_clinical_trial_p_group_id);


--
-- Name: bio_clinc_trial_time_pt_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_clinc_trial_time_pt_pk ON bio_clinc_trial_time_pt USING btree (bio_clinc_trial_tm_pt_id);


--
-- Name: bio_clinical_trial_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_clinical_trial_pk ON bio_clinical_trial USING btree (bio_experiment_id);


--
-- Name: bio_compound_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_compound_pk ON bio_compound USING btree (bio_compound_id);


--
-- Name: bio_concept_code_type_index; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_concept_code_type_index ON bio_concept_code USING btree (code_type_name);


--
-- Name: bio_content_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_content_pk ON bio_content USING btree (bio_file_content_id);


--
-- Name: bio_content_reference_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_content_reference_pk ON bio_content_reference USING btree (bio_content_reference_id);


--
-- Name: bio_content_repository_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_content_repository_pk ON bio_content_repository USING btree (bio_content_repo_id);


--
-- Name: bio_curated_data_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_curated_data_pk ON bio_curated_data USING btree (bio_data_id);


--
-- Name: bio_curation_dataset_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_curation_dataset_pk ON bio_curation_dataset USING btree (bio_curation_dataset_id);


--
-- Name: bio_d_e_c_did_ct_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_d_e_c_did_ct_idx ON bio_data_ext_code USING btree (bio_data_id, code_type);


--
-- Name: bio_d_fg_m_marker2_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_d_fg_m_marker2_pk ON bio_assay_data_annotation USING btree (bio_marker_id, bio_assay_feature_group_id);


--
-- Name: bio_d_o_m_marker2_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_d_o_m_marker2_pk ON bio_data_omic_marker USING btree (bio_marker_id, bio_data_id);


--
-- Name: bio_data_attribute_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_data_attribute_pk ON bio_data_attribute USING btree (bio_data_attribute_id);


--
-- Name: bio_data_correl_descr_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_data_correl_descr_pk ON bio_data_correl_descr USING btree (bio_data_correl_descr_id);


--
-- Name: bio_data_e_c_c_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_data_e_c_c_idx ON bio_data_ext_code USING btree (code);


--
-- Name: bio_data_e_c_t_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_data_e_c_t_idx ON bio_data_ext_code USING btree (code_type);


--
-- Name: bio_data_o_m_did_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_data_o_m_did_idx ON bio_data_omic_marker USING btree (bio_data_id);


--
-- Name: bio_dd_idx2; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_dd_idx2 ON bio_data_disease USING btree (bio_disease_id);


--
-- Name: bio_disease_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_disease_pk ON bio_disease USING btree (bio_disease_id);


--
-- Name: bio_dt_dis_did_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_dt_dis_did_idx ON bio_data_disease USING btree (bio_data_id);


--
-- Name: bio_exp_acen_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_exp_acen_idx ON bio_experiment USING btree (accession);


--
-- Name: bio_exp_type_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_exp_type_idx ON bio_experiment USING btree (bio_experiment_type);


--
-- Name: bio_experiment_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_experiment_pk ON bio_experiment USING btree (bio_experiment_id);


--
-- Name: bio_marker_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_marker_pk ON bio_marker USING btree (bio_marker_id);


--
-- Name: bio_mkr_ext_id; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_mkr_ext_id ON bio_marker USING btree (primary_external_id);


--
-- Name: bio_mkr_type_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_mkr_type_idx ON bio_marker USING btree (bio_marker_type);


--
-- Name: bio_patient_event_attr_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_patient_event_attr_pk ON bio_patient_event_attr USING btree (bio_patient_attribute_id);


--
-- Name: bio_sample_pk; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX bio_sample_pk ON bio_sample USING btree (bio_sample_id);


--
-- Name: bio_stats_exp_mk_exp_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_stats_exp_mk_exp_idx ON bio_stats_exp_marker USING btree (bio_experiment_id);


--
-- Name: bio_stats_exp_mk_mk_idx; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX bio_stats_exp_mk_mk_idx ON bio_stats_exp_marker USING btree (bio_marker_id);


--
-- Name: idx_baad_idx_tea_experiment_type; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX idx_baad_idx_tea_experiment_type ON bio_assay_analysis_data_tea USING btree (bio_experiment_type, bio_asy_analysis_data_id);


--
-- Name: idx_baad_idx_tea_probe_analysis; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE INDEX idx_baad_idx_tea_probe_analysis ON bio_assay_analysis_data_tea USING btree (bio_assay_feature_group_id, bio_assay_analysis_id);


--
-- Name: mesh_idx_mn; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX mesh_idx_mn ON mesh USING btree (mn);


--
-- Name: mesh_idx_ui; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX mesh_idx_ui ON mesh USING btree (ui);


--
-- Name: pk_baad; Type: INDEX; Schema: biomart; Owner: biomart; Tablespace: indx
--

CREATE UNIQUE INDEX pk_baad ON bio_assay_analysis_data USING btree (bio_asy_analysis_data_id);


SET search_path = biomart_user, pg_catalog;

SET default_tablespace = '';

--
-- Name: idx_god_organism; Type: INDEX; Schema: biomart_user; Owner: biomart_user; Tablespace: 
--

CREATE INDEX idx_god_organism ON gene_ontology_data USING btree (organism);


--
-- Name: idx_god_symbol; Type: INDEX; Schema: biomart_user; Owner: biomart_user; Tablespace: 
--

CREATE INDEX idx_god_symbol ON gene_ontology_data USING btree (gene_symbol);


SET search_path = deapp, pg_catalog;

SET default_tablespace = indx;

--
-- Name: de_microarray_data_idx1; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX de_microarray_data_idx1 ON de_subject_microarray_data USING btree (trial_name, assay_id, probeset_id);


--
-- Name: de_microarray_data_idx2; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX de_microarray_data_idx2 ON de_subject_microarray_data USING btree (assay_id, probeset_id);


--
-- Name: de_microarray_data_idx4; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX de_microarray_data_idx4 ON de_subject_microarray_data USING btree (trial_name);


--
-- Name: de_microarray_data_idx5; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX de_microarray_data_idx5 ON de_subject_microarray_data USING btree (assay_id, patient_id, probeset_id);


--
-- Name: de_mrna_annotation_idx1; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX de_mrna_annotation_idx1 ON de_mrna_annotation USING btree (gpl_id, probe_id);


--
-- Name: de_mrna_annotation_idx2; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX de_mrna_annotation_idx2 ON de_mrna_annotation USING btree (gene_id, probeset_id);


--
-- Name: de_obs_enroll_days_idx2; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX de_obs_enroll_days_idx2 ON de_obs_enroll_days USING btree (study_id);


--
-- Name: de_snp_calls_by_gsm_patient_num_idx; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX de_snp_calls_by_gsm_patient_num_idx ON de_snp_calls_by_gsm USING btree (patient_num);


--
-- Name: de_snp_copy_number_num_idx; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX de_snp_copy_number_num_idx ON de_snp_copy_number USING btree (patient_num);


--
-- Name: de_subject_acgh_data_patient; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX de_subject_acgh_data_patient ON de_subject_acgh_data USING btree (patient_id);


--
-- Name: de_subject_acgh_data_region; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX de_subject_acgh_data_region ON de_subject_acgh_data USING btree (region_id);


--
-- Name: de_subject_microarray_data_idx2; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX de_subject_microarray_data_idx2 ON de_subject_microarray_data USING btree (assay_id);


--
-- Name: de_subject_microarray_data_idx3; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX de_subject_microarray_data_idx3 ON de_subject_microarray_data USING btree (probeset_id);


--
-- Name: de_subject_microarray_data_idx4; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX de_subject_microarray_data_idx4 ON de_subject_microarray_data USING btree (assay_id, probeset_id);


--
-- Name: de_subject_rnaseq_data_patient; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX de_subject_rnaseq_data_patient ON de_subject_rnaseq_data USING btree (patient_id);


--
-- Name: de_subject_rnaseq_data_region; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX de_subject_rnaseq_data_region ON de_subject_rnaseq_data USING btree (region_id);


--
-- Name: de_subject_smpl_mpng_idx1; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX de_subject_smpl_mpng_idx1 ON de_subject_sample_mapping USING btree (timepoint, patient_id, trial_name);


--
-- Name: de_subject_smpl_mpng_idx2; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX de_subject_smpl_mpng_idx2 ON de_subject_sample_mapping USING btree (patient_id, timepoint_cd, platform_cd, assay_id, trial_name);


--
-- Name: de_variant_population_data_default_idx; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX de_variant_population_data_default_idx ON de_variant_population_data USING btree (dataset_id, chr, pos, info_name);


--
-- Name: de_variant_sub_detail_idx2; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX de_variant_sub_detail_idx2 ON de_variant_subject_detail USING btree (dataset_id, chr);


--
-- Name: de_variant_sub_dt_idx1; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX de_variant_sub_dt_idx1 ON de_variant_subject_detail USING btree (dataset_id, rs_id);


--
-- Name: idx_de_rna_data_1; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX idx_de_rna_data_1 ON de_subject_rna_data USING btree (trial_name, assay_id, probeset_id);


--
-- Name: idx_de_rna_data_2; Type: INDEX; Schema: deapp; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX idx_de_rna_data_2 ON de_subject_rna_data USING btree (assay_id, probeset_id);


--
-- Name: idx_de_sample_snp_data_sample; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX idx_de_sample_snp_data_sample ON de_sample_snp_data USING btree (sample_id);


--
-- Name: idx_de_sample_snp_data_snp; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX idx_de_sample_snp_data_snp ON de_sample_snp_data USING btree (snp_name);


--
-- Name: idx_de_subj_smpl_trial_ccode; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX idx_de_subj_smpl_trial_ccode ON de_subject_sample_mapping USING btree (trial_name, concept_code);


--
-- Name: variant_population_info_dataset_name; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE INDEX variant_population_info_dataset_name ON de_variant_population_info USING btree (dataset_id, info_name);


--
-- Name: variant_subject_detail_uk; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE UNIQUE INDEX variant_subject_detail_uk ON de_variant_subject_detail USING btree (dataset_id, chr, pos, rs_id);


--
-- Name: variant_subject_idx_uk; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE UNIQUE INDEX variant_subject_idx_uk ON de_variant_subject_idx USING btree (dataset_id, subject_id, "position");


--
-- Name: variant_subject_summary_uk; Type: INDEX; Schema: deapp; Owner: deapp; Tablespace: indx
--

CREATE UNIQUE INDEX variant_subject_summary_uk ON de_variant_subject_summary USING btree (dataset_id, chr, pos, rs_id, subject_id);


SET search_path = i2b2demodata, pg_catalog;

--
-- Name: cd_uploadid_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX cd_uploadid_idx ON concept_dimension USING btree (upload_id);


--
-- Name: cl_idx_name_char; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX cl_idx_name_char ON code_lookup USING btree (name_char);


--
-- Name: cl_idx_uploadid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX cl_idx_uploadid ON code_lookup USING btree (upload_id);


--
-- Name: em_encnum_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX em_encnum_idx ON encounter_mapping USING btree (encounter_num);


--
-- Name: em_idx_encpath; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX em_idx_encpath ON encounter_mapping USING btree (encounter_ide, encounter_ide_source, patient_ide, patient_ide_source, encounter_num);


--
-- Name: em_uploadid_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX em_uploadid_idx ON encounter_mapping USING btree (upload_id);


--
-- Name: fact_modifier_patient; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX fact_modifier_patient ON observation_fact USING btree (modifier_cd, patient_num);


SET default_tablespace = '';

--
-- Name: idx_concept_path; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: 
--

CREATE INDEX idx_concept_path ON concept_counts USING btree (concept_path);


SET default_tablespace = indx;

--
-- Name: idx_count_concept_path; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX idx_count_concept_path ON concept_counts USING btree (concept_path);


--
-- Name: idx_fact_concept; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX idx_fact_concept ON observation_fact USING btree (concept_cd);


--
-- Name: idx_fact_cpe; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX idx_fact_cpe ON observation_fact USING btree (concept_cd, patient_num, encounter_num);


--
-- Name: idx_fact_patient_num; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX idx_fact_patient_num ON observation_fact USING btree (patient_num);


--
-- Name: idx_pd_sourcesystemcd_pnum; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX idx_pd_sourcesystemcd_pnum ON patient_dimension USING btree (sourcesystem_cd, patient_num);


--
-- Name: jms_messages_destination; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX jms_messages_destination ON jms_messages USING btree (destination);


--
-- Name: jms_messages_txop_txid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX jms_messages_txop_txid ON jms_messages USING btree (txop, txid);


--
-- Name: md_idx_uploadid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX md_idx_uploadid ON modifier_dimension USING btree (upload_id);


--
-- Name: patd_uploadid_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX patd_uploadid_idx ON patient_dimension USING btree (upload_id);


--
-- Name: pd_idx_allpatientdim; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX pd_idx_allpatientdim ON patient_dimension USING btree (patient_num, vital_status_cd, birth_date, death_date, sex_cd, age_in_years_num, language_cd, race_cd, marital_status_cd, religion_cd, zip_cd, income_cd);


--
-- Name: pd_idx_dates; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX pd_idx_dates ON patient_dimension USING btree (patient_num, vital_status_cd, birth_date, death_date);


--
-- Name: pd_idx_name_char; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX pd_idx_name_char ON provider_dimension USING btree (provider_id, name_char);


--
-- Name: pd_idx_statecityzip; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX pd_idx_statecityzip ON patient_dimension USING btree (statecityzip_path, patient_num);


--
-- Name: pk_archive_obsfact; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX pk_archive_obsfact ON archive_observation_fact USING btree (encounter_num, patient_num, concept_cd, provider_id, start_date, modifier_cd, archive_upload_id);


--
-- Name: pm_encpnum_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX pm_encpnum_idx ON patient_mapping USING btree (patient_ide, patient_ide_source, patient_num);


--
-- Name: pm_patnum_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX pm_patnum_idx ON patient_mapping USING btree (patient_num);


--
-- Name: pm_uploadid_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX pm_uploadid_idx ON patient_mapping USING btree (upload_id);


--
-- Name: prod_uploadid_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX prod_uploadid_idx ON provider_dimension USING btree (upload_id);


--
-- Name: qt_apnamevergrp_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX qt_apnamevergrp_idx ON qt_analysis_plugin USING btree (plugin_name, version_cd, group_id);


--
-- Name: qt_idx_pqm_ugid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX qt_idx_pqm_ugid ON qt_pdo_query_master USING btree (user_id, group_id);


--
-- Name: qt_idx_qi_mstartid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX qt_idx_qi_mstartid ON qt_query_instance USING btree (query_master_id, start_date);


--
-- Name: qt_idx_qi_ugid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX qt_idx_qi_ugid ON qt_query_instance USING btree (user_id, group_id);


--
-- Name: qt_idx_qm_ugid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX qt_idx_qm_ugid ON qt_query_master USING btree (user_id, group_id, master_type_cd);


--
-- Name: qt_idx_qpsc_riid; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX qt_idx_qpsc_riid ON qt_patient_set_collection USING btree (result_instance_id);


--
-- Name: vd_uploadid_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX vd_uploadid_idx ON visit_dimension USING btree (upload_id);


--
-- Name: visitdim_en_pn_lp_io_sd_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX visitdim_en_pn_lp_io_sd_idx ON visit_dimension USING btree (encounter_num, patient_num, location_path, inout_cd, start_date, end_date, length_of_stay);


--
-- Name: visitdim_std_edd_idx; Type: INDEX; Schema: i2b2demodata; Owner: i2b2demodata; Tablespace: indx
--

CREATE INDEX visitdim_std_edd_idx ON visit_dimension USING btree (start_date, end_date);


SET search_path = i2b2metadata, pg_catalog;

--
-- Name: i2b2_c_comment_char_length_idx; Type: INDEX; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: indx
--

CREATE INDEX i2b2_c_comment_char_length_idx ON i2b2 USING btree (c_comment, char_length((c_fullname)::text));


--
-- Name: INDEX i2b2_c_comment_char_length_idx; Type: COMMENT; Schema: i2b2metadata; Owner: i2b2metadata
--

COMMENT ON INDEX i2b2_c_comment_char_length_idx IS 'For i2b2metadata.i2b2_trial_nodes view';


--
-- Name: i2b2meta_idx_record_id; Type: INDEX; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: indx
--

CREATE INDEX i2b2meta_idx_record_id ON i2b2 USING btree (record_id);


--
-- Name: idx_i2b2_basecode; Type: INDEX; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: indx
--

CREATE INDEX idx_i2b2_basecode ON i2b2 USING btree (c_basecode, record_id, c_visualattributes);


--
-- Name: idx_i2b2_fullname_basecode; Type: INDEX; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: indx
--

CREATE INDEX idx_i2b2_fullname_basecode ON i2b2 USING btree (c_fullname, c_basecode);


--
-- Name: idx_i2b2_secure_fullname; Type: INDEX; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: indx
--

CREATE INDEX idx_i2b2_secure_fullname ON i2b2_secure USING btree (c_fullname);


--
-- Name: ix_i2b2_source_system_cd; Type: INDEX; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: indx
--

CREATE INDEX ix_i2b2_source_system_cd ON i2b2 USING btree (sourcesystem_cd);


--
-- Name: meta_applied_path_custom_idx; Type: INDEX; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: indx
--

CREATE INDEX meta_applied_path_custom_idx ON custom_meta USING btree (m_applied_path);


--
-- Name: meta_fullname_custom_idx; Type: INDEX; Schema: i2b2metadata; Owner: i2b2metadata; Tablespace: indx
--

CREATE INDEX meta_fullname_custom_idx ON custom_meta USING btree (c_fullname);


SET search_path = searchapp, pg_catalog;

--
-- Name: search_keyword_index1; Type: INDEX; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

CREATE INDEX search_keyword_index1 ON search_keyword USING btree (keyword);


--
-- Name: search_keyword_index2; Type: INDEX; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

CREATE INDEX search_keyword_index2 ON search_keyword USING btree (bio_data_id);


--
-- Name: search_keyword_index3; Type: INDEX; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

CREATE INDEX search_keyword_index3 ON search_keyword USING btree (owner_auth_user_id);


--
-- Name: search_kw_term_skid_idx; Type: INDEX; Schema: searchapp; Owner: searchapp; Tablespace: indx
--

CREATE INDEX search_kw_term_skid_idx ON search_keyword_term USING btree (search_keyword_id);


SET search_path = tm_cz, pg_catalog;

--
-- Name: node_curation_pk; Type: INDEX; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

CREATE UNIQUE INDEX node_curation_pk ON node_curation USING btree (node_type, node_name, study_id);


--
-- Name: probeset_deapp_i1; Type: INDEX; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX probeset_deapp_i1 ON probeset_deapp USING btree (probeset_id);


--
-- Name: probeset_deapp_i2; Type: INDEX; Schema: tm_cz; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX probeset_deapp_i2 ON probeset_deapp USING btree (probeset, platform);


SET search_path = tm_dataloader, pg_catalog;

SET default_tablespace = '';

--
-- Name: idx_wrk_cln_id_value; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX idx_wrk_cln_id_value ON wrk_clinical_data USING btree (usubjid, data_value, data_type);


--
-- Name: idx_wt_trialnodes; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX idx_wt_trialnodes ON wt_trial_nodes USING btree (leaf_node, node_name);


--
-- Name: idx_wtn_load_clinical; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX idx_wtn_load_clinical ON wt_trial_nodes USING btree (leaf_node, category_cd, data_label);


--
-- Name: tm_wz_idx_child; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_child ON i2b2_load_tree_full USING btree (idchild, idroot);


--
-- Name: tm_wz_idx_path; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_path ON i2b2_load_path USING btree (path varchar_pattern_ops, record_id);


--
-- Name: tm_wz_idx_path100; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_path100 ON i2b2_load_path USING btree (path100 varchar_pattern_ops, record_id);


--
-- Name: tm_wz_idx_path150; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_path150 ON i2b2_load_path USING btree (path150 varchar_pattern_ops, record_id);


--
-- Name: tm_wz_idx_path200; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_path200 ON i2b2_load_path USING btree (path200 varchar_pattern_ops, record_id);


--
-- Name: tm_wz_idx_path50; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_path50 ON i2b2_load_path USING btree (path50 varchar_pattern_ops, record_id);


--
-- Name: tm_wz_idx_path_count; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_path_count ON i2b2_load_path_with_count USING btree (c_fullname);


--
-- Name: tm_wz_idx_path_len; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_path_len ON i2b2_load_path USING btree (path_len, path varchar_pattern_ops, record_id);


--
-- Name: tm_wz_idx_path_len100; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_path_len100 ON i2b2_load_path USING btree (path_len, path100 varchar_pattern_ops, record_id);


--
-- Name: tm_wz_idx_path_len150; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_path_len150 ON i2b2_load_path USING btree (path_len, path150 varchar_pattern_ops, record_id);


--
-- Name: tm_wz_idx_path_len200; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_path_len200 ON i2b2_load_path USING btree (path_len, path200 varchar_pattern_ops, record_id);


--
-- Name: tm_wz_idx_path_len50; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_path_len50 ON i2b2_load_path USING btree (path_len, path50 varchar_pattern_ops, record_id);


--
-- Name: tm_wz_idx_root; Type: INDEX; Schema: tm_dataloader; Owner: weymouth; Tablespace: 
--

CREATE INDEX tm_wz_idx_root ON i2b2_load_tree_full USING btree (idroot, idchild);


SET search_path = tm_lz, pg_catalog;

SET default_tablespace = indx;

--
-- Name: lz_src_mrna_subj_samp_idx1; Type: INDEX; Schema: tm_lz; Owner: tm_lz; Tablespace: indx
--

CREATE INDEX lz_src_mrna_subj_samp_idx1 ON lz_src_mrna_subj_samp_map USING btree (trial_name, source_cd);


SET search_path = tm_wz, pg_catalog;

SET default_tablespace = '';

--
-- Name: wt_subject_mrna_calcs_i1; Type: INDEX; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE INDEX wt_subject_mrna_calcs_i1 ON wt_subject_microarray_calcs USING btree (trial_name, probeset_id);


--
-- Name: wt_subject_mrna_logs_i1; Type: INDEX; Schema: tm_wz; Owner: tm_wz; Tablespace: 
--

CREATE INDEX wt_subject_mrna_logs_i1 ON wt_subject_microarray_logs USING btree (trial_name, probeset_id);


SET default_tablespace = indx;

--
-- Name: wt_subject_rbm_calcs_i1; Type: INDEX; Schema: tm_wz; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX wt_subject_rbm_calcs_i1 ON wt_subject_rbm_calcs USING btree (trial_name, probeset_id);


--
-- Name: wt_subject_rna_calcs_i1; Type: INDEX; Schema: tm_wz; Owner: tm_cz; Tablespace: indx
--

CREATE INDEX wt_subject_rna_calcs_i1 ON wt_subject_rna_calcs USING btree (trial_name, probeset_id);


SET search_path = amapp, pg_catalog;

--
-- Name: trg_am_tag_item_id; Type: TRIGGER; Schema: amapp; Owner: amapp
--

CREATE TRIGGER trg_am_tag_item_id BEFORE INSERT ON am_tag_item FOR EACH ROW EXECUTE PROCEDURE tf_trg_am_tag_item_id();


--
-- Name: trg_am_tag_temp_assoc_id; Type: TRIGGER; Schema: amapp; Owner: amapp
--

CREATE TRIGGER trg_am_tag_temp_assoc_id BEFORE INSERT ON am_tag_template_association FOR EACH ROW EXECUTE PROCEDURE tf_trg_am_tag_temp_assoc_id();


--
-- Name: trg_am_tag_template_id; Type: TRIGGER; Schema: amapp; Owner: amapp
--

CREATE TRIGGER trg_am_tag_template_id BEFORE INSERT ON am_tag_template FOR EACH ROW EXECUTE PROCEDURE tf_trg_am_tag_template_id();


--
-- Name: trg_am_tag_value_id; Type: TRIGGER; Schema: amapp; Owner: amapp
--

CREATE TRIGGER trg_am_tag_value_id BEFORE INSERT ON am_tag_value FOR EACH ROW EXECUTE PROCEDURE tf_trg_am_tag_value_id();


--
-- Name: trg_am_tag_value_uid; Type: TRIGGER; Schema: amapp; Owner: amapp
--

CREATE TRIGGER trg_am_tag_value_uid BEFORE INSERT ON am_tag_value FOR EACH ROW EXECUTE PROCEDURE tf_trg_am_tag_value_uid();


SET search_path = biomart, pg_catalog;

--
-- Name: trg_bio_ad_hoc_prop_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_ad_hoc_prop_id BEFORE INSERT ON bio_ad_hoc_property FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_ad_hoc_prop_id();


--
-- Name: trg_bio_analysis_al_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_analysis_al_id BEFORE INSERT ON bio_analysis_attribute_lineage FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_analysis_al_id();


--
-- Name: trg_bio_analysis_attribute_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_analysis_attribute_id BEFORE INSERT ON bio_analysis_attribute FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_analysis_attribute_id();


--
-- Name: trg_bio_assay_analysis_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_analysis_id BEFORE INSERT ON bio_assay_analysis FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_analysis_id();


--
-- Name: trg_bio_assay_analysis_uid; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_analysis_uid BEFORE INSERT ON bio_assay_analysis FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_analysis_uid();


--
-- Name: trg_bio_assay_cohort_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_cohort_id BEFORE INSERT ON bio_assay_cohort FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_cohort_id();


--
-- Name: trg_bio_assay_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_data_id BEFORE INSERT ON bio_assay_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_data_id();


--
-- Name: trg_bio_assay_dataset_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_dataset_id BEFORE INSERT ON bio_assay_dataset FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_dataset_id();


--
-- Name: trg_bio_assay_f_g_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_f_g_id BEFORE INSERT ON bio_assay_feature_group FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_f_g_id();


--
-- Name: trg_bio_assay_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_id BEFORE INSERT ON bio_assay FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_id();


--
-- Name: trg_bio_assay_platform_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_assay_platform_id BEFORE INSERT ON bio_assay_platform FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_assay_platform_id();


--
-- Name: trg_bio_asy_adi_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_asy_adi_id BEFORE INSERT ON bio_asy_analysis_data_idx FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_asy_adi_id();


--
-- Name: trg_bio_asy_analysis_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_asy_analysis_data_id BEFORE INSERT ON bio_assay_analysis_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_asy_analysis_data_id();


--
-- Name: trg_bio_asy_analysis_pltfm_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_asy_analysis_pltfm_id BEFORE INSERT ON bio_asy_analysis_pltfm FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_asy_analysis_pltfm_id();


--
-- Name: trg_bio_asy_dt_stats_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_asy_dt_stats_id BEFORE INSERT ON bio_asy_data_stats_all FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_asy_dt_stats_id();


--
-- Name: trg_bio_cell_line_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_cell_line_id BEFORE INSERT ON bio_cell_line FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_cell_line_id();


--
-- Name: trg_bio_cl_trl_time_pt_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_cl_trl_time_pt_id BEFORE INSERT ON bio_clinc_trial_time_pt FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_cl_trl_time_pt_id();


--
-- Name: trg_bio_clin_trl_pt_grp_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_clin_trl_pt_grp_id BEFORE INSERT ON bio_clinc_trial_pt_group FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_clin_trl_pt_grp_id();


--
-- Name: trg_bio_cln_trl_attr_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_cln_trl_attr_id BEFORE INSERT ON bio_clinc_trial_attr FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_cln_trl_attr_id();


--
-- Name: trg_bio_compound_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_compound_id BEFORE INSERT ON bio_compound FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_compound_id();


--
-- Name: trg_bio_concept_code_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_concept_code_id BEFORE INSERT ON bio_concept_code FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_concept_code_id();


--
-- Name: trg_bio_content_ref_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_content_ref_id BEFORE INSERT ON bio_content_reference FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_content_ref_id();


--
-- Name: trg_bio_content_repo_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_content_repo_id BEFORE INSERT ON bio_content_repository FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_content_repo_id();


--
-- Name: trg_bio_curation_dataset_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_curation_dataset_id BEFORE INSERT ON bio_curation_dataset FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_curation_dataset_id();


--
-- Name: trg_bio_data_attr_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_data_attr_id BEFORE INSERT ON bio_data_attribute FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_data_attr_id();


--
-- Name: trg_bio_data_correl_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_data_correl_id BEFORE INSERT ON bio_data_correlation FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_data_correl_id();


--
-- Name: trg_bio_data_ext_code_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_data_ext_code_id BEFORE INSERT ON bio_data_ext_code FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_data_ext_code_id();


--
-- Name: trg_bio_disease_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_disease_id BEFORE INSERT ON bio_disease FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_disease_id();


--
-- Name: trg_bio_experiment_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_experiment_id BEFORE INSERT ON bio_experiment FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_experiment_id();


--
-- Name: trg_bio_experiment_uid; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_experiment_uid BEFORE INSERT ON bio_experiment FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_experiment_uid();


--
-- Name: trg_bio_file_content_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_file_content_id BEFORE INSERT ON bio_content FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_file_content_id();


--
-- Name: trg_bio_lit_alt_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_alt_data_id BEFORE INSERT ON bio_lit_alt_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_alt_data_id();


--
-- Name: trg_bio_lit_amd_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_amd_data_id BEFORE INSERT ON bio_lit_amd_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_amd_data_id();


--
-- Name: trg_bio_lit_inh_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_inh_data_id BEFORE INSERT ON bio_lit_inh_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_inh_data_id();


--
-- Name: trg_bio_lit_int_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_int_data_id BEFORE INSERT ON bio_lit_int_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_int_data_id();


--
-- Name: trg_bio_lit_model_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_model_data_id BEFORE INSERT ON bio_lit_model_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_model_data_id();


--
-- Name: trg_bio_lit_pe_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_pe_data_id BEFORE INSERT ON bio_lit_pe_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_pe_data_id();


--
-- Name: trg_bio_lit_ref_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_ref_data_id BEFORE INSERT ON bio_lit_ref_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_ref_data_id();


--
-- Name: trg_bio_lit_sum_data_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_lit_sum_data_id BEFORE INSERT ON bio_lit_sum_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_lit_sum_data_id();


--
-- Name: trg_bio_marker_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_marker_id BEFORE INSERT ON bio_marker FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_marker_id();


--
-- Name: trg_bio_mkr_correl_descr_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_mkr_correl_descr_id BEFORE INSERT ON bio_data_correl_descr FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_mkr_correl_descr_id();


--
-- Name: trg_bio_observation_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_observation_id BEFORE INSERT ON bio_observation FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_observation_id();


--
-- Name: trg_bio_patient_event_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_patient_event_id BEFORE INSERT ON bio_patient_event FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_patient_event_id();


--
-- Name: trg_bio_patient_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_patient_id BEFORE INSERT ON bio_patient FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_patient_id();


--
-- Name: trg_bio_pt_evt_attr_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_pt_evt_attr_id BEFORE INSERT ON bio_patient_event_attr FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_pt_evt_attr_id();


--
-- Name: trg_bio_sample_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_sample_id BEFORE INSERT ON bio_sample FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_sample_id();


--
-- Name: trg_bio_subject_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_subject_id BEFORE INSERT ON bio_subject FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_subject_id();


--
-- Name: trg_bio_taxon_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_bio_taxon_id BEFORE INSERT ON bio_taxonomy FOR EACH ROW EXECUTE PROCEDURE tf_trg_bio_taxon_id();


--
-- Name: trg_ctd2_clin_inhib_effect; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_ctd2_clin_inhib_effect BEFORE INSERT ON ctd2_clin_inhib_effect FOR EACH ROW EXECUTE PROCEDURE tf_trg_ctd2_clin_inhib_effect();


--
-- Name: trg_ctd2_disease; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_ctd2_disease BEFORE INSERT ON ctd2_disease FOR EACH ROW EXECUTE PROCEDURE tf_trg_ctd2_disease();


--
-- Name: trg_ctd2_inhib_details; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_ctd2_inhib_details BEFORE INSERT ON ctd2_inhib_details FOR EACH ROW EXECUTE PROCEDURE tf_trg_ctd2_inhib_details();


--
-- Name: trg_ctd2_study_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_ctd2_study_id BEFORE INSERT ON ctd2_study FOR EACH ROW EXECUTE PROCEDURE tf_trg_ctd2_study_id();


--
-- Name: trg_ctd2_trial_details; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trg_ctd2_trial_details BEFORE INSERT ON ctd2_trial_details FOR EACH ROW EXECUTE PROCEDURE tf_trg_ctd2_trial_details();


--
-- Name: trig_clinical_trial_design_id; Type: TRIGGER; Schema: biomart; Owner: biomart
--

CREATE TRIGGER trig_clinical_trial_design_id BEFORE INSERT ON ctd_full FOR EACH ROW EXECUTE PROCEDURE tf_trig_clinical_trial_design_id();


SET search_path = deapp, pg_catalog;

--
-- Name: de_parent_cd_trg; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER de_parent_cd_trg BEFORE INSERT ON de_xtrial_parent_names FOR EACH ROW WHEN ((COALESCE((new.parent_cd)::text, ''::text) = ''::text)) EXECUTE PROCEDURE tf_de_parent_cd_trg();


--
-- Name: rbm_id_trigger; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER rbm_id_trigger BEFORE INSERT ON de_rbm_annotation FOR EACH ROW EXECUTE PROCEDURE tf_rbm_id_trigger();


--
-- Name: trg_de_mrna_annotation_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_mrna_annotation_id BEFORE INSERT ON de_mrna_annotation FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_mrna_annotation_id();


--
-- Name: trg_de_pathway_gene_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_pathway_gene_id BEFORE INSERT ON de_pathway_gene FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_pathway_gene_id();


--
-- Name: trg_de_pathway_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_pathway_id BEFORE INSERT ON de_pathway FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_pathway_id();


--
-- Name: trg_de_snp_info_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_snp_info_id BEFORE INSERT ON de_snp_info FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_snp_info_id();


--
-- Name: trg_de_snp_probe_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_snp_probe_id BEFORE INSERT ON de_snp_probe FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_snp_probe_id();


--
-- Name: trg_de_snp_probe_sorted_def_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_snp_probe_sorted_def_id BEFORE INSERT ON de_snp_probe_sorted_def FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_snp_probe_sorted_def_id();


--
-- Name: trg_de_subj_rbm_data_id; Type: TRIGGER; Schema: deapp; Owner: tm_cz
--

CREATE TRIGGER trg_de_subj_rbm_data_id BEFORE INSERT ON de_subject_rbm_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_subj_rbm_data_id();


--
-- Name: trg_de_subject_snp_dataset_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_subject_snp_dataset_id BEFORE INSERT ON de_subject_snp_dataset FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_subject_snp_dataset_id();


--
-- Name: trg_de_subject_sorted_def_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_de_subject_sorted_def_id BEFORE INSERT ON de_snp_subject_sorted_def FOR EACH ROW EXECUTE PROCEDURE tf_trg_de_subject_sorted_def_id();


--
-- Name: trg_snp_data_by_patient_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_snp_data_by_patient_id BEFORE INSERT ON de_snp_data_by_patient FOR EACH ROW EXECUTE PROCEDURE tf_trg_snp_data_by_patient_id();


--
-- Name: trg_snp_data_by_pprobe_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_snp_data_by_pprobe_id BEFORE INSERT ON de_snp_data_by_probe FOR EACH ROW EXECUTE PROCEDURE tf_trg_snp_data_by_pprobe_id();


--
-- Name: trg_snp_data_dataset_loc_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_snp_data_dataset_loc_id BEFORE INSERT ON de_snp_data_dataset_loc FOR EACH ROW EXECUTE PROCEDURE tf_trg_snp_data_dataset_loc_id();


--
-- Name: trg_snp_subject_sorted_def_id; Type: TRIGGER; Schema: deapp; Owner: deapp
--

CREATE TRIGGER trg_snp_subject_sorted_def_id BEFORE INSERT ON de_snp_subject_sorted_def FOR EACH ROW EXECUTE PROCEDURE tf_trg_snp_subject_sorted_def_id();


SET search_path = fmapp, pg_catalog;

--
-- Name: trg_fm_file_id; Type: TRIGGER; Schema: fmapp; Owner: fmapp
--

CREATE TRIGGER trg_fm_file_id BEFORE INSERT ON fm_file FOR EACH ROW EXECUTE PROCEDURE tf_trg_fm_file_id();


--
-- Name: trg_fm_file_uid; Type: TRIGGER; Schema: fmapp; Owner: fmapp
--

CREATE TRIGGER trg_fm_file_uid BEFORE INSERT ON fm_file FOR EACH ROW EXECUTE PROCEDURE tf_trg_fm_file_uid();


--
-- Name: trg_fm_folder_id; Type: TRIGGER; Schema: fmapp; Owner: fmapp
--

CREATE TRIGGER trg_fm_folder_id BEFORE INSERT ON fm_folder FOR EACH ROW EXECUTE PROCEDURE tf_trg_fm_folder_id();


--
-- Name: trg_fm_folder_uid; Type: TRIGGER; Schema: fmapp; Owner: fmapp
--

CREATE TRIGGER trg_fm_folder_uid BEFORE INSERT ON fm_folder FOR EACH ROW EXECUTE PROCEDURE tf_trg_fm_folder_uid();


SET search_path = i2b2demodata, pg_catalog;

--
-- Name: trg_concept_dimension_cd; Type: TRIGGER; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE TRIGGER trg_concept_dimension_cd BEFORE INSERT ON concept_dimension FOR EACH ROW EXECUTE PROCEDURE tf_trg_concept_dimension_cd();


--
-- Name: trg_encounter_num; Type: TRIGGER; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE TRIGGER trg_encounter_num BEFORE INSERT ON observation_fact FOR EACH ROW EXECUTE PROCEDURE tf_trg_encounter_num();


--
-- Name: trg_patient_dimension; Type: TRIGGER; Schema: i2b2demodata; Owner: i2b2demodata
--

CREATE TRIGGER trg_patient_dimension BEFORE INSERT ON patient_dimension FOR EACH ROW EXECUTE PROCEDURE tf_trg_patient_dimension();


SET search_path = i2b2metadata, pg_catalog;

--
-- Name: trg_i2b2_id; Type: TRIGGER; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE TRIGGER trg_i2b2_id BEFORE INSERT ON i2b2 FOR EACH ROW EXECUTE PROCEDURE tf_trg_i2b2_id();


--
-- Name: trg_i2b2_tag_id; Type: TRIGGER; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE TRIGGER trg_i2b2_tag_id BEFORE INSERT ON i2b2_tags FOR EACH ROW EXECUTE PROCEDURE tf_trg_i2b2_tag_id();


--
-- Name: trg_i2b2_tags_tag_id; Type: TRIGGER; Schema: i2b2metadata; Owner: i2b2metadata
--

CREATE TRIGGER trg_i2b2_tags_tag_id BEFORE INSERT ON i2b2_tags FOR EACH ROW EXECUTE PROCEDURE tf_trg_i2b2_tags_tag_id();


SET search_path = searchapp, pg_catalog;

--
-- Name: trg_saved_faceted_search_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_saved_faceted_search_id BEFORE INSERT ON saved_faceted_search FOR EACH ROW EXECUTE PROCEDURE tf_trg_saved_faceted_search_id();


--
-- Name: trg_search_a_u_sec_access_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_search_a_u_sec_access_id BEFORE INSERT ON search_auth_user_sec_access FOR EACH ROW EXECUTE PROCEDURE tf_trg_search_a_u_sec_access_id();


--
-- Name: trg_search_au_obj_access_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_search_au_obj_access_id BEFORE INSERT ON search_auth_sec_object_access FOR EACH ROW EXECUTE PROCEDURE tf_trg_search_au_obj_access_id();


--
-- Name: trg_search_au_prcpl_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_search_au_prcpl_id BEFORE INSERT ON search_auth_principal FOR EACH ROW EXECUTE PROCEDURE tf_trg_search_au_prcpl_id();


--
-- Name: trg_search_cust_fil_item_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_search_cust_fil_item_id BEFORE INSERT ON search_custom_filter_item FOR EACH ROW EXECUTE PROCEDURE tf_trg_search_cust_fil_item_id();


--
-- Name: trg_search_custom_filter_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_search_custom_filter_id BEFORE INSERT ON search_custom_filter FOR EACH ROW EXECUTE PROCEDURE tf_trg_search_custom_filter_id();


--
-- Name: trg_search_keyword_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_search_keyword_id BEFORE INSERT ON search_keyword FOR EACH ROW EXECUTE PROCEDURE tf_trg_search_keyword_id();


--
-- Name: trg_search_keyword_term_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_search_keyword_term_id BEFORE INSERT ON search_keyword_term FOR EACH ROW EXECUTE PROCEDURE tf_trg_search_keyword_term_id();


--
-- Name: trg_search_sec_acc_level_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_search_sec_acc_level_id BEFORE INSERT ON search_sec_access_level FOR EACH ROW EXECUTE PROCEDURE tf_trg_search_sec_acc_level_id();


--
-- Name: trg_search_sec_obj_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_search_sec_obj_id BEFORE INSERT ON search_secure_object FOR EACH ROW EXECUTE PROCEDURE tf_trg_search_sec_obj_id();


--
-- Name: trg_search_sec_obj_path_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_search_sec_obj_path_id BEFORE INSERT ON search_secure_object_path FOR EACH ROW EXECUTE PROCEDURE tf_trg_search_sec_obj_path_id();


--
-- Name: trg_search_taxonomy_rels_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_search_taxonomy_rels_id BEFORE INSERT ON search_taxonomy_rels FOR EACH ROW EXECUTE PROCEDURE tf_trg_search_taxonomy_rels_id();


--
-- Name: trg_search_taxonomy_term_id; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_search_taxonomy_term_id BEFORE INSERT ON search_taxonomy FOR EACH ROW EXECUTE PROCEDURE tf_trg_search_taxonomy_term_id();


--
-- Name: trg_upd_saved_faceted_search; Type: TRIGGER; Schema: searchapp; Owner: searchapp
--

CREATE TRIGGER trg_upd_saved_faceted_search BEFORE UPDATE ON saved_faceted_search FOR EACH ROW EXECUTE PROCEDURE tf_trg_upd_saved_faceted_search();


SET search_path = tm_cz, pg_catalog;

--
-- Name: tf_trg_az_test_run_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER tf_trg_az_test_run_id BEFORE INSERT ON az_test_run FOR EACH ROW EXECUTE PROCEDURE tf_trg_az_test_run_id();


--
-- Name: trg_antigen_deapp; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_antigen_deapp BEFORE INSERT ON antigen_deapp FOR EACH ROW EXECUTE PROCEDURE tf_trg_antigen_deapp();


--
-- Name: trg_az_test_step_act_result; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_az_test_step_act_result BEFORE INSERT ON az_test_step_act_result FOR EACH ROW EXECUTE PROCEDURE tf_trg_az_test_step_act_result();


--
-- Name: trg_az_test_step_run_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_az_test_step_run_id BEFORE INSERT ON az_test_step_run FOR EACH ROW EXECUTE PROCEDURE tf_trg_az_test_step_run_id();


--
-- Name: trg_cz_data_file_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_data_file_id BEFORE INSERT ON cz_data_file FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_data_file_id();


--
-- Name: trg_cz_data_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_data_id BEFORE INSERT ON cz_data FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_data_id();


--
-- Name: trg_cz_dw_version_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_dw_version_id BEFORE INSERT ON cz_dw_version FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_dw_version_id();


--
-- Name: trg_cz_form_layout_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_form_layout_id BEFORE INSERT ON cz_form_layout FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_form_layout_id();


--
-- Name: trg_cz_job_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_job_id BEFORE INSERT ON cz_job_master FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_job_id();


--
-- Name: trg_cz_message_seq_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_message_seq_id BEFORE INSERT ON cz_job_message FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_message_seq_id();


--
-- Name: trg_cz_personid; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_personid BEFORE INSERT ON cz_person FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_personid();


--
-- Name: trg_cz_seq_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_seq_id BEFORE INSERT ON cz_job_audit FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_seq_id();


--
-- Name: trg_cz_test_category_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_test_category_id BEFORE INSERT ON cz_test_category FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_test_category_id();


--
-- Name: trg_cz_test_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_test_id BEFORE INSERT ON cz_test FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_test_id();


--
-- Name: trg_cz_test_result_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_test_result_id BEFORE INSERT ON cz_test_result FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_test_result_id();


--
-- Name: trg_cz_xtrial_ctrl_vocab_id; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_cz_xtrial_ctrl_vocab_id BEFORE INSERT ON cz_xtrial_ctrl_vocab FOR EACH ROW EXECUTE PROCEDURE tf_trg_cz_xtrial_ctrl_vocab_id();


--
-- Name: trg_probeset_deapp; Type: TRIGGER; Schema: tm_cz; Owner: tm_cz
--

CREATE TRIGGER trg_probeset_deapp BEFORE INSERT ON probeset_deapp FOR EACH ROW EXECUTE PROCEDURE tf_trg_probeset_deapp();


SET search_path = tm_lz, pg_catalog;

--
-- Name: trg_lz_src_analysis_meta_id; Type: TRIGGER; Schema: tm_lz; Owner: tm_lz
--

CREATE TRIGGER trg_lz_src_analysis_meta_id BEFORE INSERT ON lz_src_analysis_metadata FOR EACH ROW EXECUTE PROCEDURE tf_trg_lz_src_analysis_meta_id();


SET search_path = biomart, pg_catalog;

--
-- Name: bio_assay_analysis_data_n_fk1; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data
    ADD CONSTRAINT bio_assay_analysis_data_n_fk1 FOREIGN KEY (bio_assay_analysis_id) REFERENCES bio_assay_analysis(bio_assay_analysis_id);


--
-- Name: bio_assay_analysis_data_n_fk2; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data
    ADD CONSTRAINT bio_assay_analysis_data_n_fk2 FOREIGN KEY (bio_experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: bio_assay_analysis_data_n_fk3; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data
    ADD CONSTRAINT bio_assay_analysis_data_n_fk3 FOREIGN KEY (bio_assay_platform_id) REFERENCES bio_assay_platform(bio_assay_platform_id);


--
-- Name: bio_assay_analysis_data_t_fk1; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data_tea
    ADD CONSTRAINT bio_assay_analysis_data_t_fk1 FOREIGN KEY (bio_assay_analysis_id) REFERENCES bio_assay_analysis(bio_assay_analysis_id);


--
-- Name: bio_assay_analysis_data_t_fk2; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data_tea
    ADD CONSTRAINT bio_assay_analysis_data_t_fk2 FOREIGN KEY (bio_experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: bio_assay_analysis_data_t_fk3; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data_tea
    ADD CONSTRAINT bio_assay_analysis_data_t_fk3 FOREIGN KEY (bio_assay_platform_id) REFERENCES bio_assay_platform(bio_assay_platform_id);


--
-- Name: bio_assay_ans_pltfm_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis
    ADD CONSTRAINT bio_assay_ans_pltfm_fk FOREIGN KEY (bio_asy_analysis_pltfm_id) REFERENCES bio_asy_analysis_pltfm(bio_asy_analysis_pltfm_id);


--
-- Name: bio_assay_sample_bio_assay_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_sample
    ADD CONSTRAINT bio_assay_sample_bio_assay_fk FOREIGN KEY (bio_assay_id) REFERENCES bio_assay(bio_assay_id);


--
-- Name: bio_assay_sample_bio_sample_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_sample
    ADD CONSTRAINT bio_assay_sample_bio_sample_fk FOREIGN KEY (bio_sample_id) REFERENCES bio_sample(bio_sample_id);


--
-- Name: bio_asy_ad_fg_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data
    ADD CONSTRAINT bio_asy_ad_fg_fk FOREIGN KEY (bio_assay_feature_group_id) REFERENCES bio_assay_feature_group(bio_assay_feature_group_id);


--
-- Name: bio_asy_ad_tea_fg_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_analysis_data_tea
    ADD CONSTRAINT bio_asy_ad_tea_fg_fk FOREIGN KEY (bio_assay_feature_group_id) REFERENCES bio_assay_feature_group(bio_assay_feature_group_id);


--
-- Name: bio_asy_asy_pfm_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay
    ADD CONSTRAINT bio_asy_asy_pfm_fk FOREIGN KEY (bio_assay_platform_id) REFERENCES bio_assay_platform(bio_assay_platform_id);


--
-- Name: bio_asy_dt_ds_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data
    ADD CONSTRAINT bio_asy_dt_ds_fk FOREIGN KEY (bio_assay_dataset_id) REFERENCES bio_assay_dataset(bio_assay_dataset_id);


--
-- Name: bio_asy_dt_fg_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data_stats
    ADD CONSTRAINT bio_asy_dt_fg_fk FOREIGN KEY (bio_assay_feature_group_id) REFERENCES bio_assay_feature_group(bio_assay_feature_group_id);


--
-- Name: bio_asy_dt_stat_exp_s_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data_stats
    ADD CONSTRAINT bio_asy_dt_stat_exp_s_fk FOREIGN KEY (bio_experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: bio_asy_dt_stats_ds_s_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data_stats
    ADD CONSTRAINT bio_asy_dt_stats_ds_s_fk FOREIGN KEY (bio_assay_dataset_id) REFERENCES bio_assay_dataset(bio_assay_dataset_id);


--
-- Name: bio_asy_dt_stats_smp_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_asy_data_stats_all
    ADD CONSTRAINT bio_asy_dt_stats_smp_fk FOREIGN KEY (bio_sample_id) REFERENCES bio_sample(bio_sample_id);


--
-- Name: bio_asy_dt_stats_smp_s_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data_stats
    ADD CONSTRAINT bio_asy_dt_stats_smp_s_fk FOREIGN KEY (bio_sample_id) REFERENCES bio_sample(bio_sample_id);


--
-- Name: bio_asy_exp_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data
    ADD CONSTRAINT bio_asy_exp_fk FOREIGN KEY (bio_experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: bio_cli_trial_time_trl_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_clinc_trial_time_pt
    ADD CONSTRAINT bio_cli_trial_time_trl_fk FOREIGN KEY (bio_experiment_id) REFERENCES bio_clinical_trial(bio_experiment_id);


--
-- Name: bio_clinc_trl_pt_grp_exp_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_clinc_trial_pt_group
    ADD CONSTRAINT bio_clinc_trl_pt_grp_exp_fk FOREIGN KEY (bio_experiment_id) REFERENCES bio_clinical_trial(bio_experiment_id);


--
-- Name: bio_clinical_trial_bio_experim; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_clinical_trial
    ADD CONSTRAINT bio_clinical_trial_bio_experim FOREIGN KEY (bio_experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: bio_clinical_trial_property_bi; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_clinc_trial_attr
    ADD CONSTRAINT bio_clinical_trial_property_bi FOREIGN KEY (bio_experiment_id) REFERENCES bio_clinical_trial(bio_experiment_id);


--
-- Name: bio_content_ref_cont_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_content_reference
    ADD CONSTRAINT bio_content_ref_cont_fk FOREIGN KEY (bio_content_id) REFERENCES bio_content(bio_file_content_id);


--
-- Name: bio_data_anl_ds_anl_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_asy_analysis_dataset
    ADD CONSTRAINT bio_data_anl_ds_anl_fk FOREIGN KEY (bio_assay_analysis_id) REFERENCES bio_assay_analysis(bio_assay_analysis_id);


--
-- Name: bio_data_anl_ds_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_asy_analysis_dataset
    ADD CONSTRAINT bio_data_anl_ds_fk FOREIGN KEY (bio_assay_dataset_id) REFERENCES bio_assay_dataset(bio_assay_dataset_id);


--
-- Name: bio_dataset_experiment_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_dataset
    ADD CONSTRAINT bio_dataset_experiment_fk FOREIGN KEY (bio_experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: bio_df_cmp_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_data_compound
    ADD CONSTRAINT bio_df_cmp_fk FOREIGN KEY (bio_compound_id) REFERENCES bio_compound(bio_compound_id);


--
-- Name: bio_df_disease_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_data_disease
    ADD CONSTRAINT bio_df_disease_fk FOREIGN KEY (bio_disease_id) REFERENCES bio_disease(bio_disease_id);


--
-- Name: bio_exp_data_fact_samp_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay_data
    ADD CONSTRAINT bio_exp_data_fact_samp_fk FOREIGN KEY (bio_sample_id) REFERENCES bio_sample(bio_sample_id);


--
-- Name: bio_ext_analys_ext_anl_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_curated_data
    ADD CONSTRAINT bio_ext_analys_ext_anl_fk FOREIGN KEY (bio_curation_dataset_id) REFERENCES bio_curation_dataset(bio_curation_dataset_id);


--
-- Name: bio_ext_anl_pltfm_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_curation_dataset
    ADD CONSTRAINT bio_ext_anl_pltfm_fk FOREIGN KEY (bio_asy_analysis_pltfm_id) REFERENCES bio_asy_analysis_pltfm(bio_asy_analysis_pltfm_id);


--
-- Name: bio_lit_alt_ref_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_lit_alt_data
    ADD CONSTRAINT bio_lit_alt_ref_fk FOREIGN KEY (bio_lit_ref_data_id) REFERENCES bio_lit_ref_data(bio_lit_ref_data_id);


--
-- Name: bio_lit_amd_alt_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_lit_amd_data
    ADD CONSTRAINT bio_lit_amd_alt_fk FOREIGN KEY (bio_lit_alt_data_id) REFERENCES bio_lit_alt_data(bio_lit_alt_data_id);


--
-- Name: bio_lit_curation_dataset_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_data_literature
    ADD CONSTRAINT bio_lit_curation_dataset_fk FOREIGN KEY (bio_curation_dataset_id) REFERENCES bio_curation_dataset(bio_curation_dataset_id);


--
-- Name: bio_lit_inh_ref_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_lit_inh_data
    ADD CONSTRAINT bio_lit_inh_ref_fk FOREIGN KEY (bio_lit_ref_data_id) REFERENCES bio_lit_ref_data(bio_lit_ref_data_id);


--
-- Name: bio_lit_int_ref_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_lit_int_data
    ADD CONSTRAINT bio_lit_int_ref_fk FOREIGN KEY (bio_lit_ref_data_id) REFERENCES bio_lit_ref_data(bio_lit_ref_data_id);


--
-- Name: bio_lit_pe_ref_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_lit_pe_data
    ADD CONSTRAINT bio_lit_pe_ref_fk FOREIGN KEY (bio_lit_ref_data_id) REFERENCES bio_lit_ref_data(bio_lit_ref_data_id);


--
-- Name: bio_marker_link_bio_marker_rel; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_data_correlation
    ADD CONSTRAINT bio_marker_link_bio_marker_rel FOREIGN KEY (bio_data_correl_descr_id) REFERENCES bio_data_correl_descr(bio_data_correl_descr_id);


--
-- Name: bio_patient_bio_clinic_tri_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient
    ADD CONSTRAINT bio_patient_bio_clinic_tri_fk FOREIGN KEY (bio_clinical_trial_p_group_id) REFERENCES bio_clinc_trial_pt_group(bio_clinical_trial_p_group_id);


--
-- Name: bio_patient_bio_clinical_trial; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient
    ADD CONSTRAINT bio_patient_bio_clinical_trial FOREIGN KEY (bio_experiment_id) REFERENCES bio_clinical_trial(bio_experiment_id);


--
-- Name: bio_patient_bio_subject_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient
    ADD CONSTRAINT bio_patient_bio_subject_fk FOREIGN KEY (bio_patient_id) REFERENCES bio_subject(bio_subject_id);


--
-- Name: bio_pt_attr_trl_attr_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient_event_attr
    ADD CONSTRAINT bio_pt_attr_trl_attr_fk FOREIGN KEY (bio_clinic_trial_attr_id) REFERENCES bio_clinc_trial_attr(bio_clinc_trial_attr_id);


--
-- Name: bio_pt_event_attr_evt_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient_event_attr
    ADD CONSTRAINT bio_pt_event_attr_evt_fk FOREIGN KEY (bio_patient_event_id) REFERENCES bio_patient_event(bio_patient_event_id);


--
-- Name: bio_pt_event_bio_pt_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient_event
    ADD CONSTRAINT bio_pt_event_bio_pt_fk FOREIGN KEY (bio_patient_id) REFERENCES bio_patient(bio_patient_id);


--
-- Name: bio_pt_event_bio_trl_tp_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_patient_event
    ADD CONSTRAINT bio_pt_event_bio_trl_tp_fk FOREIGN KEY (bio_clinic_trial_timepoint_id) REFERENCES bio_clinc_trial_time_pt(bio_clinc_trial_tm_pt_id);


--
-- Name: bio_sample_bio_subject_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_sample
    ADD CONSTRAINT bio_sample_bio_subject_fk FOREIGN KEY (bio_subject_id) REFERENCES bio_subject(bio_subject_id);


--
-- Name: bio_sample_cl_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_sample
    ADD CONSTRAINT bio_sample_cl_fk FOREIGN KEY (bio_cell_line_id) REFERENCES bio_cell_line(bio_cell_line_id);


--
-- Name: bio_sample_pt_evt_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_sample
    ADD CONSTRAINT bio_sample_pt_evt_fk FOREIGN KEY (bio_patient_event_id) REFERENCES bio_patient_event(bio_patient_event_id);


--
-- Name: bio_taxon_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_data_taxonomy
    ADD CONSTRAINT bio_taxon_fk FOREIGN KEY (bio_taxonomy_id) REFERENCES bio_taxonomy(bio_taxonomy_id);


--
-- Name: cd_disease_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_cell_line
    ADD CONSTRAINT cd_disease_fk FOREIGN KEY (bio_disease_id) REFERENCES bio_disease(bio_disease_id);


--
-- Name: dataset_experiment_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_assay
    ADD CONSTRAINT dataset_experiment_fk FOREIGN KEY (experiment_id) REFERENCES bio_experiment(bio_experiment_id);


--
-- Name: ext_file_cnt_cnt_repo_fk; Type: FK CONSTRAINT; Schema: biomart; Owner: biomart
--

ALTER TABLE ONLY bio_content
    ADD CONSTRAINT ext_file_cnt_cnt_repo_fk FOREIGN KEY (repository_id) REFERENCES bio_content_repository(bio_content_repo_id);


SET search_path = deapp, pg_catalog;

--
-- Name: de_chrom_region_gpl_id_fkey; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_chromosomal_region
    ADD CONSTRAINT de_chrom_region_gpl_id_fkey FOREIGN KEY (gpl_id) REFERENCES de_gpl_info(platform);


--
-- Name: de_met_sub_pw_met_met_id_fk; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_metabolite_sub_pway_metab
    ADD CONSTRAINT de_met_sub_pw_met_met_id_fk FOREIGN KEY (metabolite_id) REFERENCES de_metabolite_annotation(id);


--
-- Name: de_met_sub_pw_met_sub_pw_id_fk; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_metabolite_sub_pway_metab
    ADD CONSTRAINT de_met_sub_pw_met_sub_pw_id_fk FOREIGN KEY (sub_pathway_id) REFERENCES de_metabolite_sub_pathways(id);


--
-- Name: de_met_sub_pw_sup_pw_id_fkey; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_metabolite_sub_pathways
    ADD CONSTRAINT de_met_sub_pw_sup_pw_id_fkey FOREIGN KEY (super_pathway_id) REFERENCES de_metabolite_super_pathways(id);


--
-- Name: de_rbm_data_ann_jn_ann_id_fk; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_rbm_data_annotation_join
    ADD CONSTRAINT de_rbm_data_ann_jn_ann_id_fk FOREIGN KEY (annotation_id) REFERENCES de_rbm_annotation(id) ON DELETE CASCADE;


--
-- Name: de_rbm_data_ann_jn_data_id_fk; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_rbm_data_annotation_join
    ADD CONSTRAINT de_rbm_data_ann_jn_data_id_fk FOREIGN KEY (data_id) REFERENCES de_subject_rbm_data(id) ON DELETE CASCADE;


--
-- Name: de_sj_met_data_met_ann_id_fk; Type: FK CONSTRAINT; Schema: deapp; Owner: tm_cz
--

ALTER TABLE ONLY de_subject_metabolomics_data
    ADD CONSTRAINT de_sj_met_data_met_ann_id_fk FOREIGN KEY (metabolite_annotation_id) REFERENCES de_metabolite_annotation(id);


--
-- Name: de_subj_acgh_region_id_fkey; Type: FK CONSTRAINT; Schema: deapp; Owner: tm_cz
--

ALTER TABLE ONLY de_subject_acgh_data
    ADD CONSTRAINT de_subj_acgh_region_id_fkey FOREIGN KEY (region_id) REFERENCES de_chromosomal_region(region_id);


--
-- Name: de_subj_rnaseq_region_id_fkey; Type: FK CONSTRAINT; Schema: deapp; Owner: tm_cz
--

ALTER TABLE ONLY de_subject_rnaseq_data
    ADD CONSTRAINT de_subj_rnaseq_region_id_fkey FOREIGN KEY (region_id) REFERENCES de_chromosomal_region(region_id);


--
-- Name: de_variant_population_data_fk; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_variant_population_data
    ADD CONSTRAINT de_variant_population_data_fk FOREIGN KEY (dataset_id) REFERENCES de_variant_dataset(dataset_id);


--
-- Name: de_variant_population_info_fk; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_variant_population_info
    ADD CONSTRAINT de_variant_population_info_fk FOREIGN KEY (dataset_id) REFERENCES de_variant_dataset(dataset_id);


--
-- Name: dexcm_parent_cd_fk; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_xtrial_child_map
    ADD CONSTRAINT dexcm_parent_cd_fk FOREIGN KEY (parent_cd) REFERENCES de_xtrial_parent_names(parent_cd);


--
-- Name: fk_protein_annotation_id; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_subject_protein_data
    ADD CONSTRAINT fk_protein_annotation_id FOREIGN KEY (protein_annotation_id) REFERENCES de_protein_annotation(id);


--
-- Name: fk_snp_by_probe_probe_id; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_snp_data_by_probe
    ADD CONSTRAINT fk_snp_by_probe_probe_id FOREIGN KEY (probe_id) REFERENCES de_snp_probe(snp_probe_id);


--
-- Name: fk_snp_by_probe_snp_id; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_snp_data_by_probe
    ADD CONSTRAINT fk_snp_by_probe_snp_id FOREIGN KEY (snp_id) REFERENCES de_snp_info(snp_info_id);


--
-- Name: fk_snp_dataset_id; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_snp_data_by_patient
    ADD CONSTRAINT fk_snp_dataset_id FOREIGN KEY (snp_dataset_id) REFERENCES de_subject_snp_dataset(subject_snp_dataset_id);


--
-- Name: fk_snp_gene_map_snp_id; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_snp_gene_map
    ADD CONSTRAINT fk_snp_gene_map_snp_id FOREIGN KEY (snp_id) REFERENCES de_snp_info(snp_info_id);


--
-- Name: fk_snp_loc_dataset_id; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_snp_data_dataset_loc
    ADD CONSTRAINT fk_snp_loc_dataset_id FOREIGN KEY (snp_dataset_id) REFERENCES de_subject_snp_dataset(subject_snp_dataset_id);


--
-- Name: fk_snp_probe_snp_id; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_snp_probe
    ADD CONSTRAINT fk_snp_probe_snp_id FOREIGN KEY (snp_id) REFERENCES de_snp_info(snp_info_id);


--
-- Name: gpl_id; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_variant_dataset
    ADD CONSTRAINT gpl_id FOREIGN KEY (gpl_id) REFERENCES de_gpl_info(platform);


--
-- Name: var_met_dataset_id; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_variant_metadata
    ADD CONSTRAINT var_met_dataset_id FOREIGN KEY (dataset_id) REFERENCES de_variant_dataset(dataset_id);


--
-- Name: variant_subject_detail_fk; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_variant_subject_detail
    ADD CONSTRAINT variant_subject_detail_fk FOREIGN KEY (dataset_id) REFERENCES de_variant_dataset(dataset_id);


--
-- Name: variant_subject_idx_fk; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_variant_subject_idx
    ADD CONSTRAINT variant_subject_idx_fk FOREIGN KEY (dataset_id) REFERENCES de_variant_dataset(dataset_id);


--
-- Name: variant_subject_summary_fk; Type: FK CONSTRAINT; Schema: deapp; Owner: deapp
--

ALTER TABLE ONLY de_variant_subject_summary
    ADD CONSTRAINT variant_subject_summary_fk FOREIGN KEY (dataset_id) REFERENCES de_variant_dataset(dataset_id);


SET search_path = fmapp, pg_catalog;

--
-- Name: fk_fm_folder_assoc_fm_folder; Type: FK CONSTRAINT; Schema: fmapp; Owner: fmapp
--

ALTER TABLE ONLY fm_folder_association
    ADD CONSTRAINT fk_fm_folder_assoc_fm_folder FOREIGN KEY (folder_id) REFERENCES fm_folder(folder_id);


--
-- Name: fk_fm_folder_fm_folder; Type: FK CONSTRAINT; Schema: fmapp; Owner: fmapp
--

ALTER TABLE ONLY fm_folder_file_association
    ADD CONSTRAINT fk_fm_folder_fm_folder FOREIGN KEY (folder_id) REFERENCES fm_folder(folder_id);


--
-- Name: fk_folder_file_assoc_file; Type: FK CONSTRAINT; Schema: fmapp; Owner: fmapp
--

ALTER TABLE ONLY fm_folder_file_association
    ADD CONSTRAINT fk_folder_file_assoc_file FOREIGN KEY (file_id) REFERENCES fm_file(file_id);


SET search_path = i2b2demodata, pg_catalog;

--
-- Name: fk_up_set_type_id; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY set_upload_status
    ADD CONSTRAINT fk_up_set_type_id FOREIGN KEY (set_type_id) REFERENCES set_type(id);


--
-- Name: qt_fk_pec_ri; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_patient_enc_collection
    ADD CONSTRAINT qt_fk_pec_ri FOREIGN KEY (result_instance_id) REFERENCES qt_query_result_instance(result_instance_id);


--
-- Name: qt_fk_psc_ri; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_patient_set_collection
    ADD CONSTRAINT qt_fk_psc_ri FOREIGN KEY (result_instance_id) REFERENCES qt_query_result_instance(result_instance_id);


--
-- Name: qt_fk_qi_mid; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_query_instance
    ADD CONSTRAINT qt_fk_qi_mid FOREIGN KEY (query_master_id) REFERENCES qt_query_master(query_master_id);


--
-- Name: qt_fk_qi_stid; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_query_instance
    ADD CONSTRAINT qt_fk_qi_stid FOREIGN KEY (status_type_id) REFERENCES qt_query_status_type(status_type_id);


--
-- Name: qt_fk_qri_rid; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_query_result_instance
    ADD CONSTRAINT qt_fk_qri_rid FOREIGN KEY (query_instance_id) REFERENCES qt_query_instance(query_instance_id);


--
-- Name: qt_fk_qri_rtid; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_query_result_instance
    ADD CONSTRAINT qt_fk_qri_rtid FOREIGN KEY (result_type_id) REFERENCES qt_query_result_type(result_type_id);


--
-- Name: qt_fk_qri_stid; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_query_result_instance
    ADD CONSTRAINT qt_fk_qri_stid FOREIGN KEY (status_type_id) REFERENCES qt_query_status_type(status_type_id);


--
-- Name: qt_fk_xmlr_riid; Type: FK CONSTRAINT; Schema: i2b2demodata; Owner: i2b2demodata
--

ALTER TABLE ONLY qt_xml_result
    ADD CONSTRAINT qt_fk_xmlr_riid FOREIGN KEY (result_instance_id) REFERENCES qt_query_result_instance(result_instance_id);


SET search_path = searchapp, pg_catalog;

--
-- Name: fk_search_tax_rels_child; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_taxonomy_rels
    ADD CONSTRAINT fk_search_tax_rels_child FOREIGN KEY (child_id) REFERENCES search_taxonomy(term_id);


--
-- Name: fk_search_tax_rels_parent; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_taxonomy_rels
    ADD CONSTRAINT fk_search_tax_rels_parent FOREIGN KEY (parent_id) REFERENCES search_taxonomy(term_id);


--
-- Name: fk_search_tax_search_keyword; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_taxonomy
    ADD CONSTRAINT fk_search_tax_search_keyword FOREIGN KEY (search_keyword_id) REFERENCES search_keyword(search_keyword_id);


--
-- Name: fkfb14ef79287e0cac; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_role_auth_user
    ADD CONSTRAINT fkfb14ef79287e0cac FOREIGN KEY (authorities_id) REFERENCES search_auth_user(id);


--
-- Name: fkfb14ef798f01f561; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_role_auth_user
    ADD CONSTRAINT fkfb14ef798f01f561 FOREIGN KEY (people_id) REFERENCES search_role(id);


--
-- Name: gene_sig_create_auth_user_fk1; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_gene_signature
    ADD CONSTRAINT gene_sig_create_auth_user_fk1 FOREIGN KEY (created_by_auth_user_id) REFERENCES search_auth_user(id);


--
-- Name: gene_sig_file_schema_fk1; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_gene_signature
    ADD CONSTRAINT gene_sig_file_schema_fk1 FOREIGN KEY (search_gene_sig_file_schema_id) REFERENCES search_gene_sig_file_schema(search_gene_sig_file_schema_id);


--
-- Name: gene_sig_mod_auth_user_fk1; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_gene_signature
    ADD CONSTRAINT gene_sig_mod_auth_user_fk1 FOREIGN KEY (modified_by_auth_user_id) REFERENCES search_auth_user(id);


--
-- Name: gene_sig_parent_fk1; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_gene_signature
    ADD CONSTRAINT gene_sig_parent_fk1 FOREIGN KEY (parent_gene_signature_id) REFERENCES search_gene_signature(search_gene_signature_id);


--
-- Name: plugin_module_plugin_fk1; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY plugin_module
    ADD CONSTRAINT plugin_module_plugin_fk1 FOREIGN KEY (plugin_seq) REFERENCES plugin(plugin_seq);


--
-- Name: saved_faceted_search_user_id; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY saved_faceted_search
    ADD CONSTRAINT saved_faceted_search_user_id FOREIGN KEY (user_id) REFERENCES search_auth_user(id);


--
-- Name: sch_sec_a_u_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_sec_object_access
    ADD CONSTRAINT sch_sec_a_u_fk FOREIGN KEY (auth_principal_id) REFERENCES search_auth_principal(id);


--
-- Name: sch_sec_s_a_l_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_sec_object_access
    ADD CONSTRAINT sch_sec_s_a_l_fk FOREIGN KEY (secure_access_level_id) REFERENCES search_sec_access_level(search_sec_access_level_id);


--
-- Name: sch_sec_s_o_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_sec_object_access
    ADD CONSTRAINT sch_sec_s_o_fk FOREIGN KEY (secure_object_id) REFERENCES search_secure_object(search_secure_object_id);


--
-- Name: sch_user_gp_m_grp_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_group_member
    ADD CONSTRAINT sch_user_gp_m_grp_fk FOREIGN KEY (auth_group_id) REFERENCES search_auth_group(id);


--
-- Name: sch_user_gp_m_usr_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_group_member
    ADD CONSTRAINT sch_user_gp_m_usr_fk FOREIGN KEY (auth_user_id) REFERENCES search_auth_principal(id);


--
-- Name: search_kw_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_keyword_term
    ADD CONSTRAINT search_kw_fk FOREIGN KEY (search_keyword_id) REFERENCES search_keyword(search_keyword_id);


--
-- Name: search_sec_a_u_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_user_sec_access
    ADD CONSTRAINT search_sec_a_u_fk FOREIGN KEY (search_auth_user_id) REFERENCES search_auth_user(id);


--
-- Name: search_sec_s_a_l_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_user_sec_access
    ADD CONSTRAINT search_sec_s_a_l_fk FOREIGN KEY (search_sec_access_level_id) REFERENCES search_sec_access_level(search_sec_access_level_id);


--
-- Name: search_sec_s_o_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_user_sec_access
    ADD CONSTRAINT search_sec_s_o_fk FOREIGN KEY (search_secure_object_id) REFERENCES search_secure_object(search_secure_object_id);


--
-- Name: sh_auth_gp_id_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_group
    ADD CONSTRAINT sh_auth_gp_id_fk FOREIGN KEY (id) REFERENCES search_auth_principal(id);


--
-- Name: sh_auth_user_id_fk; Type: FK CONSTRAINT; Schema: searchapp; Owner: searchapp
--

ALTER TABLE ONLY search_auth_user
    ADD CONSTRAINT sh_auth_user_id_fk FOREIGN KEY (id) REFERENCES search_auth_principal(id);


SET search_path = tm_cz, pg_catalog;

--
-- Name: az_test_run_cz_dw_version_fk1; Type: FK CONSTRAINT; Schema: tm_cz; Owner: tm_cz
--

ALTER TABLE ONLY az_test_run
    ADD CONSTRAINT az_test_run_cz_dw_version_fk1 FOREIGN KEY (dw_version_id) REFERENCES cz_dw_version(dw_version_id);


--
-- Name: az_test_run_cz_test_categ_fk1; Type: FK CONSTRAINT; Schema: tm_cz; Owner: tm_cz
--

ALTER TABLE ONLY az_test_run
    ADD CONSTRAINT az_test_run_cz_test_categ_fk1 FOREIGN KEY (test_category_id) REFERENCES cz_test_category(test_category_id);


--
-- Name: az_test_step_act_result_az_fk1; Type: FK CONSTRAINT; Schema: tm_cz; Owner: tm_cz
--

ALTER TABLE ONLY az_test_step_act_result
    ADD CONSTRAINT az_test_step_act_result_az_fk1 FOREIGN KEY (test_step_run_id) REFERENCES az_test_step_run(test_step_run_id);


--
-- Name: az_test_step_run_cz_job_fk1; Type: FK CONSTRAINT; Schema: tm_cz; Owner: tm_cz
--

ALTER TABLE ONLY az_test_step_run
    ADD CONSTRAINT az_test_step_run_cz_job_fk1 FOREIGN KEY (test_id) REFERENCES cz_test(test_id);


--
-- Name: az_tst_step_run_az_test_ru_fk1; Type: FK CONSTRAINT; Schema: tm_cz; Owner: tm_cz
--

ALTER TABLE ONLY az_test_step_run
    ADD CONSTRAINT az_tst_step_run_az_test_ru_fk1 FOREIGN KEY (test_run_id) REFERENCES az_test_run(test_run_id);


--
-- Name: cz_data_file_cz_data_fk1; Type: FK CONSTRAINT; Schema: tm_cz; Owner: tm_cz
--

ALTER TABLE ONLY cz_data_file
    ADD CONSTRAINT cz_data_file_cz_data_fk1 FOREIGN KEY (data_id) REFERENCES cz_data(data_id);


--
-- Name: cz_test_category_cz_perso_fk1; Type: FK CONSTRAINT; Schema: tm_cz; Owner: tm_cz
--

ALTER TABLE ONLY cz_test_category
    ADD CONSTRAINT cz_test_category_cz_perso_fk1 FOREIGN KEY (person_id) REFERENCES cz_person(person_id);


--
-- Name: cz_test_cz_test_category_fk1; Type: FK CONSTRAINT; Schema: tm_cz; Owner: tm_cz
--

ALTER TABLE ONLY cz_test
    ADD CONSTRAINT cz_test_cz_test_category_fk1 FOREIGN KEY (test_category_id) REFERENCES cz_test_category(test_category_id);


--
-- Name: amapp; Type: ACL; Schema: -; Owner: amapp
--

REVOKE ALL ON SCHEMA amapp FROM PUBLIC;
REVOKE ALL ON SCHEMA amapp FROM amapp;
GRANT ALL ON SCHEMA amapp TO amapp;
GRANT ALL ON SCHEMA amapp TO tm_cz;
GRANT USAGE ON SCHEMA amapp TO biomart_user;


--
-- Name: biomart; Type: ACL; Schema: -; Owner: biomart
--

REVOKE ALL ON SCHEMA biomart FROM PUBLIC;
REVOKE ALL ON SCHEMA biomart FROM biomart;
GRANT ALL ON SCHEMA biomart TO biomart;
GRANT ALL ON SCHEMA biomart TO tm_cz;
GRANT USAGE ON SCHEMA biomart TO biomart_user;


--
-- Name: biomart_user; Type: ACL; Schema: -; Owner: biomart_user
--

REVOKE ALL ON SCHEMA biomart_user FROM PUBLIC;
REVOKE ALL ON SCHEMA biomart_user FROM biomart_user;
GRANT ALL ON SCHEMA biomart_user TO biomart_user;
GRANT ALL ON SCHEMA biomart_user TO tm_cz;


--
-- Name: deapp; Type: ACL; Schema: -; Owner: deapp
--

REVOKE ALL ON SCHEMA deapp FROM PUBLIC;
REVOKE ALL ON SCHEMA deapp FROM deapp;
GRANT ALL ON SCHEMA deapp TO deapp;
GRANT ALL ON SCHEMA deapp TO tm_cz;
GRANT USAGE ON SCHEMA deapp TO biomart_user;
GRANT USAGE ON SCHEMA deapp TO tm_lz;
GRANT USAGE ON SCHEMA deapp TO tm_dataloader;


--
-- Name: fmapp; Type: ACL; Schema: -; Owner: fmapp
--

REVOKE ALL ON SCHEMA fmapp FROM PUBLIC;
REVOKE ALL ON SCHEMA fmapp FROM fmapp;
GRANT ALL ON SCHEMA fmapp TO fmapp;
GRANT ALL ON SCHEMA fmapp TO tm_cz;
GRANT USAGE ON SCHEMA fmapp TO biomart_user;


--
-- Name: galaxy; Type: ACL; Schema: -; Owner: galaxy
--

REVOKE ALL ON SCHEMA galaxy FROM PUBLIC;
REVOKE ALL ON SCHEMA galaxy FROM galaxy;
GRANT ALL ON SCHEMA galaxy TO galaxy;
GRANT ALL ON SCHEMA galaxy TO tm_cz;
GRANT USAGE ON SCHEMA galaxy TO biomart_user;


--
-- Name: i2b2demodata; Type: ACL; Schema: -; Owner: i2b2demodata
--

REVOKE ALL ON SCHEMA i2b2demodata FROM PUBLIC;
REVOKE ALL ON SCHEMA i2b2demodata FROM i2b2demodata;
GRANT ALL ON SCHEMA i2b2demodata TO i2b2demodata;
GRANT ALL ON SCHEMA i2b2demodata TO tm_cz;
GRANT USAGE ON SCHEMA i2b2demodata TO biomart_user;
GRANT USAGE ON SCHEMA i2b2demodata TO tm_dataloader;


--
-- Name: i2b2metadata; Type: ACL; Schema: -; Owner: i2b2metadata
--

REVOKE ALL ON SCHEMA i2b2metadata FROM PUBLIC;
REVOKE ALL ON SCHEMA i2b2metadata FROM i2b2metadata;
GRANT ALL ON SCHEMA i2b2metadata TO i2b2metadata;
GRANT ALL ON SCHEMA i2b2metadata TO tm_cz;
GRANT USAGE ON SCHEMA i2b2metadata TO biomart_user;
GRANT USAGE ON SCHEMA i2b2metadata TO tm_dataloader;


--
-- Name: public; Type: ACL; Schema: -; Owner: weymouth
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM weymouth;
GRANT ALL ON SCHEMA public TO weymouth;
GRANT ALL ON SCHEMA public TO PUBLIC;


--
-- Name: searchapp; Type: ACL; Schema: -; Owner: searchapp
--

REVOKE ALL ON SCHEMA searchapp FROM PUBLIC;
REVOKE ALL ON SCHEMA searchapp FROM searchapp;
GRANT ALL ON SCHEMA searchapp TO searchapp;
GRANT ALL ON SCHEMA searchapp TO tm_cz;
GRANT USAGE ON SCHEMA searchapp TO biomart_user;


--
-- Name: tm_cz; Type: ACL; Schema: -; Owner: tm_cz
--

REVOKE ALL ON SCHEMA tm_cz FROM PUBLIC;
REVOKE ALL ON SCHEMA tm_cz FROM tm_cz;
GRANT ALL ON SCHEMA tm_cz TO tm_cz;


--
-- Name: tm_dataloader; Type: ACL; Schema: -; Owner: tm_dataloader
--

REVOKE ALL ON SCHEMA tm_dataloader FROM PUBLIC;
REVOKE ALL ON SCHEMA tm_dataloader FROM tm_dataloader;
GRANT ALL ON SCHEMA tm_dataloader TO tm_dataloader;


--
-- Name: tm_lz; Type: ACL; Schema: -; Owner: tm_lz
--

REVOKE ALL ON SCHEMA tm_lz FROM PUBLIC;
REVOKE ALL ON SCHEMA tm_lz FROM tm_lz;
GRANT ALL ON SCHEMA tm_lz TO tm_lz;
GRANT ALL ON SCHEMA tm_lz TO tm_cz;


--
-- Name: tm_wz; Type: ACL; Schema: -; Owner: tm_wz
--

REVOKE ALL ON SCHEMA tm_wz FROM PUBLIC;
REVOKE ALL ON SCHEMA tm_wz FROM tm_wz;
GRANT ALL ON SCHEMA tm_wz TO tm_wz;
GRANT ALL ON SCHEMA tm_wz TO tm_cz;


SET search_path = amapp, pg_catalog;

--
-- Name: am_tag_value_uid(bigint); Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON FUNCTION am_tag_value_uid(tag_value_id bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION am_tag_value_uid(tag_value_id bigint) FROM amapp;
GRANT ALL ON FUNCTION am_tag_value_uid(tag_value_id bigint) TO amapp;
GRANT ALL ON FUNCTION am_tag_value_uid(tag_value_id bigint) TO tm_cz;
GRANT ALL ON FUNCTION am_tag_value_uid(tag_value_id bigint) TO biomart_user;


--
-- Name: tf_trg_am_tag_item_id(); Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON FUNCTION tf_trg_am_tag_item_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_am_tag_item_id() FROM amapp;
GRANT ALL ON FUNCTION tf_trg_am_tag_item_id() TO amapp;
GRANT ALL ON FUNCTION tf_trg_am_tag_item_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_am_tag_item_id() TO biomart_user;


--
-- Name: tf_trg_am_tag_temp_assoc_id(); Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON FUNCTION tf_trg_am_tag_temp_assoc_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_am_tag_temp_assoc_id() FROM amapp;
GRANT ALL ON FUNCTION tf_trg_am_tag_temp_assoc_id() TO amapp;
GRANT ALL ON FUNCTION tf_trg_am_tag_temp_assoc_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_am_tag_temp_assoc_id() TO biomart_user;


--
-- Name: tf_trg_am_tag_template_id(); Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON FUNCTION tf_trg_am_tag_template_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_am_tag_template_id() FROM amapp;
GRANT ALL ON FUNCTION tf_trg_am_tag_template_id() TO amapp;
GRANT ALL ON FUNCTION tf_trg_am_tag_template_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_am_tag_template_id() TO biomart_user;


--
-- Name: tf_trg_am_tag_value_id(); Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON FUNCTION tf_trg_am_tag_value_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_am_tag_value_id() FROM amapp;
GRANT ALL ON FUNCTION tf_trg_am_tag_value_id() TO amapp;
GRANT ALL ON FUNCTION tf_trg_am_tag_value_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_am_tag_value_id() TO biomart_user;


--
-- Name: tf_trg_am_tag_value_uid(); Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON FUNCTION tf_trg_am_tag_value_uid() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_am_tag_value_uid() FROM amapp;
GRANT ALL ON FUNCTION tf_trg_am_tag_value_uid() TO amapp;
GRANT ALL ON FUNCTION tf_trg_am_tag_value_uid() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_am_tag_value_uid() TO biomart_user;


SET search_path = biomart, pg_catalog;

--
-- Name: bio_assay_analysis_uid(character varying); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_assay_analysis_uid(analysis_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_assay_analysis_uid(analysis_name character varying) FROM biomart;
GRANT ALL ON FUNCTION bio_assay_analysis_uid(analysis_name character varying) TO biomart;
GRANT ALL ON FUNCTION bio_assay_analysis_uid(analysis_name character varying) TO tm_cz;
GRANT ALL ON FUNCTION bio_assay_analysis_uid(analysis_name character varying) TO biomart_user;


--
-- Name: bio_assay_platform_uid(character varying); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_assay_platform_uid(platform_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_assay_platform_uid(platform_name character varying) FROM biomart;
GRANT ALL ON FUNCTION bio_assay_platform_uid(platform_name character varying) TO biomart;
GRANT ALL ON FUNCTION bio_assay_platform_uid(platform_name character varying) TO tm_cz;
GRANT ALL ON FUNCTION bio_assay_platform_uid(platform_name character varying) TO biomart_user;


--
-- Name: bio_asy_analysis_pltfm_uid(character varying); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name character varying) FROM biomart;
GRANT ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name character varying) TO biomart;
GRANT ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name character varying) TO tm_cz;
GRANT ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name character varying) TO biomart_user;


--
-- Name: bio_compound_uid(character varying, character varying, character varying); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) FROM biomart;
GRANT ALL ON FUNCTION bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) TO biomart;
GRANT ALL ON FUNCTION bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) TO tm_cz;
GRANT ALL ON FUNCTION bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) TO biomart_user;


--
-- Name: bio_curation_dataset_uid(character varying); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type character varying) FROM biomart;
GRANT ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type character varying) TO biomart;
GRANT ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type character varying) TO tm_cz;
GRANT ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type character varying) TO biomart_user;


--
-- Name: bio_disease_uid(character varying); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_disease_uid(mesh_code character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_disease_uid(mesh_code character varying) FROM biomart;
GRANT ALL ON FUNCTION bio_disease_uid(mesh_code character varying) TO biomart;
GRANT ALL ON FUNCTION bio_disease_uid(mesh_code character varying) TO tm_cz;
GRANT ALL ON FUNCTION bio_disease_uid(mesh_code character varying) TO biomart_user;


--
-- Name: bio_experiment_uid(character varying); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_experiment_uid(primary_id character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_experiment_uid(primary_id character varying) FROM biomart;
GRANT ALL ON FUNCTION bio_experiment_uid(primary_id character varying) TO biomart;
GRANT ALL ON FUNCTION bio_experiment_uid(primary_id character varying) TO tm_cz;
GRANT ALL ON FUNCTION bio_experiment_uid(primary_id character varying) TO biomart_user;


--
-- Name: bio_jub_oncol_data_uid(numeric, character varying); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_jub_oncol_data_uid(record_id numeric, bio_curation_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_jub_oncol_data_uid(record_id numeric, bio_curation_name character varying) FROM biomart;
GRANT ALL ON FUNCTION bio_jub_oncol_data_uid(record_id numeric, bio_curation_name character varying) TO biomart;
GRANT ALL ON FUNCTION bio_jub_oncol_data_uid(record_id numeric, bio_curation_name character varying) TO tm_cz;
GRANT ALL ON FUNCTION bio_jub_oncol_data_uid(record_id numeric, bio_curation_name character varying) TO biomart_user;


--
-- Name: bio_jub_oncol_sum_data_uid(numeric, character varying); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id numeric, bio_curation_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id numeric, bio_curation_name character varying) FROM biomart;
GRANT ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id numeric, bio_curation_name character varying) TO biomart;
GRANT ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id numeric, bio_curation_name character varying) TO tm_cz;
GRANT ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id numeric, bio_curation_name character varying) TO biomart_user;


--
-- Name: biomarker_gene_uid(character varying); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION biomarker_gene_uid(gene_id character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION biomarker_gene_uid(gene_id character varying) FROM biomart;
GRANT ALL ON FUNCTION biomarker_gene_uid(gene_id character varying) TO biomart;
GRANT ALL ON FUNCTION biomarker_gene_uid(gene_id character varying) TO tm_cz;
GRANT ALL ON FUNCTION biomarker_gene_uid(gene_id character varying) TO biomart_user;


--
-- Name: biomarker_pathway_uid(character varying, character varying); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION biomarker_pathway_uid(p_source character varying, pathway_id character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION biomarker_pathway_uid(p_source character varying, pathway_id character varying) FROM biomart;
GRANT ALL ON FUNCTION biomarker_pathway_uid(p_source character varying, pathway_id character varying) TO biomart;
GRANT ALL ON FUNCTION biomarker_pathway_uid(p_source character varying, pathway_id character varying) TO tm_cz;
GRANT ALL ON FUNCTION biomarker_pathway_uid(p_source character varying, pathway_id character varying) TO biomart_user;


--
-- Name: cum_normal_dist(numeric, numeric, numeric); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) FROM biomart;
GRANT ALL ON FUNCTION cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) TO biomart;
GRANT ALL ON FUNCTION cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) TO tm_cz;
GRANT ALL ON FUNCTION cum_normal_dist(foldchg numeric, mu numeric, sigma numeric) TO biomart_user;


--
-- Name: fract_error_dist(numeric); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION fract_error_dist(norminput numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION fract_error_dist(norminput numeric) FROM biomart;
GRANT ALL ON FUNCTION fract_error_dist(norminput numeric) TO biomart;
GRANT ALL ON FUNCTION fract_error_dist(norminput numeric) TO tm_cz;
GRANT ALL ON FUNCTION fract_error_dist(norminput numeric) TO biomart_user;


--
-- Name: refresh_bio_lit_int_model_mv(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION refresh_bio_lit_int_model_mv() FROM PUBLIC;
REVOKE ALL ON FUNCTION refresh_bio_lit_int_model_mv() FROM biomart;
GRANT ALL ON FUNCTION refresh_bio_lit_int_model_mv() TO biomart;
GRANT ALL ON FUNCTION refresh_bio_lit_int_model_mv() TO tm_cz;
GRANT ALL ON FUNCTION refresh_bio_lit_int_model_mv() TO biomart_user;


--
-- Name: refresh_bio_marker_correl_mv(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION refresh_bio_marker_correl_mv() FROM PUBLIC;
REVOKE ALL ON FUNCTION refresh_bio_marker_correl_mv() FROM biomart;
GRANT ALL ON FUNCTION refresh_bio_marker_correl_mv() TO biomart;
GRANT ALL ON FUNCTION refresh_bio_marker_correl_mv() TO tm_cz;
GRANT ALL ON FUNCTION refresh_bio_marker_correl_mv() TO biomart_user;


--
-- Name: tea_npv_precompute(numeric, numeric, numeric); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) FROM biomart;
GRANT ALL ON FUNCTION tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) TO biomart;
GRANT ALL ON FUNCTION tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) TO tm_cz;
GRANT ALL ON FUNCTION tea_npv_precompute(foldchg numeric, mu numeric, sigma numeric) TO biomart_user;


--
-- Name: tf_trg_bio_ad_hoc_prop_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_ad_hoc_prop_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_ad_hoc_prop_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_ad_hoc_prop_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_ad_hoc_prop_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_ad_hoc_prop_id() TO biomart_user;


--
-- Name: tf_trg_bio_analysis_al_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_analysis_al_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_analysis_al_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_analysis_al_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_analysis_al_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_analysis_al_id() TO biomart_user;


--
-- Name: tf_trg_bio_analysis_attribute_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_analysis_attribute_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_analysis_attribute_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_analysis_attribute_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_analysis_attribute_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_analysis_attribute_id() TO biomart_user;


--
-- Name: tf_trg_bio_assay_analysis_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_analysis_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_analysis_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_analysis_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_analysis_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_assay_analysis_id() TO biomart_user;


--
-- Name: tf_trg_bio_assay_analysis_uid(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_analysis_uid() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_analysis_uid() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_analysis_uid() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_analysis_uid() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_assay_analysis_uid() TO biomart_user;


--
-- Name: tf_trg_bio_assay_cohort_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_cohort_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_cohort_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_cohort_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_cohort_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_assay_cohort_id() TO biomart_user;


--
-- Name: tf_trg_bio_assay_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_data_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_assay_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_assay_dataset_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_dataset_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_dataset_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_dataset_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_dataset_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_assay_dataset_id() TO biomart_user;


--
-- Name: tf_trg_bio_assay_f_g_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_f_g_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_f_g_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_f_g_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_f_g_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_assay_f_g_id() TO biomart_user;


--
-- Name: tf_trg_bio_assay_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_assay_id() TO biomart_user;


--
-- Name: tf_trg_bio_assay_platform_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_assay_platform_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_assay_platform_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_platform_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_assay_platform_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_assay_platform_id() TO biomart_user;


--
-- Name: tf_trg_bio_asy_adi_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_asy_adi_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_asy_adi_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_asy_adi_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_asy_adi_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_asy_adi_id() TO biomart_user;


--
-- Name: tf_trg_bio_asy_analysis_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_asy_analysis_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_asy_analysis_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_asy_analysis_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_asy_analysis_data_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_asy_analysis_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_asy_analysis_pltfm_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_asy_analysis_pltfm_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_asy_analysis_pltfm_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_asy_analysis_pltfm_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_asy_analysis_pltfm_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_asy_analysis_pltfm_id() TO biomart_user;


--
-- Name: tf_trg_bio_asy_dt_stats_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_asy_dt_stats_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_asy_dt_stats_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_asy_dt_stats_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_asy_dt_stats_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_asy_dt_stats_id() TO biomart_user;


--
-- Name: tf_trg_bio_cell_line_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_cell_line_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_cell_line_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_cell_line_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_cell_line_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_cell_line_id() TO biomart_user;


--
-- Name: tf_trg_bio_cl_trl_time_pt_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_cl_trl_time_pt_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_cl_trl_time_pt_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_cl_trl_time_pt_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_cl_trl_time_pt_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_cl_trl_time_pt_id() TO biomart_user;


--
-- Name: tf_trg_bio_clin_trl_pt_grp_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_clin_trl_pt_grp_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_clin_trl_pt_grp_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_clin_trl_pt_grp_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_clin_trl_pt_grp_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_clin_trl_pt_grp_id() TO biomart_user;


--
-- Name: tf_trg_bio_cln_trl_attr_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_cln_trl_attr_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_cln_trl_attr_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_cln_trl_attr_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_cln_trl_attr_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_cln_trl_attr_id() TO biomart_user;


--
-- Name: tf_trg_bio_compound_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_compound_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_compound_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_compound_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_compound_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_compound_id() TO biomart_user;


--
-- Name: tf_trg_bio_concept_code_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_concept_code_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_concept_code_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_concept_code_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_concept_code_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_concept_code_id() TO biomart_user;


--
-- Name: tf_trg_bio_content_ref_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_content_ref_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_content_ref_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_content_ref_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_content_ref_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_content_ref_id() TO biomart_user;


--
-- Name: tf_trg_bio_content_repo_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_content_repo_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_content_repo_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_content_repo_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_content_repo_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_content_repo_id() TO biomart_user;


--
-- Name: tf_trg_bio_curation_dataset_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_curation_dataset_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_curation_dataset_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_curation_dataset_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_curation_dataset_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_curation_dataset_id() TO biomart_user;


--
-- Name: tf_trg_bio_data_attr_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_data_attr_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_data_attr_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_data_attr_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_data_attr_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_data_attr_id() TO biomart_user;


--
-- Name: tf_trg_bio_data_correl_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_data_correl_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_data_correl_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_data_correl_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_data_correl_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_data_correl_id() TO biomart_user;


--
-- Name: tf_trg_bio_data_ext_code_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_data_ext_code_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_data_ext_code_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_data_ext_code_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_data_ext_code_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_data_ext_code_id() TO biomart_user;


--
-- Name: tf_trg_bio_disease_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_disease_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_disease_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_disease_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_disease_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_disease_id() TO biomart_user;


--
-- Name: tf_trg_bio_experiment_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_experiment_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_experiment_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_experiment_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_experiment_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_experiment_id() TO biomart_user;


--
-- Name: tf_trg_bio_experiment_uid(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_experiment_uid() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_experiment_uid() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_experiment_uid() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_experiment_uid() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_experiment_uid() TO biomart_user;


--
-- Name: tf_trg_bio_file_content_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_file_content_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_file_content_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_file_content_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_file_content_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_file_content_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_alt_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_alt_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_alt_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_alt_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_alt_data_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_lit_alt_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_amd_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_amd_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_amd_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_amd_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_amd_data_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_lit_amd_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_inh_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_inh_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_inh_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_inh_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_inh_data_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_lit_inh_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_int_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_int_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_int_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_int_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_int_data_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_lit_int_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_model_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_model_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_model_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_model_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_model_data_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_lit_model_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_pe_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_pe_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_pe_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_pe_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_pe_data_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_lit_pe_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_ref_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_ref_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_ref_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_ref_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_ref_data_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_lit_ref_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_lit_sum_data_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_lit_sum_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_lit_sum_data_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_sum_data_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_lit_sum_data_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_lit_sum_data_id() TO biomart_user;


--
-- Name: tf_trg_bio_marker_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_marker_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_marker_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_marker_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_marker_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_marker_id() TO biomart_user;


--
-- Name: tf_trg_bio_mkr_correl_descr_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_mkr_correl_descr_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_mkr_correl_descr_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_mkr_correl_descr_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_mkr_correl_descr_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_mkr_correl_descr_id() TO biomart_user;


--
-- Name: tf_trg_bio_observation_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_observation_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_observation_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_observation_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_observation_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_observation_id() TO biomart_user;


--
-- Name: tf_trg_bio_patient_event_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_patient_event_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_patient_event_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_patient_event_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_patient_event_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_patient_event_id() TO biomart_user;


--
-- Name: tf_trg_bio_patient_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_patient_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_patient_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_patient_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_patient_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_patient_id() TO biomart_user;


--
-- Name: tf_trg_bio_pt_evt_attr_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_pt_evt_attr_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_pt_evt_attr_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_pt_evt_attr_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_pt_evt_attr_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_pt_evt_attr_id() TO biomart_user;


--
-- Name: tf_trg_bio_sample_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_sample_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_sample_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_sample_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_sample_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_sample_id() TO biomart_user;


--
-- Name: tf_trg_bio_subject_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_subject_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_subject_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_subject_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_subject_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_subject_id() TO biomart_user;


--
-- Name: tf_trg_bio_taxon_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_bio_taxon_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_bio_taxon_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_bio_taxon_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_bio_taxon_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_bio_taxon_id() TO biomart_user;


--
-- Name: tf_trg_ctd2_clin_inhib_effect(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_ctd2_clin_inhib_effect() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_ctd2_clin_inhib_effect() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_clin_inhib_effect() TO biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_clin_inhib_effect() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_ctd2_clin_inhib_effect() TO biomart_user;


--
-- Name: tf_trg_ctd2_disease(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_ctd2_disease() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_ctd2_disease() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_disease() TO biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_disease() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_ctd2_disease() TO biomart_user;


--
-- Name: tf_trg_ctd2_inhib_details(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_ctd2_inhib_details() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_ctd2_inhib_details() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_inhib_details() TO biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_inhib_details() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_ctd2_inhib_details() TO biomart_user;


--
-- Name: tf_trg_ctd2_study_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_ctd2_study_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_ctd2_study_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_study_id() TO biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_study_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_ctd2_study_id() TO biomart_user;


--
-- Name: tf_trg_ctd2_trial_details(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trg_ctd2_trial_details() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_ctd2_trial_details() FROM biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_trial_details() TO biomart;
GRANT ALL ON FUNCTION tf_trg_ctd2_trial_details() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_ctd2_trial_details() TO biomart_user;


--
-- Name: tf_trig_clinical_trial_design_id(); Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON FUNCTION tf_trig_clinical_trial_design_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trig_clinical_trial_design_id() FROM biomart;
GRANT ALL ON FUNCTION tf_trig_clinical_trial_design_id() TO biomart;
GRANT ALL ON FUNCTION tf_trig_clinical_trial_design_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trig_clinical_trial_design_id() TO biomart_user;


SET search_path = biomart_user, pg_catalog;

--
-- Name: i2b2_bulk_add_search_term(bigint); Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON FUNCTION i2b2_bulk_add_search_term(currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_bulk_add_search_term(currentjobid bigint) FROM biomart_user;
GRANT ALL ON FUNCTION i2b2_bulk_add_search_term(currentjobid bigint) TO biomart_user;
GRANT ALL ON FUNCTION i2b2_bulk_add_search_term(currentjobid bigint) TO tm_cz;


--
-- Name: i2b2_metabolomics_zscore_calc(character varying, character varying, character varying, numeric, character varying, numeric); Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) FROM biomart_user;
GRANT ALL ON FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) TO biomart_user;
GRANT ALL ON FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) TO tm_cz;


--
-- Name: instr(character varying, character varying, character varying); Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON FUNCTION instr(character varying, character varying, character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION instr(character varying, character varying, character varying) FROM biomart_user;
GRANT ALL ON FUNCTION instr(character varying, character varying, character varying) TO biomart_user;
GRANT ALL ON FUNCTION instr(character varying, character varying, character varying) TO tm_cz;


--
-- Name: instr(character varying, character varying, integer, integer); Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON FUNCTION instr(string character varying, string_to_search character varying, beg_index integer, occur_index integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION instr(string character varying, string_to_search character varying, beg_index integer, occur_index integer) FROM biomart_user;
GRANT ALL ON FUNCTION instr(string character varying, string_to_search character varying, beg_index integer, occur_index integer) TO biomart_user;
GRANT ALL ON FUNCTION instr(string character varying, string_to_search character varying, beg_index integer, occur_index integer) TO tm_cz;


SET search_path = deapp, pg_catalog;

--
-- Name: dump_table_to_csv(character varying, character varying, character varying); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION dump_table_to_csv(p_tname character varying, p_dir character varying, p_filename character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION dump_table_to_csv(p_tname character varying, p_dir character varying, p_filename character varying) FROM deapp;
GRANT ALL ON FUNCTION dump_table_to_csv(p_tname character varying, p_dir character varying, p_filename character varying) TO deapp;
GRANT ALL ON FUNCTION dump_table_to_csv(p_tname character varying, p_dir character varying, p_filename character varying) TO tm_cz;
GRANT ALL ON FUNCTION dump_table_to_csv(p_tname character varying, p_dir character varying, p_filename character varying) TO biomart_user;


--
-- Name: i2b2_process_rna_seq_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, OUT rtn_code numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, OUT rtn_code numeric) FROM deapp;
GRANT ALL ON FUNCTION i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, OUT rtn_code numeric) TO deapp;
GRANT ALL ON FUNCTION i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, OUT rtn_code numeric) TO tm_cz;
GRANT ALL ON FUNCTION i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, OUT rtn_code numeric) TO biomart_user;


--
-- Name: protein_comparison_qry(character varying, character varying, character varying, character varying, refcursor); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION protein_comparison_qry(patient_ids character varying, sample_types character varying, pathway_uid1 character varying, timepoints character varying, INOUT cv_1 refcursor) FROM PUBLIC;
REVOKE ALL ON FUNCTION protein_comparison_qry(patient_ids character varying, sample_types character varying, pathway_uid1 character varying, timepoints character varying, INOUT cv_1 refcursor) FROM deapp;
GRANT ALL ON FUNCTION protein_comparison_qry(patient_ids character varying, sample_types character varying, pathway_uid1 character varying, timepoints character varying, INOUT cv_1 refcursor) TO deapp;
GRANT ALL ON FUNCTION protein_comparison_qry(patient_ids character varying, sample_types character varying, pathway_uid1 character varying, timepoints character varying, INOUT cv_1 refcursor) TO tm_cz;
GRANT ALL ON FUNCTION protein_comparison_qry(patient_ids character varying, sample_types character varying, pathway_uid1 character varying, timepoints character varying, INOUT cv_1 refcursor) TO biomart_user;


--
-- Name: protein_dbl_comp_qry(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, refcursor); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION protein_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, sample_types1 character varying, sample_types2 character varying, pathway_uid1 character varying, pathway_uid2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) FROM PUBLIC;
REVOKE ALL ON FUNCTION protein_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, sample_types1 character varying, sample_types2 character varying, pathway_uid1 character varying, pathway_uid2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) FROM deapp;
GRANT ALL ON FUNCTION protein_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, sample_types1 character varying, sample_types2 character varying, pathway_uid1 character varying, pathway_uid2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) TO deapp;
GRANT ALL ON FUNCTION protein_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, sample_types1 character varying, sample_types2 character varying, pathway_uid1 character varying, pathway_uid2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) TO tm_cz;
GRANT ALL ON FUNCTION protein_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, sample_types1 character varying, sample_types2 character varying, pathway_uid1 character varying, pathway_uid2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) TO biomart_user;


--
-- Name: rbm_comparison_qry(character varying, character varying, character varying, refcursor); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION rbm_comparison_qry(patient_ids character varying, concept_cds character varying, timepoints character varying, INOUT cv_1 refcursor) FROM PUBLIC;
REVOKE ALL ON FUNCTION rbm_comparison_qry(patient_ids character varying, concept_cds character varying, timepoints character varying, INOUT cv_1 refcursor) FROM deapp;
GRANT ALL ON FUNCTION rbm_comparison_qry(patient_ids character varying, concept_cds character varying, timepoints character varying, INOUT cv_1 refcursor) TO deapp;
GRANT ALL ON FUNCTION rbm_comparison_qry(patient_ids character varying, concept_cds character varying, timepoints character varying, INOUT cv_1 refcursor) TO tm_cz;
GRANT ALL ON FUNCTION rbm_comparison_qry(patient_ids character varying, concept_cds character varying, timepoints character varying, INOUT cv_1 refcursor) TO biomart_user;


--
-- Name: rbm_dbl_comp_qry(character varying, character varying, character varying, character varying, character varying, character varying, refcursor); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION rbm_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, concept_cds1 character varying, concept_cds2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) FROM PUBLIC;
REVOKE ALL ON FUNCTION rbm_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, concept_cds1 character varying, concept_cds2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) FROM deapp;
GRANT ALL ON FUNCTION rbm_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, concept_cds1 character varying, concept_cds2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) TO deapp;
GRANT ALL ON FUNCTION rbm_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, concept_cds1 character varying, concept_cds2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) TO tm_cz;
GRANT ALL ON FUNCTION rbm_dbl_comp_qry(patient_ids1 character varying, patient_ids2 character varying, concept_cds1 character varying, concept_cds2 character varying, timepoints1 character varying, timepoints2 character varying, INOUT cv_1 refcursor) TO biomart_user;


--
-- Name: tf_de_parent_cd_trg(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_de_parent_cd_trg() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_de_parent_cd_trg() FROM deapp;
GRANT ALL ON FUNCTION tf_de_parent_cd_trg() TO deapp;
GRANT ALL ON FUNCTION tf_de_parent_cd_trg() TO tm_cz;
GRANT ALL ON FUNCTION tf_de_parent_cd_trg() TO biomart_user;


--
-- Name: tf_rbm_id_trigger(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_rbm_id_trigger() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_rbm_id_trigger() FROM deapp;
GRANT ALL ON FUNCTION tf_rbm_id_trigger() TO deapp;
GRANT ALL ON FUNCTION tf_rbm_id_trigger() TO tm_cz;
GRANT ALL ON FUNCTION tf_rbm_id_trigger() TO biomart_user;


--
-- Name: tf_trg_de_mrna_annotation_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_mrna_annotation_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_mrna_annotation_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_mrna_annotation_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_mrna_annotation_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_de_mrna_annotation_id() TO biomart_user;


--
-- Name: tf_trg_de_pathway_gene_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_pathway_gene_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_pathway_gene_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_pathway_gene_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_pathway_gene_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_de_pathway_gene_id() TO biomart_user;


--
-- Name: tf_trg_de_pathway_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_pathway_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_pathway_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_pathway_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_pathway_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_de_pathway_id() TO biomart_user;


--
-- Name: tf_trg_de_snp_info_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_snp_info_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_snp_info_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_snp_info_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_snp_info_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_de_snp_info_id() TO biomart_user;


--
-- Name: tf_trg_de_snp_probe_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_snp_probe_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_snp_probe_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_snp_probe_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_snp_probe_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_de_snp_probe_id() TO biomart_user;


--
-- Name: tf_trg_de_snp_probe_sorted_def_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_snp_probe_sorted_def_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_snp_probe_sorted_def_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_snp_probe_sorted_def_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_snp_probe_sorted_def_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_de_snp_probe_sorted_def_id() TO biomart_user;


--
-- Name: tf_trg_de_subj_rbm_data_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_subj_rbm_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_subj_rbm_data_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_subj_rbm_data_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_subj_rbm_data_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_de_subj_rbm_data_id() TO biomart_user;


--
-- Name: tf_trg_de_subject_snp_dataset_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_subject_snp_dataset_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_subject_snp_dataset_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_subject_snp_dataset_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_subject_snp_dataset_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_de_subject_snp_dataset_id() TO biomart_user;


--
-- Name: tf_trg_de_subject_sorted_def_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_de_subject_sorted_def_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_de_subject_sorted_def_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_de_subject_sorted_def_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_de_subject_sorted_def_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_de_subject_sorted_def_id() TO biomart_user;


--
-- Name: tf_trg_snp_data_by_patient_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_snp_data_by_patient_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_snp_data_by_patient_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_snp_data_by_patient_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_snp_data_by_patient_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_snp_data_by_patient_id() TO biomart_user;


--
-- Name: tf_trg_snp_data_by_pprobe_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_snp_data_by_pprobe_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_snp_data_by_pprobe_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_snp_data_by_pprobe_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_snp_data_by_pprobe_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_snp_data_by_pprobe_id() TO biomart_user;


--
-- Name: tf_trg_snp_data_dataset_loc_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_snp_data_dataset_loc_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_snp_data_dataset_loc_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_snp_data_dataset_loc_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_snp_data_dataset_loc_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_snp_data_dataset_loc_id() TO biomart_user;


--
-- Name: tf_trg_snp_subject_sorted_def_id(); Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON FUNCTION tf_trg_snp_subject_sorted_def_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_snp_subject_sorted_def_id() FROM deapp;
GRANT ALL ON FUNCTION tf_trg_snp_subject_sorted_def_id() TO deapp;
GRANT ALL ON FUNCTION tf_trg_snp_subject_sorted_def_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_snp_subject_sorted_def_id() TO biomart_user;


SET search_path = fmapp, pg_catalog;

--
-- Name: fm_file_uid(character varying); Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON FUNCTION fm_file_uid(file_id character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION fm_file_uid(file_id character varying) FROM fmapp;
GRANT ALL ON FUNCTION fm_file_uid(file_id character varying) TO fmapp;
GRANT ALL ON FUNCTION fm_file_uid(file_id character varying) TO tm_cz;
GRANT ALL ON FUNCTION fm_file_uid(file_id character varying) TO biomart_user;


--
-- Name: fm_folder_uid(numeric); Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON FUNCTION fm_folder_uid(folder_id numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION fm_folder_uid(folder_id numeric) FROM fmapp;
GRANT ALL ON FUNCTION fm_folder_uid(folder_id numeric) TO fmapp;
GRANT ALL ON FUNCTION fm_folder_uid(folder_id numeric) TO tm_cz;
GRANT ALL ON FUNCTION fm_folder_uid(folder_id numeric) TO biomart_user;


--
-- Name: fm_get_folder_full_name(bigint); Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON FUNCTION fm_get_folder_full_name(p_folder_id bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION fm_get_folder_full_name(p_folder_id bigint) FROM fmapp;
GRANT ALL ON FUNCTION fm_get_folder_full_name(p_folder_id bigint) TO fmapp;
GRANT ALL ON FUNCTION fm_get_folder_full_name(p_folder_id bigint) TO tm_cz;
GRANT ALL ON FUNCTION fm_get_folder_full_name(p_folder_id bigint) TO biomart_user;


--
-- Name: fm_update_folder_full_name(); Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON FUNCTION fm_update_folder_full_name() FROM PUBLIC;
REVOKE ALL ON FUNCTION fm_update_folder_full_name() FROM fmapp;
GRANT ALL ON FUNCTION fm_update_folder_full_name() TO fmapp;
GRANT ALL ON FUNCTION fm_update_folder_full_name() TO tm_cz;
GRANT ALL ON FUNCTION fm_update_folder_full_name() TO biomart_user;


--
-- Name: tf_trg_fm_file_id(); Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON FUNCTION tf_trg_fm_file_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_fm_file_id() FROM fmapp;
GRANT ALL ON FUNCTION tf_trg_fm_file_id() TO fmapp;
GRANT ALL ON FUNCTION tf_trg_fm_file_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_fm_file_id() TO biomart_user;


--
-- Name: tf_trg_fm_file_uid(); Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON FUNCTION tf_trg_fm_file_uid() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_fm_file_uid() FROM fmapp;
GRANT ALL ON FUNCTION tf_trg_fm_file_uid() TO fmapp;
GRANT ALL ON FUNCTION tf_trg_fm_file_uid() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_fm_file_uid() TO biomart_user;


--
-- Name: tf_trg_fm_folder_id(); Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON FUNCTION tf_trg_fm_folder_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_fm_folder_id() FROM fmapp;
GRANT ALL ON FUNCTION tf_trg_fm_folder_id() TO fmapp;
GRANT ALL ON FUNCTION tf_trg_fm_folder_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_fm_folder_id() TO biomart_user;


--
-- Name: tf_trg_fm_folder_uid(); Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON FUNCTION tf_trg_fm_folder_uid() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_fm_folder_uid() FROM fmapp;
GRANT ALL ON FUNCTION tf_trg_fm_folder_uid() TO fmapp;
GRANT ALL ON FUNCTION tf_trg_fm_folder_uid() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_fm_folder_uid() TO biomart_user;


SET search_path = i2b2demodata, pg_catalog;

--
-- Name: create_temp_concept_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION create_temp_concept_table(tempconcepttablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_eid_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION create_temp_eid_table(temppatientmappingtablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_modifier_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_modifier_table(tempmodifiertablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_modifier_table(tempmodifiertablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_modifier_table(tempmodifiertablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_modifier_table(tempmodifiertablename character varying, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION create_temp_modifier_table(tempmodifiertablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_patient_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION create_temp_patient_table(temppatientdimensiontablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_pid_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION create_temp_pid_table(temppatientmappingtablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_provider_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION create_temp_provider_table(tempprovidertablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_table(temptablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_table(temptablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_table(temptablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_table(temptablename character varying, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION create_temp_table(temptablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: create_temp_visit_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION create_temp_visit_table(temptablename character varying, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_temp_visit_table(temptablename character varying, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION create_temp_visit_table(temptablename character varying, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION create_temp_visit_table(temptablename character varying, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION create_temp_visit_table(temptablename character varying, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_concept_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION insert_concept_fromtemp(tempconcepttablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_eid_map_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION insert_eid_map_fromtemp(tempeidtablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_encountervisit_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION insert_encountervisit_fromtemp(temptablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_modifier_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION insert_modifier_fromtemp(tempmodifiertablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_patient_map_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION insert_patient_map_fromtemp(temppatienttablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_pid_map_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION insert_pid_map_fromtemp(temppidtablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: insert_provider_fromtemp(character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION insert_provider_fromtemp(tempprovidertablename character varying, upload_id numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: remove_temp_table(character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION remove_temp_table(temptablename character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION remove_temp_table(temptablename character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION remove_temp_table(temptablename character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION remove_temp_table(temptablename character varying) TO tm_cz;
GRANT ALL ON FUNCTION remove_temp_table(temptablename character varying) TO biomart_user;


--
-- Name: sp_xtab(character varying, integer, character varying); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION sp_xtab(v_variable character varying, v_protocol integer, v_subject character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION sp_xtab(v_variable character varying, v_protocol integer, v_subject character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION sp_xtab(v_variable character varying, v_protocol integer, v_subject character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION sp_xtab(v_variable character varying, v_protocol integer, v_subject character varying) TO tm_cz;
GRANT ALL ON FUNCTION sp_xtab(v_variable character varying, v_protocol integer, v_subject character varying) TO biomart_user;


--
-- Name: sync_clear_concept_table(character varying, character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION sync_clear_concept_table(tempconcepttablename character varying, backupconcepttablename character varying, uploadid numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: sync_clear_modifier_table(character varying, character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION sync_clear_modifier_table(tempmodifiertablename character varying, backupmodifiertablename character varying, uploadid numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION sync_clear_modifier_table(tempmodifiertablename character varying, backupmodifiertablename character varying, uploadid numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION sync_clear_modifier_table(tempmodifiertablename character varying, backupmodifiertablename character varying, uploadid numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION sync_clear_modifier_table(tempmodifiertablename character varying, backupmodifiertablename character varying, uploadid numeric, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION sync_clear_modifier_table(tempmodifiertablename character varying, backupmodifiertablename character varying, uploadid numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: sync_clear_provider_table(character varying, character varying, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION sync_clear_provider_table(tempprovidertablename character varying, backupprovidertablename character varying, uploadid numeric, OUT errormsg character varying) TO biomart_user;


--
-- Name: tf_trg_concept_dimension_cd(); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION tf_trg_concept_dimension_cd() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_concept_dimension_cd() FROM i2b2demodata;
GRANT ALL ON FUNCTION tf_trg_concept_dimension_cd() TO i2b2demodata;
GRANT ALL ON FUNCTION tf_trg_concept_dimension_cd() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_concept_dimension_cd() TO biomart_user;


--
-- Name: tf_trg_encounter_num(); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION tf_trg_encounter_num() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_encounter_num() FROM i2b2demodata;
GRANT ALL ON FUNCTION tf_trg_encounter_num() TO i2b2demodata;
GRANT ALL ON FUNCTION tf_trg_encounter_num() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_encounter_num() TO biomart_user;


--
-- Name: tf_trg_patient_dimension(); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION tf_trg_patient_dimension() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_patient_dimension() FROM i2b2demodata;
GRANT ALL ON FUNCTION tf_trg_patient_dimension() TO i2b2demodata;
GRANT ALL ON FUNCTION tf_trg_patient_dimension() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_patient_dimension() TO biomart_user;


--
-- Name: update_observation_fact(character varying, numeric, numeric); Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON FUNCTION update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) FROM i2b2demodata;
GRANT ALL ON FUNCTION update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) TO i2b2demodata;
GRANT ALL ON FUNCTION update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) TO tm_cz;
GRANT ALL ON FUNCTION update_observation_fact(upload_temptable_name character varying, upload_id numeric, appendflag numeric, OUT errormsg character varying) TO biomart_user;


SET search_path = i2b2metadata, pg_catalog;

--
-- Name: add_ontology_node(character varying, character varying, character varying, character varying, character varying); Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON FUNCTION add_ontology_node(parent_path_src character varying, node_name character varying, is_leaf_src character varying, is_number character varying, prefix character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION add_ontology_node(parent_path_src character varying, node_name character varying, is_leaf_src character varying, is_number character varying, prefix character varying) FROM i2b2metadata;
GRANT ALL ON FUNCTION add_ontology_node(parent_path_src character varying, node_name character varying, is_leaf_src character varying, is_number character varying, prefix character varying) TO i2b2metadata;
GRANT ALL ON FUNCTION add_ontology_node(parent_path_src character varying, node_name character varying, is_leaf_src character varying, is_number character varying, prefix character varying) TO tm_cz;
GRANT ALL ON FUNCTION add_ontology_node(parent_path_src character varying, node_name character varying, is_leaf_src character varying, is_number character varying, prefix character varying) TO biomart_user;


--
-- Name: tf_trg_i2b2_id(); Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON FUNCTION tf_trg_i2b2_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_i2b2_id() FROM i2b2metadata;
GRANT ALL ON FUNCTION tf_trg_i2b2_id() TO i2b2metadata;
GRANT ALL ON FUNCTION tf_trg_i2b2_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_i2b2_id() TO biomart_user;


--
-- Name: tf_trg_i2b2_tag_id(); Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON FUNCTION tf_trg_i2b2_tag_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_i2b2_tag_id() FROM i2b2metadata;
GRANT ALL ON FUNCTION tf_trg_i2b2_tag_id() TO i2b2metadata;
GRANT ALL ON FUNCTION tf_trg_i2b2_tag_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_i2b2_tag_id() TO biomart_user;


--
-- Name: tf_trg_i2b2_tags_tag_id(); Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON FUNCTION tf_trg_i2b2_tags_tag_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_i2b2_tags_tag_id() FROM i2b2metadata;
GRANT ALL ON FUNCTION tf_trg_i2b2_tags_tag_id() TO i2b2metadata;
GRANT ALL ON FUNCTION tf_trg_i2b2_tags_tag_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_i2b2_tags_tag_id() TO biomart_user;


SET search_path = searchapp, pg_catalog;

--
-- Name: bio_clinical_trial_uid(character varying, character varying, character varying); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION bio_clinical_trial_uid(trial_number character varying, title character varying, condition character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_clinical_trial_uid(trial_number character varying, title character varying, condition character varying) FROM searchapp;
GRANT ALL ON FUNCTION bio_clinical_trial_uid(trial_number character varying, title character varying, condition character varying) TO searchapp;
GRANT ALL ON FUNCTION bio_clinical_trial_uid(trial_number character varying, title character varying, condition character varying) TO tm_cz;
GRANT ALL ON FUNCTION bio_clinical_trial_uid(trial_number character varying, title character varying, condition character varying) TO biomart_user;


--
-- Name: bio_compound_uid(character varying, character varying, character varying); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) FROM searchapp;
GRANT ALL ON FUNCTION bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) TO searchapp;
GRANT ALL ON FUNCTION bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) TO tm_cz;
GRANT ALL ON FUNCTION bio_compound_uid(cas_registry character varying, jnj_number character varying, cnto_number character varying) TO biomart_user;


--
-- Name: refresh_search_bio_mkr_correl_fast_mv(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION refresh_search_bio_mkr_correl_fast_mv() FROM PUBLIC;
REVOKE ALL ON FUNCTION refresh_search_bio_mkr_correl_fast_mv() FROM searchapp;
GRANT ALL ON FUNCTION refresh_search_bio_mkr_correl_fast_mv() TO searchapp;
GRANT ALL ON FUNCTION refresh_search_bio_mkr_correl_fast_mv() TO tm_cz;
GRANT ALL ON FUNCTION refresh_search_bio_mkr_correl_fast_mv() TO biomart_user;


--
-- Name: tf_trg_saved_faceted_search_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_saved_faceted_search_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_saved_faceted_search_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_saved_faceted_search_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_saved_faceted_search_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_saved_faceted_search_id() TO biomart_user;


--
-- Name: tf_trg_search_a_u_sec_access_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_search_a_u_sec_access_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_search_a_u_sec_access_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_search_a_u_sec_access_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_search_a_u_sec_access_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_search_a_u_sec_access_id() TO biomart_user;


--
-- Name: tf_trg_search_au_obj_access_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_search_au_obj_access_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_search_au_obj_access_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_search_au_obj_access_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_search_au_obj_access_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_search_au_obj_access_id() TO biomart_user;


--
-- Name: tf_trg_search_au_prcpl_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_search_au_prcpl_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_search_au_prcpl_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_search_au_prcpl_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_search_au_prcpl_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_search_au_prcpl_id() TO biomart_user;


--
-- Name: tf_trg_search_cust_fil_item_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_search_cust_fil_item_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_search_cust_fil_item_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_search_cust_fil_item_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_search_cust_fil_item_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_search_cust_fil_item_id() TO biomart_user;


--
-- Name: tf_trg_search_custom_filter_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_search_custom_filter_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_search_custom_filter_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_search_custom_filter_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_search_custom_filter_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_search_custom_filter_id() TO biomart_user;


--
-- Name: tf_trg_search_keyword_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_search_keyword_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_search_keyword_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_search_keyword_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_search_keyword_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_search_keyword_id() TO biomart_user;


--
-- Name: tf_trg_search_keyword_term_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_search_keyword_term_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_search_keyword_term_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_search_keyword_term_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_search_keyword_term_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_search_keyword_term_id() TO biomart_user;


--
-- Name: tf_trg_search_sec_acc_level_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_search_sec_acc_level_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_search_sec_acc_level_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_search_sec_acc_level_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_search_sec_acc_level_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_search_sec_acc_level_id() TO biomart_user;


--
-- Name: tf_trg_search_sec_obj_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_search_sec_obj_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_search_sec_obj_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_search_sec_obj_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_search_sec_obj_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_search_sec_obj_id() TO biomart_user;


--
-- Name: tf_trg_search_sec_obj_path_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_search_sec_obj_path_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_search_sec_obj_path_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_search_sec_obj_path_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_search_sec_obj_path_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_search_sec_obj_path_id() TO biomart_user;


--
-- Name: tf_trg_search_taxonomy_rels_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_search_taxonomy_rels_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_search_taxonomy_rels_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_search_taxonomy_rels_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_search_taxonomy_rels_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_search_taxonomy_rels_id() TO biomart_user;


--
-- Name: tf_trg_search_taxonomy_term_id(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_search_taxonomy_term_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_search_taxonomy_term_id() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_search_taxonomy_term_id() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_search_taxonomy_term_id() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_search_taxonomy_term_id() TO biomart_user;


--
-- Name: tf_trg_upd_saved_faceted_search(); Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON FUNCTION tf_trg_upd_saved_faceted_search() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_upd_saved_faceted_search() FROM searchapp;
GRANT ALL ON FUNCTION tf_trg_upd_saved_faceted_search() TO searchapp;
GRANT ALL ON FUNCTION tf_trg_upd_saved_faceted_search() TO tm_cz;
GRANT ALL ON FUNCTION tf_trg_upd_saved_faceted_search() TO biomart_user;


SET search_path = tm_cz, pg_catalog;

--
-- Name: _final_median(anyarray); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION _final_median(anyarray) FROM PUBLIC;
REVOKE ALL ON FUNCTION _final_median(anyarray) FROM tm_cz;
GRANT ALL ON FUNCTION _final_median(anyarray) TO tm_cz;


--
-- Name: _final_median(double precision[]); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION _final_median(double precision[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION _final_median(double precision[]) FROM tm_cz;
GRANT ALL ON FUNCTION _final_median(double precision[]) TO tm_cz;


--
-- Name: bio_assay_analysis_uid(bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION bio_assay_analysis_uid(analysis_id bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_assay_analysis_uid(analysis_id bigint) FROM tm_cz;
GRANT ALL ON FUNCTION bio_assay_analysis_uid(analysis_id bigint) TO tm_cz;


--
-- Name: bio_assay_analysis_uid(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION bio_assay_analysis_uid(analysis_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_assay_analysis_uid(analysis_name character varying) FROM tm_cz;
GRANT ALL ON FUNCTION bio_assay_analysis_uid(analysis_name character varying) TO tm_cz;


--
-- Name: bio_assay_platform_uid(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION bio_assay_platform_uid(platform_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_assay_platform_uid(platform_name character varying) FROM tm_cz;
GRANT ALL ON FUNCTION bio_assay_platform_uid(platform_name character varying) TO tm_cz;


--
-- Name: bio_asy_analysis_pltfm_uid(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name character varying) FROM tm_cz;
GRANT ALL ON FUNCTION bio_asy_analysis_pltfm_uid(platform_name character varying) TO tm_cz;


--
-- Name: bio_compound_uid(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION bio_compound_uid(jnj_number character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_compound_uid(jnj_number character varying) FROM tm_cz;
GRANT ALL ON FUNCTION bio_compound_uid(jnj_number character varying) TO tm_cz;


--
-- Name: bio_curation_dataset_uid(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type character varying) FROM tm_cz;
GRANT ALL ON FUNCTION bio_curation_dataset_uid(bio_curation_type character varying) TO tm_cz;


--
-- Name: bio_disease_uid(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION bio_disease_uid(mesh_code character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_disease_uid(mesh_code character varying) FROM tm_cz;
GRANT ALL ON FUNCTION bio_disease_uid(mesh_code character varying) TO tm_cz;


--
-- Name: bio_experiment_uid(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION bio_experiment_uid(primary_id character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_experiment_uid(primary_id character varying) FROM tm_cz;
GRANT ALL ON FUNCTION bio_experiment_uid(primary_id character varying) TO tm_cz;


--
-- Name: bio_jub_oncol_data_uid(numeric, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION bio_jub_oncol_data_uid(record_id numeric, bio_curation_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_jub_oncol_data_uid(record_id numeric, bio_curation_name character varying) FROM tm_cz;
GRANT ALL ON FUNCTION bio_jub_oncol_data_uid(record_id numeric, bio_curation_name character varying) TO tm_cz;


--
-- Name: bio_jub_oncol_sum_data_uid(numeric, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id numeric, bio_curation_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id numeric, bio_curation_name character varying) FROM tm_cz;
GRANT ALL ON FUNCTION bio_jub_oncol_sum_data_uid(record_id numeric, bio_curation_name character varying) TO tm_cz;


--
-- Name: biomarker_gene_uid(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION biomarker_gene_uid(gene_id character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION biomarker_gene_uid(gene_id character varying) FROM tm_cz;
GRANT ALL ON FUNCTION biomarker_gene_uid(gene_id character varying) TO tm_cz;


--
-- Name: biomarker_pathway_uid(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION biomarker_pathway_uid(p_source character varying, pathway_id character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION biomarker_pathway_uid(p_source character varying, pathway_id character varying) FROM tm_cz;
GRANT ALL ON FUNCTION biomarker_pathway_uid(p_source character varying, pathway_id character varying) TO tm_cz;


--
-- Name: create_synonyms(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION create_synonyms(fromdb character varying, todb character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION create_synonyms(fromdb character varying, todb character varying) FROM tm_cz;
GRANT ALL ON FUNCTION create_synonyms(fromdb character varying, todb character varying) TO tm_cz;


--
-- Name: cum_normal_dist(double precision, double precision, double precision); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION cum_normal_dist(foldchg double precision, mu double precision, sigma double precision) FROM PUBLIC;
REVOKE ALL ON FUNCTION cum_normal_dist(foldchg double precision, mu double precision, sigma double precision) FROM tm_cz;
GRANT ALL ON FUNCTION cum_normal_dist(foldchg double precision, mu double precision, sigma double precision) TO tm_cz;


--
-- Name: cz_audit_example(bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION cz_audit_example(currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION cz_audit_example(currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION cz_audit_example(currentjobid bigint) TO tm_cz;


--
-- Name: cz_end_audit(numeric, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION cz_end_audit(jobid numeric, jobstatus character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION cz_end_audit(jobid numeric, jobstatus character varying) FROM tm_cz;
GRANT ALL ON FUNCTION cz_end_audit(jobid numeric, jobstatus character varying) TO tm_cz;


--
-- Name: cz_error_handler(numeric, character varying, character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION cz_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION cz_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) FROM tm_cz;
GRANT ALL ON FUNCTION cz_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) TO tm_cz;


--
-- Name: cz_info_handler(numeric, numeric, numeric, character varying, character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION cz_info_handler(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying, stepnumber character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION cz_info_handler(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying, stepnumber character varying) FROM tm_cz;
GRANT ALL ON FUNCTION cz_info_handler(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying, stepnumber character varying) TO tm_cz;


--
-- Name: cz_start_audit(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION cz_start_audit(jobname character varying, databasename character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION cz_start_audit(jobname character varying, databasename character varying) FROM tm_cz;
GRANT ALL ON FUNCTION cz_start_audit(jobname character varying, databasename character varying) TO tm_cz;


--
-- Name: cz_start_audit(character varying, character varying, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION cz_start_audit(jobname character varying, databasename character varying, jobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION cz_start_audit(jobname character varying, databasename character varying, jobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION cz_start_audit(jobname character varying, databasename character varying, jobid bigint) TO tm_cz;


--
-- Name: cz_write_audit(numeric, character varying, character varying, character varying, numeric, numeric, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION cz_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION cz_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) FROM tm_cz;
GRANT ALL ON FUNCTION cz_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) TO tm_cz;


--
-- Name: cz_write_error(numeric, character varying, character varying, character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION cz_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION cz_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) FROM tm_cz;
GRANT ALL ON FUNCTION cz_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) TO tm_cz;


--
-- Name: cz_write_info(numeric, numeric, numeric, character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION cz_write_info(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION cz_write_info(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying) FROM tm_cz;
GRANT ALL ON FUNCTION cz_write_info(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying) TO tm_cz;


--
-- Name: czf_init_cap(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czf_init_cap(text_to_parse character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION czf_init_cap(text_to_parse character varying) FROM tm_cz;
GRANT ALL ON FUNCTION czf_init_cap(text_to_parse character varying) TO tm_cz;


--
-- Name: czf_num_occurances(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czf_num_occurances(input_str character varying, search_str character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION czf_num_occurances(input_str character varying, search_str character varying) FROM tm_cz;
GRANT ALL ON FUNCTION czf_num_occurances(input_str character varying, search_str character varying) TO tm_cz;


--
-- Name: czf_parse_nth_value(character varying, numeric, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czf_parse_nth_value(pvalue character varying, location numeric, delimiter character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION czf_parse_nth_value(pvalue character varying, location numeric, delimiter character varying) FROM tm_cz;
GRANT ALL ON FUNCTION czf_parse_nth_value(pvalue character varying, location numeric, delimiter character varying) TO tm_cz;


--
-- Name: czx_array_sort(anyarray); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czx_array_sort(anyarray) FROM PUBLIC;
REVOKE ALL ON FUNCTION czx_array_sort(anyarray) FROM tm_cz;
GRANT ALL ON FUNCTION czx_array_sort(anyarray) TO tm_cz;


--
-- Name: czx_end_audit(numeric, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czx_end_audit(jobid numeric, jobstatus character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION czx_end_audit(jobid numeric, jobstatus character varying) FROM tm_cz;
GRANT ALL ON FUNCTION czx_end_audit(jobid numeric, jobstatus character varying) TO tm_cz;


--
-- Name: czx_error_handler(numeric, character varying, character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czx_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION czx_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) FROM tm_cz;
GRANT ALL ON FUNCTION czx_error_handler(jobid numeric, procedurename character varying, errornumber character varying, errormessage character varying) TO tm_cz;


--
-- Name: czx_info_handler(numeric, numeric, numeric, character varying, character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czx_info_handler(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying, stepnumber character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION czx_info_handler(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying, stepnumber character varying) FROM tm_cz;
GRANT ALL ON FUNCTION czx_info_handler(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying, stepnumber character varying) TO tm_cz;


--
-- Name: czx_percentile_cont(real[], real); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czx_percentile_cont(myarray real[], percentile real) FROM PUBLIC;
REVOKE ALL ON FUNCTION czx_percentile_cont(myarray real[], percentile real) FROM tm_cz;
GRANT ALL ON FUNCTION czx_percentile_cont(myarray real[], percentile real) TO tm_cz;


--
-- Name: czx_start_audit(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czx_start_audit(jobname character varying, databasename character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION czx_start_audit(jobname character varying, databasename character varying) FROM tm_cz;
GRANT ALL ON FUNCTION czx_start_audit(jobname character varying, databasename character varying) TO tm_cz;


--
-- Name: czx_table_index_maint(character varying, character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czx_table_index_maint(p_run_type character varying, p_schema character varying, p_table character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION czx_table_index_maint(p_run_type character varying, p_schema character varying, p_table character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION czx_table_index_maint(p_run_type character varying, p_schema character varying, p_table character varying, currentjobid numeric) TO tm_cz;


--
-- Name: czx_write_audit(numeric, character varying, character varying, character varying, numeric, numeric, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czx_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION czx_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) FROM tm_cz;
GRANT ALL ON FUNCTION czx_write_audit(jobid numeric, databasename character varying, procedurename character varying, stepdesc character varying, recordsmanipulated numeric, stepnumber numeric, stepstatus character varying) TO tm_cz;


--
-- Name: czx_write_error(numeric, character varying, character varying, character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czx_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION czx_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) FROM tm_cz;
GRANT ALL ON FUNCTION czx_write_error(jobid numeric, errornumber character varying, errormessage character varying, errorstack character varying, errorbacktrace character varying) TO tm_cz;


--
-- Name: czx_write_info(numeric, numeric, numeric, character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION czx_write_info(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION czx_write_info(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying) FROM tm_cz;
GRANT ALL ON FUNCTION czx_write_info(jobid numeric, messageid numeric, messageline numeric, messageprocedure character varying, infomessage character varying) TO tm_cz;


--
-- Name: data_export(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION data_export() FROM PUBLIC;
REVOKE ALL ON FUNCTION data_export() FROM tm_cz;
GRANT ALL ON FUNCTION data_export() TO tm_cz;


--
-- Name: drop_table(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION drop_table(tabowner character varying, tabname character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION drop_table(tabowner character varying, tabname character varying) FROM tm_cz;
GRANT ALL ON FUNCTION drop_table(tabowner character varying, tabname character varying) TO tm_cz;


--
-- Name: dropsyn(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION dropsyn() FROM PUBLIC;
REVOKE ALL ON FUNCTION dropsyn() FROM tm_cz;
GRANT ALL ON FUNCTION dropsyn() TO tm_cz;


--
-- Name: find_user(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION find_user(user_type character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION find_user(user_type character varying) FROM tm_cz;
GRANT ALL ON FUNCTION find_user(user_type character varying) TO tm_cz;


--
-- Name: fract_error_dist(double precision); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION fract_error_dist(norminput double precision) FROM PUBLIC;
REVOKE ALL ON FUNCTION fract_error_dist(norminput double precision) FROM tm_cz;
GRANT ALL ON FUNCTION fract_error_dist(norminput double precision) TO tm_cz;


--
-- Name: i2b2_add_node(character varying, character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_add_node(trialid character varying, path character varying, path_name character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_add_node(trialid character varying, path character varying, path_name character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_add_node(trialid character varying, path character varying, path_name character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_add_root_node(character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_add_root_node(root_node character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_add_root_node(root_node character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_add_root_node(root_node character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_add_snp_biomarker_nodes(character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_add_snp_biomarker_nodes(trial_id character varying, ont_path character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_add_snp_biomarker_nodes(trial_id character varying, ont_path character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_add_snp_biomarker_nodes(trial_id character varying, ont_path character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_backout_trial(character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: postgres
--

REVOKE ALL ON FUNCTION i2b2_backout_trial(trialid character varying, path_string character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_backout_trial(trialid character varying, path_string character varying, currentjobid numeric) FROM postgres;
GRANT ALL ON FUNCTION i2b2_backout_trial(trialid character varying, path_string character varying, currentjobid numeric) TO postgres;
GRANT ALL ON FUNCTION i2b2_backout_trial(trialid character varying, path_string character varying, currentjobid numeric) TO PUBLIC;
GRANT ALL ON FUNCTION i2b2_backout_trial(trialid character varying, path_string character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_bulk_add_search_term(bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_bulk_add_search_term(currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_bulk_add_search_term(currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_bulk_add_search_term(currentjobid bigint) TO tm_cz;


--
-- Name: i2b2_create_concept_counts(character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_create_concept_counts(path character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_create_concept_counts(path character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_create_concept_counts(path character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_create_external_tables(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_create_external_tables(tpmextfn character varying, catgextfn character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_create_external_tables(tpmextfn character varying, catgextfn character varying) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_create_external_tables(tpmextfn character varying, catgextfn character varying) TO tm_cz;


--
-- Name: i2b2_create_security_for_trial(character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_create_security_for_trial(trial_id character varying, secured_study character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_create_security_for_trial(trial_id character varying, secured_study character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_create_security_for_trial(trial_id character varying, secured_study character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_create_stage_tables(bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_create_stage_tables(bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_create_stage_tables(bigint) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_create_stage_tables(bigint) TO tm_cz;


--
-- Name: i2b2_delete_1_node(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_delete_1_node(path character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_delete_1_node(path character varying) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_delete_1_node(path character varying) TO tm_cz;


--
-- Name: i2b2_delete_all_nodes(character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_delete_all_nodes(path character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_delete_all_nodes(path character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_delete_all_nodes(path character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_extend_clinical_data(character varying, character varying, character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_extend_clinical_data(trial_id character varying, top_node character varying, secure_study character varying, highlight_study character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_extend_clinical_data(trial_id character varying, top_node character varying, secure_study character varying, highlight_study character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_extend_clinical_data(trial_id character varying, top_node character varying, secure_study character varying, highlight_study character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_fill_in_tree(character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_fill_in_tree(trial_id character varying, path character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_fill_in_tree(trial_id character varying, path character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_fill_in_tree(trial_id character varying, path character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_hide_node(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_hide_node(path character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_hide_node(path character varying) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_hide_node(path character varying) TO tm_cz;


--
-- Name: i2b2_link_additional_data(bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_link_additional_data(bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_link_additional_data(bigint) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_link_additional_data(bigint) TO tm_cz;


--
-- Name: i2b2_load_annotation_deapp(numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_annotation_deapp(currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_annotation_deapp(currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_annotation_deapp(currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_load_chrom_region(character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_chrom_region(platform_title character varying, genome_release character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_chrom_region(platform_title character varying, genome_release character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_chrom_region(platform_title character varying, genome_release character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_load_clinical_data(character varying, character varying, character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_clinical_data(trial_id character varying, top_node character varying, secure_study character varying, highlight_study character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_clinical_data(trial_id character varying, top_node character varying, secure_study character varying, highlight_study character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_clinical_data(trial_id character varying, top_node character varying, secure_study character varying, highlight_study character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_load_eqtl_top50(numeric, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_eqtl_top50(i_bio_assay_analysis_id numeric, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_eqtl_top50(i_bio_assay_analysis_id numeric, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_eqtl_top50(i_bio_assay_analysis_id numeric, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_load_from_stage(character varying, character varying, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_from_stage(character varying, character varying, bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_from_stage(character varying, character varying, bigint) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_from_stage(character varying, character varying, bigint) TO tm_cz;


--
-- Name: i2b2_load_gwas_top50(numeric, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_gwas_top50(i_bio_assay_analysis_id numeric, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_gwas_top50(i_bio_assay_analysis_id numeric, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_gwas_top50(i_bio_assay_analysis_id numeric, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_load_metabolomics_annot(numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_metabolomics_annot(currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_metabolomics_annot(currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_metabolomics_annot(currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_load_mirna_annot_deapp(numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_mirna_annot_deapp(currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_mirna_annot_deapp(currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_mirna_annot_deapp(currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_load_omicsoft_annot(bigint, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_omicsoft_annot(analysis_id bigint, i_job_id bigint, OUT rtn_code bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_omicsoft_annot(analysis_id bigint, i_job_id bigint, OUT rtn_code bigint) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_omicsoft_annot(analysis_id bigint, i_job_id bigint, OUT rtn_code bigint) TO tm_cz;


--
-- Name: i2b2_load_proteomics_annot(numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_proteomics_annot(currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_proteomics_annot(currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_proteomics_annot(currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_load_rbm_annotation(bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_rbm_annotation(currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_rbm_annotation(currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_rbm_annotation(currentjobid bigint) TO tm_cz;


--
-- Name: i2b2_load_rbm_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_rbm_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base numeric, secure_study character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_rbm_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base numeric, secure_study character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_rbm_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base numeric, secure_study character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_load_sample_categories(bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_sample_categories(currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_sample_categories(currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_sample_categories(currentjobid bigint) TO tm_cz;


--
-- Name: i2b2_load_security_data(numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_security_data(currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_security_data(currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_security_data(currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_load_security_data(character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_security_data(sourcesystemcd character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_security_data(sourcesystemcd character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_security_data(sourcesystemcd character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_load_study_metadata(numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_load_study_metadata(currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_load_study_metadata(currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_load_study_metadata(currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_metabolomics_zscore_calc(character varying, character varying, character varying, numeric, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) TO tm_cz;


--
-- Name: i2b2_metabolomics_zscore_calc(character varying, character varying, character varying, numeric, character varying, character varying, numeric, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_metabolomics_zscore_calc(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) TO tm_cz;


--
-- Name: i2b2_mirna_zscore_calc(character varying, character varying, numeric, character varying, numeric, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_mirna_zscore_calc(trial_id character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric, source_cd character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_mirna_zscore_calc(trial_id character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric, source_cd character varying) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_mirna_zscore_calc(trial_id character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric, source_cd character varying) TO tm_cz;


--
-- Name: i2b2_move_analysis_to_prod(numeric, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_move_analysis_to_prod(i_etl_id numeric, i_job_id numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_move_analysis_to_prod(i_etl_id numeric, i_job_id numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_move_analysis_to_prod(i_etl_id numeric, i_job_id numeric) TO tm_cz;


--
-- Name: i2b2_move_node(character varying, character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_move_node(old_path character varying, new_path character varying, topnode character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_move_node(old_path character varying, new_path character varying, topnode character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_move_node(old_path character varying, new_path character varying, topnode character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_move_study(character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: postgres
--

REVOKE ALL ON FUNCTION i2b2_move_study(old_path character varying, new_path character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_move_study(old_path character varying, new_path character varying, currentjobid numeric) FROM postgres;
GRANT ALL ON FUNCTION i2b2_move_study(old_path character varying, new_path character varying, currentjobid numeric) TO postgres;


--
-- Name: i2b2_mrna_index_maint(text, text, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_mrna_index_maint(run_type text, tablespace_name text, currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_mrna_index_maint(run_type text, tablespace_name text, currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_mrna_index_maint(run_type text, tablespace_name text, currentjobid bigint) TO tm_cz;


--
-- Name: i2b2_mrna_zscore_calc(character varying, character varying, character varying, numeric, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_mrna_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_mrna_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_mrna_zscore_calc(trial_id character varying, source_cd character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric) TO tm_cz;


--
-- Name: i2b2_process_acgh_data(character varying, character varying, character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_process_acgh_data(trial_id character varying, top_node character varying, source_cd character varying, secure_study character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_process_acgh_data(trial_id character varying, top_node character varying, source_cd character varying, secure_study character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_process_acgh_data(trial_id character varying, top_node character varying, source_cd character varying, secure_study character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_process_metabolomic_data(character varying, character varying, character varying, character varying, bigint, character varying, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_process_metabolomic_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base bigint, secure_study character varying, currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_process_metabolomic_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base bigint, secure_study character varying, currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_process_metabolomic_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base bigint, secure_study character varying, currentjobid bigint) TO tm_cz;


--
-- Name: i2b2_process_mrna_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: postgres
--

REVOKE ALL ON FUNCTION i2b2_process_mrna_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_process_mrna_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric) FROM postgres;
GRANT ALL ON FUNCTION i2b2_process_mrna_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric) TO postgres;


--
-- Name: i2b2_process_proteomics_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_process_proteomics_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_process_proteomics_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_process_proteomics_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_process_qpcr_mirna_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, mirna_type character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, mirna_type character varying) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, mirna_type character varying) TO tm_cz;


--
-- Name: i2b2_process_rna_seq_data(character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base numeric, secure_study character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base numeric, secure_study character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_process_rna_seq_data(trial_id character varying, top_node character varying, data_type character varying, source_code character varying, log_base numeric, secure_study character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_process_rnaseq_data(character varying, character varying, character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_process_rnaseq_data(trial_id character varying, top_node character varying, source_cd character varying, secure_study character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_process_rnaseq_data(trial_id character varying, top_node character varying, source_cd character varying, secure_study character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_process_rnaseq_data(trial_id character varying, top_node character varying, source_cd character varying, secure_study character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_proteomics_zscore_calc(character varying, character varying, numeric, character varying, numeric, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_proteomics_zscore_calc(trial_id character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric, source_cd character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_proteomics_zscore_calc(trial_id character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric, source_cd character varying) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_proteomics_zscore_calc(trial_id character varying, run_type character varying, currentjobid numeric, data_type character varying, log_base numeric, source_cd character varying) TO tm_cz;


--
-- Name: i2b2_rbm_zscore_calc_new(character varying, character varying, bigint, character varying, bigint, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) TO tm_cz;


--
-- Name: i2b2_rbm_zscore_calc_new(character varying, character varying, character varying, character varying, bigint, character varying, bigint, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, partition_name character varying, partition_indx character varying, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, partition_name character varying, partition_indx character varying, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, partition_name character varying, partition_indx character varying, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) TO tm_cz;


--
-- Name: i2b2_rbm_zscore_calc_new(character varying, character varying, character varying, numeric, character varying, bigint, character varying, bigint, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_rbm_zscore_calc_new(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, run_type character varying, currentjobid bigint, data_type character varying, log_base bigint, source_cd character varying) TO tm_cz;


--
-- Name: i2b2_rename_node(character varying, character varying, character varying, numeric); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_rename_node(trial_id character varying, old_node character varying, new_node character varying, currentjobid numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_rename_node(trial_id character varying, old_node character varying, new_node character varying, currentjobid numeric) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_rename_node(trial_id character varying, old_node character varying, new_node character varying, currentjobid numeric) TO tm_cz;


--
-- Name: i2b2_rna_seq_annotation(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_rna_seq_annotation() FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_rna_seq_annotation() FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_rna_seq_annotation() TO tm_cz;


--
-- Name: i2b2_rna_seq_annotation(bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_rna_seq_annotation(currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_rna_seq_annotation(currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_rna_seq_annotation(currentjobid bigint) TO tm_cz;


--
-- Name: i2b2_rna_seq_zscore_calc(character varying, character varying, character varying, numeric, character varying, numeric, character varying, bigint, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_rna_seq_zscore_calc(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, run_type character varying, currentjobid numeric, data_type character varying, log_base bigint, source_cd character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_rna_seq_zscore_calc(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, run_type character varying, currentjobid numeric, data_type character varying, log_base bigint, source_cd character varying) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_rna_seq_zscore_calc(trial_id character varying, partition_name character varying, partition_indx character varying, partitionid numeric, run_type character varying, currentjobid numeric, data_type character varying, log_base bigint, source_cd character varying) TO tm_cz;


--
-- Name: i2b2_secure_study(text, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_secure_study(trial_id text, currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_secure_study(trial_id text, currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_secure_study(trial_id text, currentjobid bigint) TO tm_cz;


--
-- Name: i2b2_show_node(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_show_node(path character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_show_node(path character varying) FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_show_node(path character varying) TO tm_cz;


--
-- Name: i2b2_table_bkp(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_table_bkp() FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_table_bkp() FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_table_bkp() TO tm_cz;


--
-- Name: i2b2_table_defrag(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_table_defrag() FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_table_defrag() FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_table_defrag() TO tm_cz;


--
-- Name: i2b2_truncate_release_tables(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION i2b2_truncate_release_tables() FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_truncate_release_tables() FROM tm_cz;
GRANT ALL ON FUNCTION i2b2_truncate_release_tables() TO tm_cz;


--
-- Name: instr(character varying, character varying, integer, integer); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION instr(string character varying, string_to_search character varying, beg_index integer, occur_index integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION instr(string character varying, string_to_search character varying, beg_index integer, occur_index integer) FROM tm_cz;
GRANT ALL ON FUNCTION instr(string character varying, string_to_search character varying, beg_index integer, occur_index integer) TO tm_cz;


--
-- Name: is_date(character varying); Type: ACL; Schema: tm_cz; Owner: weymouth
--

REVOKE ALL ON FUNCTION is_date(character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION is_date(character varying) FROM weymouth;
GRANT ALL ON FUNCTION is_date(character varying) TO weymouth;
GRANT ALL ON FUNCTION is_date(character varying) TO PUBLIC;
GRANT ALL ON FUNCTION is_date(character varying) TO tm_cz;


--
-- Name: is_date(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION is_date(character varying, character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION is_date(character varying, character varying) FROM tm_cz;
GRANT ALL ON FUNCTION is_date(character varying, character varying) TO tm_cz;


--
-- Name: is_number_v2(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION is_number_v2(p_string character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION is_number_v2(p_string character varying) FROM tm_cz;
GRANT ALL ON FUNCTION is_number_v2(p_string character varying) TO tm_cz;


--
-- Name: is_numeric(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION is_numeric(character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION is_numeric(character varying) FROM tm_cz;
GRANT ALL ON FUNCTION is_numeric(character varying) TO tm_cz;


--
-- Name: isnumeric(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION isnumeric(p_string character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION isnumeric(p_string character varying) FROM tm_cz;
GRANT ALL ON FUNCTION isnumeric(p_string character varying) TO tm_cz;


--
-- Name: jnj_init_cap(text); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION jnj_init_cap(text_to_parse text) FROM PUBLIC;
REVOKE ALL ON FUNCTION jnj_init_cap(text_to_parse text) FROM tm_cz;
GRANT ALL ON FUNCTION jnj_init_cap(text_to_parse text) TO tm_cz;


--
-- Name: load_kegg_content_data(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION load_kegg_content_data() FROM PUBLIC;
REVOKE ALL ON FUNCTION load_kegg_content_data() FROM tm_cz;
GRANT ALL ON FUNCTION load_kegg_content_data() TO tm_cz;


--
-- Name: num_occurances(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION num_occurances(input_str character varying, search_str character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION num_occurances(input_str character varying, search_str character varying) FROM tm_cz;
GRANT ALL ON FUNCTION num_occurances(input_str character varying, search_str character varying) TO tm_cz;


--
-- Name: number_parser(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION number_parser(numbers_to_parse character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION number_parser(numbers_to_parse character varying) FROM tm_cz;
GRANT ALL ON FUNCTION number_parser(numbers_to_parse character varying) TO tm_cz;


--
-- Name: nz_i2b2_copy_to_stage(character varying, character varying, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION nz_i2b2_copy_to_stage(character varying, character varying, bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION nz_i2b2_copy_to_stage(character varying, character varying, bigint) FROM tm_cz;
GRANT ALL ON FUNCTION nz_i2b2_copy_to_stage(character varying, character varying, bigint) TO tm_cz;


--
-- Name: parse_nth_value(character varying, numeric, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION parse_nth_value(pvalue character varying, location numeric, delimiter character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION parse_nth_value(pvalue character varying, location numeric, delimiter character varying) FROM tm_cz;
GRANT ALL ON FUNCTION parse_nth_value(pvalue character varying, location numeric, delimiter character varying) TO tm_cz;


--
-- Name: rdc_init_cap(text); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION rdc_init_cap(text_to_parse text) FROM PUBLIC;
REVOKE ALL ON FUNCTION rdc_init_cap(text_to_parse text) FROM tm_cz;
GRANT ALL ON FUNCTION rdc_init_cap(text_to_parse text) TO tm_cz;


--
-- Name: rdc_reload_mrna_data(text, text, text, bigint, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION rdc_reload_mrna_data(trial_id text, data_type text, source_cd text, log_base bigint, currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION rdc_reload_mrna_data(trial_id text, data_type text, source_cd text, log_base bigint, currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION rdc_reload_mrna_data(trial_id text, data_type text, source_cd text, log_base bigint, currentjobid bigint) TO tm_cz;


--
-- Name: rename_program(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION rename_program(oldprogramname character varying, newprogramname character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION rename_program(oldprogramname character varying, newprogramname character varying) FROM tm_cz;
GRANT ALL ON FUNCTION rename_program(oldprogramname character varying, newprogramname character varying) TO tm_cz;


--
-- Name: rename_study(character varying, character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION rename_study(programname character varying, oldtitle character varying, newtitle character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION rename_study(programname character varying, oldtitle character varying, newtitle character varying) FROM tm_cz;
GRANT ALL ON FUNCTION rename_study(programname character varying, oldtitle character varying, newtitle character varying) TO tm_cz;


--
-- Name: rwg_add_search_term(text, text, text, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION rwg_add_search_term(new_term text, category_name text, category_display text, currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION rwg_add_search_term(new_term text, category_name text, category_display text, currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION rwg_add_search_term(new_term text, category_name text, category_display text, currentjobid bigint) TO tm_cz;


--
-- Name: rwg_add_taxonomy_term(text, text, text, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION rwg_add_taxonomy_term(new_term_in text, parent_term_in text, category_term_in text, currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION rwg_add_taxonomy_term(new_term_in text, parent_term_in text, category_term_in text, currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION rwg_add_taxonomy_term(new_term_in text, parent_term_in text, category_term_in text, currentjobid bigint) TO tm_cz;


--
-- Name: rwg_create_analysis_entry(text, text, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION rwg_create_analysis_entry(trialid text, delete_flag text, currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION rwg_create_analysis_entry(trialid text, delete_flag text, currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION rwg_create_analysis_entry(trialid text, delete_flag text, currentjobid bigint) TO tm_cz;


--
-- Name: rwg_import_from_ext(text, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION rwg_import_from_ext(trialid text, currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION rwg_import_from_ext(trialid text, currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION rwg_import_from_ext(trialid text, currentjobid bigint) TO tm_cz;


--
-- Name: rwg_load_analysis_data(text, bigint, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION rwg_load_analysis_data(trialid text, currentjobid bigint, inplatformid bigint, OUT rtn_code bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION rwg_load_analysis_data(trialid text, currentjobid bigint, inplatformid bigint, OUT rtn_code bigint) FROM tm_cz;
GRANT ALL ON FUNCTION rwg_load_analysis_data(trialid text, currentjobid bigint, inplatformid bigint, OUT rtn_code bigint) TO tm_cz;


--
-- Name: rwg_load_analysis_metadata(text, text, text, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION rwg_load_analysis_metadata(trialid text, i_study_data_category text, i_study_category_display text, currentjobid bigint, OUT rtn_code bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION rwg_load_analysis_metadata(trialid text, i_study_data_category text, i_study_category_display text, currentjobid bigint, OUT rtn_code bigint) FROM tm_cz;
GRANT ALL ON FUNCTION rwg_load_analysis_metadata(trialid text, i_study_data_category text, i_study_category_display text, currentjobid bigint, OUT rtn_code bigint) TO tm_cz;


--
-- Name: rwg_load_heat_map_results(text, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION rwg_load_heat_map_results(in_study_id text, currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION rwg_load_heat_map_results(in_study_id text, currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION rwg_load_heat_map_results(in_study_id text, currentjobid bigint) TO tm_cz;


--
-- Name: rwg_remove_study(text, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION rwg_remove_study(trialid text, currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION rwg_remove_study(trialid text, currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION rwg_remove_study(trialid text, currentjobid bigint) TO tm_cz;


--
-- Name: set_bio_data_uid_dis(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION set_bio_data_uid_dis() FROM PUBLIC;
REVOKE ALL ON FUNCTION set_bio_data_uid_dis() FROM tm_cz;
GRANT ALL ON FUNCTION set_bio_data_uid_dis() TO tm_cz;


--
-- Name: set_bio_data_uid_path(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION set_bio_data_uid_path() FROM PUBLIC;
REVOKE ALL ON FUNCTION set_bio_data_uid_path() FROM tm_cz;
GRANT ALL ON FUNCTION set_bio_data_uid_path() TO tm_cz;


--
-- Name: sf_xtab(character varying, numeric, character varying, bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION sf_xtab(v_variable character varying, v_protocol numeric, v_subject character varying, v_rowid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION sf_xtab(v_variable character varying, v_protocol numeric, v_subject character varying, v_rowid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION sf_xtab(v_variable character varying, v_protocol numeric, v_subject character varying, v_rowid bigint) TO tm_cz;


--
-- Name: tea_npv_precompute(double precision, double precision, double precision); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tea_npv_precompute(foldchg double precision, mu double precision, sigma double precision) FROM PUBLIC;
REVOKE ALL ON FUNCTION tea_npv_precompute(foldchg double precision, mu double precision, sigma double precision) FROM tm_cz;
GRANT ALL ON FUNCTION tea_npv_precompute(foldchg double precision, mu double precision, sigma double precision) TO tm_cz;


--
-- Name: text_parser(text); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION text_parser(text_to_parse text) FROM PUBLIC;
REVOKE ALL ON FUNCTION text_parser(text_to_parse text) FROM tm_cz;
GRANT ALL ON FUNCTION text_parser(text_to_parse text) TO tm_cz;


--
-- Name: tf_trg_antigen_deapp(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_antigen_deapp() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_antigen_deapp() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_antigen_deapp() TO tm_cz;


--
-- Name: tf_trg_az_test_run_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_az_test_run_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_az_test_run_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_az_test_run_id() TO tm_cz;


--
-- Name: tf_trg_az_test_step_act_result(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_az_test_step_act_result() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_az_test_step_act_result() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_az_test_step_act_result() TO tm_cz;


--
-- Name: tf_trg_az_test_step_run_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_az_test_step_run_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_az_test_step_run_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_az_test_step_run_id() TO tm_cz;


--
-- Name: tf_trg_cz_data_file_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_cz_data_file_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_cz_data_file_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_cz_data_file_id() TO tm_cz;


--
-- Name: tf_trg_cz_data_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_cz_data_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_cz_data_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_cz_data_id() TO tm_cz;


--
-- Name: tf_trg_cz_dw_version_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_cz_dw_version_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_cz_dw_version_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_cz_dw_version_id() TO tm_cz;


--
-- Name: tf_trg_cz_form_layout_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_cz_form_layout_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_cz_form_layout_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_cz_form_layout_id() TO tm_cz;


--
-- Name: tf_trg_cz_job_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_cz_job_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_cz_job_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_cz_job_id() TO tm_cz;


--
-- Name: tf_trg_cz_message_seq_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_cz_message_seq_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_cz_message_seq_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_cz_message_seq_id() TO tm_cz;


--
-- Name: tf_trg_cz_personid(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_cz_personid() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_cz_personid() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_cz_personid() TO tm_cz;


--
-- Name: tf_trg_cz_seq_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_cz_seq_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_cz_seq_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_cz_seq_id() TO tm_cz;


--
-- Name: tf_trg_cz_test_category_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_cz_test_category_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_cz_test_category_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_cz_test_category_id() TO tm_cz;


--
-- Name: tf_trg_cz_test_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_cz_test_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_cz_test_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_cz_test_id() TO tm_cz;


--
-- Name: tf_trg_cz_test_result_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_cz_test_result_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_cz_test_result_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_cz_test_result_id() TO tm_cz;


--
-- Name: tf_trg_cz_xtrial_ctrl_vocab_id(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_cz_xtrial_ctrl_vocab_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_cz_xtrial_ctrl_vocab_id() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_cz_xtrial_ctrl_vocab_id() TO tm_cz;


--
-- Name: tf_trg_probeset_deapp(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION tf_trg_probeset_deapp() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_probeset_deapp() FROM tm_cz;
GRANT ALL ON FUNCTION tf_trg_probeset_deapp() TO tm_cz;


--
-- Name: upgrade_mrna_data(bigint); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION upgrade_mrna_data(currentjobid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION upgrade_mrna_data(currentjobid bigint) FROM tm_cz;
GRANT ALL ON FUNCTION upgrade_mrna_data(currentjobid bigint) TO tm_cz;


--
-- Name: util_create_synonym_all(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_create_synonym_all(v_fromzone character varying, v_whattype character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION util_create_synonym_all(v_fromzone character varying, v_whattype character varying) FROM tm_cz;
GRANT ALL ON FUNCTION util_create_synonym_all(v_fromzone character varying, v_whattype character varying) TO tm_cz;


--
-- Name: util_drop_all(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_drop_all(v_whattype character varying, v_dropifempty character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION util_drop_all(v_whattype character varying, v_dropifempty character varying) FROM tm_cz;
GRANT ALL ON FUNCTION util_drop_all(v_whattype character varying, v_dropifempty character varying) TO tm_cz;


--
-- Name: util_drop_anything(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_drop_anything(v_objname character varying, v_objtype character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION util_drop_anything(v_objname character varying, v_objtype character varying) FROM tm_cz;
GRANT ALL ON FUNCTION util_drop_anything(v_objname character varying, v_objtype character varying) TO tm_cz;


--
-- Name: util_drop_synonym(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_drop_synonym(v_objname character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION util_drop_synonym(v_objname character varying) FROM tm_cz;
GRANT ALL ON FUNCTION util_drop_synonym(v_objname character varying) TO tm_cz;


--
-- Name: util_drop_synonym_by_owner(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_drop_synonym_by_owner(v_owner character varying, v_dropifempty character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION util_drop_synonym_by_owner(v_owner character varying, v_dropifempty character varying) FROM tm_cz;
GRANT ALL ON FUNCTION util_drop_synonym_by_owner(v_owner character varying, v_dropifempty character varying) TO tm_cz;


--
-- Name: util_drop_table(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_drop_table(v_tabname character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION util_drop_table(v_tabname character varying) FROM tm_cz;
GRANT ALL ON FUNCTION util_drop_table(v_tabname character varying) TO tm_cz;


--
-- Name: util_grant_all(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_grant_all(username character varying, v_whattype character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION util_grant_all(username character varying, v_whattype character varying) FROM tm_cz;
GRANT ALL ON FUNCTION util_grant_all(username character varying, v_whattype character varying) TO tm_cz;


--
-- Name: util_grant_execute(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_grant_execute(v_to_zone character varying, v_type character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION util_grant_execute(v_to_zone character varying, v_type character varying) FROM tm_cz;
GRANT ALL ON FUNCTION util_grant_execute(v_to_zone character varying, v_type character varying) TO tm_cz;


--
-- Name: util_grant_select(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_grant_select(username character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION util_grant_select(username character varying) FROM tm_cz;
GRANT ALL ON FUNCTION util_grant_select(username character varying) TO tm_cz;


--
-- Name: util_is_populated(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_is_populated(tabname character varying, OUT retval integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION util_is_populated(tabname character varying, OUT retval integer) FROM tm_cz;
GRANT ALL ON FUNCTION util_is_populated(tabname character varying, OUT retval integer) TO tm_cz;


--
-- Name: util_make_object_list(character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_make_object_list(v_whattype character varying, OUT v_things character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION util_make_object_list(v_whattype character varying, OUT v_things character varying) FROM tm_cz;
GRANT ALL ON FUNCTION util_make_object_list(v_whattype character varying, OUT v_things character varying) TO tm_cz;


--
-- Name: util_recompile_all(); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_recompile_all() FROM PUBLIC;
REVOKE ALL ON FUNCTION util_recompile_all() FROM tm_cz;
GRANT ALL ON FUNCTION util_recompile_all() TO tm_cz;


--
-- Name: util_truncate_table(character varying, character varying); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION util_truncate_table(v_tabname character varying, v_dummyarg character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION util_truncate_table(v_tabname character varying, v_dummyarg character varying) FROM tm_cz;
GRANT ALL ON FUNCTION util_truncate_table(v_tabname character varying, v_dummyarg character varying) TO tm_cz;


SET search_path = tm_lz, pg_catalog;

--
-- Name: i2b2_process_qpcr_mirna_data(character varying, character varying, character varying, character varying, character varying, numeric, character varying, numeric); Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON FUNCTION i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, mirna_type character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, OUT rtn_code numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, mirna_type character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, OUT rtn_code numeric) FROM tm_lz;
GRANT ALL ON FUNCTION i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, mirna_type character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, OUT rtn_code numeric) TO tm_lz;
GRANT ALL ON FUNCTION i2b2_process_qpcr_mirna_data(trial_id character varying, top_node character varying, mirna_type character varying, data_type character varying, source_cd character varying, log_base numeric, secure_study character varying, currentjobid numeric, OUT rtn_code numeric) TO tm_cz;


--
-- Name: tf_trg_lz_src_analysis_meta_id(); Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON FUNCTION tf_trg_lz_src_analysis_meta_id() FROM PUBLIC;
REVOKE ALL ON FUNCTION tf_trg_lz_src_analysis_meta_id() FROM tm_lz;
GRANT ALL ON FUNCTION tf_trg_lz_src_analysis_meta_id() TO tm_lz;
GRANT ALL ON FUNCTION tf_trg_lz_src_analysis_meta_id() TO tm_cz;


SET search_path = tm_cz, pg_catalog;

--
-- Name: median(double precision); Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON FUNCTION median(double precision) FROM PUBLIC;
REVOKE ALL ON FUNCTION median(double precision) FROM tm_cz;
GRANT ALL ON FUNCTION median(double precision) TO tm_cz;


SET search_path = amapp, pg_catalog;

--
-- Name: am_data_uid; Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON TABLE am_data_uid FROM PUBLIC;
REVOKE ALL ON TABLE am_data_uid FROM amapp;
GRANT ALL ON TABLE am_data_uid TO amapp;
GRANT ALL ON TABLE am_data_uid TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE am_data_uid TO biomart_user;


--
-- Name: am_tag_association; Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON TABLE am_tag_association FROM PUBLIC;
REVOKE ALL ON TABLE am_tag_association FROM amapp;
GRANT ALL ON TABLE am_tag_association TO amapp;
GRANT ALL ON TABLE am_tag_association TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE am_tag_association TO biomart_user;


--
-- Name: am_tag_item; Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON TABLE am_tag_item FROM PUBLIC;
REVOKE ALL ON TABLE am_tag_item FROM amapp;
GRANT ALL ON TABLE am_tag_item TO amapp;
GRANT ALL ON TABLE am_tag_item TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE am_tag_item TO biomart_user;


--
-- Name: am_tag_value; Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON TABLE am_tag_value FROM PUBLIC;
REVOKE ALL ON TABLE am_tag_value FROM amapp;
GRANT ALL ON TABLE am_tag_value TO amapp;
GRANT ALL ON TABLE am_tag_value TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE am_tag_value TO biomart_user;


SET search_path = biomart, pg_catalog;

--
-- Name: bio_assay_platform; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_platform FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_platform FROM biomart;
GRANT ALL ON TABLE bio_assay_platform TO biomart;
GRANT ALL ON TABLE bio_assay_platform TO tm_cz;
GRANT SELECT ON TABLE bio_assay_platform TO biomart_user;


--
-- Name: bio_compound; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_compound FROM PUBLIC;
REVOKE ALL ON TABLE bio_compound FROM biomart;
GRANT ALL ON TABLE bio_compound TO biomart;
GRANT ALL ON TABLE bio_compound TO tm_cz;
GRANT SELECT ON TABLE bio_compound TO biomart_user;


--
-- Name: bio_concept_code; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_concept_code FROM PUBLIC;
REVOKE ALL ON TABLE bio_concept_code FROM biomart;
GRANT ALL ON TABLE bio_concept_code TO biomart;
GRANT ALL ON TABLE bio_concept_code TO tm_cz;
GRANT SELECT ON TABLE bio_concept_code TO biomart_user;


--
-- Name: bio_data_uid; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_uid FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_uid FROM biomart;
GRANT ALL ON TABLE bio_data_uid TO biomart;
GRANT ALL ON TABLE bio_data_uid TO tm_cz;
GRANT SELECT ON TABLE bio_data_uid TO biomart_user;


--
-- Name: bio_disease; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_disease FROM PUBLIC;
REVOKE ALL ON TABLE bio_disease FROM biomart;
GRANT ALL ON TABLE bio_disease TO biomart;
GRANT ALL ON TABLE bio_disease TO tm_cz;
GRANT SELECT ON TABLE bio_disease TO biomart_user;


--
-- Name: bio_marker; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_marker FROM PUBLIC;
REVOKE ALL ON TABLE bio_marker FROM biomart;
GRANT ALL ON TABLE bio_marker TO biomart;
GRANT ALL ON TABLE bio_marker TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE bio_marker TO biomart_user;


--
-- Name: bio_observation; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_observation FROM PUBLIC;
REVOKE ALL ON TABLE bio_observation FROM biomart;
GRANT ALL ON TABLE bio_observation TO biomart;
GRANT ALL ON TABLE bio_observation TO tm_cz;
GRANT SELECT ON TABLE bio_observation TO biomart_user;


SET search_path = amapp, pg_catalog;

--
-- Name: am_tag_display_vw; Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON TABLE am_tag_display_vw FROM PUBLIC;
REVOKE ALL ON TABLE am_tag_display_vw FROM amapp;
GRANT ALL ON TABLE am_tag_display_vw TO amapp;
GRANT ALL ON TABLE am_tag_display_vw TO tm_cz;
GRANT SELECT ON TABLE am_tag_display_vw TO biomart_user;


--
-- Name: am_tag_template; Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON TABLE am_tag_template FROM PUBLIC;
REVOKE ALL ON TABLE am_tag_template FROM amapp;
GRANT ALL ON TABLE am_tag_template TO amapp;
GRANT ALL ON TABLE am_tag_template TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE am_tag_template TO biomart_user;


--
-- Name: am_tag_template_association; Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON TABLE am_tag_template_association FROM PUBLIC;
REVOKE ALL ON TABLE am_tag_template_association FROM amapp;
GRANT ALL ON TABLE am_tag_template_association TO amapp;
GRANT ALL ON TABLE am_tag_template_association TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE am_tag_template_association TO biomart_user;


--
-- Name: seq_amapp_data_id; Type: ACL; Schema: amapp; Owner: amapp
--

REVOKE ALL ON SEQUENCE seq_amapp_data_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_amapp_data_id FROM amapp;
GRANT ALL ON SEQUENCE seq_amapp_data_id TO amapp;
GRANT ALL ON SEQUENCE seq_amapp_data_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_amapp_data_id TO biomart_user;


SET search_path = biomart, pg_catalog;

--
-- Name: annotation; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE annotation FROM PUBLIC;
REVOKE ALL ON TABLE annotation FROM biomart;
GRANT ALL ON TABLE annotation TO biomart;
GRANT ALL ON TABLE annotation TO tm_cz;
GRANT SELECT ON TABLE annotation TO biomart_user;


--
-- Name: assay_analysis_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE assay_analysis_data FROM PUBLIC;
REVOKE ALL ON TABLE assay_analysis_data FROM biomart;
GRANT ALL ON TABLE assay_analysis_data TO biomart;
GRANT ALL ON TABLE assay_analysis_data TO tm_cz;
GRANT SELECT ON TABLE assay_analysis_data TO biomart_user;


--
-- Name: bio_ad_hoc_property; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_ad_hoc_property FROM PUBLIC;
REVOKE ALL ON TABLE bio_ad_hoc_property FROM biomart;
GRANT ALL ON TABLE bio_ad_hoc_property TO biomart;
GRANT ALL ON TABLE bio_ad_hoc_property TO tm_cz;
GRANT SELECT ON TABLE bio_ad_hoc_property TO biomart_user;


--
-- Name: bio_analysis_attribute; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_analysis_attribute FROM PUBLIC;
REVOKE ALL ON TABLE bio_analysis_attribute FROM biomart;
GRANT ALL ON TABLE bio_analysis_attribute TO biomart;
GRANT ALL ON TABLE bio_analysis_attribute TO tm_cz;
GRANT SELECT ON TABLE bio_analysis_attribute TO biomart_user;


--
-- Name: bio_analysis_attribute_lineage; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_analysis_attribute_lineage FROM PUBLIC;
REVOKE ALL ON TABLE bio_analysis_attribute_lineage FROM biomart;
GRANT ALL ON TABLE bio_analysis_attribute_lineage TO biomart;
GRANT ALL ON TABLE bio_analysis_attribute_lineage TO tm_cz;
GRANT SELECT ON TABLE bio_analysis_attribute_lineage TO biomart_user;


--
-- Name: bio_analysis_cohort_xref; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_analysis_cohort_xref FROM PUBLIC;
REVOKE ALL ON TABLE bio_analysis_cohort_xref FROM biomart;
GRANT ALL ON TABLE bio_analysis_cohort_xref TO biomart;
GRANT ALL ON TABLE bio_analysis_cohort_xref TO tm_cz;
GRANT SELECT ON TABLE bio_analysis_cohort_xref TO biomart_user;


--
-- Name: bio_assay; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay FROM biomart;
GRANT ALL ON TABLE bio_assay TO biomart;
GRANT ALL ON TABLE bio_assay TO tm_cz;
GRANT SELECT ON TABLE bio_assay TO biomart_user;


--
-- Name: bio_assay_analysis; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_analysis FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_analysis FROM biomart;
GRANT ALL ON TABLE bio_assay_analysis TO biomart;
GRANT ALL ON TABLE bio_assay_analysis TO tm_cz;
GRANT SELECT ON TABLE bio_assay_analysis TO biomart_user;


--
-- Name: bio_assay_analysis_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_analysis_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_analysis_data FROM biomart;
GRANT ALL ON TABLE bio_assay_analysis_data TO biomart;
GRANT ALL ON TABLE bio_assay_analysis_data TO tm_cz;
GRANT SELECT ON TABLE bio_assay_analysis_data TO biomart_user;


--
-- Name: bio_assay_analysis_data_tea; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_analysis_data_tea FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_analysis_data_tea FROM biomart;
GRANT ALL ON TABLE bio_assay_analysis_data_tea TO biomart;
GRANT ALL ON TABLE bio_assay_analysis_data_tea TO tm_cz;
GRANT SELECT ON TABLE bio_assay_analysis_data_tea TO biomart_user;


--
-- Name: bio_assay_analysis_eqtl; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_analysis_eqtl FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_analysis_eqtl FROM biomart;
GRANT ALL ON TABLE bio_assay_analysis_eqtl TO biomart;
GRANT ALL ON TABLE bio_assay_analysis_eqtl TO tm_cz;
GRANT SELECT ON TABLE bio_assay_analysis_eqtl TO biomart_user;


--
-- Name: bio_assay_analysis_ext; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_analysis_ext FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_analysis_ext FROM biomart;
GRANT ALL ON TABLE bio_assay_analysis_ext TO biomart;
GRANT ALL ON TABLE bio_assay_analysis_ext TO tm_cz;
GRANT SELECT ON TABLE bio_assay_analysis_ext TO biomart_user;


--
-- Name: bio_assay_analysis_gwas; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_analysis_gwas FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_analysis_gwas FROM biomart;
GRANT ALL ON TABLE bio_assay_analysis_gwas TO biomart;
GRANT ALL ON TABLE bio_assay_analysis_gwas TO tm_cz;
GRANT SELECT ON TABLE bio_assay_analysis_gwas TO biomart_user;


--
-- Name: bio_assay_cohort; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_cohort FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_cohort FROM biomart;
GRANT ALL ON TABLE bio_assay_cohort TO biomart;
GRANT ALL ON TABLE bio_assay_cohort TO tm_cz;
GRANT SELECT ON TABLE bio_assay_cohort TO biomart_user;


--
-- Name: bio_assay_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_data FROM biomart;
GRANT ALL ON TABLE bio_assay_data TO biomart;
GRANT ALL ON TABLE bio_assay_data TO tm_cz;
GRANT SELECT ON TABLE bio_assay_data TO biomart_user;


--
-- Name: bio_assay_data_annotation; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_data_annotation FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_data_annotation FROM biomart;
GRANT ALL ON TABLE bio_assay_data_annotation TO biomart;
GRANT ALL ON TABLE bio_assay_data_annotation TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE bio_assay_data_annotation TO biomart_user;
GRANT SELECT ON TABLE bio_assay_data_annotation TO searchapp;


--
-- Name: bio_assay_data_stats; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_data_stats FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_data_stats FROM biomart;
GRANT ALL ON TABLE bio_assay_data_stats TO biomart;
GRANT ALL ON TABLE bio_assay_data_stats TO tm_cz;
GRANT SELECT ON TABLE bio_assay_data_stats TO biomart_user;


--
-- Name: bio_assay_data_stats_seq; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON SEQUENCE bio_assay_data_stats_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE bio_assay_data_stats_seq FROM biomart;
GRANT ALL ON SEQUENCE bio_assay_data_stats_seq TO biomart;
GRANT ALL ON SEQUENCE bio_assay_data_stats_seq TO tm_cz;
GRANT ALL ON SEQUENCE bio_assay_data_stats_seq TO biomart_user;


--
-- Name: bio_assay_dataset; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_dataset FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_dataset FROM biomart;
GRANT ALL ON TABLE bio_assay_dataset TO biomart;
GRANT ALL ON TABLE bio_assay_dataset TO tm_cz;
GRANT SELECT ON TABLE bio_assay_dataset TO biomart_user;


--
-- Name: bio_assay_feature_group; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_feature_group FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_feature_group FROM biomart;
GRANT ALL ON TABLE bio_assay_feature_group TO biomart;
GRANT ALL ON TABLE bio_assay_feature_group TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE bio_assay_feature_group TO biomart_user;


--
-- Name: bio_assay_sample; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_assay_sample FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_sample FROM biomart;
GRANT ALL ON TABLE bio_assay_sample TO biomart;
GRANT ALL ON TABLE bio_assay_sample TO tm_cz;
GRANT SELECT ON TABLE bio_assay_sample TO biomart_user;


--
-- Name: bio_asy_analysis_data_idx; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_asy_analysis_data_idx FROM PUBLIC;
REVOKE ALL ON TABLE bio_asy_analysis_data_idx FROM biomart;
GRANT ALL ON TABLE bio_asy_analysis_data_idx TO biomart;
GRANT ALL ON TABLE bio_asy_analysis_data_idx TO tm_cz;
GRANT SELECT ON TABLE bio_asy_analysis_data_idx TO biomart_user;


--
-- Name: bio_asy_analysis_dataset; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_asy_analysis_dataset FROM PUBLIC;
REVOKE ALL ON TABLE bio_asy_analysis_dataset FROM biomart;
GRANT ALL ON TABLE bio_asy_analysis_dataset TO biomart;
GRANT ALL ON TABLE bio_asy_analysis_dataset TO tm_cz;
GRANT SELECT ON TABLE bio_asy_analysis_dataset TO biomart_user;


--
-- Name: bio_asy_analysis_eqtl_top50; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_asy_analysis_eqtl_top50 FROM PUBLIC;
REVOKE ALL ON TABLE bio_asy_analysis_eqtl_top50 FROM biomart;
GRANT ALL ON TABLE bio_asy_analysis_eqtl_top50 TO biomart;
GRANT ALL ON TABLE bio_asy_analysis_eqtl_top50 TO tm_cz;
GRANT SELECT ON TABLE bio_asy_analysis_eqtl_top50 TO biomart_user;


--
-- Name: bio_asy_analysis_gwas_top50; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_asy_analysis_gwas_top50 FROM PUBLIC;
REVOKE ALL ON TABLE bio_asy_analysis_gwas_top50 FROM biomart;
GRANT ALL ON TABLE bio_asy_analysis_gwas_top50 TO biomart;
GRANT ALL ON TABLE bio_asy_analysis_gwas_top50 TO tm_cz;
GRANT SELECT ON TABLE bio_asy_analysis_gwas_top50 TO biomart_user;


--
-- Name: bio_asy_analysis_pltfm; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_asy_analysis_pltfm FROM PUBLIC;
REVOKE ALL ON TABLE bio_asy_analysis_pltfm FROM biomart;
GRANT ALL ON TABLE bio_asy_analysis_pltfm TO biomart;
GRANT ALL ON TABLE bio_asy_analysis_pltfm TO tm_cz;
GRANT SELECT ON TABLE bio_asy_analysis_pltfm TO biomart_user;


--
-- Name: bio_asy_data_stats_all; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_asy_data_stats_all FROM PUBLIC;
REVOKE ALL ON TABLE bio_asy_data_stats_all FROM biomart;
GRANT ALL ON TABLE bio_asy_data_stats_all TO biomart;
GRANT ALL ON TABLE bio_asy_data_stats_all TO tm_cz;
GRANT SELECT ON TABLE bio_asy_data_stats_all TO biomart_user;


--
-- Name: bio_cell_line; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_cell_line FROM PUBLIC;
REVOKE ALL ON TABLE bio_cell_line FROM biomart;
GRANT ALL ON TABLE bio_cell_line TO biomart;
GRANT ALL ON TABLE bio_cell_line TO tm_cz;
GRANT SELECT ON TABLE bio_cell_line TO biomart_user;


--
-- Name: bio_cgdcp_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_cgdcp_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_cgdcp_data FROM biomart;
GRANT ALL ON TABLE bio_cgdcp_data TO biomart;
GRANT ALL ON TABLE bio_cgdcp_data TO tm_cz;
GRANT SELECT ON TABLE bio_cgdcp_data TO biomart_user;


--
-- Name: bio_clinc_trial_attr; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_clinc_trial_attr FROM PUBLIC;
REVOKE ALL ON TABLE bio_clinc_trial_attr FROM biomart;
GRANT ALL ON TABLE bio_clinc_trial_attr TO biomart;
GRANT ALL ON TABLE bio_clinc_trial_attr TO tm_cz;
GRANT SELECT ON TABLE bio_clinc_trial_attr TO biomart_user;


--
-- Name: bio_clinc_trial_pt_group; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_clinc_trial_pt_group FROM PUBLIC;
REVOKE ALL ON TABLE bio_clinc_trial_pt_group FROM biomart;
GRANT ALL ON TABLE bio_clinc_trial_pt_group TO biomart;
GRANT ALL ON TABLE bio_clinc_trial_pt_group TO tm_cz;
GRANT SELECT ON TABLE bio_clinc_trial_pt_group TO biomart_user;


--
-- Name: bio_clinc_trial_time_pt; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_clinc_trial_time_pt FROM PUBLIC;
REVOKE ALL ON TABLE bio_clinc_trial_time_pt FROM biomart;
GRANT ALL ON TABLE bio_clinc_trial_time_pt TO biomart;
GRANT ALL ON TABLE bio_clinc_trial_time_pt TO tm_cz;
GRANT SELECT ON TABLE bio_clinc_trial_time_pt TO biomart_user;


--
-- Name: bio_clinical_trial; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_clinical_trial FROM PUBLIC;
REVOKE ALL ON TABLE bio_clinical_trial FROM biomart;
GRANT ALL ON TABLE bio_clinical_trial TO biomart;
GRANT ALL ON TABLE bio_clinical_trial TO tm_cz;
GRANT SELECT ON TABLE bio_clinical_trial TO biomart_user;


--
-- Name: bio_clinical_trial_design; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_clinical_trial_design FROM PUBLIC;
REVOKE ALL ON TABLE bio_clinical_trial_design FROM biomart;
GRANT ALL ON TABLE bio_clinical_trial_design TO biomart;
GRANT ALL ON TABLE bio_clinical_trial_design TO tm_cz;
GRANT SELECT ON TABLE bio_clinical_trial_design TO biomart_user;


--
-- Name: bio_cohort_exp_xref; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_cohort_exp_xref FROM PUBLIC;
REVOKE ALL ON TABLE bio_cohort_exp_xref FROM biomart;
GRANT ALL ON TABLE bio_cohort_exp_xref TO biomart;
GRANT ALL ON TABLE bio_cohort_exp_xref TO tm_cz;
GRANT SELECT ON TABLE bio_cohort_exp_xref TO biomart_user;


--
-- Name: bio_content; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_content FROM PUBLIC;
REVOKE ALL ON TABLE bio_content FROM biomart;
GRANT ALL ON TABLE bio_content TO biomart;
GRANT ALL ON TABLE bio_content TO tm_cz;
GRANT SELECT ON TABLE bio_content TO biomart_user;


--
-- Name: bio_content_reference; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_content_reference FROM PUBLIC;
REVOKE ALL ON TABLE bio_content_reference FROM biomart;
GRANT ALL ON TABLE bio_content_reference TO biomart;
GRANT ALL ON TABLE bio_content_reference TO tm_cz;
GRANT SELECT ON TABLE bio_content_reference TO biomart_user;


--
-- Name: bio_content_repository; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_content_repository FROM PUBLIC;
REVOKE ALL ON TABLE bio_content_repository FROM biomart;
GRANT ALL ON TABLE bio_content_repository TO biomart;
GRANT ALL ON TABLE bio_content_repository TO tm_cz;
GRANT SELECT ON TABLE bio_content_repository TO biomart_user;


--
-- Name: bio_curated_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_curated_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_curated_data FROM biomart;
GRANT ALL ON TABLE bio_curated_data TO biomart;
GRANT ALL ON TABLE bio_curated_data TO tm_cz;
GRANT SELECT ON TABLE bio_curated_data TO biomart_user;


--
-- Name: bio_curation_dataset; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_curation_dataset FROM PUBLIC;
REVOKE ALL ON TABLE bio_curation_dataset FROM biomart;
GRANT ALL ON TABLE bio_curation_dataset TO biomart;
GRANT ALL ON TABLE bio_curation_dataset TO tm_cz;
GRANT SELECT ON TABLE bio_curation_dataset TO biomart_user;


--
-- Name: bio_data_attribute; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_attribute FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_attribute FROM biomart;
GRANT ALL ON TABLE bio_data_attribute TO biomart;
GRANT ALL ON TABLE bio_data_attribute TO tm_cz;
GRANT SELECT ON TABLE bio_data_attribute TO biomart_user;


--
-- Name: bio_data_compound; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_compound FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_compound FROM biomart;
GRANT ALL ON TABLE bio_data_compound TO biomart;
GRANT ALL ON TABLE bio_data_compound TO tm_cz;
GRANT SELECT ON TABLE bio_data_compound TO biomart_user;


--
-- Name: bio_data_correl_descr; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_correl_descr FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_correl_descr FROM biomart;
GRANT ALL ON TABLE bio_data_correl_descr TO biomart;
GRANT ALL ON TABLE bio_data_correl_descr TO tm_cz;
GRANT SELECT ON TABLE bio_data_correl_descr TO biomart_user;


--
-- Name: bio_data_correlation; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_correlation FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_correlation FROM biomart;
GRANT ALL ON TABLE bio_data_correlation TO biomart;
GRANT ALL ON TABLE bio_data_correlation TO tm_cz;
GRANT SELECT ON TABLE bio_data_correlation TO biomart_user;


--
-- Name: bio_data_disease; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_disease FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_disease FROM biomart;
GRANT ALL ON TABLE bio_data_disease TO biomart;
GRANT ALL ON TABLE bio_data_disease TO tm_cz;
GRANT SELECT ON TABLE bio_data_disease TO biomart_user;


--
-- Name: bio_data_ext_code; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_ext_code FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_ext_code FROM biomart;
GRANT ALL ON TABLE bio_data_ext_code TO biomart;
GRANT ALL ON TABLE bio_data_ext_code TO tm_cz;
GRANT SELECT ON TABLE bio_data_ext_code TO biomart_user;


--
-- Name: bio_data_literature; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_literature FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_literature FROM biomart;
GRANT ALL ON TABLE bio_data_literature TO biomart;
GRANT ALL ON TABLE bio_data_literature TO tm_cz;
GRANT SELECT ON TABLE bio_data_literature TO biomart_user;


--
-- Name: bio_data_observation; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_observation FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_observation FROM biomart;
GRANT ALL ON TABLE bio_data_observation TO biomart;
GRANT ALL ON TABLE bio_data_observation TO tm_cz;
GRANT SELECT ON TABLE bio_data_observation TO biomart_user;


--
-- Name: bio_data_omic_marker; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_omic_marker FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_omic_marker FROM biomart;
GRANT ALL ON TABLE bio_data_omic_marker TO biomart;
GRANT ALL ON TABLE bio_data_omic_marker TO tm_cz;
GRANT SELECT ON TABLE bio_data_omic_marker TO biomart_user;


--
-- Name: bio_data_platform; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_platform FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_platform FROM biomart;
GRANT ALL ON TABLE bio_data_platform TO biomart;
GRANT ALL ON TABLE bio_data_platform TO tm_cz;
GRANT SELECT ON TABLE bio_data_platform TO biomart_user;


--
-- Name: bio_data_taxonomy; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_data_taxonomy FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_taxonomy FROM biomart;
GRANT ALL ON TABLE bio_data_taxonomy TO biomart;
GRANT ALL ON TABLE bio_data_taxonomy TO tm_cz;
GRANT SELECT ON TABLE bio_data_taxonomy TO biomart_user;


--
-- Name: bio_experiment; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_experiment FROM PUBLIC;
REVOKE ALL ON TABLE bio_experiment FROM biomart;
GRANT ALL ON TABLE bio_experiment TO biomart;
GRANT ALL ON TABLE bio_experiment TO tm_cz;
GRANT SELECT ON TABLE bio_experiment TO biomart_user;


--
-- Name: bio_lit_alt_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_alt_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_alt_data FROM biomart;
GRANT ALL ON TABLE bio_lit_alt_data TO biomart;
GRANT ALL ON TABLE bio_lit_alt_data TO tm_cz;
GRANT SELECT ON TABLE bio_lit_alt_data TO biomart_user;


--
-- Name: bio_lit_amd_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_amd_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_amd_data FROM biomart;
GRANT ALL ON TABLE bio_lit_amd_data TO biomart;
GRANT ALL ON TABLE bio_lit_amd_data TO tm_cz;
GRANT SELECT ON TABLE bio_lit_amd_data TO biomart_user;


--
-- Name: bio_lit_inh_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_inh_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_inh_data FROM biomart;
GRANT ALL ON TABLE bio_lit_inh_data TO biomart;
GRANT ALL ON TABLE bio_lit_inh_data TO tm_cz;
GRANT SELECT ON TABLE bio_lit_inh_data TO biomart_user;


--
-- Name: bio_lit_int_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_int_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_int_data FROM biomart;
GRANT ALL ON TABLE bio_lit_int_data TO biomart;
GRANT ALL ON TABLE bio_lit_int_data TO tm_cz;
GRANT SELECT ON TABLE bio_lit_int_data TO biomart_user;


--
-- Name: bio_lit_int_model_mv; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_int_model_mv FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_int_model_mv FROM biomart;
GRANT ALL ON TABLE bio_lit_int_model_mv TO biomart;
GRANT ALL ON TABLE bio_lit_int_model_mv TO tm_cz;
GRANT SELECT ON TABLE bio_lit_int_model_mv TO biomart_user;


--
-- Name: bio_lit_model_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_model_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_model_data FROM biomart;
GRANT ALL ON TABLE bio_lit_model_data TO biomart;
GRANT ALL ON TABLE bio_lit_model_data TO tm_cz;
GRANT SELECT ON TABLE bio_lit_model_data TO biomart_user;


--
-- Name: bio_lit_int_model_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_int_model_view FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_int_model_view FROM biomart;
GRANT ALL ON TABLE bio_lit_int_model_view TO biomart;
GRANT ALL ON TABLE bio_lit_int_model_view TO tm_cz;
GRANT SELECT ON TABLE bio_lit_int_model_view TO biomart_user;


--
-- Name: bio_lit_pe_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_pe_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_pe_data FROM biomart;
GRANT ALL ON TABLE bio_lit_pe_data TO biomart;
GRANT ALL ON TABLE bio_lit_pe_data TO tm_cz;
GRANT SELECT ON TABLE bio_lit_pe_data TO biomart_user;


--
-- Name: bio_lit_ref_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_ref_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_ref_data FROM biomart;
GRANT ALL ON TABLE bio_lit_ref_data TO biomart;
GRANT ALL ON TABLE bio_lit_ref_data TO tm_cz;
GRANT SELECT ON TABLE bio_lit_ref_data TO biomart_user;


--
-- Name: bio_lit_sum_data; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_lit_sum_data FROM PUBLIC;
REVOKE ALL ON TABLE bio_lit_sum_data FROM biomart;
GRANT ALL ON TABLE bio_lit_sum_data TO biomart;
GRANT ALL ON TABLE bio_lit_sum_data TO tm_cz;
GRANT SELECT ON TABLE bio_lit_sum_data TO biomart_user;


--
-- Name: bio_marker_correl_mv; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_marker_correl_mv FROM PUBLIC;
REVOKE ALL ON TABLE bio_marker_correl_mv FROM biomart;
GRANT ALL ON TABLE bio_marker_correl_mv TO biomart;
GRANT ALL ON TABLE bio_marker_correl_mv TO tm_cz;
GRANT SELECT ON TABLE bio_marker_correl_mv TO biomart_user;


--
-- Name: bio_marker_correl_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_marker_correl_view FROM PUBLIC;
REVOKE ALL ON TABLE bio_marker_correl_view FROM biomart;
GRANT ALL ON TABLE bio_marker_correl_view TO biomart;
GRANT ALL ON TABLE bio_marker_correl_view TO tm_cz;
GRANT SELECT ON TABLE bio_marker_correl_view TO biomart_user;


--
-- Name: bio_marker_exp_analysis_mv; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_marker_exp_analysis_mv FROM PUBLIC;
REVOKE ALL ON TABLE bio_marker_exp_analysis_mv FROM biomart;
GRANT ALL ON TABLE bio_marker_exp_analysis_mv TO biomart;
GRANT ALL ON TABLE bio_marker_exp_analysis_mv TO tm_cz;
GRANT SELECT ON TABLE bio_marker_exp_analysis_mv TO biomart_user;


SET search_path = deapp, pg_catalog;

--
-- Name: de_metabolite_annotation; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_metabolite_annotation FROM PUBLIC;
REVOKE ALL ON TABLE de_metabolite_annotation FROM deapp;
GRANT ALL ON TABLE de_metabolite_annotation TO deapp;
GRANT ALL ON TABLE de_metabolite_annotation TO tm_cz;
GRANT SELECT ON TABLE de_metabolite_annotation TO biomart_user;


--
-- Name: de_metabolite_sub_pathways; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_metabolite_sub_pathways FROM PUBLIC;
REVOKE ALL ON TABLE de_metabolite_sub_pathways FROM deapp;
GRANT ALL ON TABLE de_metabolite_sub_pathways TO deapp;
GRANT ALL ON TABLE de_metabolite_sub_pathways TO tm_cz;
GRANT SELECT ON TABLE de_metabolite_sub_pathways TO biomart_user;


--
-- Name: de_metabolite_sub_pway_metab; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_metabolite_sub_pway_metab FROM PUBLIC;
REVOKE ALL ON TABLE de_metabolite_sub_pway_metab FROM deapp;
GRANT ALL ON TABLE de_metabolite_sub_pway_metab TO deapp;
GRANT ALL ON TABLE de_metabolite_sub_pway_metab TO tm_cz;
GRANT SELECT ON TABLE de_metabolite_sub_pway_metab TO biomart_user;


SET search_path = biomart, pg_catalog;

--
-- Name: bio_metab_subpathway_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_metab_subpathway_view FROM PUBLIC;
REVOKE ALL ON TABLE bio_metab_subpathway_view FROM biomart;
GRANT ALL ON TABLE bio_metab_subpathway_view TO biomart;
GRANT ALL ON TABLE bio_metab_subpathway_view TO tm_cz;
GRANT SELECT ON TABLE bio_metab_subpathway_view TO biomart_user;


SET search_path = deapp, pg_catalog;

--
-- Name: de_metabolite_super_pathways; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_metabolite_super_pathways FROM PUBLIC;
REVOKE ALL ON TABLE de_metabolite_super_pathways FROM deapp;
GRANT ALL ON TABLE de_metabolite_super_pathways TO deapp;
GRANT ALL ON TABLE de_metabolite_super_pathways TO tm_cz;
GRANT SELECT ON TABLE de_metabolite_super_pathways TO biomart_user;


SET search_path = biomart, pg_catalog;

--
-- Name: bio_metab_superpathway_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_metab_superpathway_view FROM PUBLIC;
REVOKE ALL ON TABLE bio_metab_superpathway_view FROM biomart;
GRANT ALL ON TABLE bio_metab_superpathway_view TO biomart;
GRANT ALL ON TABLE bio_metab_superpathway_view TO tm_cz;
GRANT SELECT ON TABLE bio_metab_superpathway_view TO biomart_user;


--
-- Name: bio_patient; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_patient FROM PUBLIC;
REVOKE ALL ON TABLE bio_patient FROM biomart;
GRANT ALL ON TABLE bio_patient TO biomart;
GRANT ALL ON TABLE bio_patient TO tm_cz;
GRANT SELECT ON TABLE bio_patient TO biomart_user;


--
-- Name: bio_patient_event; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_patient_event FROM PUBLIC;
REVOKE ALL ON TABLE bio_patient_event FROM biomart;
GRANT ALL ON TABLE bio_patient_event TO biomart;
GRANT ALL ON TABLE bio_patient_event TO tm_cz;
GRANT SELECT ON TABLE bio_patient_event TO biomart_user;


--
-- Name: bio_patient_event_attr; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_patient_event_attr FROM PUBLIC;
REVOKE ALL ON TABLE bio_patient_event_attr FROM biomart;
GRANT ALL ON TABLE bio_patient_event_attr TO biomart;
GRANT ALL ON TABLE bio_patient_event_attr TO tm_cz;
GRANT SELECT ON TABLE bio_patient_event_attr TO biomart_user;


--
-- Name: bio_recombination_rates; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_recombination_rates FROM PUBLIC;
REVOKE ALL ON TABLE bio_recombination_rates FROM biomart;
GRANT ALL ON TABLE bio_recombination_rates TO biomart;
GRANT ALL ON TABLE bio_recombination_rates TO tm_cz;
GRANT SELECT ON TABLE bio_recombination_rates TO biomart_user;


--
-- Name: bio_regulome_score; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_regulome_score FROM PUBLIC;
REVOKE ALL ON TABLE bio_regulome_score FROM biomart;
GRANT ALL ON TABLE bio_regulome_score TO biomart;
GRANT ALL ON TABLE bio_regulome_score TO tm_cz;
GRANT SELECT ON TABLE bio_regulome_score TO biomart_user;


--
-- Name: bio_sample; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_sample FROM PUBLIC;
REVOKE ALL ON TABLE bio_sample FROM biomart;
GRANT ALL ON TABLE bio_sample TO biomart;
GRANT ALL ON TABLE bio_sample TO tm_cz;
GRANT SELECT ON TABLE bio_sample TO biomart_user;


--
-- Name: bio_species_organism; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_species_organism FROM PUBLIC;
REVOKE ALL ON TABLE bio_species_organism FROM biomart;
GRANT ALL ON TABLE bio_species_organism TO biomart;
GRANT ALL ON TABLE bio_species_organism TO tm_cz;
GRANT SELECT ON TABLE bio_species_organism TO biomart_user;


--
-- Name: bio_stats_exp_marker; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_stats_exp_marker FROM PUBLIC;
REVOKE ALL ON TABLE bio_stats_exp_marker FROM biomart;
GRANT ALL ON TABLE bio_stats_exp_marker TO biomart;
GRANT ALL ON TABLE bio_stats_exp_marker TO tm_cz;
GRANT SELECT ON TABLE bio_stats_exp_marker TO biomart_user;


--
-- Name: bio_subject; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_subject FROM PUBLIC;
REVOKE ALL ON TABLE bio_subject FROM biomart;
GRANT ALL ON TABLE bio_subject TO biomart;
GRANT ALL ON TABLE bio_subject TO tm_cz;
GRANT SELECT ON TABLE bio_subject TO biomart_user;


--
-- Name: bio_taxonomy; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE bio_taxonomy FROM PUBLIC;
REVOKE ALL ON TABLE bio_taxonomy FROM biomart;
GRANT ALL ON TABLE bio_taxonomy TO biomart;
GRANT ALL ON TABLE bio_taxonomy TO tm_cz;
GRANT SELECT ON TABLE bio_taxonomy TO biomart_user;


--
-- Name: biobank_sample; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE biobank_sample FROM PUBLIC;
REVOKE ALL ON TABLE biobank_sample FROM biomart;
GRANT ALL ON TABLE biobank_sample TO biomart;
GRANT ALL ON TABLE biobank_sample TO tm_cz;
GRANT SELECT ON TABLE biobank_sample TO biomart_user;


--
-- Name: cta_results; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE cta_results FROM PUBLIC;
REVOKE ALL ON TABLE cta_results FROM biomart;
GRANT ALL ON TABLE cta_results TO biomart;
GRANT ALL ON TABLE cta_results TO tm_cz;
GRANT SELECT ON TABLE cta_results TO biomart_user;


--
-- Name: ctd2_clin_inhib_effect; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd2_clin_inhib_effect FROM PUBLIC;
REVOKE ALL ON TABLE ctd2_clin_inhib_effect FROM biomart;
GRANT ALL ON TABLE ctd2_clin_inhib_effect TO biomart;
GRANT ALL ON TABLE ctd2_clin_inhib_effect TO tm_cz;
GRANT SELECT ON TABLE ctd2_clin_inhib_effect TO biomart_user;


--
-- Name: ctd2_disease; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd2_disease FROM PUBLIC;
REVOKE ALL ON TABLE ctd2_disease FROM biomart;
GRANT ALL ON TABLE ctd2_disease TO biomart;
GRANT ALL ON TABLE ctd2_disease TO tm_cz;
GRANT SELECT ON TABLE ctd2_disease TO biomart_user;


--
-- Name: ctd2_inhib_details; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd2_inhib_details FROM PUBLIC;
REVOKE ALL ON TABLE ctd2_inhib_details FROM biomart;
GRANT ALL ON TABLE ctd2_inhib_details TO biomart;
GRANT ALL ON TABLE ctd2_inhib_details TO tm_cz;
GRANT SELECT ON TABLE ctd2_inhib_details TO biomart_user;


--
-- Name: ctd2_study; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd2_study FROM PUBLIC;
REVOKE ALL ON TABLE ctd2_study FROM biomart;
GRANT ALL ON TABLE ctd2_study TO biomart;
GRANT ALL ON TABLE ctd2_study TO tm_cz;
GRANT SELECT ON TABLE ctd2_study TO biomart_user;


--
-- Name: ctd2_trial_details; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd2_trial_details FROM PUBLIC;
REVOKE ALL ON TABLE ctd2_trial_details FROM biomart;
GRANT ALL ON TABLE ctd2_trial_details TO biomart;
GRANT ALL ON TABLE ctd2_trial_details TO tm_cz;
GRANT SELECT ON TABLE ctd2_trial_details TO biomart_user;


--
-- Name: ctd_allowed_meds_treatment; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_allowed_meds_treatment FROM PUBLIC;
REVOKE ALL ON TABLE ctd_allowed_meds_treatment FROM biomart;
GRANT ALL ON TABLE ctd_allowed_meds_treatment TO biomart;
GRANT ALL ON TABLE ctd_allowed_meds_treatment TO tm_cz;
GRANT SELECT ON TABLE ctd_allowed_meds_treatment TO biomart_user;


--
-- Name: ctd_full; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_full FROM PUBLIC;
REVOKE ALL ON TABLE ctd_full FROM biomart;
GRANT ALL ON TABLE ctd_full TO biomart;
GRANT ALL ON TABLE ctd_full TO tm_cz;
GRANT SELECT ON TABLE ctd_full TO biomart_user;


--
-- Name: ctd_arm_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_arm_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_arm_view FROM biomart;
GRANT ALL ON TABLE ctd_arm_view TO biomart;
GRANT ALL ON TABLE ctd_arm_view TO tm_cz;
GRANT SELECT ON TABLE ctd_arm_view TO biomart_user;


--
-- Name: ctd_biomarker; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_biomarker FROM PUBLIC;
REVOKE ALL ON TABLE ctd_biomarker FROM biomart;
GRANT ALL ON TABLE ctd_biomarker TO biomart;
GRANT ALL ON TABLE ctd_biomarker TO tm_cz;
GRANT SELECT ON TABLE ctd_biomarker TO biomart_user;


--
-- Name: ctd_biomarker_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_biomarker_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_biomarker_view FROM biomart;
GRANT ALL ON TABLE ctd_biomarker_view TO biomart;
GRANT ALL ON TABLE ctd_biomarker_view TO tm_cz;
GRANT SELECT ON TABLE ctd_biomarker_view TO biomart_user;


--
-- Name: ctd_cell_info_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_cell_info_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_cell_info_view FROM biomart;
GRANT ALL ON TABLE ctd_cell_info_view TO biomart;
GRANT ALL ON TABLE ctd_cell_info_view TO tm_cz;
GRANT SELECT ON TABLE ctd_cell_info_view TO biomart_user;


--
-- Name: ctd_clinical_chars_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_clinical_chars_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_clinical_chars_view FROM biomart;
GRANT ALL ON TABLE ctd_clinical_chars_view TO biomart;
GRANT ALL ON TABLE ctd_clinical_chars_view TO tm_cz;
GRANT SELECT ON TABLE ctd_clinical_chars_view TO biomart_user;


--
-- Name: ctd_disease; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_disease FROM PUBLIC;
REVOKE ALL ON TABLE ctd_disease FROM biomart;
GRANT ALL ON TABLE ctd_disease TO biomart;
GRANT ALL ON TABLE ctd_disease TO tm_cz;
GRANT SELECT ON TABLE ctd_disease TO biomart_user;


--
-- Name: ctd_drug_effects_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_drug_effects_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_drug_effects_view FROM biomart;
GRANT ALL ON TABLE ctd_drug_effects_view TO biomart;
GRANT ALL ON TABLE ctd_drug_effects_view TO tm_cz;
GRANT SELECT ON TABLE ctd_drug_effects_view TO biomart_user;


--
-- Name: ctd_drug_inhib; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_drug_inhib FROM PUBLIC;
REVOKE ALL ON TABLE ctd_drug_inhib FROM biomart;
GRANT ALL ON TABLE ctd_drug_inhib TO biomart;
GRANT ALL ON TABLE ctd_drug_inhib TO tm_cz;
GRANT SELECT ON TABLE ctd_drug_inhib TO biomart_user;


--
-- Name: ctd_drug_inhibitor_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_drug_inhibitor_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_drug_inhibitor_view FROM biomart;
GRANT ALL ON TABLE ctd_drug_inhibitor_view TO biomart;
GRANT ALL ON TABLE ctd_drug_inhibitor_view TO tm_cz;
GRANT SELECT ON TABLE ctd_drug_inhibitor_view TO biomart_user;


--
-- Name: ctd_events_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_events_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_events_view FROM biomart;
GRANT ALL ON TABLE ctd_events_view TO biomart;
GRANT ALL ON TABLE ctd_events_view TO tm_cz;
GRANT SELECT ON TABLE ctd_events_view TO biomart_user;


--
-- Name: ctd_experiments_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_experiments_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_experiments_view FROM biomart;
GRANT ALL ON TABLE ctd_experiments_view TO biomart;
GRANT ALL ON TABLE ctd_experiments_view TO tm_cz;
GRANT SELECT ON TABLE ctd_experiments_view TO biomart_user;


--
-- Name: ctd_expr_after_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_expr_after_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_expr_after_view FROM biomart;
GRANT ALL ON TABLE ctd_expr_after_view TO biomart;
GRANT ALL ON TABLE ctd_expr_after_view TO tm_cz;
GRANT SELECT ON TABLE ctd_expr_after_view TO biomart_user;


--
-- Name: ctd_expr_baseline_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_expr_baseline_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_expr_baseline_view FROM biomart;
GRANT ALL ON TABLE ctd_expr_baseline_view TO biomart;
GRANT ALL ON TABLE ctd_expr_baseline_view TO tm_cz;
GRANT SELECT ON TABLE ctd_expr_baseline_view TO biomart_user;


--
-- Name: ctd_expr_bio_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_expr_bio_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_expr_bio_view FROM biomart;
GRANT ALL ON TABLE ctd_expr_bio_view TO biomart;
GRANT ALL ON TABLE ctd_expr_bio_view TO tm_cz;
GRANT SELECT ON TABLE ctd_expr_bio_view TO biomart_user;


--
-- Name: ctd_expr_source_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_expr_source_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_expr_source_view FROM biomart;
GRANT ALL ON TABLE ctd_expr_source_view TO biomart;
GRANT ALL ON TABLE ctd_expr_source_view TO tm_cz;
GRANT SELECT ON TABLE ctd_expr_source_view TO biomart_user;


--
-- Name: ctd_full_clinical_endpts_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_full_clinical_endpts_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_full_clinical_endpts_view FROM biomart;
GRANT ALL ON TABLE ctd_full_clinical_endpts_view TO biomart;
GRANT ALL ON TABLE ctd_full_clinical_endpts_view TO tm_cz;
GRANT SELECT ON TABLE ctd_full_clinical_endpts_view TO biomart_user;


--
-- Name: ctd_full_search_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_full_search_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_full_search_view FROM biomart;
GRANT ALL ON TABLE ctd_full_search_view TO biomart;
GRANT ALL ON TABLE ctd_full_search_view TO tm_cz;
GRANT SELECT ON TABLE ctd_full_search_view TO biomart_user;


--
-- Name: ctd_inclusion_criteria; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_inclusion_criteria FROM PUBLIC;
REVOKE ALL ON TABLE ctd_inclusion_criteria FROM biomart;
GRANT ALL ON TABLE ctd_inclusion_criteria TO biomart;
GRANT ALL ON TABLE ctd_inclusion_criteria TO tm_cz;
GRANT SELECT ON TABLE ctd_inclusion_criteria TO biomart_user;


--
-- Name: ctd_primary_endpts; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_primary_endpts FROM PUBLIC;
REVOKE ALL ON TABLE ctd_primary_endpts FROM biomart;
GRANT ALL ON TABLE ctd_primary_endpts TO biomart;
GRANT ALL ON TABLE ctd_primary_endpts TO tm_cz;
GRANT SELECT ON TABLE ctd_primary_endpts TO biomart_user;


--
-- Name: ctd_primary_endpts_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_primary_endpts_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_primary_endpts_view FROM biomart;
GRANT ALL ON TABLE ctd_primary_endpts_view TO biomart;
GRANT ALL ON TABLE ctd_primary_endpts_view TO tm_cz;
GRANT SELECT ON TABLE ctd_primary_endpts_view TO biomart_user;


--
-- Name: ctd_prior_med_use_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_prior_med_use_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_prior_med_use_view FROM biomart;
GRANT ALL ON TABLE ctd_prior_med_use_view TO biomart;
GRANT ALL ON TABLE ctd_prior_med_use_view TO tm_cz;
GRANT SELECT ON TABLE ctd_prior_med_use_view TO biomart_user;


--
-- Name: ctd_pulmonary_path_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_pulmonary_path_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_pulmonary_path_view FROM biomart;
GRANT ALL ON TABLE ctd_pulmonary_path_view TO biomart;
GRANT ALL ON TABLE ctd_pulmonary_path_view TO tm_cz;
GRANT SELECT ON TABLE ctd_pulmonary_path_view TO biomart_user;


--
-- Name: ctd_quant_params_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_quant_params_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_quant_params_view FROM biomart;
GRANT ALL ON TABLE ctd_quant_params_view TO biomart;
GRANT ALL ON TABLE ctd_quant_params_view TO tm_cz;
GRANT SELECT ON TABLE ctd_quant_params_view TO biomart_user;


--
-- Name: ctd_reference_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_reference_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_reference_view FROM biomart;
GRANT ALL ON TABLE ctd_reference_view TO biomart;
GRANT ALL ON TABLE ctd_reference_view TO tm_cz;
GRANT SELECT ON TABLE ctd_reference_view TO biomart_user;


--
-- Name: ctd_runin_therapies_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_runin_therapies_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_runin_therapies_view FROM biomart;
GRANT ALL ON TABLE ctd_runin_therapies_view TO biomart;
GRANT ALL ON TABLE ctd_runin_therapies_view TO tm_cz;
GRANT SELECT ON TABLE ctd_runin_therapies_view TO biomart_user;


--
-- Name: ctd_sec_endpts; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_sec_endpts FROM PUBLIC;
REVOKE ALL ON TABLE ctd_sec_endpts FROM biomart;
GRANT ALL ON TABLE ctd_sec_endpts TO biomart;
GRANT ALL ON TABLE ctd_sec_endpts TO tm_cz;
GRANT SELECT ON TABLE ctd_sec_endpts TO biomart_user;


--
-- Name: ctd_secondary_endpts_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_secondary_endpts_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_secondary_endpts_view FROM biomart;
GRANT ALL ON TABLE ctd_secondary_endpts_view TO biomart;
GRANT ALL ON TABLE ctd_secondary_endpts_view TO tm_cz;
GRANT SELECT ON TABLE ctd_secondary_endpts_view TO biomart_user;


--
-- Name: ctd_stats_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_stats_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_stats_view FROM biomart;
GRANT ALL ON TABLE ctd_stats_view TO biomart;
GRANT ALL ON TABLE ctd_stats_view TO tm_cz;
GRANT SELECT ON TABLE ctd_stats_view TO biomart_user;


--
-- Name: ctd_study; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_study FROM PUBLIC;
REVOKE ALL ON TABLE ctd_study FROM biomart;
GRANT ALL ON TABLE ctd_study TO biomart;
GRANT ALL ON TABLE ctd_study TO tm_cz;
GRANT SELECT ON TABLE ctd_study TO biomart_user;


--
-- Name: ctd_study_details_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_study_details_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_study_details_view FROM biomart;
GRANT ALL ON TABLE ctd_study_details_view TO biomart;
GRANT ALL ON TABLE ctd_study_details_view TO tm_cz;
GRANT SELECT ON TABLE ctd_study_details_view TO biomart_user;


--
-- Name: ctd_td_design_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_td_design_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_td_design_view FROM biomart;
GRANT ALL ON TABLE ctd_td_design_view TO biomart;
GRANT ALL ON TABLE ctd_td_design_view TO tm_cz;
GRANT SELECT ON TABLE ctd_td_design_view TO biomart_user;


--
-- Name: ctd_td_excl_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_td_excl_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_td_excl_view FROM biomart;
GRANT ALL ON TABLE ctd_td_excl_view TO biomart;
GRANT ALL ON TABLE ctd_td_excl_view TO tm_cz;
GRANT SELECT ON TABLE ctd_td_excl_view TO biomart_user;


--
-- Name: ctd_td_inclusion_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_td_inclusion_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_td_inclusion_view FROM biomart;
GRANT ALL ON TABLE ctd_td_inclusion_view TO biomart;
GRANT ALL ON TABLE ctd_td_inclusion_view TO tm_cz;
GRANT SELECT ON TABLE ctd_td_inclusion_view TO biomart_user;


--
-- Name: ctd_td_smoker_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_td_smoker_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_td_smoker_view FROM biomart;
GRANT ALL ON TABLE ctd_td_smoker_view TO biomart;
GRANT ALL ON TABLE ctd_td_smoker_view TO tm_cz;
GRANT SELECT ON TABLE ctd_td_smoker_view TO biomart_user;


--
-- Name: ctd_td_sponsor_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_td_sponsor_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_td_sponsor_view FROM biomart;
GRANT ALL ON TABLE ctd_td_sponsor_view TO biomart;
GRANT ALL ON TABLE ctd_td_sponsor_view TO tm_cz;
GRANT SELECT ON TABLE ctd_td_sponsor_view TO biomart_user;


--
-- Name: ctd_td_status_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_td_status_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_td_status_view FROM biomart;
GRANT ALL ON TABLE ctd_td_status_view TO biomart;
GRANT ALL ON TABLE ctd_td_status_view TO tm_cz;
GRANT SELECT ON TABLE ctd_td_status_view TO biomart_user;


--
-- Name: ctd_treatment_phases_view; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE ctd_treatment_phases_view FROM PUBLIC;
REVOKE ALL ON TABLE ctd_treatment_phases_view FROM biomart;
GRANT ALL ON TABLE ctd_treatment_phases_view TO biomart;
GRANT ALL ON TABLE ctd_treatment_phases_view TO tm_cz;
GRANT SELECT ON TABLE ctd_treatment_phases_view TO biomart_user;


--
-- Name: dd; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE dd FROM PUBLIC;
REVOKE ALL ON TABLE dd FROM biomart;
GRANT ALL ON TABLE dd TO biomart;
GRANT ALL ON TABLE dd TO tm_cz;
GRANT SELECT ON TABLE dd TO biomart_user;


--
-- Name: gene_info_test; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE gene_info_test FROM PUBLIC;
REVOKE ALL ON TABLE gene_info_test FROM biomart;
GRANT ALL ON TABLE gene_info_test TO biomart;
GRANT ALL ON TABLE gene_info_test TO tm_cz;
GRANT SELECT ON TABLE gene_info_test TO biomart_user;


--
-- Name: gene_synonym_test; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE gene_synonym_test FROM PUBLIC;
REVOKE ALL ON TABLE gene_synonym_test FROM biomart;
GRANT ALL ON TABLE gene_synonym_test TO biomart;
GRANT ALL ON TABLE gene_synonym_test TO tm_cz;
GRANT SELECT ON TABLE gene_synonym_test TO biomart_user;


--
-- Name: genego_gene_map; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE genego_gene_map FROM PUBLIC;
REVOKE ALL ON TABLE genego_gene_map FROM biomart;
GRANT ALL ON TABLE genego_gene_map TO biomart;
GRANT ALL ON TABLE genego_gene_map TO tm_cz;
GRANT SELECT ON TABLE genego_gene_map TO biomart_user;


--
-- Name: gse_analysis; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE gse_analysis FROM PUBLIC;
REVOKE ALL ON TABLE gse_analysis FROM biomart;
GRANT ALL ON TABLE gse_analysis TO biomart;
GRANT ALL ON TABLE gse_analysis TO tm_cz;
GRANT SELECT ON TABLE gse_analysis TO biomart_user;


--
-- Name: gse_probeset; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE gse_probeset FROM PUBLIC;
REVOKE ALL ON TABLE gse_probeset FROM biomart;
GRANT ALL ON TABLE gse_probeset TO biomart;
GRANT ALL ON TABLE gse_probeset TO tm_cz;
GRANT SELECT ON TABLE gse_probeset TO biomart_user;


--
-- Name: heat_map_results; Type: ACL; Schema: biomart; Owner: tm_cz
--

REVOKE ALL ON TABLE heat_map_results FROM PUBLIC;
REVOKE ALL ON TABLE heat_map_results FROM tm_cz;
GRANT ALL ON TABLE heat_map_results TO tm_cz;
GRANT ALL ON TABLE heat_map_results TO biomart;
GRANT SELECT ON TABLE heat_map_results TO biomart_user;


--
-- Name: hibernate_sequence; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON SEQUENCE hibernate_sequence FROM PUBLIC;
REVOKE ALL ON SEQUENCE hibernate_sequence FROM biomart;
GRANT ALL ON SEQUENCE hibernate_sequence TO biomart;
GRANT ALL ON SEQUENCE hibernate_sequence TO tm_cz;
GRANT ALL ON SEQUENCE hibernate_sequence TO biomart_user;


--
-- Name: mesh; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE mesh FROM PUBLIC;
REVOKE ALL ON TABLE mesh FROM biomart;
GRANT ALL ON TABLE mesh TO biomart;
GRANT ALL ON TABLE mesh TO tm_cz;
GRANT SELECT ON TABLE mesh TO biomart_user;


--
-- Name: mesh_copy; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE mesh_copy FROM PUBLIC;
REVOKE ALL ON TABLE mesh_copy FROM biomart;
GRANT ALL ON TABLE mesh_copy TO biomart;
GRANT ALL ON TABLE mesh_copy TO tm_cz;
GRANT SELECT ON TABLE mesh_copy TO biomart_user;


--
-- Name: mesh_descriptor; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE mesh_descriptor FROM PUBLIC;
REVOKE ALL ON TABLE mesh_descriptor FROM biomart;
GRANT ALL ON TABLE mesh_descriptor TO biomart;
GRANT ALL ON TABLE mesh_descriptor TO tm_cz;
GRANT SELECT ON TABLE mesh_descriptor TO biomart_user;


--
-- Name: mesh_entry; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE mesh_entry FROM PUBLIC;
REVOKE ALL ON TABLE mesh_entry FROM biomart;
GRANT ALL ON TABLE mesh_entry TO biomart;
GRANT ALL ON TABLE mesh_entry TO tm_cz;
GRANT SELECT ON TABLE mesh_entry TO biomart_user;


--
-- Name: mesh_path; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE mesh_path FROM PUBLIC;
REVOKE ALL ON TABLE mesh_path FROM biomart;
GRANT ALL ON TABLE mesh_path TO biomart;
GRANT ALL ON TABLE mesh_path TO tm_cz;
GRANT SELECT ON TABLE mesh_path TO biomart_user;


--
-- Name: mesh_temp; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE mesh_temp FROM PUBLIC;
REVOKE ALL ON TABLE mesh_temp FROM biomart;
GRANT ALL ON TABLE mesh_temp TO biomart;
GRANT ALL ON TABLE mesh_temp TO tm_cz;
GRANT SELECT ON TABLE mesh_temp TO biomart_user;


--
-- Name: mesh_with_parent; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE mesh_with_parent FROM PUBLIC;
REVOKE ALL ON TABLE mesh_with_parent FROM biomart;
GRANT ALL ON TABLE mesh_with_parent TO biomart;
GRANT ALL ON TABLE mesh_with_parent TO tm_cz;
GRANT SELECT ON TABLE mesh_with_parent TO biomart_user;


--
-- Name: mirna_bio_assay_data_annot; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE mirna_bio_assay_data_annot FROM PUBLIC;
REVOKE ALL ON TABLE mirna_bio_assay_data_annot FROM biomart;
GRANT ALL ON TABLE mirna_bio_assay_data_annot TO biomart;
GRANT ALL ON TABLE mirna_bio_assay_data_annot TO tm_cz;
GRANT SELECT ON TABLE mirna_bio_assay_data_annot TO biomart_user;


--
-- Name: seq_bio_data_id; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON SEQUENCE seq_bio_data_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_bio_data_id FROM biomart;
GRANT ALL ON SEQUENCE seq_bio_data_id TO biomart;
GRANT ALL ON SEQUENCE seq_bio_data_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_bio_data_id TO biomart_user;


--
-- Name: mirna_bio_assay_feature_group; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE mirna_bio_assay_feature_group FROM PUBLIC;
REVOKE ALL ON TABLE mirna_bio_assay_feature_group FROM biomart;
GRANT ALL ON TABLE mirna_bio_assay_feature_group TO biomart;
GRANT ALL ON TABLE mirna_bio_assay_feature_group TO tm_cz;
GRANT SELECT ON TABLE mirna_bio_assay_feature_group TO biomart_user;


--
-- Name: mirna_bio_marker; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE mirna_bio_marker FROM PUBLIC;
REVOKE ALL ON TABLE mirna_bio_marker FROM biomart;
GRANT ALL ON TABLE mirna_bio_marker TO biomart;
GRANT ALL ON TABLE mirna_bio_marker TO tm_cz;
GRANT SELECT ON TABLE mirna_bio_marker TO biomart_user;


--
-- Name: project_info; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE project_info FROM PUBLIC;
REVOKE ALL ON TABLE project_info FROM biomart;
GRANT ALL ON TABLE project_info TO biomart;
GRANT ALL ON TABLE project_info TO tm_cz;
GRANT SELECT ON TABLE project_info TO biomart_user;


--
-- Name: seq_bio_data_fact_id; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON SEQUENCE seq_bio_data_fact_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_bio_data_fact_id FROM biomart;
GRANT ALL ON SEQUENCE seq_bio_data_fact_id TO biomart;
GRANT ALL ON SEQUENCE seq_bio_data_fact_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_bio_data_fact_id TO biomart_user;


--
-- Name: seq_clinical_trial_design_id; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON SEQUENCE seq_clinical_trial_design_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_clinical_trial_design_id FROM biomart;
GRANT ALL ON SEQUENCE seq_clinical_trial_design_id TO biomart;
GRANT ALL ON SEQUENCE seq_clinical_trial_design_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_clinical_trial_design_id TO biomart_user;


--
-- Name: tests; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE tests FROM PUBLIC;
REVOKE ALL ON TABLE tests FROM biomart;
GRANT ALL ON TABLE tests TO biomart;
GRANT ALL ON TABLE tests TO tm_cz;
GRANT SELECT ON TABLE tests TO biomart_user;


--
-- Name: tmp_bio_marker; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE tmp_bio_marker FROM PUBLIC;
REVOKE ALL ON TABLE tmp_bio_marker FROM biomart;
GRANT ALL ON TABLE tmp_bio_marker TO biomart;
GRANT ALL ON TABLE tmp_bio_marker TO tm_cz;
GRANT SELECT ON TABLE tmp_bio_marker TO biomart_user;


--
-- Name: tmp_omicsoft_compound; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE tmp_omicsoft_compound FROM PUBLIC;
REVOKE ALL ON TABLE tmp_omicsoft_compound FROM biomart;
GRANT ALL ON TABLE tmp_omicsoft_compound TO biomart;
GRANT ALL ON TABLE tmp_omicsoft_compound TO tm_cz;
GRANT SELECT ON TABLE tmp_omicsoft_compound TO biomart_user;


--
-- Name: tmp_omicsoft_disease_m1; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE tmp_omicsoft_disease_m1 FROM PUBLIC;
REVOKE ALL ON TABLE tmp_omicsoft_disease_m1 FROM biomart;
GRANT ALL ON TABLE tmp_omicsoft_disease_m1 TO biomart;
GRANT ALL ON TABLE tmp_omicsoft_disease_m1 TO tm_cz;
GRANT SELECT ON TABLE tmp_omicsoft_disease_m1 TO biomart_user;


--
-- Name: tmp_project_category; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE tmp_project_category FROM PUBLIC;
REVOKE ALL ON TABLE tmp_project_category FROM biomart;
GRANT ALL ON TABLE tmp_project_category TO biomart;
GRANT ALL ON TABLE tmp_project_category TO tm_cz;
GRANT SELECT ON TABLE tmp_project_category TO biomart_user;


--
-- Name: tmp_project_compound; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE tmp_project_compound FROM PUBLIC;
REVOKE ALL ON TABLE tmp_project_compound FROM biomart;
GRANT ALL ON TABLE tmp_project_compound TO biomart;
GRANT ALL ON TABLE tmp_project_compound TO tm_cz;
GRANT SELECT ON TABLE tmp_project_compound TO biomart_user;


--
-- Name: tmp_project_disease; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE tmp_project_disease FROM PUBLIC;
REVOKE ALL ON TABLE tmp_project_disease FROM biomart;
GRANT ALL ON TABLE tmp_project_disease TO biomart;
GRANT ALL ON TABLE tmp_project_disease TO tm_cz;
GRANT SELECT ON TABLE tmp_project_disease TO biomart_user;


--
-- Name: vw_faceted_search; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE vw_faceted_search FROM PUBLIC;
REVOKE ALL ON TABLE vw_faceted_search FROM biomart;
GRANT ALL ON TABLE vw_faceted_search TO biomart;
GRANT ALL ON TABLE vw_faceted_search TO tm_cz;
GRANT SELECT ON TABLE vw_faceted_search TO biomart_user;


--
-- Name: vw_faceted_search_disease; Type: ACL; Schema: biomart; Owner: biomart
--

REVOKE ALL ON TABLE vw_faceted_search_disease FROM PUBLIC;
REVOKE ALL ON TABLE vw_faceted_search_disease FROM biomart;
GRANT ALL ON TABLE vw_faceted_search_disease TO biomart;
GRANT ALL ON TABLE vw_faceted_search_disease TO tm_cz;
GRANT SELECT ON TABLE vw_faceted_search_disease TO biomart_user;


SET search_path = fmapp, pg_catalog;

--
-- Name: fm_data_uid; Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON TABLE fm_data_uid FROM PUBLIC;
REVOKE ALL ON TABLE fm_data_uid FROM fmapp;
GRANT ALL ON TABLE fm_data_uid TO fmapp;
GRANT ALL ON TABLE fm_data_uid TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE fm_data_uid TO biomart_user;


--
-- Name: fm_folder; Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON TABLE fm_folder FROM PUBLIC;
REVOKE ALL ON TABLE fm_folder FROM fmapp;
GRANT ALL ON TABLE fm_folder TO fmapp;
GRANT ALL ON TABLE fm_folder TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE fm_folder TO biomart_user;


--
-- Name: fm_folder_association; Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON TABLE fm_folder_association FROM PUBLIC;
REVOKE ALL ON TABLE fm_folder_association FROM fmapp;
GRANT ALL ON TABLE fm_folder_association TO fmapp;
GRANT ALL ON TABLE fm_folder_association TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE fm_folder_association TO biomart_user;


SET search_path = biomart_user, pg_catalog;

--
-- Name: browse_analyses_view; Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON TABLE browse_analyses_view FROM PUBLIC;
REVOKE ALL ON TABLE browse_analyses_view FROM biomart_user;
GRANT ALL ON TABLE browse_analyses_view TO biomart_user;
GRANT ALL ON TABLE browse_analyses_view TO tm_cz;


--
-- Name: browse_assays_view; Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON TABLE browse_assays_view FROM PUBLIC;
REVOKE ALL ON TABLE browse_assays_view FROM biomart_user;
GRANT ALL ON TABLE browse_assays_view TO biomart_user;
GRANT ALL ON TABLE browse_assays_view TO tm_cz;


--
-- Name: browse_folders_view; Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON TABLE browse_folders_view FROM PUBLIC;
REVOKE ALL ON TABLE browse_folders_view FROM biomart_user;
GRANT ALL ON TABLE browse_folders_view TO biomart_user;
GRANT ALL ON TABLE browse_folders_view TO tm_cz;


--
-- Name: browse_programs_view; Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON TABLE browse_programs_view FROM PUBLIC;
REVOKE ALL ON TABLE browse_programs_view FROM biomart_user;
GRANT ALL ON TABLE browse_programs_view TO biomart_user;
GRANT ALL ON TABLE browse_programs_view TO tm_cz;


--
-- Name: browse_studies_view; Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON TABLE browse_studies_view FROM PUBLIC;
REVOKE ALL ON TABLE browse_studies_view FROM biomart_user;
GRANT ALL ON TABLE browse_studies_view TO biomart_user;
GRANT ALL ON TABLE browse_studies_view TO tm_cz;


--
-- Name: gene_ontology; Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON TABLE gene_ontology FROM PUBLIC;
REVOKE ALL ON TABLE gene_ontology FROM biomart_user;
GRANT ALL ON TABLE gene_ontology TO biomart_user;
GRANT ALL ON TABLE gene_ontology TO tm_cz;


--
-- Name: gene_ontology_data; Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON TABLE gene_ontology_data FROM PUBLIC;
REVOKE ALL ON TABLE gene_ontology_data FROM biomart_user;
GRANT ALL ON TABLE gene_ontology_data TO biomart_user;
GRANT ALL ON TABLE gene_ontology_data TO tm_cz;


--
-- Name: ioe_temp_obj_reg2; Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON TABLE ioe_temp_obj_reg2 FROM PUBLIC;
REVOKE ALL ON TABLE ioe_temp_obj_reg2 FROM biomart_user;
GRANT ALL ON TABLE ioe_temp_obj_reg2 TO biomart_user;
GRANT ALL ON TABLE ioe_temp_obj_reg2 TO tm_cz;


--
-- Name: kde_temp_obj_reg3; Type: ACL; Schema: biomart_user; Owner: biomart_user
--

REVOKE ALL ON TABLE kde_temp_obj_reg3 FROM PUBLIC;
REVOKE ALL ON TABLE kde_temp_obj_reg3 FROM biomart_user;
GRANT ALL ON TABLE kde_temp_obj_reg3 TO biomart_user;
GRANT ALL ON TABLE kde_temp_obj_reg3 TO tm_cz;


SET search_path = deapp, pg_catalog;

--
-- Name: de_chromo_region_id_seq; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE de_chromo_region_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE de_chromo_region_id_seq FROM deapp;
GRANT ALL ON SEQUENCE de_chromo_region_id_seq TO deapp;
GRANT ALL ON SEQUENCE de_chromo_region_id_seq TO tm_cz;
GRANT ALL ON SEQUENCE de_chromo_region_id_seq TO biomart_user;


--
-- Name: de_chromosomal_region; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_chromosomal_region FROM PUBLIC;
REVOKE ALL ON TABLE de_chromosomal_region FROM deapp;
GRANT ALL ON TABLE de_chromosomal_region TO deapp;
GRANT ALL ON TABLE de_chromosomal_region TO tm_cz;
GRANT SELECT ON TABLE de_chromosomal_region TO biomart_user;


--
-- Name: de_concept_visit; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_concept_visit FROM PUBLIC;
REVOKE ALL ON TABLE de_concept_visit FROM deapp;
GRANT ALL ON TABLE de_concept_visit TO deapp;
GRANT ALL ON TABLE de_concept_visit TO tm_cz;
GRANT SELECT ON TABLE de_concept_visit TO biomart_user;


--
-- Name: de_encounter_level; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_encounter_level FROM PUBLIC;
REVOKE ALL ON TABLE de_encounter_level FROM deapp;
GRANT ALL ON TABLE de_encounter_level TO deapp;
GRANT ALL ON TABLE de_encounter_level TO tm_cz;
GRANT SELECT ON TABLE de_encounter_level TO biomart_user;


--
-- Name: de_encounter_type; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_encounter_type FROM PUBLIC;
REVOKE ALL ON TABLE de_encounter_type FROM deapp;
GRANT ALL ON TABLE de_encounter_type TO deapp;
GRANT ALL ON TABLE de_encounter_type TO tm_cz;
GRANT SELECT ON TABLE de_encounter_type TO biomart_user;


--
-- Name: de_gpl_info; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_gpl_info FROM PUBLIC;
REVOKE ALL ON TABLE de_gpl_info FROM deapp;
GRANT ALL ON TABLE de_gpl_info TO deapp;
GRANT ALL ON TABLE de_gpl_info TO tm_cz;
GRANT SELECT ON TABLE de_gpl_info TO biomart_user;


--
-- Name: de_mrna_annotation; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_mrna_annotation FROM PUBLIC;
REVOKE ALL ON TABLE de_mrna_annotation FROM deapp;
GRANT ALL ON TABLE de_mrna_annotation TO deapp;
GRANT ALL ON TABLE de_mrna_annotation TO tm_cz;
GRANT SELECT ON TABLE de_mrna_annotation TO biomart_user;


--
-- Name: de_obs_enroll_days; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_obs_enroll_days FROM PUBLIC;
REVOKE ALL ON TABLE de_obs_enroll_days FROM deapp;
GRANT ALL ON TABLE de_obs_enroll_days TO deapp;
GRANT ALL ON TABLE de_obs_enroll_days TO tm_cz;
GRANT SELECT ON TABLE de_obs_enroll_days TO biomart_user;


--
-- Name: de_parent_cd_seq; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE de_parent_cd_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE de_parent_cd_seq FROM deapp;
GRANT ALL ON SEQUENCE de_parent_cd_seq TO deapp;
GRANT ALL ON SEQUENCE de_parent_cd_seq TO tm_cz;
GRANT ALL ON SEQUENCE de_parent_cd_seq TO biomart_user;


--
-- Name: de_pathway; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_pathway FROM PUBLIC;
REVOKE ALL ON TABLE de_pathway FROM deapp;
GRANT ALL ON TABLE de_pathway TO deapp;
GRANT ALL ON TABLE de_pathway TO tm_cz;
GRANT SELECT ON TABLE de_pathway TO biomart_user;


--
-- Name: de_pathway_gene; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_pathway_gene FROM PUBLIC;
REVOKE ALL ON TABLE de_pathway_gene FROM deapp;
GRANT ALL ON TABLE de_pathway_gene TO deapp;
GRANT ALL ON TABLE de_pathway_gene TO tm_cz;
GRANT SELECT ON TABLE de_pathway_gene TO biomart_user;


--
-- Name: protein_annotation_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE protein_annotation_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE protein_annotation_id FROM deapp;
GRANT ALL ON SEQUENCE protein_annotation_id TO deapp;
GRANT ALL ON SEQUENCE protein_annotation_id TO tm_cz;
GRANT ALL ON SEQUENCE protein_annotation_id TO biomart_user;


--
-- Name: de_protein_annotation; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_protein_annotation FROM PUBLIC;
REVOKE ALL ON TABLE de_protein_annotation FROM deapp;
GRANT ALL ON TABLE de_protein_annotation TO deapp;
GRANT ALL ON TABLE de_protein_annotation TO tm_cz;
GRANT SELECT ON TABLE de_protein_annotation TO biomart_user;


--
-- Name: de_qpcr_mirna_annotation; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_qpcr_mirna_annotation FROM PUBLIC;
REVOKE ALL ON TABLE de_qpcr_mirna_annotation FROM deapp;
GRANT ALL ON TABLE de_qpcr_mirna_annotation TO deapp;
GRANT ALL ON TABLE de_qpcr_mirna_annotation TO tm_cz;
GRANT SELECT ON TABLE de_qpcr_mirna_annotation TO biomart_user;


--
-- Name: de_rbm_annotation; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_rbm_annotation FROM PUBLIC;
REVOKE ALL ON TABLE de_rbm_annotation FROM deapp;
GRANT ALL ON TABLE de_rbm_annotation TO deapp;
GRANT ALL ON TABLE de_rbm_annotation TO tm_cz;
GRANT SELECT ON TABLE de_rbm_annotation TO biomart_user;


--
-- Name: de_rbm_data_annotation_join; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_rbm_data_annotation_join FROM PUBLIC;
REVOKE ALL ON TABLE de_rbm_data_annotation_join FROM deapp;
GRANT ALL ON TABLE de_rbm_data_annotation_join TO deapp;
GRANT ALL ON TABLE de_rbm_data_annotation_join TO tm_cz;
GRANT SELECT ON TABLE de_rbm_data_annotation_join TO biomart_user;


--
-- Name: de_rc_snp_info_seq; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE de_rc_snp_info_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE de_rc_snp_info_seq FROM deapp;
GRANT ALL ON SEQUENCE de_rc_snp_info_seq TO deapp;
GRANT ALL ON SEQUENCE de_rc_snp_info_seq TO tm_cz;
GRANT ALL ON SEQUENCE de_rc_snp_info_seq TO biomart_user;


--
-- Name: de_rc_snp_info; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_rc_snp_info FROM PUBLIC;
REVOKE ALL ON TABLE de_rc_snp_info FROM deapp;
GRANT ALL ON TABLE de_rc_snp_info TO deapp;
GRANT ALL ON TABLE de_rc_snp_info TO tm_cz;
GRANT SELECT ON TABLE de_rc_snp_info TO biomart_user;


--
-- Name: de_rc_snp_info1; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_rc_snp_info1 FROM PUBLIC;
REVOKE ALL ON TABLE de_rc_snp_info1 FROM deapp;
GRANT ALL ON TABLE de_rc_snp_info1 TO deapp;
GRANT ALL ON TABLE de_rc_snp_info1 TO tm_cz;
GRANT SELECT ON TABLE de_rc_snp_info1 TO biomart_user;


--
-- Name: de_rnaseq_annotation; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_rnaseq_annotation FROM PUBLIC;
REVOKE ALL ON TABLE de_rnaseq_annotation FROM deapp;
GRANT ALL ON TABLE de_rnaseq_annotation TO deapp;
GRANT ALL ON TABLE de_rnaseq_annotation TO tm_cz;
GRANT SELECT ON TABLE de_rnaseq_annotation TO biomart_user;


--
-- Name: de_sample_snp_data; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_sample_snp_data FROM PUBLIC;
REVOKE ALL ON TABLE de_sample_snp_data FROM deapp;
GRANT ALL ON TABLE de_sample_snp_data TO deapp;
GRANT ALL ON TABLE de_sample_snp_data TO tm_cz;
GRANT SELECT ON TABLE de_sample_snp_data TO biomart_user;


--
-- Name: de_saved_comparison; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_saved_comparison FROM PUBLIC;
REVOKE ALL ON TABLE de_saved_comparison FROM deapp;
GRANT ALL ON TABLE de_saved_comparison TO deapp;
GRANT ALL ON TABLE de_saved_comparison TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE de_saved_comparison TO biomart_user;


--
-- Name: de_snp_calls_by_gsm; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_calls_by_gsm FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_calls_by_gsm FROM deapp;
GRANT ALL ON TABLE de_snp_calls_by_gsm TO deapp;
GRANT ALL ON TABLE de_snp_calls_by_gsm TO tm_cz;
GRANT SELECT ON TABLE de_snp_calls_by_gsm TO biomart_user;


--
-- Name: de_snp_copy_number; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_copy_number FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_copy_number FROM deapp;
GRANT ALL ON TABLE de_snp_copy_number TO deapp;
GRANT ALL ON TABLE de_snp_copy_number TO tm_cz;
GRANT SELECT ON TABLE de_snp_copy_number TO biomart_user;


--
-- Name: de_snp_data_by_patient; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_data_by_patient FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_data_by_patient FROM deapp;
GRANT ALL ON TABLE de_snp_data_by_patient TO deapp;
GRANT ALL ON TABLE de_snp_data_by_patient TO tm_cz;
GRANT SELECT ON TABLE de_snp_data_by_patient TO biomart_user;


--
-- Name: de_snp_data_by_probe; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_data_by_probe FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_data_by_probe FROM deapp;
GRANT ALL ON TABLE de_snp_data_by_probe TO deapp;
GRANT ALL ON TABLE de_snp_data_by_probe TO tm_cz;
GRANT SELECT ON TABLE de_snp_data_by_probe TO biomart_user;


--
-- Name: de_snp_data_dataset_loc; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_data_dataset_loc FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_data_dataset_loc FROM deapp;
GRANT ALL ON TABLE de_snp_data_dataset_loc TO deapp;
GRANT ALL ON TABLE de_snp_data_dataset_loc TO tm_cz;
GRANT SELECT ON TABLE de_snp_data_dataset_loc TO biomart_user;


--
-- Name: de_snp_gene_map; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_gene_map FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_gene_map FROM deapp;
GRANT ALL ON TABLE de_snp_gene_map TO deapp;
GRANT ALL ON TABLE de_snp_gene_map TO tm_cz;
GRANT SELECT ON TABLE de_snp_gene_map TO biomart_user;


--
-- Name: de_snp_info; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_info FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_info FROM deapp;
GRANT ALL ON TABLE de_snp_info TO deapp;
GRANT ALL ON TABLE de_snp_info TO tm_cz;
GRANT SELECT ON TABLE de_snp_info TO biomart_user;


--
-- Name: de_snp_probe; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_probe FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_probe FROM deapp;
GRANT ALL ON TABLE de_snp_probe TO deapp;
GRANT ALL ON TABLE de_snp_probe TO tm_cz;
GRANT SELECT ON TABLE de_snp_probe TO biomart_user;


--
-- Name: de_snp_probe_sorted_def; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_probe_sorted_def FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_probe_sorted_def FROM deapp;
GRANT ALL ON TABLE de_snp_probe_sorted_def TO deapp;
GRANT ALL ON TABLE de_snp_probe_sorted_def TO tm_cz;
GRANT SELECT ON TABLE de_snp_probe_sorted_def TO biomart_user;


--
-- Name: de_snp_subject_sorted_def; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_snp_subject_sorted_def FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_subject_sorted_def FROM deapp;
GRANT ALL ON TABLE de_snp_subject_sorted_def TO deapp;
GRANT ALL ON TABLE de_snp_subject_sorted_def TO tm_cz;
GRANT SELECT ON TABLE de_snp_subject_sorted_def TO biomart_user;


--
-- Name: de_subject_acgh_data; Type: ACL; Schema: deapp; Owner: tm_cz
--

REVOKE ALL ON TABLE de_subject_acgh_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_acgh_data FROM tm_cz;
GRANT ALL ON TABLE de_subject_acgh_data TO tm_cz;
GRANT ALL ON TABLE de_subject_acgh_data TO deapp;
GRANT SELECT ON TABLE de_subject_acgh_data TO biomart_user;


--
-- Name: de_subject_metabolomics_data; Type: ACL; Schema: deapp; Owner: tm_cz
--

REVOKE ALL ON TABLE de_subject_metabolomics_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_metabolomics_data FROM tm_cz;
GRANT ALL ON TABLE de_subject_metabolomics_data TO tm_cz;
GRANT ALL ON TABLE de_subject_metabolomics_data TO deapp;
GRANT SELECT ON TABLE de_subject_metabolomics_data TO biomart_user;


--
-- Name: de_subject_microarray_data; Type: ACL; Schema: deapp; Owner: tm_cz
--

REVOKE ALL ON TABLE de_subject_microarray_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_microarray_data FROM tm_cz;
GRANT ALL ON TABLE de_subject_microarray_data TO tm_cz;
GRANT ALL ON TABLE de_subject_microarray_data TO deapp;
GRANT SELECT ON TABLE de_subject_microarray_data TO biomart_user;


--
-- Name: de_subject_microarray_data_new; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_microarray_data_new FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_microarray_data_new FROM deapp;
GRANT ALL ON TABLE de_subject_microarray_data_new TO deapp;
GRANT ALL ON TABLE de_subject_microarray_data_new TO tm_cz;
GRANT SELECT ON TABLE de_subject_microarray_data_new TO biomart_user;


--
-- Name: de_subject_microarray_logs; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_microarray_logs FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_microarray_logs FROM deapp;
GRANT ALL ON TABLE de_subject_microarray_logs TO deapp;
GRANT ALL ON TABLE de_subject_microarray_logs TO tm_cz;
GRANT SELECT ON TABLE de_subject_microarray_logs TO biomart_user;


--
-- Name: de_subject_microarray_med; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_microarray_med FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_microarray_med FROM deapp;
GRANT ALL ON TABLE de_subject_microarray_med TO deapp;
GRANT ALL ON TABLE de_subject_microarray_med TO tm_cz;
GRANT SELECT ON TABLE de_subject_microarray_med TO biomart_user;


--
-- Name: de_subject_mirna_data; Type: ACL; Schema: deapp; Owner: tm_cz
--

REVOKE ALL ON TABLE de_subject_mirna_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_mirna_data FROM tm_cz;
GRANT ALL ON TABLE de_subject_mirna_data TO tm_cz;
GRANT ALL ON TABLE de_subject_mirna_data TO deapp;
GRANT SELECT ON TABLE de_subject_mirna_data TO biomart_user;


--
-- Name: de_subject_protein_data; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_protein_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_protein_data FROM deapp;
GRANT ALL ON TABLE de_subject_protein_data TO deapp;
GRANT ALL ON TABLE de_subject_protein_data TO tm_cz;
GRANT SELECT ON TABLE de_subject_protein_data TO biomart_user;


--
-- Name: de_subject_proteomics_data; Type: ACL; Schema: deapp; Owner: tm_cz
--

REVOKE ALL ON TABLE de_subject_proteomics_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_proteomics_data FROM tm_cz;
GRANT ALL ON TABLE de_subject_proteomics_data TO tm_cz;
GRANT ALL ON TABLE de_subject_proteomics_data TO deapp;
GRANT SELECT ON TABLE de_subject_proteomics_data TO biomart_user;


--
-- Name: de_subject_rbm_data; Type: ACL; Schema: deapp; Owner: tm_cz
--

REVOKE ALL ON TABLE de_subject_rbm_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_rbm_data FROM tm_cz;
GRANT ALL ON TABLE de_subject_rbm_data TO tm_cz;
GRANT ALL ON TABLE de_subject_rbm_data TO deapp;
GRANT SELECT ON TABLE de_subject_rbm_data TO biomart_user;


--
-- Name: de_subject_rbm_data_seq; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE de_subject_rbm_data_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE de_subject_rbm_data_seq FROM deapp;
GRANT ALL ON SEQUENCE de_subject_rbm_data_seq TO deapp;
GRANT ALL ON SEQUENCE de_subject_rbm_data_seq TO tm_cz;
GRANT ALL ON SEQUENCE de_subject_rbm_data_seq TO biomart_user;


--
-- Name: de_subject_rna_data; Type: ACL; Schema: deapp; Owner: tm_cz
--

REVOKE ALL ON TABLE de_subject_rna_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_rna_data FROM tm_cz;
GRANT ALL ON TABLE de_subject_rna_data TO tm_cz;
GRANT ALL ON TABLE de_subject_rna_data TO deapp;
GRANT SELECT ON TABLE de_subject_rna_data TO biomart_user;


--
-- Name: de_subject_rnaseq_data; Type: ACL; Schema: deapp; Owner: tm_cz
--

REVOKE ALL ON TABLE de_subject_rnaseq_data FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_rnaseq_data FROM tm_cz;
GRANT ALL ON TABLE de_subject_rnaseq_data TO tm_cz;
GRANT ALL ON TABLE de_subject_rnaseq_data TO deapp;
GRANT SELECT ON TABLE de_subject_rnaseq_data TO biomart_user;


--
-- Name: de_subject_sample_mapping; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_sample_mapping FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_sample_mapping FROM deapp;
GRANT ALL ON TABLE de_subject_sample_mapping TO deapp;
GRANT ALL ON TABLE de_subject_sample_mapping TO tm_cz;
GRANT SELECT ON TABLE de_subject_sample_mapping TO biomart_user;
GRANT SELECT ON TABLE de_subject_sample_mapping TO tm_lz;


--
-- Name: de_subject_snp_dataset; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_subject_snp_dataset FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_snp_dataset FROM deapp;
GRANT ALL ON TABLE de_subject_snp_dataset TO deapp;
GRANT ALL ON TABLE de_subject_snp_dataset TO tm_cz;
GRANT SELECT ON TABLE de_subject_snp_dataset TO biomart_user;


--
-- Name: de_variant_dataset; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_variant_dataset FROM PUBLIC;
REVOKE ALL ON TABLE de_variant_dataset FROM deapp;
GRANT ALL ON TABLE de_variant_dataset TO deapp;
GRANT ALL ON TABLE de_variant_dataset TO tm_cz;
GRANT SELECT ON TABLE de_variant_dataset TO biomart_user;
GRANT SELECT,INSERT,DELETE ON TABLE de_variant_dataset TO tm_dataloader;


--
-- Name: de_variant_metadata_seq; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE de_variant_metadata_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE de_variant_metadata_seq FROM deapp;
GRANT ALL ON SEQUENCE de_variant_metadata_seq TO deapp;
GRANT ALL ON SEQUENCE de_variant_metadata_seq TO tm_cz;
GRANT ALL ON SEQUENCE de_variant_metadata_seq TO biomart_user;


--
-- Name: de_variant_metadata; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_variant_metadata FROM PUBLIC;
REVOKE ALL ON TABLE de_variant_metadata FROM deapp;
GRANT ALL ON TABLE de_variant_metadata TO deapp;
GRANT ALL ON TABLE de_variant_metadata TO tm_cz;
GRANT SELECT ON TABLE de_variant_metadata TO biomart_user;


--
-- Name: de_variant_population_data_seq; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE de_variant_population_data_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE de_variant_population_data_seq FROM deapp;
GRANT ALL ON SEQUENCE de_variant_population_data_seq TO deapp;
GRANT ALL ON SEQUENCE de_variant_population_data_seq TO tm_cz;
GRANT ALL ON SEQUENCE de_variant_population_data_seq TO biomart_user;
GRANT USAGE ON SEQUENCE de_variant_population_data_seq TO tm_dataloader;


--
-- Name: de_variant_population_data; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_variant_population_data FROM PUBLIC;
REVOKE ALL ON TABLE de_variant_population_data FROM deapp;
GRANT ALL ON TABLE de_variant_population_data TO deapp;
GRANT ALL ON TABLE de_variant_population_data TO tm_cz;
GRANT SELECT ON TABLE de_variant_population_data TO biomart_user;
GRANT SELECT,INSERT,DELETE ON TABLE de_variant_population_data TO tm_dataloader;


--
-- Name: de_variant_population_info_seq; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE de_variant_population_info_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE de_variant_population_info_seq FROM deapp;
GRANT ALL ON SEQUENCE de_variant_population_info_seq TO deapp;
GRANT ALL ON SEQUENCE de_variant_population_info_seq TO tm_cz;
GRANT ALL ON SEQUENCE de_variant_population_info_seq TO biomart_user;
GRANT USAGE ON SEQUENCE de_variant_population_info_seq TO tm_dataloader;


--
-- Name: de_variant_population_info; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_variant_population_info FROM PUBLIC;
REVOKE ALL ON TABLE de_variant_population_info FROM deapp;
GRANT ALL ON TABLE de_variant_population_info TO deapp;
GRANT ALL ON TABLE de_variant_population_info TO tm_cz;
GRANT SELECT ON TABLE de_variant_population_info TO biomart_user;
GRANT SELECT,INSERT,DELETE ON TABLE de_variant_population_info TO tm_dataloader;


--
-- Name: de_variant_subject_detail_seq; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE de_variant_subject_detail_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE de_variant_subject_detail_seq FROM deapp;
GRANT ALL ON SEQUENCE de_variant_subject_detail_seq TO deapp;
GRANT ALL ON SEQUENCE de_variant_subject_detail_seq TO tm_cz;
GRANT ALL ON SEQUENCE de_variant_subject_detail_seq TO biomart_user;
GRANT USAGE ON SEQUENCE de_variant_subject_detail_seq TO tm_dataloader;


--
-- Name: de_variant_subject_detail; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_variant_subject_detail FROM PUBLIC;
REVOKE ALL ON TABLE de_variant_subject_detail FROM deapp;
GRANT ALL ON TABLE de_variant_subject_detail TO deapp;
GRANT ALL ON TABLE de_variant_subject_detail TO tm_cz;
GRANT SELECT ON TABLE de_variant_subject_detail TO biomart_user;
GRANT SELECT,INSERT,DELETE ON TABLE de_variant_subject_detail TO tm_dataloader;


--
-- Name: de_variant_subject_idx_seq; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE de_variant_subject_idx_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE de_variant_subject_idx_seq FROM deapp;
GRANT ALL ON SEQUENCE de_variant_subject_idx_seq TO deapp;
GRANT ALL ON SEQUENCE de_variant_subject_idx_seq TO tm_cz;
GRANT ALL ON SEQUENCE de_variant_subject_idx_seq TO biomart_user;
GRANT USAGE ON SEQUENCE de_variant_subject_idx_seq TO tm_dataloader;


--
-- Name: de_variant_subject_idx; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_variant_subject_idx FROM PUBLIC;
REVOKE ALL ON TABLE de_variant_subject_idx FROM deapp;
GRANT ALL ON TABLE de_variant_subject_idx TO deapp;
GRANT ALL ON TABLE de_variant_subject_idx TO tm_cz;
GRANT SELECT ON TABLE de_variant_subject_idx TO biomart_user;
GRANT SELECT,INSERT,DELETE ON TABLE de_variant_subject_idx TO tm_dataloader;


--
-- Name: de_variant_subject_summary_seq; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE de_variant_subject_summary_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE de_variant_subject_summary_seq FROM deapp;
GRANT ALL ON SEQUENCE de_variant_subject_summary_seq TO deapp;
GRANT ALL ON SEQUENCE de_variant_subject_summary_seq TO tm_cz;
GRANT ALL ON SEQUENCE de_variant_subject_summary_seq TO biomart_user;
GRANT USAGE ON SEQUENCE de_variant_subject_summary_seq TO tm_dataloader;


--
-- Name: de_variant_subject_summary; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_variant_subject_summary FROM PUBLIC;
REVOKE ALL ON TABLE de_variant_subject_summary FROM deapp;
GRANT ALL ON TABLE de_variant_subject_summary TO deapp;
GRANT ALL ON TABLE de_variant_subject_summary TO tm_cz;
GRANT SELECT ON TABLE de_variant_subject_summary TO biomart_user;
GRANT SELECT,INSERT,DELETE ON TABLE de_variant_subject_summary TO tm_dataloader;


--
-- Name: de_xtrial_child_map; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_xtrial_child_map FROM PUBLIC;
REVOKE ALL ON TABLE de_xtrial_child_map FROM deapp;
GRANT ALL ON TABLE de_xtrial_child_map TO deapp;
GRANT ALL ON TABLE de_xtrial_child_map TO tm_cz;
GRANT SELECT ON TABLE de_xtrial_child_map TO biomart_user;


--
-- Name: de_xtrial_parent_names; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE de_xtrial_parent_names FROM PUBLIC;
REVOKE ALL ON TABLE de_xtrial_parent_names FROM deapp;
GRANT ALL ON TABLE de_xtrial_parent_names TO deapp;
GRANT ALL ON TABLE de_xtrial_parent_names TO tm_cz;
GRANT SELECT ON TABLE de_xtrial_parent_names TO biomart_user;


--
-- Name: deapp_annotation; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE deapp_annotation FROM PUBLIC;
REVOKE ALL ON TABLE deapp_annotation FROM deapp;
GRANT ALL ON TABLE deapp_annotation TO deapp;
GRANT ALL ON TABLE deapp_annotation TO tm_cz;
GRANT SELECT ON TABLE deapp_annotation TO biomart_user;


--
-- Name: haploview_data; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE haploview_data FROM PUBLIC;
REVOKE ALL ON TABLE haploview_data FROM deapp;
GRANT ALL ON TABLE haploview_data TO deapp;
GRANT ALL ON TABLE haploview_data TO tm_cz;
GRANT SELECT ON TABLE haploview_data TO biomart_user;


--
-- Name: kegg; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE kegg FROM PUBLIC;
REVOKE ALL ON TABLE kegg FROM deapp;
GRANT ALL ON TABLE kegg TO deapp;
GRANT ALL ON TABLE kegg TO tm_cz;
GRANT SELECT ON TABLE kegg TO biomart_user;


--
-- Name: kegg_data; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE kegg_data FROM PUBLIC;
REVOKE ALL ON TABLE kegg_data FROM deapp;
GRANT ALL ON TABLE kegg_data TO deapp;
GRANT ALL ON TABLE kegg_data TO tm_cz;
GRANT SELECT ON TABLE kegg_data TO biomart_user;


--
-- Name: kegg_def; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE kegg_def FROM PUBLIC;
REVOKE ALL ON TABLE kegg_def FROM deapp;
GRANT ALL ON TABLE kegg_def TO deapp;
GRANT ALL ON TABLE kegg_def TO tm_cz;
GRANT SELECT ON TABLE kegg_def TO biomart_user;


--
-- Name: metabolite_sub_pth_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE metabolite_sub_pth_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE metabolite_sub_pth_id FROM deapp;
GRANT ALL ON SEQUENCE metabolite_sub_pth_id TO deapp;
GRANT ALL ON SEQUENCE metabolite_sub_pth_id TO tm_cz;
GRANT ALL ON SEQUENCE metabolite_sub_pth_id TO biomart_user;


--
-- Name: metabolite_sup_pth_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE metabolite_sup_pth_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE metabolite_sup_pth_id FROM deapp;
GRANT ALL ON SEQUENCE metabolite_sup_pth_id TO deapp;
GRANT ALL ON SEQUENCE metabolite_sup_pth_id TO tm_cz;
GRANT ALL ON SEQUENCE metabolite_sup_pth_id TO biomart_user;


--
-- Name: metabolomics_annot_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE metabolomics_annot_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE metabolomics_annot_id FROM deapp;
GRANT ALL ON SEQUENCE metabolomics_annot_id TO deapp;
GRANT ALL ON SEQUENCE metabolomics_annot_id TO tm_cz;
GRANT ALL ON SEQUENCE metabolomics_annot_id TO biomart_user;


--
-- Name: rbm_annotation_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE rbm_annotation_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE rbm_annotation_id FROM deapp;
GRANT ALL ON SEQUENCE rbm_annotation_id TO deapp;
GRANT ALL ON SEQUENCE rbm_annotation_id TO tm_cz;
GRANT ALL ON SEQUENCE rbm_annotation_id TO biomart_user;


--
-- Name: ricerca; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON TABLE ricerca FROM PUBLIC;
REVOKE ALL ON TABLE ricerca FROM deapp;
GRANT ALL ON TABLE ricerca TO deapp;
GRANT ALL ON TABLE ricerca TO tm_cz;
GRANT SELECT ON TABLE ricerca TO biomart_user;


--
-- Name: seq_assay_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE seq_assay_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_assay_id FROM deapp;
GRANT ALL ON SEQUENCE seq_assay_id TO deapp;
GRANT ALL ON SEQUENCE seq_assay_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_assay_id TO biomart_user;


--
-- Name: seq_data_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE seq_data_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_data_id FROM deapp;
GRANT ALL ON SEQUENCE seq_data_id TO deapp;
GRANT ALL ON SEQUENCE seq_data_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_data_id TO biomart_user;


--
-- Name: seq_de_mrna_annotation_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE seq_de_mrna_annotation_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_de_mrna_annotation_id FROM deapp;
GRANT ALL ON SEQUENCE seq_de_mrna_annotation_id TO deapp;
GRANT ALL ON SEQUENCE seq_de_mrna_annotation_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_de_mrna_annotation_id TO biomart_user;


--
-- Name: seq_metabolomics_partition_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE seq_metabolomics_partition_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_metabolomics_partition_id FROM deapp;
GRANT ALL ON SEQUENCE seq_metabolomics_partition_id TO deapp;
GRANT ALL ON SEQUENCE seq_metabolomics_partition_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_metabolomics_partition_id TO biomart_user;


--
-- Name: seq_mrna_partition_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE seq_mrna_partition_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_mrna_partition_id FROM deapp;
GRANT ALL ON SEQUENCE seq_mrna_partition_id TO deapp;
GRANT ALL ON SEQUENCE seq_mrna_partition_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_mrna_partition_id TO biomart_user;


--
-- Name: seq_rbm_partition_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE seq_rbm_partition_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_rbm_partition_id FROM deapp;
GRANT ALL ON SEQUENCE seq_rbm_partition_id TO deapp;
GRANT ALL ON SEQUENCE seq_rbm_partition_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_rbm_partition_id TO biomart_user;


--
-- Name: seq_rna_partition_id; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE seq_rna_partition_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_rna_partition_id FROM deapp;
GRANT ALL ON SEQUENCE seq_rna_partition_id TO deapp;
GRANT ALL ON SEQUENCE seq_rna_partition_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_rna_partition_id TO biomart_user;


--
-- Name: tt; Type: ACL; Schema: deapp; Owner: deapp
--

REVOKE ALL ON SEQUENCE tt FROM PUBLIC;
REVOKE ALL ON SEQUENCE tt FROM deapp;
GRANT ALL ON SEQUENCE tt TO deapp;
GRANT ALL ON SEQUENCE tt TO tm_cz;
GRANT ALL ON SEQUENCE tt TO biomart_user;


SET search_path = fmapp, pg_catalog;

--
-- Name: fm_file; Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON TABLE fm_file FROM PUBLIC;
REVOKE ALL ON TABLE fm_file FROM fmapp;
GRANT ALL ON TABLE fm_file TO fmapp;
GRANT ALL ON TABLE fm_file TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE fm_file TO biomart_user;


--
-- Name: fm_folder_file_association; Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON TABLE fm_folder_file_association FROM PUBLIC;
REVOKE ALL ON TABLE fm_folder_file_association FROM fmapp;
GRANT ALL ON TABLE fm_folder_file_association TO fmapp;
GRANT ALL ON TABLE fm_folder_file_association TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE fm_folder_file_association TO biomart_user;


--
-- Name: seq_fm_id; Type: ACL; Schema: fmapp; Owner: fmapp
--

REVOKE ALL ON SEQUENCE seq_fm_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_fm_id FROM fmapp;
GRANT ALL ON SEQUENCE seq_fm_id TO fmapp;
GRANT ALL ON SEQUENCE seq_fm_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_fm_id TO biomart_user;


SET search_path = galaxy, pg_catalog;

--
-- Name: status_of_export_job; Type: ACL; Schema: galaxy; Owner: galaxy
--

REVOKE ALL ON TABLE status_of_export_job FROM PUBLIC;
REVOKE ALL ON TABLE status_of_export_job FROM galaxy;
GRANT ALL ON TABLE status_of_export_job TO galaxy;
GRANT ALL ON TABLE status_of_export_job TO tm_cz;
GRANT SELECT ON TABLE status_of_export_job TO biomart_user;


--
-- Name: users_details_for_export_gal; Type: ACL; Schema: galaxy; Owner: galaxy
--

REVOKE ALL ON TABLE users_details_for_export_gal FROM PUBLIC;
REVOKE ALL ON TABLE users_details_for_export_gal FROM galaxy;
GRANT ALL ON TABLE users_details_for_export_gal TO galaxy;
GRANT ALL ON TABLE users_details_for_export_gal TO tm_cz;
GRANT SELECT ON TABLE users_details_for_export_gal TO biomart_user;


SET search_path = i2b2demodata, pg_catalog;

--
-- Name: archive_observation_fact; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE archive_observation_fact FROM PUBLIC;
REVOKE ALL ON TABLE archive_observation_fact FROM i2b2demodata;
GRANT ALL ON TABLE archive_observation_fact TO i2b2demodata;
GRANT ALL ON TABLE archive_observation_fact TO tm_cz;
GRANT SELECT ON TABLE archive_observation_fact TO biomart_user;


--
-- Name: async_job; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE async_job FROM PUBLIC;
REVOKE ALL ON TABLE async_job FROM i2b2demodata;
GRANT ALL ON TABLE async_job TO i2b2demodata;
GRANT ALL ON TABLE async_job TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE async_job TO biomart_user;


--
-- Name: async_job_seq; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE async_job_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE async_job_seq FROM i2b2demodata;
GRANT ALL ON SEQUENCE async_job_seq TO i2b2demodata;
GRANT ALL ON SEQUENCE async_job_seq TO tm_cz;
GRANT ALL ON SEQUENCE async_job_seq TO biomart_user;


--
-- Name: cd; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE cd FROM PUBLIC;
REVOKE ALL ON TABLE cd FROM i2b2demodata;
GRANT ALL ON TABLE cd TO i2b2demodata;
GRANT ALL ON TABLE cd TO tm_cz;
GRANT SELECT ON TABLE cd TO biomart_user;


--
-- Name: code_lookup; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE code_lookup FROM PUBLIC;
REVOKE ALL ON TABLE code_lookup FROM i2b2demodata;
GRANT ALL ON TABLE code_lookup TO i2b2demodata;
GRANT ALL ON TABLE code_lookup TO tm_cz;
GRANT SELECT ON TABLE code_lookup TO biomart_user;


--
-- Name: concept_counts; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE concept_counts FROM PUBLIC;
REVOKE ALL ON TABLE concept_counts FROM i2b2demodata;
GRANT ALL ON TABLE concept_counts TO i2b2demodata;
GRANT ALL ON TABLE concept_counts TO tm_cz;
GRANT SELECT ON TABLE concept_counts TO biomart_user;


--
-- Name: concept_dimension; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE concept_dimension FROM PUBLIC;
REVOKE ALL ON TABLE concept_dimension FROM i2b2demodata;
GRANT ALL ON TABLE concept_dimension TO i2b2demodata;
GRANT ALL ON TABLE concept_dimension TO tm_cz;
GRANT SELECT ON TABLE concept_dimension TO biomart_user;


--
-- Name: concept_id; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE concept_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE concept_id FROM i2b2demodata;
GRANT ALL ON SEQUENCE concept_id TO i2b2demodata;
GRANT ALL ON SEQUENCE concept_id TO tm_cz;
GRANT ALL ON SEQUENCE concept_id TO biomart_user;


--
-- Name: counter; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE counter FROM PUBLIC;
REVOKE ALL ON TABLE counter FROM i2b2demodata;
GRANT ALL ON TABLE counter TO i2b2demodata;
GRANT ALL ON TABLE counter TO tm_cz;
GRANT SELECT ON TABLE counter TO biomart_user;


--
-- Name: crc_db_lookup; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE crc_db_lookup FROM PUBLIC;
REVOKE ALL ON TABLE crc_db_lookup FROM i2b2demodata;
GRANT ALL ON TABLE crc_db_lookup TO i2b2demodata;
GRANT ALL ON TABLE crc_db_lookup TO tm_cz;
GRANT SELECT ON TABLE crc_db_lookup TO biomart_user;


--
-- Name: datamart_report; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE datamart_report FROM PUBLIC;
REVOKE ALL ON TABLE datamart_report FROM i2b2demodata;
GRANT ALL ON TABLE datamart_report TO i2b2demodata;
GRANT ALL ON TABLE datamart_report TO tm_cz;
GRANT SELECT ON TABLE datamart_report TO biomart_user;


--
-- Name: dimloader; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE dimloader FROM PUBLIC;
REVOKE ALL ON TABLE dimloader FROM i2b2demodata;
GRANT ALL ON TABLE dimloader TO i2b2demodata;
GRANT ALL ON TABLE dimloader TO tm_cz;
GRANT SELECT ON TABLE dimloader TO biomart_user;


--
-- Name: encounter_mapping; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE encounter_mapping FROM PUBLIC;
REVOKE ALL ON TABLE encounter_mapping FROM i2b2demodata;
GRANT ALL ON TABLE encounter_mapping TO i2b2demodata;
GRANT ALL ON TABLE encounter_mapping TO tm_cz;
GRANT SELECT ON TABLE encounter_mapping TO biomart_user;


--
-- Name: hilosequences; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE hilosequences FROM PUBLIC;
REVOKE ALL ON TABLE hilosequences FROM i2b2demodata;
GRANT ALL ON TABLE hilosequences TO i2b2demodata;
GRANT ALL ON TABLE hilosequences TO tm_cz;
GRANT SELECT ON TABLE hilosequences TO biomart_user;


--
-- Name: jms_messages; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE jms_messages FROM PUBLIC;
REVOKE ALL ON TABLE jms_messages FROM i2b2demodata;
GRANT ALL ON TABLE jms_messages TO i2b2demodata;
GRANT ALL ON TABLE jms_messages TO tm_cz;
GRANT SELECT ON TABLE jms_messages TO biomart_user;


--
-- Name: jms_roles; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE jms_roles FROM PUBLIC;
REVOKE ALL ON TABLE jms_roles FROM i2b2demodata;
GRANT ALL ON TABLE jms_roles TO i2b2demodata;
GRANT ALL ON TABLE jms_roles TO tm_cz;
GRANT SELECT ON TABLE jms_roles TO biomart_user;


--
-- Name: jms_subscriptions; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE jms_subscriptions FROM PUBLIC;
REVOKE ALL ON TABLE jms_subscriptions FROM i2b2demodata;
GRANT ALL ON TABLE jms_subscriptions TO i2b2demodata;
GRANT ALL ON TABLE jms_subscriptions TO tm_cz;
GRANT SELECT ON TABLE jms_subscriptions TO biomart_user;


--
-- Name: jms_transactions; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE jms_transactions FROM PUBLIC;
REVOKE ALL ON TABLE jms_transactions FROM i2b2demodata;
GRANT ALL ON TABLE jms_transactions TO i2b2demodata;
GRANT ALL ON TABLE jms_transactions TO tm_cz;
GRANT SELECT ON TABLE jms_transactions TO biomart_user;


--
-- Name: jms_users; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE jms_users FROM PUBLIC;
REVOKE ALL ON TABLE jms_users FROM i2b2demodata;
GRANT ALL ON TABLE jms_users TO i2b2demodata;
GRANT ALL ON TABLE jms_users TO tm_cz;
GRANT SELECT ON TABLE jms_users TO biomart_user;


--
-- Name: map; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE map FROM PUBLIC;
REVOKE ALL ON TABLE map FROM i2b2demodata;
GRANT ALL ON TABLE map TO i2b2demodata;
GRANT ALL ON TABLE map TO tm_cz;
GRANT SELECT ON TABLE map TO biomart_user;


--
-- Name: modifier_dimension; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE modifier_dimension FROM PUBLIC;
REVOKE ALL ON TABLE modifier_dimension FROM i2b2demodata;
GRANT ALL ON TABLE modifier_dimension TO i2b2demodata;
GRANT ALL ON TABLE modifier_dimension TO tm_cz;
GRANT SELECT ON TABLE modifier_dimension TO biomart_user;


--
-- Name: modifier_metadata; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE modifier_metadata FROM PUBLIC;
REVOKE ALL ON TABLE modifier_metadata FROM i2b2demodata;
GRANT ALL ON TABLE modifier_metadata TO i2b2demodata;
GRANT ALL ON TABLE modifier_metadata TO tm_cz;
GRANT SELECT ON TABLE modifier_metadata TO biomart_user;


--
-- Name: modifier_dimension_view; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE modifier_dimension_view FROM PUBLIC;
REVOKE ALL ON TABLE modifier_dimension_view FROM i2b2demodata;
GRANT ALL ON TABLE modifier_dimension_view TO i2b2demodata;
GRANT ALL ON TABLE modifier_dimension_view TO tm_cz;
GRANT SELECT ON TABLE modifier_dimension_view TO biomart_user;


--
-- Name: news_updates; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE news_updates FROM PUBLIC;
REVOKE ALL ON TABLE news_updates FROM i2b2demodata;
GRANT ALL ON TABLE news_updates TO i2b2demodata;
GRANT ALL ON TABLE news_updates TO tm_cz;
GRANT SELECT ON TABLE news_updates TO biomart_user;


--
-- Name: observation_fact; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE observation_fact FROM PUBLIC;
REVOKE ALL ON TABLE observation_fact FROM i2b2demodata;
GRANT ALL ON TABLE observation_fact TO i2b2demodata;
GRANT ALL ON TABLE observation_fact TO tm_cz;
GRANT SELECT ON TABLE observation_fact TO biomart_user;


--
-- Name: patient_dimension; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE patient_dimension FROM PUBLIC;
REVOKE ALL ON TABLE patient_dimension FROM i2b2demodata;
GRANT ALL ON TABLE patient_dimension TO i2b2demodata;
GRANT ALL ON TABLE patient_dimension TO tm_cz;
GRANT SELECT ON TABLE patient_dimension TO biomart_user;


--
-- Name: patient_mapping; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE patient_mapping FROM PUBLIC;
REVOKE ALL ON TABLE patient_mapping FROM i2b2demodata;
GRANT ALL ON TABLE patient_mapping TO i2b2demodata;
GRANT ALL ON TABLE patient_mapping TO tm_cz;
GRANT SELECT ON TABLE patient_mapping TO biomart_user;


--
-- Name: patient_trial; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE patient_trial FROM PUBLIC;
REVOKE ALL ON TABLE patient_trial FROM i2b2demodata;
GRANT ALL ON TABLE patient_trial TO i2b2demodata;
GRANT ALL ON TABLE patient_trial TO tm_cz;
GRANT SELECT ON TABLE patient_trial TO biomart_user;


--
-- Name: protocol_id_seq; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE protocol_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE protocol_id_seq FROM i2b2demodata;
GRANT ALL ON SEQUENCE protocol_id_seq TO i2b2demodata;
GRANT ALL ON SEQUENCE protocol_id_seq TO tm_cz;
GRANT ALL ON SEQUENCE protocol_id_seq TO biomart_user;


--
-- Name: provider_dimension; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE provider_dimension FROM PUBLIC;
REVOKE ALL ON TABLE provider_dimension FROM i2b2demodata;
GRANT ALL ON TABLE provider_dimension TO i2b2demodata;
GRANT ALL ON TABLE provider_dimension TO tm_cz;
GRANT SELECT ON TABLE provider_dimension TO biomart_user;


--
-- Name: qt_analysis_plugin; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_analysis_plugin FROM PUBLIC;
REVOKE ALL ON TABLE qt_analysis_plugin FROM i2b2demodata;
GRANT ALL ON TABLE qt_analysis_plugin TO i2b2demodata;
GRANT ALL ON TABLE qt_analysis_plugin TO tm_cz;
GRANT SELECT ON TABLE qt_analysis_plugin TO biomart_user;


--
-- Name: qt_analysis_plugin_result_type; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_analysis_plugin_result_type FROM PUBLIC;
REVOKE ALL ON TABLE qt_analysis_plugin_result_type FROM i2b2demodata;
GRANT ALL ON TABLE qt_analysis_plugin_result_type TO i2b2demodata;
GRANT ALL ON TABLE qt_analysis_plugin_result_type TO tm_cz;
GRANT SELECT ON TABLE qt_analysis_plugin_result_type TO biomart_user;


--
-- Name: qt_breakdown_path; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_breakdown_path FROM PUBLIC;
REVOKE ALL ON TABLE qt_breakdown_path FROM i2b2demodata;
GRANT ALL ON TABLE qt_breakdown_path TO i2b2demodata;
GRANT ALL ON TABLE qt_breakdown_path TO tm_cz;
GRANT SELECT ON TABLE qt_breakdown_path TO biomart_user;


--
-- Name: qt_sq_qper_pecid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qper_pecid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qper_pecid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qper_pecid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qper_pecid TO tm_cz;
GRANT ALL ON SEQUENCE qt_sq_qper_pecid TO biomart_user;


--
-- Name: qt_patient_enc_collection; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_patient_enc_collection FROM PUBLIC;
REVOKE ALL ON TABLE qt_patient_enc_collection FROM i2b2demodata;
GRANT ALL ON TABLE qt_patient_enc_collection TO i2b2demodata;
GRANT ALL ON TABLE qt_patient_enc_collection TO tm_cz;
GRANT SELECT ON TABLE qt_patient_enc_collection TO biomart_user;


--
-- Name: qt_sq_qpr_pcid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qpr_pcid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qpr_pcid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qpr_pcid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qpr_pcid TO tm_cz;
GRANT ALL ON SEQUENCE qt_sq_qpr_pcid TO biomart_user;


--
-- Name: qt_patient_set_collection; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_patient_set_collection FROM PUBLIC;
REVOKE ALL ON TABLE qt_patient_set_collection FROM i2b2demodata;
GRANT ALL ON TABLE qt_patient_set_collection TO i2b2demodata;
GRANT ALL ON TABLE qt_patient_set_collection TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE qt_patient_set_collection TO biomart_user;


--
-- Name: qt_sq_pqm_qmid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_pqm_qmid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_pqm_qmid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_pqm_qmid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_pqm_qmid TO tm_cz;
GRANT ALL ON SEQUENCE qt_sq_pqm_qmid TO biomart_user;


--
-- Name: qt_pdo_query_master; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_pdo_query_master FROM PUBLIC;
REVOKE ALL ON TABLE qt_pdo_query_master FROM i2b2demodata;
GRANT ALL ON TABLE qt_pdo_query_master TO i2b2demodata;
GRANT ALL ON TABLE qt_pdo_query_master TO tm_cz;
GRANT SELECT ON TABLE qt_pdo_query_master TO biomart_user;


--
-- Name: qt_privilege; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_privilege FROM PUBLIC;
REVOKE ALL ON TABLE qt_privilege FROM i2b2demodata;
GRANT ALL ON TABLE qt_privilege TO i2b2demodata;
GRANT ALL ON TABLE qt_privilege TO tm_cz;
GRANT SELECT ON TABLE qt_privilege TO biomart_user;


--
-- Name: qt_sq_qi_qiid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qi_qiid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qi_qiid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qi_qiid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qi_qiid TO tm_cz;
GRANT ALL ON SEQUENCE qt_sq_qi_qiid TO biomart_user;


--
-- Name: qt_query_instance; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_query_instance FROM PUBLIC;
REVOKE ALL ON TABLE qt_query_instance FROM i2b2demodata;
GRANT ALL ON TABLE qt_query_instance TO i2b2demodata;
GRANT ALL ON TABLE qt_query_instance TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE qt_query_instance TO biomart_user;


--
-- Name: qt_sq_qm_qmid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qm_qmid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qm_qmid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qm_qmid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qm_qmid TO tm_cz;
GRANT ALL ON SEQUENCE qt_sq_qm_qmid TO biomart_user;


--
-- Name: qt_query_master; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_query_master FROM PUBLIC;
REVOKE ALL ON TABLE qt_query_master FROM i2b2demodata;
GRANT ALL ON TABLE qt_query_master TO i2b2demodata;
GRANT ALL ON TABLE qt_query_master TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE qt_query_master TO biomart_user;


--
-- Name: qt_sq_qri_qriid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qri_qriid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qri_qriid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qri_qriid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qri_qriid TO tm_cz;
GRANT ALL ON SEQUENCE qt_sq_qri_qriid TO biomart_user;


--
-- Name: qt_query_result_instance; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_query_result_instance FROM PUBLIC;
REVOKE ALL ON TABLE qt_query_result_instance FROM i2b2demodata;
GRANT ALL ON TABLE qt_query_result_instance TO i2b2demodata;
GRANT ALL ON TABLE qt_query_result_instance TO tm_cz;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE qt_query_result_instance TO biomart_user;


--
-- Name: qt_sq_qr_qrid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qr_qrid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qr_qrid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qr_qrid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qr_qrid TO tm_cz;
GRANT ALL ON SEQUENCE qt_sq_qr_qrid TO biomart_user;


--
-- Name: qt_query_result_type; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_query_result_type FROM PUBLIC;
REVOKE ALL ON TABLE qt_query_result_type FROM i2b2demodata;
GRANT ALL ON TABLE qt_query_result_type TO i2b2demodata;
GRANT ALL ON TABLE qt_query_result_type TO tm_cz;
GRANT SELECT ON TABLE qt_query_result_type TO biomart_user;


--
-- Name: qt_sq_qs_qsid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qs_qsid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qs_qsid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qs_qsid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qs_qsid TO tm_cz;
GRANT ALL ON SEQUENCE qt_sq_qs_qsid TO biomart_user;


--
-- Name: qt_query_status_type; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_query_status_type FROM PUBLIC;
REVOKE ALL ON TABLE qt_query_status_type FROM i2b2demodata;
GRANT ALL ON TABLE qt_query_status_type TO i2b2demodata;
GRANT ALL ON TABLE qt_query_status_type TO tm_cz;
GRANT SELECT ON TABLE qt_query_status_type TO biomart_user;


--
-- Name: qt_sq_qxr_xrid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE qt_sq_qxr_xrid FROM PUBLIC;
REVOKE ALL ON SEQUENCE qt_sq_qxr_xrid FROM i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qxr_xrid TO i2b2demodata;
GRANT ALL ON SEQUENCE qt_sq_qxr_xrid TO tm_cz;
GRANT ALL ON SEQUENCE qt_sq_qxr_xrid TO biomart_user;


--
-- Name: qt_xml_result; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE qt_xml_result FROM PUBLIC;
REVOKE ALL ON TABLE qt_xml_result FROM i2b2demodata;
GRANT ALL ON TABLE qt_xml_result TO i2b2demodata;
GRANT ALL ON TABLE qt_xml_result TO tm_cz;
GRANT SELECT ON TABLE qt_xml_result TO biomart_user;


--
-- Name: ricerca; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE ricerca FROM PUBLIC;
REVOKE ALL ON TABLE ricerca FROM i2b2demodata;
GRANT ALL ON TABLE ricerca TO i2b2demodata;
GRANT ALL ON TABLE ricerca TO tm_cz;
GRANT SELECT ON TABLE ricerca TO biomart_user;


--
-- Name: sample_categories; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE sample_categories FROM PUBLIC;
REVOKE ALL ON TABLE sample_categories FROM i2b2demodata;
GRANT ALL ON TABLE sample_categories TO i2b2demodata;
GRANT ALL ON TABLE sample_categories TO tm_cz;
GRANT SELECT ON TABLE sample_categories TO biomart_user;


--
-- Name: sample_dimension; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE sample_dimension FROM PUBLIC;
REVOKE ALL ON TABLE sample_dimension FROM i2b2demodata;
GRANT ALL ON TABLE sample_dimension TO i2b2demodata;
GRANT ALL ON TABLE sample_dimension TO tm_cz;
GRANT SELECT ON TABLE sample_dimension TO biomart_user;


--
-- Name: seq_encounter_num; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE seq_encounter_num FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_encounter_num FROM i2b2demodata;
GRANT ALL ON SEQUENCE seq_encounter_num TO i2b2demodata;
GRANT ALL ON SEQUENCE seq_encounter_num TO tm_cz;
GRANT ALL ON SEQUENCE seq_encounter_num TO biomart_user;


--
-- Name: seq_patient_num; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE seq_patient_num FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_patient_num FROM i2b2demodata;
GRANT ALL ON SEQUENCE seq_patient_num TO i2b2demodata;
GRANT ALL ON SEQUENCE seq_patient_num TO tm_cz;
GRANT ALL ON SEQUENCE seq_patient_num TO biomart_user;


--
-- Name: seq_subject_reference; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE seq_subject_reference FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_subject_reference FROM i2b2demodata;
GRANT ALL ON SEQUENCE seq_subject_reference TO i2b2demodata;
GRANT ALL ON SEQUENCE seq_subject_reference TO tm_cz;
GRANT ALL ON SEQUENCE seq_subject_reference TO biomart_user;


--
-- Name: sq_up_patdim_patientnum; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE sq_up_patdim_patientnum FROM PUBLIC;
REVOKE ALL ON SEQUENCE sq_up_patdim_patientnum FROM i2b2demodata;
GRANT ALL ON SEQUENCE sq_up_patdim_patientnum TO i2b2demodata;
GRANT ALL ON SEQUENCE sq_up_patdim_patientnum TO tm_cz;
GRANT ALL ON SEQUENCE sq_up_patdim_patientnum TO biomart_user;


--
-- Name: set_type; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE set_type FROM PUBLIC;
REVOKE ALL ON TABLE set_type FROM i2b2demodata;
GRANT ALL ON TABLE set_type TO i2b2demodata;
GRANT ALL ON TABLE set_type TO tm_cz;
GRANT SELECT ON TABLE set_type TO biomart_user;


--
-- Name: set_upload_status; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE set_upload_status FROM PUBLIC;
REVOKE ALL ON TABLE set_upload_status FROM i2b2demodata;
GRANT ALL ON TABLE set_upload_status TO i2b2demodata;
GRANT ALL ON TABLE set_upload_status TO tm_cz;
GRANT SELECT ON TABLE set_upload_status TO biomart_user;


--
-- Name: source_master; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE source_master FROM PUBLIC;
REVOKE ALL ON TABLE source_master FROM i2b2demodata;
GRANT ALL ON TABLE source_master TO i2b2demodata;
GRANT ALL ON TABLE source_master TO tm_cz;
GRANT SELECT ON TABLE source_master TO biomart_user;


--
-- Name: sq_up_encdim_encounternum; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE sq_up_encdim_encounternum FROM PUBLIC;
REVOKE ALL ON SEQUENCE sq_up_encdim_encounternum FROM i2b2demodata;
GRANT ALL ON SEQUENCE sq_up_encdim_encounternum TO i2b2demodata;
GRANT ALL ON SEQUENCE sq_up_encdim_encounternum TO tm_cz;
GRANT ALL ON SEQUENCE sq_up_encdim_encounternum TO biomart_user;


--
-- Name: sq_uploadstatus_uploadid; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON SEQUENCE sq_uploadstatus_uploadid FROM PUBLIC;
REVOKE ALL ON SEQUENCE sq_uploadstatus_uploadid FROM i2b2demodata;
GRANT ALL ON SEQUENCE sq_uploadstatus_uploadid TO i2b2demodata;
GRANT ALL ON SEQUENCE sq_uploadstatus_uploadid TO tm_cz;
GRANT ALL ON SEQUENCE sq_uploadstatus_uploadid TO biomart_user;


--
-- Name: timers; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE timers FROM PUBLIC;
REVOKE ALL ON TABLE timers FROM i2b2demodata;
GRANT ALL ON TABLE timers TO i2b2demodata;
GRANT ALL ON TABLE timers TO tm_cz;
GRANT SELECT ON TABLE timers TO biomart_user;


--
-- Name: upload_status; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE upload_status FROM PUBLIC;
REVOKE ALL ON TABLE upload_status FROM i2b2demodata;
GRANT ALL ON TABLE upload_status TO i2b2demodata;
GRANT ALL ON TABLE upload_status TO tm_cz;
GRANT SELECT ON TABLE upload_status TO biomart_user;


--
-- Name: visit_dimension; Type: ACL; Schema: i2b2demodata; Owner: i2b2demodata
--

REVOKE ALL ON TABLE visit_dimension FROM PUBLIC;
REVOKE ALL ON TABLE visit_dimension FROM i2b2demodata;
GRANT ALL ON TABLE visit_dimension TO i2b2demodata;
GRANT ALL ON TABLE visit_dimension TO tm_cz;
GRANT SELECT ON TABLE visit_dimension TO biomart_user;


SET search_path = i2b2metadata, pg_catalog;

--
-- Name: custom_meta; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE custom_meta FROM PUBLIC;
REVOKE ALL ON TABLE custom_meta FROM i2b2metadata;
GRANT ALL ON TABLE custom_meta TO i2b2metadata;
GRANT ALL ON TABLE custom_meta TO tm_cz;
GRANT SELECT ON TABLE custom_meta TO biomart_user;


--
-- Name: i2b2_record_id_seq; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON SEQUENCE i2b2_record_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE i2b2_record_id_seq FROM i2b2metadata;
GRANT ALL ON SEQUENCE i2b2_record_id_seq TO i2b2metadata;
GRANT ALL ON SEQUENCE i2b2_record_id_seq TO tm_cz;
GRANT ALL ON SEQUENCE i2b2_record_id_seq TO biomart_user;


--
-- Name: i2b2; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE i2b2 FROM PUBLIC;
REVOKE ALL ON TABLE i2b2 FROM i2b2metadata;
GRANT ALL ON TABLE i2b2 TO i2b2metadata;
GRANT ALL ON TABLE i2b2 TO tm_cz;
GRANT SELECT ON TABLE i2b2 TO biomart_user;


--
-- Name: i2b2_id_seq; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON SEQUENCE i2b2_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE i2b2_id_seq FROM i2b2metadata;
GRANT ALL ON SEQUENCE i2b2_id_seq TO i2b2metadata;
GRANT ALL ON SEQUENCE i2b2_id_seq TO tm_cz;
GRANT ALL ON SEQUENCE i2b2_id_seq TO biomart_user;


--
-- Name: i2b2_secure; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE i2b2_secure FROM PUBLIC;
REVOKE ALL ON TABLE i2b2_secure FROM i2b2metadata;
GRANT ALL ON TABLE i2b2_secure TO i2b2metadata;
GRANT ALL ON TABLE i2b2_secure TO tm_cz;
GRANT SELECT ON TABLE i2b2_secure TO biomart_user;


--
-- Name: i2b2_tags; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE i2b2_tags FROM PUBLIC;
REVOKE ALL ON TABLE i2b2_tags FROM i2b2metadata;
GRANT ALL ON TABLE i2b2_tags TO i2b2metadata;
GRANT ALL ON TABLE i2b2_tags TO tm_cz;
GRANT SELECT ON TABLE i2b2_tags TO biomart_user;


--
-- Name: i2b2_trial_nodes; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE i2b2_trial_nodes FROM PUBLIC;
REVOKE ALL ON TABLE i2b2_trial_nodes FROM i2b2metadata;
GRANT ALL ON TABLE i2b2_trial_nodes TO i2b2metadata;
GRANT ALL ON TABLE i2b2_trial_nodes TO tm_cz;
GRANT SELECT ON TABLE i2b2_trial_nodes TO biomart_user;


--
-- Name: ont_db_lookup; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE ont_db_lookup FROM PUBLIC;
REVOKE ALL ON TABLE ont_db_lookup FROM i2b2metadata;
GRANT ALL ON TABLE ont_db_lookup TO i2b2metadata;
GRANT ALL ON TABLE ont_db_lookup TO tm_cz;
GRANT SELECT ON TABLE ont_db_lookup TO biomart_user;


--
-- Name: ont_sq_ps_prid; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON SEQUENCE ont_sq_ps_prid FROM PUBLIC;
REVOKE ALL ON SEQUENCE ont_sq_ps_prid FROM i2b2metadata;
GRANT ALL ON SEQUENCE ont_sq_ps_prid TO i2b2metadata;
GRANT ALL ON SEQUENCE ont_sq_ps_prid TO tm_cz;
GRANT ALL ON SEQUENCE ont_sq_ps_prid TO biomart_user;


--
-- Name: ont_process_status; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE ont_process_status FROM PUBLIC;
REVOKE ALL ON TABLE ont_process_status FROM i2b2metadata;
GRANT ALL ON TABLE ont_process_status TO i2b2metadata;
GRANT ALL ON TABLE ont_process_status TO tm_cz;
GRANT SELECT ON TABLE ont_process_status TO biomart_user;


--
-- Name: schemes; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE schemes FROM PUBLIC;
REVOKE ALL ON TABLE schemes FROM i2b2metadata;
GRANT ALL ON TABLE schemes TO i2b2metadata;
GRANT ALL ON TABLE schemes TO tm_cz;
GRANT SELECT ON TABLE schemes TO biomart_user;


--
-- Name: seq_concept_code; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON SEQUENCE seq_concept_code FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_concept_code FROM i2b2metadata;
GRANT ALL ON SEQUENCE seq_concept_code TO i2b2metadata;
GRANT ALL ON SEQUENCE seq_concept_code TO tm_cz;
GRANT ALL ON SEQUENCE seq_concept_code TO biomart_user;


--
-- Name: seq_i2b2_data_id; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON SEQUENCE seq_i2b2_data_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_i2b2_data_id FROM i2b2metadata;
GRANT ALL ON SEQUENCE seq_i2b2_data_id TO i2b2metadata;
GRANT ALL ON SEQUENCE seq_i2b2_data_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_i2b2_data_id TO biomart_user;


--
-- Name: seq_i2b2_tags_tag_id; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON SEQUENCE seq_i2b2_tags_tag_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_i2b2_tags_tag_id FROM i2b2metadata;
GRANT ALL ON SEQUENCE seq_i2b2_tags_tag_id TO i2b2metadata;
GRANT ALL ON SEQUENCE seq_i2b2_tags_tag_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_i2b2_tags_tag_id TO biomart_user;


--
-- Name: sq_i2b2_id; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON SEQUENCE sq_i2b2_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE sq_i2b2_id FROM i2b2metadata;
GRANT ALL ON SEQUENCE sq_i2b2_id TO i2b2metadata;
GRANT ALL ON SEQUENCE sq_i2b2_id TO tm_cz;
GRANT ALL ON SEQUENCE sq_i2b2_id TO biomart_user;


--
-- Name: sq_i2b2_tag_id; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON SEQUENCE sq_i2b2_tag_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE sq_i2b2_tag_id FROM i2b2metadata;
GRANT ALL ON SEQUENCE sq_i2b2_tag_id TO i2b2metadata;
GRANT ALL ON SEQUENCE sq_i2b2_tag_id TO tm_cz;
GRANT ALL ON SEQUENCE sq_i2b2_tag_id TO biomart_user;


--
-- Name: table_access; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE table_access FROM PUBLIC;
REVOKE ALL ON TABLE table_access FROM i2b2metadata;
GRANT ALL ON TABLE table_access TO i2b2metadata;
GRANT ALL ON TABLE table_access TO tm_cz;
GRANT SELECT ON TABLE table_access TO biomart_user;


--
-- Name: tmp_secure_token; Type: ACL; Schema: i2b2metadata; Owner: i2b2metadata
--

REVOKE ALL ON TABLE tmp_secure_token FROM PUBLIC;
REVOKE ALL ON TABLE tmp_secure_token FROM i2b2metadata;
GRANT ALL ON TABLE tmp_secure_token TO i2b2metadata;
GRANT ALL ON TABLE tmp_secure_token TO tm_cz;
GRANT SELECT ON TABLE tmp_secure_token TO biomart_user;


SET search_path = searchapp, pg_catalog;

--
-- Name: hibernate_sequence; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON SEQUENCE hibernate_sequence FROM PUBLIC;
REVOKE ALL ON SEQUENCE hibernate_sequence FROM searchapp;
GRANT ALL ON SEQUENCE hibernate_sequence TO searchapp;
GRANT ALL ON SEQUENCE hibernate_sequence TO tm_cz;
GRANT ALL ON SEQUENCE hibernate_sequence TO biomart_user;


--
-- Name: search_gene_signature; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_gene_signature FROM PUBLIC;
REVOKE ALL ON TABLE search_gene_signature FROM searchapp;
GRANT ALL ON TABLE search_gene_signature TO searchapp;
GRANT ALL ON TABLE search_gene_signature TO tm_cz;
GRANT ALL ON TABLE search_gene_signature TO biomart_user;


--
-- Name: search_gene_signature_item; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_gene_signature_item FROM PUBLIC;
REVOKE ALL ON TABLE search_gene_signature_item FROM searchapp;
GRANT ALL ON TABLE search_gene_signature_item TO searchapp;
GRANT ALL ON TABLE search_gene_signature_item TO tm_cz;
GRANT ALL ON TABLE search_gene_signature_item TO biomart_user;


--
-- Name: search_keyword; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_keyword FROM PUBLIC;
REVOKE ALL ON TABLE search_keyword FROM searchapp;
GRANT ALL ON TABLE search_keyword TO searchapp;
GRANT ALL ON TABLE search_keyword TO tm_cz;
GRANT ALL ON TABLE search_keyword TO biomart_user;


--
-- Name: listsig_genes; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE listsig_genes FROM PUBLIC;
REVOKE ALL ON TABLE listsig_genes FROM searchapp;
GRANT ALL ON TABLE listsig_genes TO searchapp;
GRANT ALL ON TABLE listsig_genes TO tm_cz;
GRANT SELECT ON TABLE listsig_genes TO biomart_user;


--
-- Name: pathway_genes; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE pathway_genes FROM PUBLIC;
REVOKE ALL ON TABLE pathway_genes FROM searchapp;
GRANT ALL ON TABLE pathway_genes TO searchapp;
GRANT ALL ON TABLE pathway_genes TO tm_cz;
GRANT SELECT ON TABLE pathway_genes TO biomart_user;


--
-- Name: plugin; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE plugin FROM PUBLIC;
REVOKE ALL ON TABLE plugin FROM searchapp;
GRANT ALL ON TABLE plugin TO searchapp;
GRANT ALL ON TABLE plugin TO tm_cz;
GRANT ALL ON TABLE plugin TO biomart_user;


--
-- Name: plugin_module; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE plugin_module FROM PUBLIC;
REVOKE ALL ON TABLE plugin_module FROM searchapp;
GRANT ALL ON TABLE plugin_module TO searchapp;
GRANT ALL ON TABLE plugin_module TO tm_cz;
GRANT ALL ON TABLE plugin_module TO biomart_user;


--
-- Name: plugin_module_backup; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE plugin_module_backup FROM PUBLIC;
REVOKE ALL ON TABLE plugin_module_backup FROM searchapp;
GRANT ALL ON TABLE plugin_module_backup TO searchapp;
GRANT ALL ON TABLE plugin_module_backup TO tm_cz;
GRANT ALL ON TABLE plugin_module_backup TO biomart_user;


--
-- Name: plugin_module_seq; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON SEQUENCE plugin_module_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE plugin_module_seq FROM searchapp;
GRANT ALL ON SEQUENCE plugin_module_seq TO searchapp;
GRANT ALL ON SEQUENCE plugin_module_seq TO tm_cz;
GRANT ALL ON SEQUENCE plugin_module_seq TO biomart_user;


--
-- Name: plugin_seq; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON SEQUENCE plugin_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE plugin_seq FROM searchapp;
GRANT ALL ON SEQUENCE plugin_seq TO searchapp;
GRANT ALL ON SEQUENCE plugin_seq TO tm_cz;
GRANT ALL ON SEQUENCE plugin_seq TO biomart_user;


--
-- Name: report; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE report FROM PUBLIC;
REVOKE ALL ON TABLE report FROM searchapp;
GRANT ALL ON TABLE report TO searchapp;
GRANT ALL ON TABLE report TO tm_cz;
GRANT ALL ON TABLE report TO biomart_user;


--
-- Name: report_item; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE report_item FROM PUBLIC;
REVOKE ALL ON TABLE report_item FROM searchapp;
GRANT ALL ON TABLE report_item TO searchapp;
GRANT ALL ON TABLE report_item TO tm_cz;
GRANT ALL ON TABLE report_item TO biomart_user;


--
-- Name: saved_faceted_search; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE saved_faceted_search FROM PUBLIC;
REVOKE ALL ON TABLE saved_faceted_search FROM searchapp;
GRANT ALL ON TABLE saved_faceted_search TO searchapp;
GRANT ALL ON TABLE saved_faceted_search TO tm_cz;
GRANT ALL ON TABLE saved_faceted_search TO biomart_user;


--
-- Name: search_app_access_log; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_app_access_log FROM PUBLIC;
REVOKE ALL ON TABLE search_app_access_log FROM searchapp;
GRANT ALL ON TABLE search_app_access_log TO searchapp;
GRANT ALL ON TABLE search_app_access_log TO tm_cz;
GRANT ALL ON TABLE search_app_access_log TO biomart_user;


--
-- Name: search_auth_group; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_group FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_group FROM searchapp;
GRANT ALL ON TABLE search_auth_group TO searchapp;
GRANT ALL ON TABLE search_auth_group TO tm_cz;
GRANT ALL ON TABLE search_auth_group TO biomart_user;


--
-- Name: search_auth_group_member; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_group_member FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_group_member FROM searchapp;
GRANT ALL ON TABLE search_auth_group_member TO searchapp;
GRANT ALL ON TABLE search_auth_group_member TO tm_cz;
GRANT ALL ON TABLE search_auth_group_member TO biomart_user;


--
-- Name: search_auth_principal; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_principal FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_principal FROM searchapp;
GRANT ALL ON TABLE search_auth_principal TO searchapp;
GRANT ALL ON TABLE search_auth_principal TO tm_cz;
GRANT ALL ON TABLE search_auth_principal TO biomart_user;


--
-- Name: search_auth_sec_object_access; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_sec_object_access FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_sec_object_access FROM searchapp;
GRANT ALL ON TABLE search_auth_sec_object_access TO searchapp;
GRANT ALL ON TABLE search_auth_sec_object_access TO tm_cz;
GRANT ALL ON TABLE search_auth_sec_object_access TO biomart_user;


--
-- Name: search_auth_user; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_user FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_user FROM searchapp;
GRANT ALL ON TABLE search_auth_user TO searchapp;
GRANT ALL ON TABLE search_auth_user TO tm_cz;
GRANT ALL ON TABLE search_auth_user TO biomart_user;


--
-- Name: search_auth_user_sec_access; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_user_sec_access FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_user_sec_access FROM searchapp;
GRANT ALL ON TABLE search_auth_user_sec_access TO searchapp;
GRANT ALL ON TABLE search_auth_user_sec_access TO tm_cz;
GRANT ALL ON TABLE search_auth_user_sec_access TO biomart_user;


--
-- Name: search_auth_user_sec_access_v; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_auth_user_sec_access_v FROM PUBLIC;
REVOKE ALL ON TABLE search_auth_user_sec_access_v FROM searchapp;
GRANT ALL ON TABLE search_auth_user_sec_access_v TO searchapp;
GRANT ALL ON TABLE search_auth_user_sec_access_v TO tm_cz;
GRANT SELECT ON TABLE search_auth_user_sec_access_v TO biomart_user;


--
-- Name: search_bio_mkr_correl_fast_mv; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_bio_mkr_correl_fast_mv FROM PUBLIC;
REVOKE ALL ON TABLE search_bio_mkr_correl_fast_mv FROM searchapp;
GRANT ALL ON TABLE search_bio_mkr_correl_fast_mv TO searchapp;
GRANT ALL ON TABLE search_bio_mkr_correl_fast_mv TO tm_cz;
GRANT ALL ON TABLE search_bio_mkr_correl_fast_mv TO biomart_user;


--
-- Name: search_bio_mkr_correl_fast_view; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_bio_mkr_correl_fast_view FROM PUBLIC;
REVOKE ALL ON TABLE search_bio_mkr_correl_fast_view FROM searchapp;
GRANT ALL ON TABLE search_bio_mkr_correl_fast_view TO searchapp;
GRANT ALL ON TABLE search_bio_mkr_correl_fast_view TO tm_cz;
GRANT SELECT ON TABLE search_bio_mkr_correl_fast_view TO biomart_user;


--
-- Name: search_bio_mkr_correl_view; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_bio_mkr_correl_view FROM PUBLIC;
REVOKE ALL ON TABLE search_bio_mkr_correl_view FROM searchapp;
GRANT ALL ON TABLE search_bio_mkr_correl_view TO searchapp;
GRANT ALL ON TABLE search_bio_mkr_correl_view TO tm_cz;
GRANT SELECT ON TABLE search_bio_mkr_correl_view TO biomart_user;


--
-- Name: search_taxonomy; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_taxonomy FROM PUBLIC;
REVOKE ALL ON TABLE search_taxonomy FROM searchapp;
GRANT ALL ON TABLE search_taxonomy TO searchapp;
GRANT ALL ON TABLE search_taxonomy TO tm_cz;
GRANT ALL ON TABLE search_taxonomy TO biomart_user;


--
-- Name: search_taxonomy_rels; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_taxonomy_rels FROM PUBLIC;
REVOKE ALL ON TABLE search_taxonomy_rels FROM searchapp;
GRANT ALL ON TABLE search_taxonomy_rels TO searchapp;
GRANT ALL ON TABLE search_taxonomy_rels TO tm_cz;
GRANT ALL ON TABLE search_taxonomy_rels TO biomart_user;


--
-- Name: search_categories; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_categories FROM PUBLIC;
REVOKE ALL ON TABLE search_categories FROM searchapp;
GRANT ALL ON TABLE search_categories TO searchapp;
GRANT ALL ON TABLE search_categories TO tm_cz;
GRANT SELECT ON TABLE search_categories TO biomart_user;


--
-- Name: search_custom_filter; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_custom_filter FROM PUBLIC;
REVOKE ALL ON TABLE search_custom_filter FROM searchapp;
GRANT ALL ON TABLE search_custom_filter TO searchapp;
GRANT ALL ON TABLE search_custom_filter TO tm_cz;
GRANT ALL ON TABLE search_custom_filter TO biomart_user;


--
-- Name: search_custom_filter_item; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_custom_filter_item FROM PUBLIC;
REVOKE ALL ON TABLE search_custom_filter_item FROM searchapp;
GRANT ALL ON TABLE search_custom_filter_item TO searchapp;
GRANT ALL ON TABLE search_custom_filter_item TO tm_cz;
GRANT ALL ON TABLE search_custom_filter_item TO biomart_user;


--
-- Name: search_gene_sig_file_schema; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_gene_sig_file_schema FROM PUBLIC;
REVOKE ALL ON TABLE search_gene_sig_file_schema FROM searchapp;
GRANT ALL ON TABLE search_gene_sig_file_schema TO searchapp;
GRANT ALL ON TABLE search_gene_sig_file_schema TO tm_cz;
GRANT ALL ON TABLE search_gene_sig_file_schema TO biomart_user;


--
-- Name: search_keyword_term; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_keyword_term FROM PUBLIC;
REVOKE ALL ON TABLE search_keyword_term FROM searchapp;
GRANT ALL ON TABLE search_keyword_term TO searchapp;
GRANT ALL ON TABLE search_keyword_term TO tm_cz;
GRANT ALL ON TABLE search_keyword_term TO biomart_user;


--
-- Name: search_request_map; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_request_map FROM PUBLIC;
REVOKE ALL ON TABLE search_request_map FROM searchapp;
GRANT ALL ON TABLE search_request_map TO searchapp;
GRANT ALL ON TABLE search_request_map TO tm_cz;
GRANT ALL ON TABLE search_request_map TO biomart_user;


--
-- Name: search_role; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_role FROM PUBLIC;
REVOKE ALL ON TABLE search_role FROM searchapp;
GRANT ALL ON TABLE search_role TO searchapp;
GRANT ALL ON TABLE search_role TO tm_cz;
GRANT ALL ON TABLE search_role TO biomart_user;


--
-- Name: search_role_auth_user; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_role_auth_user FROM PUBLIC;
REVOKE ALL ON TABLE search_role_auth_user FROM searchapp;
GRANT ALL ON TABLE search_role_auth_user TO searchapp;
GRANT ALL ON TABLE search_role_auth_user TO tm_cz;
GRANT ALL ON TABLE search_role_auth_user TO biomart_user;


--
-- Name: search_sec_access_level; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_sec_access_level FROM PUBLIC;
REVOKE ALL ON TABLE search_sec_access_level FROM searchapp;
GRANT ALL ON TABLE search_sec_access_level TO searchapp;
GRANT ALL ON TABLE search_sec_access_level TO tm_cz;
GRANT ALL ON TABLE search_sec_access_level TO biomart_user;


--
-- Name: search_secure_object; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_secure_object FROM PUBLIC;
REVOKE ALL ON TABLE search_secure_object FROM searchapp;
GRANT ALL ON TABLE search_secure_object TO searchapp;
GRANT ALL ON TABLE search_secure_object TO tm_cz;
GRANT ALL ON TABLE search_secure_object TO biomart_user;


--
-- Name: search_secure_object_path; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_secure_object_path FROM PUBLIC;
REVOKE ALL ON TABLE search_secure_object_path FROM searchapp;
GRANT ALL ON TABLE search_secure_object_path TO searchapp;
GRANT ALL ON TABLE search_secure_object_path TO tm_cz;
GRANT ALL ON TABLE search_secure_object_path TO biomart_user;


--
-- Name: search_taxonomy_level1; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_taxonomy_level1 FROM PUBLIC;
REVOKE ALL ON TABLE search_taxonomy_level1 FROM searchapp;
GRANT ALL ON TABLE search_taxonomy_level1 TO searchapp;
GRANT ALL ON TABLE search_taxonomy_level1 TO tm_cz;
GRANT SELECT ON TABLE search_taxonomy_level1 TO biomart_user;


--
-- Name: search_taxonomy_level2; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_taxonomy_level2 FROM PUBLIC;
REVOKE ALL ON TABLE search_taxonomy_level2 FROM searchapp;
GRANT ALL ON TABLE search_taxonomy_level2 TO searchapp;
GRANT ALL ON TABLE search_taxonomy_level2 TO tm_cz;
GRANT SELECT ON TABLE search_taxonomy_level2 TO biomart_user;


--
-- Name: search_taxonomy_level3; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_taxonomy_level3 FROM PUBLIC;
REVOKE ALL ON TABLE search_taxonomy_level3 FROM searchapp;
GRANT ALL ON TABLE search_taxonomy_level3 TO searchapp;
GRANT ALL ON TABLE search_taxonomy_level3 TO tm_cz;
GRANT SELECT ON TABLE search_taxonomy_level3 TO biomart_user;


--
-- Name: search_taxonomy_level4; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_taxonomy_level4 FROM PUBLIC;
REVOKE ALL ON TABLE search_taxonomy_level4 FROM searchapp;
GRANT ALL ON TABLE search_taxonomy_level4 TO searchapp;
GRANT ALL ON TABLE search_taxonomy_level4 TO tm_cz;
GRANT SELECT ON TABLE search_taxonomy_level4 TO biomart_user;


--
-- Name: search_taxonomy_level5; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_taxonomy_level5 FROM PUBLIC;
REVOKE ALL ON TABLE search_taxonomy_level5 FROM searchapp;
GRANT ALL ON TABLE search_taxonomy_level5 TO searchapp;
GRANT ALL ON TABLE search_taxonomy_level5 TO tm_cz;
GRANT SELECT ON TABLE search_taxonomy_level5 TO biomart_user;


--
-- Name: search_taxonomy_lineage; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_taxonomy_lineage FROM PUBLIC;
REVOKE ALL ON TABLE search_taxonomy_lineage FROM searchapp;
GRANT ALL ON TABLE search_taxonomy_lineage TO searchapp;
GRANT ALL ON TABLE search_taxonomy_lineage TO tm_cz;
GRANT SELECT ON TABLE search_taxonomy_lineage TO biomart_user;


--
-- Name: search_taxonomy_terms_cats; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_taxonomy_terms_cats FROM PUBLIC;
REVOKE ALL ON TABLE search_taxonomy_terms_cats FROM searchapp;
GRANT ALL ON TABLE search_taxonomy_terms_cats TO searchapp;
GRANT ALL ON TABLE search_taxonomy_terms_cats TO tm_cz;
GRANT SELECT ON TABLE search_taxonomy_terms_cats TO biomart_user;


--
-- Name: search_user_feedback; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_user_feedback FROM PUBLIC;
REVOKE ALL ON TABLE search_user_feedback FROM searchapp;
GRANT ALL ON TABLE search_user_feedback TO searchapp;
GRANT ALL ON TABLE search_user_feedback TO tm_cz;
GRANT ALL ON TABLE search_user_feedback TO biomart_user;


--
-- Name: search_user_settings; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE search_user_settings FROM PUBLIC;
REVOKE ALL ON TABLE search_user_settings FROM searchapp;
GRANT ALL ON TABLE search_user_settings TO searchapp;
GRANT ALL ON TABLE search_user_settings TO tm_cz;
GRANT ALL ON TABLE search_user_settings TO biomart_user;


--
-- Name: seq_saved_faceted_search_id; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON SEQUENCE seq_saved_faceted_search_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_saved_faceted_search_id FROM searchapp;
GRANT ALL ON SEQUENCE seq_saved_faceted_search_id TO searchapp;
GRANT ALL ON SEQUENCE seq_saved_faceted_search_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_saved_faceted_search_id TO biomart_user;


--
-- Name: seq_search_data_id; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON SEQUENCE seq_search_data_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_search_data_id FROM searchapp;
GRANT ALL ON SEQUENCE seq_search_data_id TO searchapp;
GRANT ALL ON SEQUENCE seq_search_data_id TO tm_cz;
GRANT ALL ON SEQUENCE seq_search_data_id TO biomart_user;


--
-- Name: solr_keywords_lineage; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE solr_keywords_lineage FROM PUBLIC;
REVOKE ALL ON TABLE solr_keywords_lineage FROM searchapp;
GRANT ALL ON TABLE solr_keywords_lineage TO searchapp;
GRANT ALL ON TABLE solr_keywords_lineage TO tm_cz;
GRANT SELECT ON TABLE solr_keywords_lineage TO biomart_user;


--
-- Name: subset; Type: ACL; Schema: searchapp; Owner: searchapp
--

REVOKE ALL ON TABLE subset FROM PUBLIC;
REVOKE ALL ON TABLE subset FROM searchapp;
GRANT ALL ON TABLE subset TO searchapp;
GRANT ALL ON TABLE subset TO tm_cz;
GRANT ALL ON TABLE subset TO biomart_user;


SET search_path = tm_cz, pg_catalog;

--
-- Name: az_test_run; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE az_test_run FROM PUBLIC;
REVOKE ALL ON TABLE az_test_run FROM tm_cz;
GRANT ALL ON TABLE az_test_run TO tm_cz;


--
-- Name: az_test_step_act_result; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE az_test_step_act_result FROM PUBLIC;
REVOKE ALL ON TABLE az_test_step_act_result FROM tm_cz;
GRANT ALL ON TABLE az_test_step_act_result TO tm_cz;


--
-- Name: az_test_step_run; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE az_test_step_run FROM PUBLIC;
REVOKE ALL ON TABLE az_test_step_run FROM tm_cz;
GRANT ALL ON TABLE az_test_step_run TO tm_cz;


--
-- Name: cz_test; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_test FROM PUBLIC;
REVOKE ALL ON TABLE cz_test FROM tm_cz;
GRANT ALL ON TABLE cz_test TO tm_cz;


--
-- Name: cz_test_category; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_test_category FROM PUBLIC;
REVOKE ALL ON TABLE cz_test_category FROM tm_cz;
GRANT ALL ON TABLE cz_test_category TO tm_cz;


--
-- Name: all_test_detail_view; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE all_test_detail_view FROM PUBLIC;
REVOKE ALL ON TABLE all_test_detail_view FROM tm_cz;
GRANT ALL ON TABLE all_test_detail_view TO tm_cz;


--
-- Name: cz_dw_version; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_dw_version FROM PUBLIC;
REVOKE ALL ON TABLE cz_dw_version FROM tm_cz;
GRANT ALL ON TABLE cz_dw_version TO tm_cz;


--
-- Name: all_test_summary_view; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE all_test_summary_view FROM PUBLIC;
REVOKE ALL ON TABLE all_test_summary_view FROM tm_cz;
GRANT ALL ON TABLE all_test_summary_view TO tm_cz;


--
-- Name: annotation_deapp; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE annotation_deapp FROM PUBLIC;
REVOKE ALL ON TABLE annotation_deapp FROM tm_cz;
GRANT ALL ON TABLE annotation_deapp TO tm_cz;


--
-- Name: annotation_deapp_20120206; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE annotation_deapp_20120206 FROM PUBLIC;
REVOKE ALL ON TABLE annotation_deapp_20120206 FROM tm_cz;
GRANT ALL ON TABLE annotation_deapp_20120206 TO tm_cz;


--
-- Name: antigen_deapp; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE antigen_deapp FROM PUBLIC;
REVOKE ALL ON TABLE antigen_deapp FROM tm_cz;
GRANT ALL ON TABLE antigen_deapp TO tm_cz;


--
-- Name: az_test_comparison_info; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE az_test_comparison_info FROM PUBLIC;
REVOKE ALL ON TABLE az_test_comparison_info FROM tm_cz;
GRANT ALL ON TABLE az_test_comparison_info TO tm_cz;


--
-- Name: bio_clinical_trial_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE bio_clinical_trial_release FROM PUBLIC;
REVOKE ALL ON TABLE bio_clinical_trial_release FROM tm_cz;
GRANT ALL ON TABLE bio_clinical_trial_release TO tm_cz;


--
-- Name: bio_data_compound_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE bio_data_compound_release FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_compound_release FROM tm_cz;
GRANT ALL ON TABLE bio_data_compound_release TO tm_cz;


--
-- Name: bio_data_uid_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE bio_data_uid_release FROM PUBLIC;
REVOKE ALL ON TABLE bio_data_uid_release FROM tm_cz;
GRANT ALL ON TABLE bio_data_uid_release TO tm_cz;


--
-- Name: bio_experiment_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE bio_experiment_release FROM PUBLIC;
REVOKE ALL ON TABLE bio_experiment_release FROM tm_cz;
GRANT ALL ON TABLE bio_experiment_release TO tm_cz;


--
-- Name: category_path_excluded_words; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE category_path_excluded_words FROM PUBLIC;
REVOKE ALL ON TABLE category_path_excluded_words FROM tm_cz;
GRANT ALL ON TABLE category_path_excluded_words TO tm_cz;


--
-- Name: concept_dimension_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE concept_dimension_release FROM PUBLIC;
REVOKE ALL ON TABLE concept_dimension_release FROM tm_cz;
GRANT ALL ON TABLE concept_dimension_release TO tm_cz;


--
-- Name: currtime; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE currtime FROM PUBLIC;
REVOKE ALL ON TABLE currtime FROM tm_cz;
GRANT ALL ON TABLE currtime TO tm_cz;


--
-- Name: cz_data; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_data FROM PUBLIC;
REVOKE ALL ON TABLE cz_data FROM tm_cz;
GRANT ALL ON TABLE cz_data TO tm_cz;


--
-- Name: cz_data_file; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_data_file FROM PUBLIC;
REVOKE ALL ON TABLE cz_data_file FROM tm_cz;
GRANT ALL ON TABLE cz_data_file TO tm_cz;


--
-- Name: cz_data_profile_column_exclusi; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_data_profile_column_exclusi FROM PUBLIC;
REVOKE ALL ON TABLE cz_data_profile_column_exclusi FROM tm_cz;
GRANT ALL ON TABLE cz_data_profile_column_exclusi TO tm_cz;


--
-- Name: cz_data_profile_column_sample; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_data_profile_column_sample FROM PUBLIC;
REVOKE ALL ON TABLE cz_data_profile_column_sample FROM tm_cz;
GRANT ALL ON TABLE cz_data_profile_column_sample TO tm_cz;


--
-- Name: cz_data_profile_stats; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_data_profile_stats FROM PUBLIC;
REVOKE ALL ON TABLE cz_data_profile_stats FROM tm_cz;
GRANT ALL ON TABLE cz_data_profile_stats TO tm_cz;


--
-- Name: cz_form_layout; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_form_layout FROM PUBLIC;
REVOKE ALL ON TABLE cz_form_layout FROM tm_cz;
GRANT ALL ON TABLE cz_form_layout TO tm_cz;


--
-- Name: cz_form_layout_seq; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE cz_form_layout_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE cz_form_layout_seq FROM tm_cz;
GRANT ALL ON SEQUENCE cz_form_layout_seq TO tm_cz;


--
-- Name: cz_job_audit; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_job_audit FROM PUBLIC;
REVOKE ALL ON TABLE cz_job_audit FROM tm_cz;
GRANT ALL ON TABLE cz_job_audit TO tm_cz;


--
-- Name: cz_job_error; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_job_error FROM PUBLIC;
REVOKE ALL ON TABLE cz_job_error FROM tm_cz;
GRANT ALL ON TABLE cz_job_error TO tm_cz;


--
-- Name: cz_job_master; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_job_master FROM PUBLIC;
REVOKE ALL ON TABLE cz_job_master FROM tm_cz;
GRANT ALL ON TABLE cz_job_master TO tm_cz;


--
-- Name: cz_job_message; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_job_message FROM PUBLIC;
REVOKE ALL ON TABLE cz_job_message FROM tm_cz;
GRANT ALL ON TABLE cz_job_message TO tm_cz;


--
-- Name: cz_person; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_person FROM PUBLIC;
REVOKE ALL ON TABLE cz_person FROM tm_cz;
GRANT ALL ON TABLE cz_person TO tm_cz;


--
-- Name: cz_rwg_invalid_terms; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_rwg_invalid_terms FROM PUBLIC;
REVOKE ALL ON TABLE cz_rwg_invalid_terms FROM tm_cz;
GRANT ALL ON TABLE cz_rwg_invalid_terms TO tm_cz;


--
-- Name: cz_test_result; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_test_result FROM PUBLIC;
REVOKE ALL ON TABLE cz_test_result FROM tm_cz;
GRANT ALL ON TABLE cz_test_result TO tm_cz;


--
-- Name: cz_test_severity; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_test_severity FROM PUBLIC;
REVOKE ALL ON TABLE cz_test_severity FROM tm_cz;
GRANT ALL ON TABLE cz_test_severity TO tm_cz;


--
-- Name: cz_xtrial_ctrl_vocab; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_xtrial_ctrl_vocab FROM PUBLIC;
REVOKE ALL ON TABLE cz_xtrial_ctrl_vocab FROM tm_cz;
GRANT ALL ON TABLE cz_xtrial_ctrl_vocab TO tm_cz;


--
-- Name: cz_xtrial_exclusion; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE cz_xtrial_exclusion FROM PUBLIC;
REVOKE ALL ON TABLE cz_xtrial_exclusion FROM tm_cz;
GRANT ALL ON TABLE cz_xtrial_exclusion TO tm_cz;


SET search_path = tm_lz, pg_catalog;

--
-- Name: lz_src_sample_categories; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lz_src_sample_categories FROM PUBLIC;
REVOKE ALL ON TABLE lz_src_sample_categories FROM tm_lz;
GRANT ALL ON TABLE lz_src_sample_categories TO tm_lz;
GRANT ALL ON TABLE lz_src_sample_categories TO tm_cz;


SET search_path = tm_cz, pg_catalog;

--
-- Name: czv_pivot_sample_categories; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE czv_pivot_sample_categories FROM PUBLIC;
REVOKE ALL ON TABLE czv_pivot_sample_categories FROM tm_cz;
GRANT ALL ON TABLE czv_pivot_sample_categories TO tm_cz;


--
-- Name: de_gpl_info_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_gpl_info_release FROM PUBLIC;
REVOKE ALL ON TABLE de_gpl_info_release FROM tm_cz;
GRANT ALL ON TABLE de_gpl_info_release TO tm_cz;


--
-- Name: de_mrna_annotation_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_mrna_annotation_release FROM PUBLIC;
REVOKE ALL ON TABLE de_mrna_annotation_release FROM tm_cz;
GRANT ALL ON TABLE de_mrna_annotation_release TO tm_cz;


--
-- Name: de_snp_data_by_patient_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_snp_data_by_patient_release FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_data_by_patient_release FROM tm_cz;
GRANT ALL ON TABLE de_snp_data_by_patient_release TO tm_cz;


--
-- Name: de_snp_data_by_probe_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_snp_data_by_probe_release FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_data_by_probe_release FROM tm_cz;
GRANT ALL ON TABLE de_snp_data_by_probe_release TO tm_cz;


--
-- Name: de_snp_data_ds_loc_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_snp_data_ds_loc_release FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_data_ds_loc_release FROM tm_cz;
GRANT ALL ON TABLE de_snp_data_ds_loc_release TO tm_cz;


--
-- Name: de_snp_gene_map_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_snp_gene_map_release FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_gene_map_release FROM tm_cz;
GRANT ALL ON TABLE de_snp_gene_map_release TO tm_cz;


--
-- Name: de_snp_info_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_snp_info_release FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_info_release FROM tm_cz;
GRANT ALL ON TABLE de_snp_info_release TO tm_cz;


--
-- Name: de_snp_probe_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_snp_probe_release FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_probe_release FROM tm_cz;
GRANT ALL ON TABLE de_snp_probe_release TO tm_cz;


--
-- Name: de_snp_probe_sort_def_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_snp_probe_sort_def_release FROM PUBLIC;
REVOKE ALL ON TABLE de_snp_probe_sort_def_release FROM tm_cz;
GRANT ALL ON TABLE de_snp_probe_sort_def_release TO tm_cz;


--
-- Name: de_subj_protein_data_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_subj_protein_data_release FROM PUBLIC;
REVOKE ALL ON TABLE de_subj_protein_data_release FROM tm_cz;
GRANT ALL ON TABLE de_subj_protein_data_release TO tm_cz;


--
-- Name: de_subj_sample_map_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_subj_sample_map_release FROM PUBLIC;
REVOKE ALL ON TABLE de_subj_sample_map_release FROM tm_cz;
GRANT ALL ON TABLE de_subj_sample_map_release TO tm_cz;


--
-- Name: de_subject_mrna_data_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_subject_mrna_data_release FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_mrna_data_release FROM tm_cz;
GRANT ALL ON TABLE de_subject_mrna_data_release TO tm_cz;


--
-- Name: de_subject_rbm_data_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE de_subject_rbm_data_release FROM PUBLIC;
REVOKE ALL ON TABLE de_subject_rbm_data_release FROM tm_cz;
GRANT ALL ON TABLE de_subject_rbm_data_release TO tm_cz;


--
-- Name: dk1; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE dk1 FROM PUBLIC;
REVOKE ALL ON TABLE dk1 FROM tm_cz;
GRANT ALL ON TABLE dk1 TO tm_cz;


--
-- Name: emt_temp_seq; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE emt_temp_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE emt_temp_seq FROM tm_cz;
GRANT ALL ON SEQUENCE emt_temp_seq TO tm_cz;


--
-- Name: gplid; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE gplid FROM PUBLIC;
REVOKE ALL ON TABLE gplid FROM tm_cz;
GRANT ALL ON TABLE gplid TO tm_cz;


--
-- Name: haploview_data_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE haploview_data_release FROM PUBLIC;
REVOKE ALL ON TABLE haploview_data_release FROM tm_cz;
GRANT ALL ON TABLE haploview_data_release TO tm_cz;


--
-- Name: i2b2_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE i2b2_release FROM PUBLIC;
REVOKE ALL ON TABLE i2b2_release FROM tm_cz;
GRANT ALL ON TABLE i2b2_release TO tm_cz;


--
-- Name: i2b2_tags_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE i2b2_tags_release FROM PUBLIC;
REVOKE ALL ON TABLE i2b2_tags_release FROM tm_cz;
GRANT ALL ON TABLE i2b2_tags_release TO tm_cz;


--
-- Name: last_test_detail_view; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE last_test_detail_view FROM PUBLIC;
REVOKE ALL ON TABLE last_test_detail_view FROM tm_cz;
GRANT ALL ON TABLE last_test_detail_view TO tm_cz;


--
-- Name: last_test_summary_view; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE last_test_summary_view FROM PUBLIC;
REVOKE ALL ON TABLE last_test_summary_view FROM tm_cz;
GRANT ALL ON TABLE last_test_summary_view TO tm_cz;


--
-- Name: migrate_tables; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE migrate_tables FROM PUBLIC;
REVOKE ALL ON TABLE migrate_tables FROM tm_cz;
GRANT ALL ON TABLE migrate_tables TO tm_cz;


--
-- Name: mirna_annotation_deapp; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE mirna_annotation_deapp FROM PUBLIC;
REVOKE ALL ON TABLE mirna_annotation_deapp FROM tm_cz;
GRANT ALL ON TABLE mirna_annotation_deapp TO tm_cz;


--
-- Name: seq_probeset_id; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_probeset_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_probeset_id FROM tm_cz;
GRANT ALL ON SEQUENCE seq_probeset_id TO tm_cz;


--
-- Name: mirna_probeset_deapp; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE mirna_probeset_deapp FROM PUBLIC;
REVOKE ALL ON TABLE mirna_probeset_deapp FROM tm_cz;
GRANT ALL ON TABLE mirna_probeset_deapp TO tm_cz;


--
-- Name: node_curation; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE node_curation FROM PUBLIC;
REVOKE ALL ON TABLE node_curation FROM tm_cz;
GRANT ALL ON TABLE node_curation TO tm_cz;


--
-- Name: observation_fact_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE observation_fact_release FROM PUBLIC;
REVOKE ALL ON TABLE observation_fact_release FROM tm_cz;
GRANT ALL ON TABLE observation_fact_release TO tm_cz;


--
-- Name: patient_dimension_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE patient_dimension_release FROM PUBLIC;
REVOKE ALL ON TABLE patient_dimension_release FROM tm_cz;
GRANT ALL ON TABLE patient_dimension_release TO tm_cz;


--
-- Name: probeset_deapp; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE probeset_deapp FROM PUBLIC;
REVOKE ALL ON TABLE probeset_deapp FROM tm_cz;
GRANT ALL ON TABLE probeset_deapp TO tm_cz;


--
-- Name: probeset_deapp_20120206; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE probeset_deapp_20120206 FROM PUBLIC;
REVOKE ALL ON TABLE probeset_deapp_20120206 FROM tm_cz;
GRANT ALL ON TABLE probeset_deapp_20120206 TO tm_cz;


--
-- Name: rtqalimits_testid_seq; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE rtqalimits_testid_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE rtqalimits_testid_seq FROM tm_cz;
GRANT ALL ON SEQUENCE rtqalimits_testid_seq TO tm_cz;


--
-- Name: rtqastatslist_testid_seq; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE rtqastatslist_testid_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE rtqastatslist_testid_seq FROM tm_cz;
GRANT ALL ON SEQUENCE rtqastatslist_testid_seq TO tm_cz;


--
-- Name: sample_categories_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE sample_categories_release FROM PUBLIC;
REVOKE ALL ON TABLE sample_categories_release FROM tm_cz;
GRANT ALL ON TABLE sample_categories_release TO tm_cz;


--
-- Name: search_secure_object_release; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE search_secure_object_release FROM PUBLIC;
REVOKE ALL ON TABLE search_secure_object_release FROM tm_cz;
GRANT ALL ON TABLE search_secure_object_release TO tm_cz;


--
-- Name: seq_antigen_id; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_antigen_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_antigen_id FROM tm_cz;
GRANT ALL ON SEQUENCE seq_antigen_id TO tm_cz;


--
-- Name: seq_child_rollup_id; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_child_rollup_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_child_rollup_id FROM tm_cz;
GRANT ALL ON SEQUENCE seq_child_rollup_id TO tm_cz;


--
-- Name: seq_cz; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_cz FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_cz FROM tm_cz;
GRANT ALL ON SEQUENCE seq_cz TO tm_cz;


--
-- Name: seq_cz_data; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_cz_data FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_cz_data FROM tm_cz;
GRANT ALL ON SEQUENCE seq_cz_data TO tm_cz;


--
-- Name: seq_cz_data_file; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_cz_data_file FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_cz_data_file FROM tm_cz;
GRANT ALL ON SEQUENCE seq_cz_data_file TO tm_cz;


--
-- Name: seq_cz_dw_version_id; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_cz_dw_version_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_cz_dw_version_id FROM tm_cz;
GRANT ALL ON SEQUENCE seq_cz_dw_version_id TO tm_cz;


--
-- Name: seq_cz_job_audit; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_cz_job_audit FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_cz_job_audit FROM tm_cz;
GRANT ALL ON SEQUENCE seq_cz_job_audit TO tm_cz;


--
-- Name: seq_cz_job_id; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_cz_job_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_cz_job_id FROM tm_cz;
GRANT ALL ON SEQUENCE seq_cz_job_id TO tm_cz;


--
-- Name: seq_cz_job_master; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_cz_job_master FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_cz_job_master FROM tm_cz;
GRANT ALL ON SEQUENCE seq_cz_job_master TO tm_cz;


--
-- Name: seq_cz_job_message; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_cz_job_message FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_cz_job_message FROM tm_cz;
GRANT ALL ON SEQUENCE seq_cz_job_message TO tm_cz;


--
-- Name: seq_cz_person_id; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_cz_person_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_cz_person_id FROM tm_cz;
GRANT ALL ON SEQUENCE seq_cz_person_id TO tm_cz;


--
-- Name: seq_cz_test; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_cz_test FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_cz_test FROM tm_cz;
GRANT ALL ON SEQUENCE seq_cz_test TO tm_cz;


--
-- Name: seq_cz_test_category; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_cz_test_category FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_cz_test_category FROM tm_cz;
GRANT ALL ON SEQUENCE seq_cz_test_category TO tm_cz;


--
-- Name: seq_form_layout_id; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_form_layout_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_form_layout_id FROM tm_cz;
GRANT ALL ON SEQUENCE seq_form_layout_id TO tm_cz;


--
-- Name: seq_region_id; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON SEQUENCE seq_region_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_region_id FROM tm_cz;
GRANT ALL ON SEQUENCE seq_region_id TO tm_cz;


--
-- Name: tmp_num_data_types; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE tmp_num_data_types FROM PUBLIC;
REVOKE ALL ON TABLE tmp_num_data_types FROM tm_cz;
GRANT ALL ON TABLE tmp_num_data_types TO tm_cz;


--
-- Name: tmp_subject_info; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE tmp_subject_info FROM PUBLIC;
REVOKE ALL ON TABLE tmp_subject_info FROM tm_cz;
GRANT ALL ON TABLE tmp_subject_info TO tm_cz;


--
-- Name: tmp_trial_data; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE tmp_trial_data FROM PUBLIC;
REVOKE ALL ON TABLE tmp_trial_data FROM tm_cz;
GRANT ALL ON TABLE tmp_trial_data TO tm_cz;


--
-- Name: tmp_trial_nodes; Type: ACL; Schema: tm_cz; Owner: tm_cz
--

REVOKE ALL ON TABLE tmp_trial_nodes FROM PUBLIC;
REVOKE ALL ON TABLE tmp_trial_nodes FROM tm_cz;
GRANT ALL ON TABLE tmp_trial_nodes TO tm_cz;


SET search_path = tm_dataloader, pg_catalog;

--
-- Name: lt_snp_calls_by_gsm; Type: ACL; Schema: tm_dataloader; Owner: tm_dataloader
--

REVOKE ALL ON TABLE lt_snp_calls_by_gsm FROM PUBLIC;
REVOKE ALL ON TABLE lt_snp_calls_by_gsm FROM tm_dataloader;
GRANT ALL ON TABLE lt_snp_calls_by_gsm TO tm_dataloader;


--
-- Name: lt_snp_copy_number; Type: ACL; Schema: tm_dataloader; Owner: tm_dataloader
--

REVOKE ALL ON TABLE lt_snp_copy_number FROM PUBLIC;
REVOKE ALL ON TABLE lt_snp_copy_number FROM tm_dataloader;
GRANT ALL ON TABLE lt_snp_copy_number TO tm_dataloader;


--
-- Name: lt_snp_gene_map; Type: ACL; Schema: tm_dataloader; Owner: tm_dataloader
--

REVOKE ALL ON TABLE lt_snp_gene_map FROM PUBLIC;
REVOKE ALL ON TABLE lt_snp_gene_map FROM tm_dataloader;
GRANT ALL ON TABLE lt_snp_gene_map TO tm_dataloader;


--
-- Name: lt_src_clinical_data; Type: ACL; Schema: tm_dataloader; Owner: weymouth
--

REVOKE ALL ON TABLE lt_src_clinical_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_clinical_data FROM weymouth;
GRANT ALL ON TABLE lt_src_clinical_data TO weymouth;
GRANT SELECT,INSERT,DELETE,TRUNCATE ON TABLE lt_src_clinical_data TO tm_dataloader;


--
-- Name: lt_src_deapp_annot; Type: ACL; Schema: tm_dataloader; Owner: weymouth
--

REVOKE ALL ON TABLE lt_src_deapp_annot FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_deapp_annot FROM weymouth;
GRANT ALL ON TABLE lt_src_deapp_annot TO weymouth;
GRANT SELECT,INSERT,DELETE,TRUNCATE ON TABLE lt_src_deapp_annot TO tm_dataloader;


--
-- Name: lt_src_mrna_data; Type: ACL; Schema: tm_dataloader; Owner: weymouth
--

REVOKE ALL ON TABLE lt_src_mrna_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_mrna_data FROM weymouth;
GRANT ALL ON TABLE lt_src_mrna_data TO weymouth;
GRANT SELECT,INSERT,DELETE,TRUNCATE ON TABLE lt_src_mrna_data TO tm_dataloader;


--
-- Name: lt_src_mrna_subj_samp_map; Type: ACL; Schema: tm_dataloader; Owner: weymouth
--

REVOKE ALL ON TABLE lt_src_mrna_subj_samp_map FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_mrna_subj_samp_map FROM weymouth;
GRANT ALL ON TABLE lt_src_mrna_subj_samp_map TO weymouth;
GRANT SELECT,INSERT,DELETE,TRUNCATE ON TABLE lt_src_mrna_subj_samp_map TO tm_dataloader;


SET search_path = tm_lz, pg_catalog;

--
-- Name: clinical_trial_metadata_ext; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE clinical_trial_metadata_ext FROM PUBLIC;
REVOKE ALL ON TABLE clinical_trial_metadata_ext FROM tm_lz;
GRANT ALL ON TABLE clinical_trial_metadata_ext TO tm_lz;
GRANT ALL ON TABLE clinical_trial_metadata_ext TO tm_cz;


--
-- Name: lt_chromo_region_id_seq; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON SEQUENCE lt_chromo_region_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE lt_chromo_region_id_seq FROM tm_lz;
GRANT ALL ON SEQUENCE lt_chromo_region_id_seq TO tm_lz;
GRANT ALL ON SEQUENCE lt_chromo_region_id_seq TO tm_cz;


--
-- Name: lt_chromosomal_region; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_chromosomal_region FROM PUBLIC;
REVOKE ALL ON TABLE lt_chromosomal_region FROM tm_lz;
GRANT ALL ON TABLE lt_chromosomal_region TO tm_lz;
GRANT ALL ON TABLE lt_chromosomal_region TO tm_cz;


--
-- Name: lt_metabolomic_annotation; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_metabolomic_annotation FROM PUBLIC;
REVOKE ALL ON TABLE lt_metabolomic_annotation FROM tm_lz;
GRANT ALL ON TABLE lt_metabolomic_annotation TO tm_lz;
GRANT ALL ON TABLE lt_metabolomic_annotation TO tm_cz;


--
-- Name: lt_metabolomic_display_mapping; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_metabolomic_display_mapping FROM PUBLIC;
REVOKE ALL ON TABLE lt_metabolomic_display_mapping FROM tm_lz;
GRANT ALL ON TABLE lt_metabolomic_display_mapping TO tm_lz;
GRANT ALL ON TABLE lt_metabolomic_display_mapping TO tm_cz;


--
-- Name: lt_protein_annotation; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_protein_annotation FROM PUBLIC;
REVOKE ALL ON TABLE lt_protein_annotation FROM tm_lz;
GRANT ALL ON TABLE lt_protein_annotation TO tm_lz;
GRANT ALL ON TABLE lt_protein_annotation TO tm_cz;


--
-- Name: lt_qpcr_mirna_annotation; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_qpcr_mirna_annotation FROM PUBLIC;
REVOKE ALL ON TABLE lt_qpcr_mirna_annotation FROM tm_lz;
GRANT ALL ON TABLE lt_qpcr_mirna_annotation TO tm_lz;
GRANT ALL ON TABLE lt_qpcr_mirna_annotation TO tm_cz;


--
-- Name: lt_rnaseq_annotation; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_rnaseq_annotation FROM PUBLIC;
REVOKE ALL ON TABLE lt_rnaseq_annotation FROM tm_lz;
GRANT ALL ON TABLE lt_rnaseq_annotation TO tm_lz;
GRANT ALL ON TABLE lt_rnaseq_annotation TO tm_cz;


--
-- Name: lt_snp_calls_by_gsm; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_snp_calls_by_gsm FROM PUBLIC;
REVOKE ALL ON TABLE lt_snp_calls_by_gsm FROM tm_lz;
GRANT ALL ON TABLE lt_snp_calls_by_gsm TO tm_lz;
GRANT ALL ON TABLE lt_snp_calls_by_gsm TO tm_cz;


--
-- Name: lt_snp_copy_number; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_snp_copy_number FROM PUBLIC;
REVOKE ALL ON TABLE lt_snp_copy_number FROM tm_lz;
GRANT ALL ON TABLE lt_snp_copy_number TO tm_lz;
GRANT ALL ON TABLE lt_snp_copy_number TO tm_cz;


--
-- Name: lt_snp_gene_map; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_snp_gene_map FROM PUBLIC;
REVOKE ALL ON TABLE lt_snp_gene_map FROM tm_lz;
GRANT ALL ON TABLE lt_snp_gene_map TO tm_lz;
GRANT ALL ON TABLE lt_snp_gene_map TO tm_cz;


--
-- Name: lt_src_acgh_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_acgh_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_acgh_data FROM tm_lz;
GRANT ALL ON TABLE lt_src_acgh_data TO tm_lz;
GRANT ALL ON TABLE lt_src_acgh_data TO tm_cz;


--
-- Name: lt_src_cel_files; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_cel_files FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_cel_files FROM tm_lz;
GRANT ALL ON TABLE lt_src_cel_files TO tm_lz;
GRANT ALL ON TABLE lt_src_cel_files TO tm_cz;


--
-- Name: lt_src_clinical_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_clinical_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_clinical_data FROM tm_lz;
GRANT ALL ON TABLE lt_src_clinical_data TO tm_lz;
GRANT ALL ON TABLE lt_src_clinical_data TO tm_cz;


--
-- Name: lt_src_data_metadata; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_data_metadata FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_data_metadata FROM tm_lz;
GRANT ALL ON TABLE lt_src_data_metadata TO tm_lz;
GRANT ALL ON TABLE lt_src_data_metadata TO tm_cz;


--
-- Name: lt_src_deapp_annot; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_deapp_annot FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_deapp_annot FROM tm_lz;
GRANT ALL ON TABLE lt_src_deapp_annot TO tm_lz;
GRANT ALL ON TABLE lt_src_deapp_annot TO tm_cz;


--
-- Name: lt_src_display_mapping; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_display_mapping FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_display_mapping FROM tm_lz;
GRANT ALL ON TABLE lt_src_display_mapping TO tm_lz;
GRANT ALL ON TABLE lt_src_display_mapping TO tm_cz;


--
-- Name: lt_src_metabolomic_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_metabolomic_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_metabolomic_data FROM tm_lz;
GRANT ALL ON TABLE lt_src_metabolomic_data TO tm_lz;
GRANT ALL ON TABLE lt_src_metabolomic_data TO tm_cz;


--
-- Name: lt_src_metabolomic_map; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_metabolomic_map FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_metabolomic_map FROM tm_lz;
GRANT ALL ON TABLE lt_src_metabolomic_map TO tm_lz;
GRANT ALL ON TABLE lt_src_metabolomic_map TO tm_cz;


--
-- Name: lt_src_metabolomics_display_mapping; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_metabolomics_display_mapping FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_metabolomics_display_mapping FROM tm_lz;
GRANT ALL ON TABLE lt_src_metabolomics_display_mapping TO tm_lz;
GRANT ALL ON TABLE lt_src_metabolomics_display_mapping TO tm_cz;


--
-- Name: lt_src_mirna_deapp_annot; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_mirna_deapp_annot FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_mirna_deapp_annot FROM tm_lz;
GRANT ALL ON TABLE lt_src_mirna_deapp_annot TO tm_lz;
GRANT ALL ON TABLE lt_src_mirna_deapp_annot TO tm_cz;


--
-- Name: lt_src_mirna_display_mapping; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_mirna_display_mapping FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_mirna_display_mapping FROM tm_lz;
GRANT ALL ON TABLE lt_src_mirna_display_mapping TO tm_lz;
GRANT ALL ON TABLE lt_src_mirna_display_mapping TO tm_cz;


--
-- Name: lt_src_mirna_subj_samp_map; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_mirna_subj_samp_map FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_mirna_subj_samp_map FROM tm_lz;
GRANT ALL ON TABLE lt_src_mirna_subj_samp_map TO tm_lz;
GRANT ALL ON TABLE lt_src_mirna_subj_samp_map TO tm_cz;


--
-- Name: lt_src_mrna_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_mrna_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_mrna_data FROM tm_lz;
GRANT ALL ON TABLE lt_src_mrna_data TO tm_lz;
GRANT ALL ON TABLE lt_src_mrna_data TO tm_cz;


--
-- Name: lt_src_mrna_subj_samp_map; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_mrna_subj_samp_map FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_mrna_subj_samp_map FROM tm_lz;
GRANT ALL ON TABLE lt_src_mrna_subj_samp_map TO tm_lz;
GRANT ALL ON TABLE lt_src_mrna_subj_samp_map TO tm_cz;


--
-- Name: lt_src_nextbio; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_nextbio FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_nextbio FROM tm_lz;
GRANT ALL ON TABLE lt_src_nextbio TO tm_lz;
GRANT ALL ON TABLE lt_src_nextbio TO tm_cz;


--
-- Name: lt_src_omicsoft_annot; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_omicsoft_annot FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_omicsoft_annot FROM tm_lz;
GRANT ALL ON TABLE lt_src_omicsoft_annot TO tm_lz;
GRANT ALL ON TABLE lt_src_omicsoft_annot TO tm_cz;


--
-- Name: lt_src_omicsoft_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_omicsoft_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_omicsoft_data FROM tm_lz;
GRANT ALL ON TABLE lt_src_omicsoft_data TO tm_lz;
GRANT ALL ON TABLE lt_src_omicsoft_data TO tm_cz;


--
-- Name: lt_src_pathway; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_pathway FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_pathway FROM tm_lz;
GRANT ALL ON TABLE lt_src_pathway TO tm_lz;
GRANT ALL ON TABLE lt_src_pathway TO tm_cz;


--
-- Name: lt_src_pathway_org; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_pathway_org FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_pathway_org FROM tm_lz;
GRANT ALL ON TABLE lt_src_pathway_org TO tm_lz;
GRANT ALL ON TABLE lt_src_pathway_org TO tm_cz;


--
-- Name: lt_src_protein_display_mapping; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_protein_display_mapping FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_protein_display_mapping FROM tm_lz;
GRANT ALL ON TABLE lt_src_protein_display_mapping TO tm_lz;
GRANT ALL ON TABLE lt_src_protein_display_mapping TO tm_cz;


--
-- Name: lt_src_proteomics_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_proteomics_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_proteomics_data FROM tm_lz;
GRANT ALL ON TABLE lt_src_proteomics_data TO tm_lz;
GRANT ALL ON TABLE lt_src_proteomics_data TO tm_cz;


--
-- Name: lt_src_proteomics_sub_sam_map; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_proteomics_sub_sam_map FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_proteomics_sub_sam_map FROM tm_lz;
GRANT ALL ON TABLE lt_src_proteomics_sub_sam_map TO tm_lz;
GRANT ALL ON TABLE lt_src_proteomics_sub_sam_map TO tm_cz;


--
-- Name: lt_src_qpcr_mirna_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_qpcr_mirna_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_qpcr_mirna_data FROM tm_lz;
GRANT ALL ON TABLE lt_src_qpcr_mirna_data TO tm_lz;
GRANT ALL ON TABLE lt_src_qpcr_mirna_data TO tm_cz;


--
-- Name: lt_src_rbm_annotation; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_rbm_annotation FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_rbm_annotation FROM tm_lz;
GRANT ALL ON TABLE lt_src_rbm_annotation TO tm_lz;
GRANT ALL ON TABLE lt_src_rbm_annotation TO tm_cz;


--
-- Name: lt_src_rbm_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_rbm_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_rbm_data FROM tm_lz;
GRANT ALL ON TABLE lt_src_rbm_data TO tm_lz;
GRANT ALL ON TABLE lt_src_rbm_data TO tm_cz;


--
-- Name: lt_src_rbm_display_mapping; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_rbm_display_mapping FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_rbm_display_mapping FROM tm_lz;
GRANT ALL ON TABLE lt_src_rbm_display_mapping TO tm_lz;
GRANT ALL ON TABLE lt_src_rbm_display_mapping TO tm_cz;


--
-- Name: lt_src_rbm_subj_samp_map; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_rbm_subj_samp_map FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_rbm_subj_samp_map FROM tm_lz;
GRANT ALL ON TABLE lt_src_rbm_subj_samp_map TO tm_lz;
GRANT ALL ON TABLE lt_src_rbm_subj_samp_map TO tm_cz;


--
-- Name: lt_src_rna_display_mapping; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_rna_display_mapping FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_rna_display_mapping FROM tm_lz;
GRANT ALL ON TABLE lt_src_rna_display_mapping TO tm_lz;
GRANT ALL ON TABLE lt_src_rna_display_mapping TO tm_cz;


--
-- Name: lt_src_rna_seq_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_rna_seq_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_rna_seq_data FROM tm_lz;
GRANT ALL ON TABLE lt_src_rna_seq_data TO tm_lz;
GRANT ALL ON TABLE lt_src_rna_seq_data TO tm_cz;


--
-- Name: lt_src_rna_seq_subj_samp_map; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_rna_seq_subj_samp_map FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_rna_seq_subj_samp_map FROM tm_lz;
GRANT ALL ON TABLE lt_src_rna_seq_subj_samp_map TO tm_lz;
GRANT ALL ON TABLE lt_src_rna_seq_subj_samp_map TO tm_cz;


--
-- Name: lt_src_rnaseq_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_rnaseq_data FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_rnaseq_data FROM tm_lz;
GRANT ALL ON TABLE lt_src_rnaseq_data TO tm_lz;
GRANT ALL ON TABLE lt_src_rnaseq_data TO tm_cz;


--
-- Name: lt_src_sample_categories; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_sample_categories FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_sample_categories FROM tm_lz;
GRANT ALL ON TABLE lt_src_sample_categories TO tm_lz;
GRANT ALL ON TABLE lt_src_sample_categories TO tm_cz;


--
-- Name: lt_src_search_keyword; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_search_keyword FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_search_keyword FROM tm_lz;
GRANT ALL ON TABLE lt_src_search_keyword TO tm_lz;
GRANT ALL ON TABLE lt_src_search_keyword TO tm_cz;


--
-- Name: lt_src_study_metadata; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_study_metadata FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_study_metadata FROM tm_lz;
GRANT ALL ON TABLE lt_src_study_metadata TO tm_lz;
GRANT ALL ON TABLE lt_src_study_metadata TO tm_cz;


--
-- Name: lt_src_study_metadata_ad_hoc; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_study_metadata_ad_hoc FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_study_metadata_ad_hoc FROM tm_lz;
GRANT ALL ON TABLE lt_src_study_metadata_ad_hoc TO tm_lz;
GRANT ALL ON TABLE lt_src_study_metadata_ad_hoc TO tm_cz;


--
-- Name: lt_src_subj_enroll_date; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lt_src_subj_enroll_date FROM PUBLIC;
REVOKE ALL ON TABLE lt_src_subj_enroll_date FROM tm_lz;
GRANT ALL ON TABLE lt_src_subj_enroll_date TO tm_lz;
GRANT ALL ON TABLE lt_src_subj_enroll_date TO tm_cz;


--
-- Name: lz_src_analysis_metadata; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lz_src_analysis_metadata FROM PUBLIC;
REVOKE ALL ON TABLE lz_src_analysis_metadata FROM tm_lz;
GRANT ALL ON TABLE lz_src_analysis_metadata TO tm_lz;
GRANT ALL ON TABLE lz_src_analysis_metadata TO tm_cz;


--
-- Name: lz_src_clinical_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lz_src_clinical_data FROM PUBLIC;
REVOKE ALL ON TABLE lz_src_clinical_data FROM tm_lz;
GRANT ALL ON TABLE lz_src_clinical_data TO tm_lz;
GRANT ALL ON TABLE lz_src_clinical_data TO tm_cz;


--
-- Name: lz_src_mrna_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lz_src_mrna_data FROM PUBLIC;
REVOKE ALL ON TABLE lz_src_mrna_data FROM tm_lz;
GRANT ALL ON TABLE lz_src_mrna_data TO tm_lz;
GRANT ALL ON TABLE lz_src_mrna_data TO tm_cz;


--
-- Name: lz_src_mrna_subj_samp_map; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lz_src_mrna_subj_samp_map FROM PUBLIC;
REVOKE ALL ON TABLE lz_src_mrna_subj_samp_map FROM tm_lz;
GRANT ALL ON TABLE lz_src_mrna_subj_samp_map TO tm_lz;
GRANT ALL ON TABLE lz_src_mrna_subj_samp_map TO tm_cz;


--
-- Name: lz_src_sample_categories_bkup; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lz_src_sample_categories_bkup FROM PUBLIC;
REVOKE ALL ON TABLE lz_src_sample_categories_bkup FROM tm_lz;
GRANT ALL ON TABLE lz_src_sample_categories_bkup TO tm_lz;
GRANT ALL ON TABLE lz_src_sample_categories_bkup TO tm_cz;


--
-- Name: lz_src_study_metadata; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lz_src_study_metadata FROM PUBLIC;
REVOKE ALL ON TABLE lz_src_study_metadata FROM tm_lz;
GRANT ALL ON TABLE lz_src_study_metadata TO tm_lz;
GRANT ALL ON TABLE lz_src_study_metadata TO tm_cz;


--
-- Name: lz_src_study_metadata_ad_hoc; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lz_src_study_metadata_ad_hoc FROM PUBLIC;
REVOKE ALL ON TABLE lz_src_study_metadata_ad_hoc FROM tm_lz;
GRANT ALL ON TABLE lz_src_study_metadata_ad_hoc TO tm_lz;
GRANT ALL ON TABLE lz_src_study_metadata_ad_hoc TO tm_cz;


--
-- Name: lz_src_subj_enroll_date; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE lz_src_subj_enroll_date FROM PUBLIC;
REVOKE ALL ON TABLE lz_src_subj_enroll_date FROM tm_lz;
GRANT ALL ON TABLE lz_src_subj_enroll_date TO tm_lz;
GRANT ALL ON TABLE lz_src_subj_enroll_date TO tm_cz;


--
-- Name: rwg_analysis; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE rwg_analysis FROM PUBLIC;
REVOKE ALL ON TABLE rwg_analysis FROM tm_lz;
GRANT ALL ON TABLE rwg_analysis TO tm_lz;
GRANT ALL ON TABLE rwg_analysis TO tm_cz;


--
-- Name: rwg_analysis_data; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE rwg_analysis_data FROM PUBLIC;
REVOKE ALL ON TABLE rwg_analysis_data FROM tm_lz;
GRANT ALL ON TABLE rwg_analysis_data TO tm_lz;
GRANT ALL ON TABLE rwg_analysis_data TO tm_cz;


--
-- Name: rwg_analysis_data_ext; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE rwg_analysis_data_ext FROM PUBLIC;
REVOKE ALL ON TABLE rwg_analysis_data_ext FROM tm_lz;
GRANT ALL ON TABLE rwg_analysis_data_ext TO tm_lz;
GRANT ALL ON TABLE rwg_analysis_data_ext TO tm_cz;


--
-- Name: rwg_analysis_ext; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE rwg_analysis_ext FROM PUBLIC;
REVOKE ALL ON TABLE rwg_analysis_ext FROM tm_lz;
GRANT ALL ON TABLE rwg_analysis_ext TO tm_lz;
GRANT ALL ON TABLE rwg_analysis_ext TO tm_cz;


--
-- Name: rwg_cohorts; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE rwg_cohorts FROM PUBLIC;
REVOKE ALL ON TABLE rwg_cohorts FROM tm_lz;
GRANT ALL ON TABLE rwg_cohorts TO tm_lz;
GRANT ALL ON TABLE rwg_cohorts TO tm_cz;


--
-- Name: rwg_cohorts_ext; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE rwg_cohorts_ext FROM PUBLIC;
REVOKE ALL ON TABLE rwg_cohorts_ext FROM tm_lz;
GRANT ALL ON TABLE rwg_cohorts_ext TO tm_lz;
GRANT ALL ON TABLE rwg_cohorts_ext TO tm_cz;


--
-- Name: rwg_samples; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE rwg_samples FROM PUBLIC;
REVOKE ALL ON TABLE rwg_samples FROM tm_lz;
GRANT ALL ON TABLE rwg_samples TO tm_lz;
GRANT ALL ON TABLE rwg_samples TO tm_cz;


--
-- Name: rwg_samples_ext; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE rwg_samples_ext FROM PUBLIC;
REVOKE ALL ON TABLE rwg_samples_ext FROM tm_lz;
GRANT ALL ON TABLE rwg_samples_ext TO tm_lz;
GRANT ALL ON TABLE rwg_samples_ext TO tm_cz;


--
-- Name: seq_etl_id; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON SEQUENCE seq_etl_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE seq_etl_id FROM tm_lz;
GRANT ALL ON SEQUENCE seq_etl_id TO tm_lz;
GRANT ALL ON SEQUENCE seq_etl_id TO tm_cz;


--
-- Name: wt_snp_node_values; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE wt_snp_node_values FROM PUBLIC;
REVOKE ALL ON TABLE wt_snp_node_values FROM tm_lz;
GRANT ALL ON TABLE wt_snp_node_values TO tm_lz;
GRANT ALL ON TABLE wt_snp_node_values TO tm_cz;


--
-- Name: wt_snp_nodes; Type: ACL; Schema: tm_lz; Owner: tm_lz
--

REVOKE ALL ON TABLE wt_snp_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_snp_nodes FROM tm_lz;
GRANT ALL ON TABLE wt_snp_nodes TO tm_lz;
GRANT ALL ON TABLE wt_snp_nodes TO tm_cz;


SET search_path = tm_wz, pg_catalog;

--
-- Name: bio_assay_analysis_data_new; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE bio_assay_analysis_data_new FROM PUBLIC;
REVOKE ALL ON TABLE bio_assay_analysis_data_new FROM tm_wz;
GRANT ALL ON TABLE bio_assay_analysis_data_new TO tm_wz;
GRANT ALL ON TABLE bio_assay_analysis_data_new TO tm_cz;


--
-- Name: tmp_assay_analysis_metrics; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE tmp_assay_analysis_metrics FROM PUBLIC;
REVOKE ALL ON TABLE tmp_assay_analysis_metrics FROM tm_wz;
GRANT ALL ON TABLE tmp_assay_analysis_metrics TO tm_wz;
GRANT ALL ON TABLE tmp_assay_analysis_metrics TO tm_cz;


--
-- Name: wrk_clinical_data; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wrk_clinical_data FROM PUBLIC;
REVOKE ALL ON TABLE wrk_clinical_data FROM tm_wz;
GRANT ALL ON TABLE wrk_clinical_data TO tm_wz;
GRANT ALL ON TABLE wrk_clinical_data TO tm_cz;


--
-- Name: wrk_mrna_data; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wrk_mrna_data FROM PUBLIC;
REVOKE ALL ON TABLE wrk_mrna_data FROM tm_wz;
GRANT ALL ON TABLE wrk_mrna_data TO tm_wz;
GRANT ALL ON TABLE wrk_mrna_data TO tm_cz;


--
-- Name: wt_clinical_data_dups; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_clinical_data_dups FROM PUBLIC;
REVOKE ALL ON TABLE wt_clinical_data_dups FROM tm_wz;
GRANT ALL ON TABLE wt_clinical_data_dups TO tm_wz;
GRANT ALL ON TABLE wt_clinical_data_dups TO tm_cz;


--
-- Name: wt_clinical_encounter; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_clinical_encounter FROM PUBLIC;
REVOKE ALL ON TABLE wt_clinical_encounter FROM tm_wz;
GRANT ALL ON TABLE wt_clinical_encounter TO tm_wz;
GRANT ALL ON TABLE wt_clinical_encounter TO tm_cz;


--
-- Name: wt_del_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_del_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_del_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_del_nodes TO tm_wz;
GRANT ALL ON TABLE wt_del_nodes TO tm_cz;


--
-- Name: wt_folder_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_folder_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_folder_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_folder_nodes TO tm_wz;
GRANT ALL ON TABLE wt_folder_nodes TO tm_cz;


--
-- Name: wt_metabolomic_node_values; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_metabolomic_node_values FROM PUBLIC;
REVOKE ALL ON TABLE wt_metabolomic_node_values FROM tm_wz;
GRANT ALL ON TABLE wt_metabolomic_node_values TO tm_wz;
GRANT ALL ON TABLE wt_metabolomic_node_values TO tm_cz;


--
-- Name: wt_metabolomic_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_metabolomic_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_metabolomic_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_metabolomic_nodes TO tm_wz;
GRANT ALL ON TABLE wt_metabolomic_nodes TO tm_cz;


--
-- Name: wt_mixed_types; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_mixed_types FROM PUBLIC;
REVOKE ALL ON TABLE wt_mixed_types FROM tm_wz;
GRANT ALL ON TABLE wt_mixed_types TO tm_wz;
GRANT ALL ON TABLE wt_mixed_types TO tm_cz;


--
-- Name: wt_mrna_data; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_mrna_data FROM PUBLIC;
REVOKE ALL ON TABLE wt_mrna_data FROM tm_wz;
GRANT ALL ON TABLE wt_mrna_data TO tm_wz;
GRANT ALL ON TABLE wt_mrna_data TO tm_cz;


--
-- Name: wt_mrna_node_values; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_mrna_node_values FROM PUBLIC;
REVOKE ALL ON TABLE wt_mrna_node_values FROM tm_wz;
GRANT ALL ON TABLE wt_mrna_node_values TO tm_wz;
GRANT ALL ON TABLE wt_mrna_node_values TO tm_cz;


--
-- Name: wt_mrna_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_mrna_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_mrna_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_mrna_nodes TO tm_wz;
GRANT ALL ON TABLE wt_mrna_nodes TO tm_cz;


--
-- Name: wt_mrna_subj_sample_map; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_mrna_subj_sample_map FROM PUBLIC;
REVOKE ALL ON TABLE wt_mrna_subj_sample_map FROM tm_wz;
GRANT ALL ON TABLE wt_mrna_subj_sample_map TO tm_wz;
GRANT ALL ON TABLE wt_mrna_subj_sample_map TO tm_cz;


--
-- Name: wt_num_data_types; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_num_data_types FROM PUBLIC;
REVOKE ALL ON TABLE wt_num_data_types FROM tm_wz;
GRANT ALL ON TABLE wt_num_data_types TO tm_wz;
GRANT ALL ON TABLE wt_num_data_types TO tm_cz;


--
-- Name: wt_proteomics_node_values; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_proteomics_node_values FROM PUBLIC;
REVOKE ALL ON TABLE wt_proteomics_node_values FROM tm_wz;
GRANT ALL ON TABLE wt_proteomics_node_values TO tm_wz;
GRANT ALL ON TABLE wt_proteomics_node_values TO tm_cz;


--
-- Name: wt_proteomics_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_proteomics_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_proteomics_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_proteomics_nodes TO tm_wz;
GRANT ALL ON TABLE wt_proteomics_nodes TO tm_cz;


--
-- Name: wt_qpcr_mirna_node_values; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_qpcr_mirna_node_values FROM PUBLIC;
REVOKE ALL ON TABLE wt_qpcr_mirna_node_values FROM tm_wz;
GRANT ALL ON TABLE wt_qpcr_mirna_node_values TO tm_wz;
GRANT ALL ON TABLE wt_qpcr_mirna_node_values TO tm_cz;


--
-- Name: wt_qpcr_mirna_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_qpcr_mirna_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_qpcr_mirna_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_qpcr_mirna_nodes TO tm_wz;
GRANT ALL ON TABLE wt_qpcr_mirna_nodes TO tm_cz;


--
-- Name: wt_rbm_node_values; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_rbm_node_values FROM PUBLIC;
REVOKE ALL ON TABLE wt_rbm_node_values FROM tm_wz;
GRANT ALL ON TABLE wt_rbm_node_values TO tm_wz;
GRANT ALL ON TABLE wt_rbm_node_values TO tm_cz;


--
-- Name: wt_rbm_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_rbm_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_rbm_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_rbm_nodes TO tm_wz;
GRANT ALL ON TABLE wt_rbm_nodes TO tm_cz;


--
-- Name: wt_rna_seq_node_values; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_rna_seq_node_values FROM PUBLIC;
REVOKE ALL ON TABLE wt_rna_seq_node_values FROM tm_wz;
GRANT ALL ON TABLE wt_rna_seq_node_values TO tm_wz;
GRANT ALL ON TABLE wt_rna_seq_node_values TO tm_cz;


--
-- Name: wt_rna_seq_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_rna_seq_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_rna_seq_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_rna_seq_nodes TO tm_wz;
GRANT ALL ON TABLE wt_rna_seq_nodes TO tm_cz;


--
-- Name: wt_subject_acgh_region; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_acgh_region FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_acgh_region FROM tm_wz;
GRANT ALL ON TABLE wt_subject_acgh_region TO tm_wz;
GRANT ALL ON TABLE wt_subject_acgh_region TO tm_cz;


--
-- Name: wt_subject_info; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_info FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_info FROM tm_wz;
GRANT ALL ON TABLE wt_subject_info TO tm_wz;
GRANT ALL ON TABLE wt_subject_info TO tm_cz;


--
-- Name: wt_subject_mbolomics_probeset; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_mbolomics_probeset FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_mbolomics_probeset FROM tm_wz;
GRANT ALL ON TABLE wt_subject_mbolomics_probeset TO tm_wz;
GRANT ALL ON TABLE wt_subject_mbolomics_probeset TO tm_cz;


--
-- Name: wt_subject_metabolomics_calcs; Type: ACL; Schema: tm_wz; Owner: tm_cz
--

REVOKE ALL ON TABLE wt_subject_metabolomics_calcs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_metabolomics_calcs FROM tm_cz;
GRANT ALL ON TABLE wt_subject_metabolomics_calcs TO tm_cz;
GRANT ALL ON TABLE wt_subject_metabolomics_calcs TO tm_wz;


--
-- Name: wt_subject_metabolomics_logs; Type: ACL; Schema: tm_wz; Owner: tm_cz
--

REVOKE ALL ON TABLE wt_subject_metabolomics_logs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_metabolomics_logs FROM tm_cz;
GRANT ALL ON TABLE wt_subject_metabolomics_logs TO tm_cz;
GRANT ALL ON TABLE wt_subject_metabolomics_logs TO tm_wz;


--
-- Name: wt_subject_metabolomics_med; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_metabolomics_med FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_metabolomics_med FROM tm_wz;
GRANT ALL ON TABLE wt_subject_metabolomics_med TO tm_wz;
GRANT ALL ON TABLE wt_subject_metabolomics_med TO tm_cz;


--
-- Name: wt_subject_microarray_calcs; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_microarray_calcs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_microarray_calcs FROM tm_wz;
GRANT ALL ON TABLE wt_subject_microarray_calcs TO tm_wz;
GRANT ALL ON TABLE wt_subject_microarray_calcs TO tm_cz;


--
-- Name: wt_subject_microarray_logs; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_microarray_logs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_microarray_logs FROM tm_wz;
GRANT ALL ON TABLE wt_subject_microarray_logs TO tm_wz;
GRANT ALL ON TABLE wt_subject_microarray_logs TO tm_cz;


--
-- Name: wt_subject_microarray_med; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_microarray_med FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_microarray_med FROM tm_wz;
GRANT ALL ON TABLE wt_subject_microarray_med TO tm_wz;
GRANT ALL ON TABLE wt_subject_microarray_med TO tm_cz;


--
-- Name: wt_subject_mirna_calcs; Type: ACL; Schema: tm_wz; Owner: tm_cz
--

REVOKE ALL ON TABLE wt_subject_mirna_calcs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_mirna_calcs FROM tm_cz;
GRANT ALL ON TABLE wt_subject_mirna_calcs TO tm_cz;
GRANT ALL ON TABLE wt_subject_mirna_calcs TO tm_wz;


--
-- Name: wt_subject_mirna_logs; Type: ACL; Schema: tm_wz; Owner: tm_cz
--

REVOKE ALL ON TABLE wt_subject_mirna_logs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_mirna_logs FROM tm_cz;
GRANT ALL ON TABLE wt_subject_mirna_logs TO tm_cz;
GRANT ALL ON TABLE wt_subject_mirna_logs TO tm_wz;


--
-- Name: wt_subject_mirna_med; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_mirna_med FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_mirna_med FROM tm_wz;
GRANT ALL ON TABLE wt_subject_mirna_med TO tm_wz;
GRANT ALL ON TABLE wt_subject_mirna_med TO tm_cz;


--
-- Name: wt_subject_mirna_probeset; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_mirna_probeset FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_mirna_probeset FROM tm_wz;
GRANT ALL ON TABLE wt_subject_mirna_probeset TO tm_wz;
GRANT ALL ON TABLE wt_subject_mirna_probeset TO tm_cz;


--
-- Name: wt_subject_mrna_data; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_mrna_data FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_mrna_data FROM tm_wz;
GRANT ALL ON TABLE wt_subject_mrna_data TO tm_wz;
GRANT ALL ON TABLE wt_subject_mrna_data TO tm_cz;


--
-- Name: wt_subject_mrna_probeset; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_mrna_probeset FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_mrna_probeset FROM tm_wz;
GRANT ALL ON TABLE wt_subject_mrna_probeset TO tm_wz;
GRANT ALL ON TABLE wt_subject_mrna_probeset TO tm_cz;


--
-- Name: wt_subject_proteomics_calcs; Type: ACL; Schema: tm_wz; Owner: tm_cz
--

REVOKE ALL ON TABLE wt_subject_proteomics_calcs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_proteomics_calcs FROM tm_cz;
GRANT ALL ON TABLE wt_subject_proteomics_calcs TO tm_cz;
GRANT ALL ON TABLE wt_subject_proteomics_calcs TO tm_wz;


--
-- Name: wt_subject_proteomics_logs; Type: ACL; Schema: tm_wz; Owner: tm_cz
--

REVOKE ALL ON TABLE wt_subject_proteomics_logs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_proteomics_logs FROM tm_cz;
GRANT ALL ON TABLE wt_subject_proteomics_logs TO tm_cz;
GRANT ALL ON TABLE wt_subject_proteomics_logs TO tm_wz;


--
-- Name: wt_subject_proteomics_med; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_proteomics_med FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_proteomics_med FROM tm_wz;
GRANT ALL ON TABLE wt_subject_proteomics_med TO tm_wz;
GRANT ALL ON TABLE wt_subject_proteomics_med TO tm_cz;


--
-- Name: wt_subject_proteomics_probeset; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_proteomics_probeset FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_proteomics_probeset FROM tm_wz;
GRANT ALL ON TABLE wt_subject_proteomics_probeset TO tm_wz;
GRANT ALL ON TABLE wt_subject_proteomics_probeset TO tm_cz;


--
-- Name: wt_subject_rbm_calcs; Type: ACL; Schema: tm_wz; Owner: tm_cz
--

REVOKE ALL ON TABLE wt_subject_rbm_calcs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_rbm_calcs FROM tm_cz;
GRANT ALL ON TABLE wt_subject_rbm_calcs TO tm_cz;
GRANT ALL ON TABLE wt_subject_rbm_calcs TO tm_wz;


--
-- Name: wt_subject_rbm_logs; Type: ACL; Schema: tm_wz; Owner: tm_cz
--

REVOKE ALL ON TABLE wt_subject_rbm_logs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_rbm_logs FROM tm_cz;
GRANT ALL ON TABLE wt_subject_rbm_logs TO tm_cz;
GRANT ALL ON TABLE wt_subject_rbm_logs TO tm_wz;


--
-- Name: wt_subject_rbm_med; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_rbm_med FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_rbm_med FROM tm_wz;
GRANT ALL ON TABLE wt_subject_rbm_med TO tm_wz;
GRANT ALL ON TABLE wt_subject_rbm_med TO tm_cz;


--
-- Name: wt_subject_rbm_probeset; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_rbm_probeset FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_rbm_probeset FROM tm_wz;
GRANT ALL ON TABLE wt_subject_rbm_probeset TO tm_wz;
GRANT ALL ON TABLE wt_subject_rbm_probeset TO tm_cz;


--
-- Name: wt_subject_rna_calcs; Type: ACL; Schema: tm_wz; Owner: tm_cz
--

REVOKE ALL ON TABLE wt_subject_rna_calcs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_rna_calcs FROM tm_cz;
GRANT ALL ON TABLE wt_subject_rna_calcs TO tm_cz;
GRANT ALL ON TABLE wt_subject_rna_calcs TO tm_wz;


--
-- Name: wt_subject_rna_logs; Type: ACL; Schema: tm_wz; Owner: tm_cz
--

REVOKE ALL ON TABLE wt_subject_rna_logs FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_rna_logs FROM tm_cz;
GRANT ALL ON TABLE wt_subject_rna_logs TO tm_cz;
GRANT ALL ON TABLE wt_subject_rna_logs TO tm_wz;


--
-- Name: wt_subject_rna_med; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_rna_med FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_rna_med FROM tm_wz;
GRANT ALL ON TABLE wt_subject_rna_med TO tm_wz;
GRANT ALL ON TABLE wt_subject_rna_med TO tm_cz;


--
-- Name: wt_subject_rna_probeset; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_rna_probeset FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_rna_probeset FROM tm_wz;
GRANT ALL ON TABLE wt_subject_rna_probeset TO tm_wz;
GRANT ALL ON TABLE wt_subject_rna_probeset TO tm_cz;


--
-- Name: wt_subject_rnaseq_region; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_rnaseq_region FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_rnaseq_region FROM tm_wz;
GRANT ALL ON TABLE wt_subject_rnaseq_region TO tm_wz;
GRANT ALL ON TABLE wt_subject_rnaseq_region TO tm_cz;


--
-- Name: wt_subject_sample_mapping; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_subject_sample_mapping FROM PUBLIC;
REVOKE ALL ON TABLE wt_subject_sample_mapping FROM tm_wz;
GRANT ALL ON TABLE wt_subject_sample_mapping TO tm_wz;
GRANT ALL ON TABLE wt_subject_sample_mapping TO tm_cz;


--
-- Name: wt_trial_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_trial_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_trial_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_trial_nodes TO tm_wz;
GRANT ALL ON TABLE wt_trial_nodes TO tm_cz;


--
-- Name: wt_vocab_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_vocab_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_vocab_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_vocab_nodes TO tm_wz;
GRANT ALL ON TABLE wt_vocab_nodes TO tm_cz;


--
-- Name: wt_xtrial_nodes; Type: ACL; Schema: tm_wz; Owner: tm_wz
--

REVOKE ALL ON TABLE wt_xtrial_nodes FROM PUBLIC;
REVOKE ALL ON TABLE wt_xtrial_nodes FROM tm_wz;
GRANT ALL ON TABLE wt_xtrial_nodes TO tm_wz;
GRANT ALL ON TABLE wt_xtrial_nodes TO tm_cz;


SET search_path = amapp, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: amapp; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA amapp REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA amapp REVOKE ALL ON SEQUENCES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA amapp GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA amapp GRANT SELECT ON SEQUENCES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: amapp; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA amapp REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA amapp REVOKE ALL ON SEQUENCES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA amapp GRANT SELECT ON SEQUENCES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA amapp GRANT ALL ON SEQUENCES  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: amapp; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA amapp REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA amapp REVOKE ALL ON FUNCTIONS  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA amapp GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA amapp GRANT ALL ON FUNCTIONS  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: amapp; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA amapp REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA amapp REVOKE ALL ON FUNCTIONS  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA amapp GRANT ALL ON FUNCTIONS  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA amapp GRANT ALL ON FUNCTIONS  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: amapp; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA amapp REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA amapp REVOKE ALL ON TABLES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA amapp GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA amapp GRANT SELECT ON TABLES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: amapp; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA amapp REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA amapp REVOKE ALL ON TABLES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA amapp GRANT SELECT ON TABLES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA amapp GRANT ALL ON TABLES  TO tm_cz;


SET search_path = biomart, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: biomart; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart REVOKE ALL ON SEQUENCES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart GRANT SELECT ON SEQUENCES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: biomart; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart REVOKE ALL ON SEQUENCES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart GRANT SELECT ON SEQUENCES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart GRANT ALL ON SEQUENCES  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: biomart; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart REVOKE ALL ON FUNCTIONS  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart GRANT ALL ON FUNCTIONS  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: biomart; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart REVOKE ALL ON FUNCTIONS  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart GRANT ALL ON FUNCTIONS  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart GRANT ALL ON FUNCTIONS  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: biomart; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart REVOKE ALL ON TABLES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart GRANT SELECT ON TABLES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: biomart; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart REVOKE ALL ON TABLES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart GRANT SELECT ON TABLES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart GRANT ALL ON TABLES  TO tm_cz;


SET search_path = biomart_user, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: biomart_user; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart_user REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart_user REVOKE ALL ON SEQUENCES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart_user GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart_user GRANT ALL ON SEQUENCES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: biomart_user; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart_user REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart_user REVOKE ALL ON SEQUENCES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart_user GRANT ALL ON SEQUENCES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart_user GRANT ALL ON SEQUENCES  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: biomart_user; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart_user REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart_user REVOKE ALL ON FUNCTIONS  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart_user GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart_user GRANT ALL ON FUNCTIONS  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: biomart_user; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart_user REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart_user REVOKE ALL ON FUNCTIONS  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart_user GRANT ALL ON FUNCTIONS  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart_user GRANT ALL ON FUNCTIONS  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: biomart_user; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart_user REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart_user REVOKE ALL ON TABLES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart_user GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA biomart_user GRANT ALL ON TABLES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: biomart_user; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart_user REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart_user REVOKE ALL ON TABLES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart_user GRANT ALL ON TABLES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA biomart_user GRANT ALL ON TABLES  TO tm_cz;


SET search_path = deapp, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: deapp; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA deapp REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA deapp REVOKE ALL ON SEQUENCES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA deapp GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA deapp GRANT SELECT ON SEQUENCES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: deapp; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA deapp REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA deapp REVOKE ALL ON SEQUENCES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA deapp GRANT SELECT ON SEQUENCES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA deapp GRANT ALL ON SEQUENCES  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: deapp; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA deapp REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA deapp REVOKE ALL ON FUNCTIONS  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA deapp GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA deapp GRANT ALL ON FUNCTIONS  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: deapp; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA deapp REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA deapp REVOKE ALL ON FUNCTIONS  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA deapp GRANT ALL ON FUNCTIONS  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA deapp GRANT ALL ON FUNCTIONS  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: deapp; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA deapp REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA deapp REVOKE ALL ON TABLES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA deapp GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA deapp GRANT SELECT ON TABLES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: deapp; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA deapp REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA deapp REVOKE ALL ON TABLES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA deapp GRANT SELECT ON TABLES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA deapp GRANT ALL ON TABLES  TO tm_cz;


SET search_path = fmapp, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: fmapp; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA fmapp REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA fmapp REVOKE ALL ON SEQUENCES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA fmapp GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA fmapp GRANT SELECT ON SEQUENCES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: fmapp; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA fmapp REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA fmapp REVOKE ALL ON SEQUENCES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA fmapp GRANT SELECT ON SEQUENCES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA fmapp GRANT ALL ON SEQUENCES  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: fmapp; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA fmapp REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA fmapp REVOKE ALL ON FUNCTIONS  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA fmapp GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA fmapp GRANT ALL ON FUNCTIONS  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: fmapp; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA fmapp REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA fmapp REVOKE ALL ON FUNCTIONS  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA fmapp GRANT ALL ON FUNCTIONS  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA fmapp GRANT ALL ON FUNCTIONS  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: fmapp; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA fmapp REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA fmapp REVOKE ALL ON TABLES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA fmapp GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA fmapp GRANT SELECT ON TABLES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: fmapp; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA fmapp REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA fmapp REVOKE ALL ON TABLES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA fmapp GRANT SELECT ON TABLES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA fmapp GRANT ALL ON TABLES  TO tm_cz;


SET search_path = galaxy, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: galaxy; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA galaxy REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA galaxy REVOKE ALL ON SEQUENCES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA galaxy GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA galaxy GRANT SELECT ON SEQUENCES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: galaxy; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA galaxy REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA galaxy REVOKE ALL ON SEQUENCES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA galaxy GRANT SELECT ON SEQUENCES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA galaxy GRANT ALL ON SEQUENCES  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: galaxy; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA galaxy REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA galaxy REVOKE ALL ON FUNCTIONS  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA galaxy GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA galaxy GRANT ALL ON FUNCTIONS  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: galaxy; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA galaxy REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA galaxy REVOKE ALL ON FUNCTIONS  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA galaxy GRANT ALL ON FUNCTIONS  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA galaxy GRANT ALL ON FUNCTIONS  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: galaxy; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA galaxy REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA galaxy REVOKE ALL ON TABLES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA galaxy GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA galaxy GRANT SELECT ON TABLES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: galaxy; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA galaxy REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA galaxy REVOKE ALL ON TABLES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA galaxy GRANT SELECT ON TABLES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA galaxy GRANT ALL ON TABLES  TO tm_cz;


SET search_path = i2b2demodata, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: i2b2demodata; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2demodata REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2demodata REVOKE ALL ON SEQUENCES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2demodata GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2demodata GRANT SELECT ON SEQUENCES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: i2b2demodata; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2demodata REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2demodata REVOKE ALL ON SEQUENCES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2demodata GRANT SELECT ON SEQUENCES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2demodata GRANT ALL ON SEQUENCES  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: i2b2demodata; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2demodata REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2demodata REVOKE ALL ON FUNCTIONS  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2demodata GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2demodata GRANT ALL ON FUNCTIONS  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: i2b2demodata; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2demodata REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2demodata REVOKE ALL ON FUNCTIONS  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2demodata GRANT ALL ON FUNCTIONS  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2demodata GRANT ALL ON FUNCTIONS  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: i2b2demodata; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2demodata REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2demodata REVOKE ALL ON TABLES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2demodata GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2demodata GRANT SELECT ON TABLES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: i2b2demodata; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2demodata REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2demodata REVOKE ALL ON TABLES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2demodata GRANT SELECT ON TABLES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2demodata GRANT ALL ON TABLES  TO tm_cz;


SET search_path = i2b2metadata, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: i2b2metadata; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2metadata REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2metadata REVOKE ALL ON SEQUENCES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2metadata GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2metadata GRANT SELECT ON SEQUENCES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: i2b2metadata; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2metadata REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2metadata REVOKE ALL ON SEQUENCES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2metadata GRANT SELECT ON SEQUENCES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2metadata GRANT ALL ON SEQUENCES  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: i2b2metadata; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2metadata REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2metadata REVOKE ALL ON FUNCTIONS  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2metadata GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2metadata GRANT ALL ON FUNCTIONS  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: i2b2metadata; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2metadata REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2metadata REVOKE ALL ON FUNCTIONS  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2metadata GRANT ALL ON FUNCTIONS  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2metadata GRANT ALL ON FUNCTIONS  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: i2b2metadata; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2metadata REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2metadata REVOKE ALL ON TABLES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2metadata GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA i2b2metadata GRANT SELECT ON TABLES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: i2b2metadata; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2metadata REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2metadata REVOKE ALL ON TABLES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2metadata GRANT SELECT ON TABLES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA i2b2metadata GRANT ALL ON TABLES  TO tm_cz;


SET search_path = searchapp, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: searchapp; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA searchapp REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA searchapp REVOKE ALL ON SEQUENCES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA searchapp GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA searchapp GRANT USAGE ON SEQUENCES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: searchapp; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA searchapp REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA searchapp REVOKE ALL ON SEQUENCES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA searchapp GRANT USAGE ON SEQUENCES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA searchapp GRANT ALL ON SEQUENCES  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: searchapp; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA searchapp REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA searchapp REVOKE ALL ON FUNCTIONS  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA searchapp GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA searchapp GRANT ALL ON FUNCTIONS  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: searchapp; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA searchapp REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA searchapp REVOKE ALL ON FUNCTIONS  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA searchapp GRANT ALL ON FUNCTIONS  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA searchapp GRANT ALL ON FUNCTIONS  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: searchapp; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA searchapp REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA searchapp REVOKE ALL ON TABLES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA searchapp GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA searchapp GRANT SELECT,INSERT,DELETE,UPDATE ON TABLES  TO biomart_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: searchapp; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA searchapp REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA searchapp REVOKE ALL ON TABLES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA searchapp GRANT SELECT,INSERT,DELETE,UPDATE ON TABLES  TO biomart_user;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA searchapp GRANT ALL ON TABLES  TO tm_cz;


SET search_path = tm_cz, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: tm_cz; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_cz REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_cz REVOKE ALL ON SEQUENCES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_cz GRANT ALL ON SEQUENCES  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: tm_cz; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_cz REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_cz REVOKE ALL ON SEQUENCES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_cz GRANT ALL ON SEQUENCES  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: tm_cz; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_cz REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_cz REVOKE ALL ON FUNCTIONS  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_cz GRANT ALL ON FUNCTIONS  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: tm_cz; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_cz REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_cz REVOKE ALL ON FUNCTIONS  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_cz GRANT ALL ON FUNCTIONS  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: tm_cz; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_cz REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_cz REVOKE ALL ON TABLES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_cz GRANT ALL ON TABLES  TO tm_cz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: tm_cz; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_cz REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_cz REVOKE ALL ON TABLES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_cz GRANT ALL ON TABLES  TO tm_cz;


SET search_path = tm_lz, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: tm_lz; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_lz REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_lz REVOKE ALL ON SEQUENCES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_lz GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_lz GRANT ALL ON SEQUENCES  TO tm_lz;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: tm_lz; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_lz REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_lz REVOKE ALL ON SEQUENCES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_lz GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_lz GRANT ALL ON SEQUENCES  TO tm_lz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: tm_lz; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_lz REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_lz REVOKE ALL ON FUNCTIONS  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_lz GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_lz GRANT ALL ON FUNCTIONS  TO tm_lz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: tm_lz; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_lz REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_lz REVOKE ALL ON FUNCTIONS  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_lz GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_lz GRANT ALL ON FUNCTIONS  TO tm_lz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: tm_lz; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_lz REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_lz REVOKE ALL ON TABLES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_lz GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_lz GRANT ALL ON TABLES  TO tm_lz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: tm_lz; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_lz REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_lz REVOKE ALL ON TABLES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_lz GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_lz GRANT ALL ON TABLES  TO tm_lz;


SET search_path = tm_wz, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: tm_wz; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_wz REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_wz REVOKE ALL ON SEQUENCES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_wz GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_wz GRANT ALL ON SEQUENCES  TO tm_wz;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: tm_wz; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_wz REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_wz REVOKE ALL ON SEQUENCES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_wz GRANT ALL ON SEQUENCES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_wz GRANT ALL ON SEQUENCES  TO tm_wz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: tm_wz; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_wz REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_wz REVOKE ALL ON FUNCTIONS  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_wz GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_wz GRANT ALL ON FUNCTIONS  TO tm_wz;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: tm_wz; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_wz REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_wz REVOKE ALL ON FUNCTIONS  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_wz GRANT ALL ON FUNCTIONS  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_wz GRANT ALL ON FUNCTIONS  TO tm_wz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: tm_wz; Owner: tm_cz
--

ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_wz REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_wz REVOKE ALL ON TABLES  FROM tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_wz GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE tm_cz IN SCHEMA tm_wz GRANT ALL ON TABLES  TO tm_wz;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: tm_wz; Owner: weymouth
--

ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_wz REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_wz REVOKE ALL ON TABLES  FROM weymouth;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_wz GRANT ALL ON TABLES  TO tm_cz;
ALTER DEFAULT PRIVILEGES FOR ROLE weymouth IN SCHEMA tm_wz GRANT ALL ON TABLES  TO tm_wz;


--
-- PostgreSQL database dump complete
--

